<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BYRIO Blogroll</title>
    <subtitle>北邮人博客圈</subtitle>
    <link href="http://planet.byr.moe/atom.xml" rel="self" type="application/atom+xml" />
    <link href="http://planet.byr.moe"/>
    <updated>2021-09-16T12:22:44+00:00</updated>
    <id>http://planet.byr.moe</id>
    
    <author>
        <name>Dimpiurr</name>
        <email>dimpurr@live.com</email>
    </author>
    
    <generator uri="https://github.com/phoenixlzx/planet.js">Planet.js</generator>
    
    <entry>
        <title>修復 Discuz! 從 7.2 轉換到 X 時的資料庫錯誤</title>
        <link href="https://asaba.sakuragawa.moe/2021/09/%e4%bf%ae%e5%be%a9-discuz-%e5%be%9e-7-2-%e8%bd%89%e6%8f%9b%e5%88%b0-x-%e6%99%82%e7%9a%84%e8%b3%87%e6%96%99%e5%ba%ab%e9%8c%af%e8%aa%a4/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-discuz-%25e5%25be%259e-7-2-%25e8%25bd%2589%25e6%258f%259b%25e5%2588%25b0-x-%25e6%2599%2582%25e7%259a%2584%25e8%25b3%2587%25e6%2596%2599%25e5%25ba%25ab%25e9%258c%25af%25e8%25aa%25a4"/>
        <id>https://asaba.sakuragawa.moe/2021/09/%e4%bf%ae%e5%be%a9-discuz-%e5%be%9e-7-2-%e8%bd%89%e6%8f%9b%e5%88%b0-x-%e6%99%82%e7%9a%84%e8%b3%87%e6%96%99%e5%ba%ab%e9%8c%af%e8%aa%a4/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-discuz-%25e5%25be%259e-7-2-%25e8%25bd%2589%25e6%258f%259b%25e5%2588%25b0-x-%25e6%2599%2582%25e7%259a%2584%25e8%25b3%2587%25e6%2596%2599%25e5%25ba%25ab%25e9%258c%25af%25e8%25aa%25a4</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-09-16T12:22:44+00:00</published>
        <updated>2021-09-16T12:22:44+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://markdown.apps.central.sakuragawa.cloud/#%E8%BD%89%E6%8F%9B%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA%E9%87%8D%E8%A4%87%E4%B8%BB%E9%8D%B5"></a>轉換工具提示重複主鍵</h2>



<p>使用轉換工具進行轉換時，會遇到莫名的主鍵重複錯誤，提示 <code>#1062 - Duplicate entry '...' for key PRIMARY</code>。一番找尋，相關的結果都說「刪掉了就好了」，問題是刪了一個又出一個，最後逼得淺羽直接用 SQL 批量刪了五六千條，下一個還是有問題。</p>



<p>然而原來的資料庫也是 MariaDB，也指定了 PRIMARY KEY，怎麼會重複呢？</p>



<blockquote><p>囧,这个是转换程序的一个Bug,<br />我开始的想法和你一样,删除重复的记录,<br />结果没用,其它记录又会出错,<br />后来才知道是因为转换程序里的SQL语句没有order by,<br />所以…</p>CzBiX 2011-04-24<br /><a href="https://lengxx.com/post/157.html" target="_blank">Discuz7.2升级至DX1.5数据表转换时出错的解决方法</a></blockquote>



<p>知道了原理，修復起來就比較簡單了：</p>



<pre><code>--- Discuz_X1.5_SC_UTF8/utility/convert/source/d7.2_x1.5/table/posts.php    2011-12-20 16:58:50.000000000 +0800
+++ bbs/convert/source/d7.2_x1.5/table/posts.php                            (new)
@@ -20,7 +20,7 @@
        $db_target-&gt;query("TRUNCATE $table_target");
 }

-$query = $db_source-&gt;query("SELECT * FROM $table_source WHERE pid&gt;'$start' LIMIT $limit");
+$query = $db_source-&gt;query("SELECT * FROM $table_source WHERE pid&gt;'$start' ORDER BY pid ASC LIMIT $limit");
 while($row = $db_source-&gt;fetch_array($query)) {
        $nextid = $row['pid'];
        $row = daddslashes($row, 1);</code></pre>



<p>保存，再執行轉換程序，這次就很順利了。</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F09%2F%25e4%25bf%25ae%25e5%25be%25a9-discuz-%25e5%25be%259e-7-2-%25e8%25bd%2589%25e6%258f%259b%25e5%2588%25b0-x-%25e6%2599%2582%25e7%259a%2584%25e8%25b3%2587%25e6%2596%2599%25e5%25ba%25ab%25e9%258c%25af%25e8%25aa%25a4%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e4%2525bf%2525ae%2525e5%2525be%2525a9-discuz-%2525e5%2525be%25259e-7-2-%2525e8%2525bd%252589%2525e6%25258f%25259b%2525e5%252588%2525b0-x-%2525e6%252599%252582%2525e7%25259a%252584%2525e8%2525b3%252587%2525e6%252596%252599%2525e5%2525ba%2525ab%2525e9%25258c%2525af%2525e8%2525aa%2525a4&amp;action_name=%E4%BF%AE%E5%BE%A9+Discuz%21+%E5%BE%9E+7.2+%E8%BD%89%E6%8F%9B%E5%88%B0+X+%E6%99%82%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB%E9%8C%AF%E8%AA%A4&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2343" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>    </span>
</div><div>
    <a data-post-id="2343" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            轉換工具提示重複主鍵    使用轉換工具進行轉換時，會遇到莫名的主鍵重複錯誤，提示 #1062 - Duplicate entry &#39;...&#39; for key PRIMARY。一番找尋，相關的結果都說「刪掉了就好了」，問題是刪了一個又出一個，最後逼得淺羽直接用 SQL 批量刪了
            
        </summary>
        
        <category term="折騰"/>
        
        <category term="#SafeForLife"/>
        
        <category term="國產"/>
        
    </entry>
    
    <entry>
        <title>犯水災和丟東西</title>
        <link href="https://asaba.sakuragawa.moe/2021/09/%e7%8a%af%e6%b0%b4%e7%81%bd%e5%92%8c%e4%b8%9f%e6%9d%b1%e8%a5%bf/?pk_campaign=feed&amp;pk_kwd=%25e7%258a%25af%25e6%25b0%25b4%25e7%2581%25bd%25e5%2592%258c%25e4%25b8%259f%25e6%259d%25b1%25e8%25a5%25bf"/>
        <id>https://asaba.sakuragawa.moe/2021/09/%e7%8a%af%e6%b0%b4%e7%81%bd%e5%92%8c%e4%b8%9f%e6%9d%b1%e8%a5%bf/?pk_campaign=feed&amp;pk_kwd=%25e7%258a%25af%25e6%25b0%25b4%25e7%2581%25bd%25e5%2592%258c%25e4%25b8%259f%25e6%259d%25b1%25e8%25a5%25bf</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-09-15T15:59:55+00:00</published>
        <updated>2021-09-15T15:59:55+00:00</updated>
        
        <content type="html"><![CDATA[<p>近來數月都極少寫網誌，主要是年初搬到了小漁村，忙碌的安家過後便開始懶散；期間斷續寫了不少草稿，但最終或只有主幹、或缺少配圖，都未能成文。</p>



<p>小漁村的夏季雨水連綿。本來雨季氣候是浅羽這隻南方貓咪從小適應的，大雨時節窩在家裏中聽雨安睡也很愜意。當時浅羽和傻老婆尚在睡夢中，直至被熱醒了，才發現空調好像不工作了，進而發現全屋都斷電了。摸到了門後的空气開關，打算重設一下，但只能閉路照明供電的線路，電器線路的始終合不上，估計是哪裏短路了。繞着客廳檢查了一圈似乎都沒發現什麼問題；正當一籌莫展，走進工作室準備坐一坐冷靜冷靜時，才發現事情的起因——因爲雨勢急大，不巧鄰居家又安裝了角度比較準確的雨棚，因此一晚大雨過後，半掩的窗戶竟然也進了不少水，以至於窗臺像洗過一般。淋進窗臺的雨水順着牆壁流下，浸溼了低處的插座，因此造成了空氣開關跳脫。偏偏浅羽的工作桌還是靠着有窗的一邊，顯示器、耳擴、手機外加幾本書都放在上，結果當然也免不了一起被淋溼。好在最後清點下來，數位裝置基本沒有問題，手機也只是接埠有些進水。書本當然是不可逆的損害，但用紙吸水晾乾後倒也還能正常讀，一時也不能計較太多了。只是窗戶是再也不敢常開了；在這多雨的地方，偶爾開一下也是提心吊膽。</p>



<p>正所謂「屋漏偏逢連夜雨」，年邁的空調本就有些機械問題，又突然開始滴水。可是空調貼着牆，正下方也是桌面，浅羽只好先用容器接住滴水；有時滴水量大，還需要放塊軟布防止濺起水花。這滴水的問題，按說也是空調常見病，發作起來也是時斷時續：往往連續幾天都沒問題，突然毫無預兆地就開始滴水。可氣的是每每想要找修理工上門時，空調又不滴水了，而且又能好上幾天。這樣一來二去的，浅羽也就犯懶，想着相安無事、得過且過了；卻不想某日夜裏空調突然又開始施水魔法，打溼了桌子放檯燈的一角，順帶着連檯燈一起報銷了。</p>



<p>到此是犯水衝，雖然多少有些損失，但尚且還能安慰自己是破財消災。然而隨後又丟了不少東西。五一剛過，浅羽突然發現一台 VPS 無法連線，於是立即提交工單。隨後浅羽發現服務確已超過續費期限 2 天，但卻未收到服務商的任何郵件，因此立即向服務商反饋郵件系統問題並要求恢復服務。服務商的反應也很迅速，立即告訴浅羽帳單逾期後 1 日即會刪除服務並無法恢復，同時表示系統已經發出郵件，是浅羽自己未及時檢查郵件；然而浅羽的郵箱幾乎每日都有在使用，並且查看郵件紀錄後發現服務商已有逾半年未能成功向 Gmail 投遞郵件。結果是服務商裝死，雖然從工單的回覆通知可以發現他們偷偷修復了郵件系統的投遞問題，但對於自己造成的問題不做任何表態。</p>



<p>禍不單行。七月末的一日，浅羽剛剛回覆完網誌上的一條留言，Jetpack 突然提示網誌「處於離線狀態」了，同時存放網誌的主機也無法登入，相信是遇到暫時的網路穩定性問題。然而等了逾四小時未恢復，浅羽不得不又緊張起來，給服務商開工單。結果等待數小時，某位客服竟然直接回覆了一句：「給你重裝系統可以嗎？」在隨後數週，浅羽才慢慢瞭解整件事情的背景：服務商正在更換虛擬化平臺，並限時要求客戶自行遷移資料，遷移完成後會關閉原有的主機。根據服務商解釋，在此過程中，員工誤將浅羽的主機關閉。至於恢復時間，「如果关机是找不到了」「资料还在」「要回数据没这么快」。幸好網誌是有定期備份資料，內容不會丟失，但會損失部分留言，因此還是有限讓服務商處理。最後經過 24 天的催促和等待，服務商終於找回了實例；而恢復後浅羽第一件做的事，就是遷移到更加大牌的服務商處。雖然對於運營商來說，浅羽只是一個小客戶、這只是一個小失誤，但一旦信任出現問題，就很難再有修補的機會了。</p>



<p>還有前些日子，出門辦事，剛下飛機就接到家裏來電，說是有一隻貓跑了。浅羽當時就有些愣了，一面是擔心一面是不甘，在機場的洗手間舉着手機打了十幾分鍾電話。幸好後來發現是家裏來了生人，貓太害怕，躲到洗衣機後人找不到的地方去了。再後來在醫院，進出診室時太匆忙，一不留神手機也丟了，問了兩天失物招領也沒有說撿到的，於是就去派出所報了案。派出所很客氣地給了一張「被偷竊案」的回執，當然到現在也還沒有找到。</p>



<p>這一篇雜七雜八的，大概就是浅羽近幾月的狀況了。總之各方面似乎都不順心，但倒也還能過。</p>



<h6><a href="https://markdown.apps.central.sakuragawa.cloud/#tags-blog-draft"></a></h6>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F09%2F%25e7%258a%25af%25e6%25b0%25b4%25e7%2581%25bd%25e5%2592%258c%25e4%25b8%259f%25e6%259d%25b1%25e8%25a5%25bf%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e7%25258a%2525af%2525e6%2525b0%2525b4%2525e7%252581%2525bd%2525e5%252592%25258c%2525e4%2525b8%25259f%2525e6%25259d%2525b1%2525e8%2525a5%2525bf&amp;action_name=%E7%8A%AF%E6%B0%B4%E7%81%BD%E5%92%8C%E4%B8%9F%E6%9D%B1%E8%A5%BF&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2341" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>1    </span>
</div><div>
    <a data-post-id="2341" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            近來數月都極少寫網誌，主要是年初搬到了小漁村，忙碌的安家過後便開始懶散；期間斷續寫了不少草稿，但最終或只有主幹、或缺少配圖，都未能成文。    小漁村的夏季雨水連綿。本來雨季氣候是浅羽這隻南方貓咪從小適應的，大雨時節窩在家裏中聽雨安睡也很愜意。當時浅羽和傻老婆尚在睡夢中，直至被
            
        </summary>
        
        <category term="日常 / 流水帳"/>
        
        <category term="#SafeForLife"/>
        
        <category term="吐槽"/>
        
    </entry>
    
    <entry>
        <title>Python实现并发的几种方式</title>
        <link href="https://icebound.cc/2021/08/28/python-async.html"/>
        <id>https://icebound.cc/2021/08/28/python-async.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-08-28T15:26:09+00:00</published>
        <updated>2021-08-28T15:26:09+00:00</updated>
        
        <content type="html"><![CDATA[<p>工作中需要蛋疼的用python实现并发，在读文档+实践了很久之后，做个总结。注意，本文全是根据我实践中的理解来 […]</p>
<p>The post <a href="https://icebound.cc/2021/08/28/python-async.html">Python实现并发的几种方式</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            工作中需要蛋疼的用python实现并发，在读文档+实践了很久之后，做个总结。注意，本文全是根据我实践中的理解来 […] The post Python实现并发的几种方式 first appeared on Icebound.
            
        </summary>
        
        <category term="文章分类"/>
        
        <category term="电脑常识"/>
        
        <category term="python"/>
        
        <category term="并发"/>
        
        <category term="异步"/>
        
        <category term="进程"/>
        
    </entry>
    
    <entry>
        <title>记一次node-gyp和python版本冲突解决</title>
        <link href="http://blog.vitechliu.com/frontend/node-gyp-conflict-with-python2-python3-gyp-error.html"/>
        <id>http://blog.vitechliu.com/frontend/node-gyp-conflict-with-python2-python3-gyp-error.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2021-07-28T10:31:00+00:00</published>
        <updated>2021-07-28T10:31:00+00:00</updated>
        
        <content type="html"><![CDATA[<p>很多前端框架自带的依赖会依赖早期的node-gyp<br />
然而早期版本node-gyp有个严重问题就是不支持python3。如果客户端没有安装python2或者说python2有问题，在npm install时就会出现如下错误</p>
<pre><code>gyp ERR! stack Error: Command failed: /Users/nick/anaconda3/bin/python3 -c import sys; print "%s.%s.%s" % sys.version_info[:3];
</code></pre>
<p>解决方法就是手动更新node-gyp到最新版</p>
<p>npm update -g node-gyp@latest</p>
<p>如果项目内依赖有node-gyp，就需要做很复杂的依赖管理去升级。</p>
<p>很多node-gyp的依赖时node-sass导致的，node-sass的新版已经不再依赖node-gyp，同时node-sass老版的编译与node 16.0以上的版本不兼容，如果出现一些其他的gyp错误，把node降到14、15的版本就可以解决</p>]]></content>
        
        <summary type="html">
            
            很多前端框架自带的依赖会依赖早期的node-gyp 然而早期版本node-gyp有个严重问题就是不支持python3。如果客户端没有安装python2或者说python2有问题，在npm install时就会出现如下错误 gyp ERR! stack Error: Comman
            
        </summary>
        
    </entry>
    
    <entry>
        <title>修復 Fedora GNU/Linux 系統下的鍵盤功能區（F 區）按鍵</title>
        <link href="https://asaba.sakuragawa.moe/2021/07/%e4%bf%ae%e5%be%a9-fedora-gnu-linux-%e7%b3%bb%e7%b5%b1%e4%b8%8b%e7%9a%84%e9%8d%b5%e7%9b%a4%e5%8a%9f%e8%83%bd%e5%8d%80%ef%bc%88f-%e5%8d%80%ef%bc%89%e6%8c%89%e9%8d%b5/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-fedora-gnu-linux-%25e7%25b3%25bb%25e7%25b5%25b1%25e4%25b8%258b%25e7%259a%2584%25e9%258d%25b5%25e7%259b%25a4%25e5%258a%259f%25e8%2583%25bd%25e5%258d%2580%25ef%25bc%2588f-%25e5%258d%2580%25ef%25bc%2589%25e6%258c%2589%25e9%258d%25b5"/>
        <id>https://asaba.sakuragawa.moe/2021/07/%e4%bf%ae%e5%be%a9-fedora-gnu-linux-%e7%b3%bb%e7%b5%b1%e4%b8%8b%e7%9a%84%e9%8d%b5%e7%9b%a4%e5%8a%9f%e8%83%bd%e5%8d%80%ef%bc%88f-%e5%8d%80%ef%bc%89%e6%8c%89%e9%8d%b5/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-fedora-gnu-linux-%25e7%25b3%25bb%25e7%25b5%25b1%25e4%25b8%258b%25e7%259a%2584%25e9%258d%25b5%25e7%259b%25a4%25e5%258a%259f%25e8%2583%25bd%25e5%258d%2580%25ef%25bc%2588f-%25e5%258d%2580%25ef%25bc%2589%25e6%258c%2589%25e9%258d%25b5</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-07-02T21:22:39+00:00</published>
        <updated>2021-07-02T21:22:39+00:00</updated>
        
        <content type="html"><![CDATA[<p>浅羽一直對於投入客製化鍵盤有所顧忌，因此大多只購買品牌量產鍵盤。然而量產鍵盤往以 104 鍵、87/TKL 配列爲多，而往小的 75 鍵、60 鍵等配列又不討浅羽喜歡，加之多有電競遊戲元素，因此久不關注鍵盤。最近在偶然的機會下瞭解到腹靈 FL·ESPORTS FL980，集<strong>有線、2.4GHz、藍芽三模式</strong>於一身，又有少見的 <strong>98 鍵配列</strong>、<strong>熱插拔軸</strong>等設計，加上不出千元的價格，堪稱是「<strong>客製化當作量產賣</strong>」的典範。不過識貨的當然不止浅羽，三模版的 FL980 可謂是有價無市，由於供貨量有限，因此每每放貨銷售都是搶購一空。然而缺貨的狀況不但沒有打消浅羽的熱情，反而讓浅羽更加趨之若鶩。好在功夫不負有心貓，浅羽還是蹲到了<s>猛男</s>桃夭配色的 Rosa 紅軸三模版和 Box 紅軸三模版各一把。</p>







<p>拿到心心念念的鍵盤，第一件事當然是──反裝空格，然後開始測試鍵盤的按鍵觸發和打感。本來鍵帽和軸都算不錯，造工也優良，打感其實是無大問題；但是使用中漸漸地就發現一個問題：爲什麼 F 區按鍵不能用呢？仔細測試後發現，並非按鍵有問題；F 區按鍵在 Windows 下單獨按下於 Fn 組合鍵都可正常工作，但在 Fedora GNU/Linux 下出現問題：</p>



<ul><li>鍵盤在 Win 模式：直接按下觸發亮度和多媒體控制；Fn 組合鍵無響應；</li><li>鍵盤在 Mac 模式：直接按下觸發 F 區功能；Fn 組合鍵觸發亮度和多媒體控制；</li></ul>



<p>本來如果只是如此，直接用 Mac 模式也能對付；奈何 Mac 模式下，由於蘋果鍵盤的鍵位問題，導致對應的 <code>Alt</code>(<code>Option</code>) 鍵和 <code>Meta</code>(<code>Command</code>) 鍵也相反了。神祕的是，浅羽其他常用的鍵盤包括 Varmilo VA68M、HHKB、Leopold FC980C/M 和 ThinkPad Compact USB Keyboard 都沒有此現象，可以正常使用功能區按鍵。</p>



<p>雖然說就用用鍵盤佈局也未嘗不可，但真的沒有解決方法嗎？</p>



<p>下定決心解決此事後，透過簡單的搜尋可以發現這<strong>不是個別現象</strong>，包括 <a href="https://schnouki.net/post/2019/how-to-use-a-keychron-k2-usb-keyboard-on-linux/" target="_blank">Keychron</a>、<a href="https://ask.fedoraproject.org/t/getting-the-function-keys-to-work-properly-with-a-varmilo-keyboard/11297" target="_blank">Varmilo VA88M</a>（爲什麼浅羽的沒問題？）等鍵盤，Fedora、<a href="https://caosiyang.github.io/posts/2020/07/22/using-keychron-k6-on-manjaro/" target="_blank">Manjaro</a> 在內的發行版都有出現問題的經驗。而<strong>解決此問題只需對 <code>hid_apple</code> 核心模組略作設定</strong>。</p>



<p>首先臨時解決此問題：</p>



<pre><code># echo 2 &gt; /sys/module/hid_apple/parameters/fnmode</code></pre>



<p>如果觀察到問題解決，那麼固化一下解決方案：</p>



<pre><code># echo "options hid_apple fnmode=2" &gt; /etc/modprobe.d/50-hid_apple.conf</code></pre>



<p>對於 Fedora，需要再給 <code>dracut</code> 添加設定項並更新 <code>initramfs</code>：</p>



<pre><code># echo " install_items+=/etc/modprobe.d/50-hid_apple.conf" &gt; /etc/dracut.conf.d/50-hid_apple.conf
# dracut -vf --regenerate-all</code></pre>



<p>以後即使重新開機，也不需要每次手工修改了。只是不知道這樣設定是否會造成先前沒有問題的鍵盤反而工作不正常。至後面有閒心時，浅羽再作補充罷。</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F07%2F%25e4%25bf%25ae%25e5%25be%25a9-fedora-gnu-linux-%25e7%25b3%25bb%25e7%25b5%25b1%25e4%25b8%258b%25e7%259a%2584%25e9%258d%25b5%25e7%259b%25a4%25e5%258a%259f%25e8%2583%25bd%25e5%258d%2580%25ef%25bc%2588f-%25e5%258d%2580%25ef%25bc%2589%25e6%258c%2589%25e9%258d%25b5%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e4%2525bf%2525ae%2525e5%2525be%2525a9-fedora-gnu-linux-%2525e7%2525b3%2525bb%2525e7%2525b5%2525b1%2525e4%2525b8%25258b%2525e7%25259a%252584%2525e9%25258d%2525b5%2525e7%25259b%2525a4%2525e5%25258a%25259f%2525e8%252583%2525bd%2525e5%25258d%252580%2525ef%2525bc%252588f-%2525e5%25258d%252580%2525ef%2525bc%252589%2525e6%25258c%252589%2525e9%25258d%2525b5&amp;action_name=%E4%BF%AE%E5%BE%A9+Fedora+GNU%2FLinux+%E7%B3%BB%E7%B5%B1%E4%B8%8B%E7%9A%84%E9%8D%B5%E7%9B%A4%E5%8A%9F%E8%83%BD%E5%8D%80%EF%BC%88F+%E5%8D%80%EF%BC%89%E6%8C%89%E9%8D%B5&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2305" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>1    </span>
</div><div>
    <a data-post-id="2305" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            浅羽一直對於投入客製化鍵盤有所顧忌，因此大多只購買品牌量產鍵盤。然而量產鍵盤往以 104 鍵、87/TKL 配列爲多，而往小的 75 鍵、60 鍵等配列又不討浅羽喜歡，加之多有電競遊戲元素，因此久不關注鍵盤。最近在偶然的機會下瞭解到腹靈 FL·ESPORTS FL980，集有線
            
        </summary>
        
        <category term="折騰"/>
        
        <category term="#SafeForLife"/>
        
        <category term="Keyboard"/>
        
        <category term="Linux"/>
        
        <category term="OS"/>
        
        <category term="國產"/>
        
        <category term="外設"/>
        
        <category term="工具控"/>
        
    </entry>
    
    <entry>
        <title>Table &#39;.\mysql\proxies_priv&#39; is marked as crashed and last (automatic?) repair failed</title>
        <link href="http://blog.vitechliu.com/note/proxies_priv_crashed.html"/>
        <id>http://blog.vitechliu.com/note/proxies_priv_crashed.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2021-05-03T19:28:22+00:00</published>
        <updated>2021-05-03T19:28:22+00:00</updated>
        
        <content type="html"><![CDATA[<p>如果是windows下xampp启动mysql失败导致类似的错误<br />
通过事件查看器发现的日志显示这个表出问题</p>
<p>建议放弃修复，这应该是一个偶发的数据索引错乱<br />
见<br />
https://community.apachefriends.org/f/viewtopic.php?t=79199<br />
https://stackoverflow.com/questions/8843776/mysql-table-is-marked-as-crashed-and-last-automatic-repair-failed</p>
<p>可以直接去xampp目录/mysql/data/mysql下把所有proxies_priv的文件删掉。<br />
理论上不影响什么，毕竟proxy_user功能基本没人用</p>]]></content>
        
        <summary type="html">
            
            如果是windows下xampp启动mysql失败导致类似的错误 通过事件查看器发现的日志显示这个表出问题 建议放弃修复，这应该是一个偶发的数据索引错乱 见 https://community.apachefriends.org/f/viewtopic.php?t=79199 
            
        </summary>
        
    </entry>
    
    <entry>
        <title>联邦学习理解及实现</title>
        <link href="https://icebound.cc/2021/04/04/flearning.html"/>
        <id>https://icebound.cc/2021/04/04/flearning.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-04-04T03:22:45+00:00</published>
        <updated>2021-04-04T03:22:45+00:00</updated>
        
        <content type="html"><![CDATA[<p>最近毕设要接触到联邦学习，在这里记录一下对联邦学习的理解，防止以后忘了。 机器学习小白一个，可能有错，欢迎指出 […]</p>
<p>The post <a href="https://icebound.cc/2021/04/04/flearning.html">联邦学习理解及实现</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            最近毕设要接触到联邦学习，在这里记录一下对联邦学习的理解，防止以后忘了。 机器学习小白一个，可能有错，欢迎指出 […] The post 联邦学习理解及实现 first appeared on Icebound.
            
        </summary>
        
        <category term="我的项目"/>
        
        <category term="文章分类"/>
        
        <category term="电脑常识"/>
        
        <category term="机器学习"/>
        
        <category term="毕设"/>
        
        <category term="联邦学习"/>
        
    </entry>
    
    <entry>
        <title>Crontab 不执行php/laravel等命令</title>
        <link href="http://blog.vitechliu.com/Linux/crontab_not_working_when_running_php_laravel_commands.html"/>
        <id>http://blog.vitechliu.com/Linux/crontab_not_working_when_running_php_laravel_commands.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2021-03-16T10:07:50+00:00</published>
        <updated>2021-03-16T10:07:50+00:00</updated>
        
        <content type="html"><![CDATA[<p>可能的原因：php有多个版本，cron的php命令指向不能识别。<br />
cron在执行php的时候和手动在终端调用php不一样，可能是由root用户发起，因此他会根据当前用户来选择全局环境变量<br />
比如如下脚本无效</p>
<pre><code>* * * * * php /www/somescripts.php
</code></pre>
<p>应该改为</p>
<pre><code>* * * * * /usr/local/bin/php /www/somescripts.php
</code></pre>
<p>可以通过whereis php等命令找到所需的php</p>]]></content>
        
        <summary type="html">
            
            可能的原因：php有多个版本，cron的php命令指向不能识别。 cron在执行php的时候和手动在终端调用php不一样，可能是由root用户发起，因此他会根据当前用户来选择全局环境变量 比如如下脚本无效 * * * * * php /www/somescripts.php  
            
        </summary>
        
    </entry>
    
    <entry>
        <title>LeetCode游记与总结</title>
        <link href="https://icebound.cc/2021/03/01/leetcode.html"/>
        <id>https://icebound.cc/2021/03/01/leetcode.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-03-01T14:06:14+00:00</published>
        <updated>2021-03-01T14:06:14+00:00</updated>
        
        <content type="html"><![CDATA[<p>为了春招开始刷leetcode。 之前学竞赛的时候更多注意的是在给定时限和空间限制下完成问题，一般也不会要求你 […]</p>
<p>The post <a href="https://icebound.cc/2021/03/01/leetcode.html">LeetCode游记与总结</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            为了春招开始刷leetcode。 之前学竞赛的时候更多注意的是在给定时限和空间限制下完成问题，一般也不会要求你 […] The post LeetCode游记与总结 first appeared on Icebound.
            
        </summary>
        
        <category term="刷题记录"/>
        
        <category term="文章分类"/>
        
        <category term="LeetCode"/>
        
        <category term="算法"/>
        
    </entry>
    
    <entry>
        <title>Laravel 明明有csrf_token仍然报419 token mismatch错误</title>
        <link href="http://blog.vitechliu.com/note/http-419-when-csrf-token-exists.html"/>
        <id>http://blog.vitechliu.com/note/http-419-when-csrf-token-exists.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2021-02-25T04:29:08+00:00</published>
        <updated>2021-02-25T04:29:08+00:00</updated>
        
        <content type="html"><![CDATA[<p>一个可能的原因是，因为项目的正式端和测试端（开发端也有可能）的.env中间配置的APP_NAME相同（或者都为纯中文），导致cookies的键相同，进而导致session冲突。</p>
<p>原理：laravel的cookies键产生位于config/session.php</p>
<pre><code>'cookie' =&gt; env(
    'SESSION_COOKIE',
    Str::slug(env('APP_NAME', 'laravel'), '_').'_session'
 ),
</code></pre>
<p>如果.env中间没有配置SESSION_COOKIE这一项（默认没有），那么cookies键会由APP_NAME格式化字符串生成，因为本土化原因中文会被删掉，所以如果两个站点的APP_NAME相同，比如都是xxwebsite,那么产生的键都是xxwebsite_session，如果都是中文的话，那么更会导致键直接是_session，引发更严重的跨站冲突。</p>
<p>解决方案：修改APP_NAME为不同的非中文字符串，或者为不同项目的.env中配置不同的SESSION_COOKIE字段。</p>
<p><a href="https://learnku.com/laravel/t/29045">参考文章</a></p>]]></content>
        
        <summary type="html">
            
            一个可能的原因是，因为项目的正式端和测试端（开发端也有可能）的.env中间配置的APP_NAME相同（或者都为纯中文），导致cookies的键相同，进而导致session冲突。 原理：laravel的cookies键产生位于config/session.php &#39;cookie&#39;
            
        </summary>
        
    </entry>
    
    <entry>
        <title>毫無邏輯的線下家電銷售</title>
        <link href="https://asaba.sakuragawa.moe/2021/02/%e6%af%ab%e7%84%a1%e9%82%8f%e8%bc%af%e7%9a%84%e7%b7%9a%e4%b8%8b%e5%ae%b6%e9%9b%bb%e9%8a%b7%e5%94%ae/?pk_campaign=feed&amp;pk_kwd=%25e6%25af%25ab%25e7%2584%25a1%25e9%2582%258f%25e8%25bc%25af%25e7%259a%2584%25e7%25b7%259a%25e4%25b8%258b%25e5%25ae%25b6%25e9%259b%25bb%25e9%258a%25b7%25e5%2594%25ae"/>
        <id>https://asaba.sakuragawa.moe/2021/02/%e6%af%ab%e7%84%a1%e9%82%8f%e8%bc%af%e7%9a%84%e7%b7%9a%e4%b8%8b%e5%ae%b6%e9%9b%bb%e9%8a%b7%e5%94%ae/?pk_campaign=feed&amp;pk_kwd=%25e6%25af%25ab%25e7%2584%25a1%25e9%2582%258f%25e8%25bc%25af%25e7%259a%2584%25e7%25b7%259a%25e4%25b8%258b%25e5%25ae%25b6%25e9%259b%25bb%25e9%258a%25b7%25e5%2594%25ae</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-02-14T17:47:34+00:00</published>
        <updated>2021-02-14T17:47:34+00:00</updated>
        
        <content type="html"><![CDATA[<p>因着喬遷新房，需要選購一套新家電，浅羽想在線下店面<s>砍價</s>看看有沒有更優惠的價格。大小店都逛了一圈，雖然價格上沒有太多收穫，但神奇言論倒是有一些。以下記錄其中的一些。</p>



<div></div>



<p>浅羽：想買一套三星的洗烘一體。<br />銷售：<a href="https://zh.wikipedia.org/zh-hant/%E9%9F%93%E5%9C%8B%E9%83%A8%E7%BD%B2%E8%96%A9%E5%BE%B7%E5%8F%8D%E5%B0%8E%E5%BD%88%E7%B3%BB%E7%B5%B1%E4%BA%8B%E4%BB%B6">薩德事件</a>之後韓國家電都很少在大陸賣了。<br />浅羽：三星的冰箱和電視不還有很多嗎？<br />銷售：只剩下電視這些了，洗衣機之類的都比較少了。</p>



<hr />



<p>浅羽：西門子感覺還可以。<br />銷售：西門子被收购了，材料都不一样，几年前还行。<br />浅羽：小天鹅不行。<br />銷售：那是以前，小天鹅被收购了，材料现在都不一样了。</p>



<pre>……</pre>



<p>浅羽：你這套松下 13K 能做我就拿一套。<br />銷售：這個價格走商場渠道的話拿不下來。<br />浅羽：這個價格都拿不下來的話我不如買小天鵝。<br />銷售：那品牌不一樣，小天鵝你用半年就知道了，不能比。就好像蘋果手機不卡，……</p>



<p>所以小天鵝到底好不好？</p>



<hr />



<p>銷售：松下這一套最低 20K<br />浅羽：京東自營不用券都可以 18K。<br />銷售：（查京東）<br />銷售：（打電話）<br />銷售：那我們這邊也 18K 吧。<br />浅羽：那我不如直接京東？<br />銷售：（打電話）<br />銷售：最低 17K 吧，再低確實做不了了。<br />浅羽：你這麼高的價格我還不如買 LG。<br />銷售：LG 在 5 年前已經退出中國市場了，你看我們店都不賣了，實體店應該只有順電在賣，很快也不賣了。</p>



<hr />



<p>（路過順電）<br />浅羽：蘇寧銷售誠不我欺！順電果然有三星和 LG！</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F02%2F%25e6%25af%25ab%25e7%2584%25a1%25e9%2582%258f%25e8%25bc%25af%25e7%259a%2584%25e7%25b7%259a%25e4%25b8%258b%25e5%25ae%25b6%25e9%259b%25bb%25e9%258a%25b7%25e5%2594%25ae%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e6%2525af%2525ab%2525e7%252584%2525a1%2525e9%252582%25258f%2525e8%2525bc%2525af%2525e7%25259a%252584%2525e7%2525b7%25259a%2525e4%2525b8%25258b%2525e5%2525ae%2525b6%2525e9%25259b%2525bb%2525e9%25258a%2525b7%2525e5%252594%2525ae&amp;action_name=%E6%AF%AB%E7%84%A1%E9%82%8F%E8%BC%AF%E7%9A%84%E7%B7%9A%E4%B8%8B%E5%AE%B6%E9%9B%BB%E9%8A%B7%E5%94%AE&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2254" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>2    </span>
</div><div>
    <a data-post-id="2254" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            因着喬遷新房，需要選購一套新家電，浅羽想在線下店面砍價看看有沒有更優惠的價格。大小店都逛了一圈，雖然價格上沒有太多收穫，但神奇言論倒是有一些。以下記錄其中的一些。        浅羽：想買一套三星的洗烘一體。銷售：薩德事件之後韓國家電都很少在大陸賣了。浅羽：三星的冰箱和電視不還
            
        </summary>
        
        <category term="日常 / 流水帳"/>
        
        <category term="#SafeForLife"/>
        
        <category term="吐槽"/>
        
    </entry>
    
    <entry>
        <title>海貝 HiBy R5 Saber (R5S) 便攜式播放器使用感受及簡單對比山靈 Q1</title>
        <link href="https://asaba.sakuragawa.moe/2021/01/%e6%b5%b7%e8%b2%9d-hiby-r5-saber-r5s-%e4%be%bf%e6%94%9c%e5%bc%8f%e6%92%ad%e6%94%be%e5%99%a8%e4%bd%bf%e7%94%a8%e6%84%9f%e5%8f%97%e5%8f%8a%e7%b0%a1%e5%96%ae%e5%b0%8d%e6%af%94%e5%b1%b1%e9%9d%88-q1/?pk_campaign=feed&amp;pk_kwd=%25e6%25b5%25b7%25e8%25b2%259d-hiby-r5-saber-r5s-%25e4%25be%25bf%25e6%2594%259c%25e5%25bc%258f%25e6%2592%25ad%25e6%2594%25be%25e5%2599%25a8%25e4%25bd%25bf%25e7%2594%25a8%25e6%2584%259f%25e5%258f%2597%25e5%258f%258a%25e7%25b0%25a1%25e5%2596%25ae%25e5%25b0%258d%25e6%25af%2594%25e5%25b1%25b1%25e9%259d%2588-q1"/>
        <id>https://asaba.sakuragawa.moe/2021/01/%e6%b5%b7%e8%b2%9d-hiby-r5-saber-r5s-%e4%be%bf%e6%94%9c%e5%bc%8f%e6%92%ad%e6%94%be%e5%99%a8%e4%bd%bf%e7%94%a8%e6%84%9f%e5%8f%97%e5%8f%8a%e7%b0%a1%e5%96%ae%e5%b0%8d%e6%af%94%e5%b1%b1%e9%9d%88-q1/?pk_campaign=feed&amp;pk_kwd=%25e6%25b5%25b7%25e8%25b2%259d-hiby-r5-saber-r5s-%25e4%25be%25bf%25e6%2594%259c%25e5%25bc%258f%25e6%2592%25ad%25e6%2594%25be%25e5%2599%25a8%25e4%25bd%25bf%25e7%2594%25a8%25e6%2584%259f%25e5%258f%2597%25e5%258f%258a%25e7%25b0%25a1%25e5%2596%25ae%25e5%25b0%258d%25e6%25af%2594%25e5%25b1%25b1%25e9%259d%2588-q1</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-01-30T23:26:43+00:00</published>
        <updated>2021-01-30T23:26:43+00:00</updated>
        
        <content type="html"><![CDATA[<p>近半年來，浅羽一直在用山靈 Q1 當隨身前端，原因無它，只是因爲小巧可愛又漂亮。當時新品發表時，山靈 Q1 鵝卵石般的造型非常吸引眼球，加之森林綠色與浅羽的小米 MIX 3 綠色相近，沒多想就下單了，替換一下用了許久的索尼 NW-A15 初音未來限定版。不過雖然山靈 Q1 是一款不錯的初階便攜播放器，但本身有一些限制和問題，浅羽還是希望可以改善一下：</p>



<ul><li>MTouch OS 並不算太好用，觸控不流暢，操控也不夠直覺；</li><li>無法自動同步歌曲；</li><li>使用 LDAC 連接 WH-1000X<sub>M3</sub> 時常有斷訊狀況；</li><li>沒有 4.4mm 平衡輸出，不方便使用部分耳機；</li></ul>



<p>趁着最近促銷活動多，浅羽也參考選擇了一些機種，包括山靈 M3X、海貝 HiBy R5 及 R5 Saber 和樂圖 Lotoo PAW 6000 等，最後綜合價格和外觀等因素（是的，沒有音質）下單了海貝 HiBy R5 Saber 版。期間爲了讓 4.4mm 平衡輸出發揮更大的作用，浅羽還下單了阿思翠 Astrotec ATC2 4.4mm – mmcx 接口的線材，配合浅羽慣用的 Lyra Nature 應該說是「原湯化原食」了。</p>



<p>海貝 R5S 給的附件非常多，<strong>出廠自帶前後貼膜</strong>，同時還給了替換貼膜各一張，不過都是光面透明膜，<strong>螢幕也沒有給玻璃貼</strong>。另外是<strong>有附贈一個皮套</strong>，有些店鋪可能會寫送官方皮套，但這個皮套其實是本來就附帶在包裝裏的，<strong>顏色似乎是黑色、棕色隨機的</strong>；官方本來還有出一款天藍色的，浅羽覺得蠻好看，可惜到處都買不到了。最後<strong>還有一枚卡針</strong>，用來開 TF 插槽，這點不知道是該稱讚海貝用心還是批評海貝設計不好。</p>



<p>海貝 R5S 的機身算是中階國磚的爆款設計了。具體來說：純黑的配色、雙面玻璃加鋁合金、圓弧過渡的中框，加上側面圓形大實體鍵，說是一款「小黑磚」也不爲過。加之 <strong>R5S 的 Android 系統對第三方播放器支援非常好</strong>，甚至可以下載 Sony Music Center 感受一下大法的操作。海貝 R5S 的電源鍵上有狀態燈號，播放音樂時會用藍色、綠色和橙色指示訊源質量類別，並且無論是使用內建的海貝音樂還是第三方應用程式，燈號都是有效的，且按鍵都可正常使用。這是浅羽最喜歡的設計。</p>







<p>不過雖然稱爲「國磚」，但體積和重量上都不比山靈 Q1 差出太多，甚至由於造型比例關係感覺上更小巧。<strong>機身整體的造工質量也非常不錯</strong>，並且<strong>有一定的抗摔能力</strong>——沒錯，浅羽在上爪的第 5 天就把它摔出了一個小坑，並且決定從此不戴皮套，進而還發現了它裸機時優秀的握持感和操作感。當然，這主要也是因爲<strong>官方皮套只防護了左右側及下側</strong>，對於頂面則完全沒有保護所致。</p>







<p>總結一下換機（升級）到海貝 R5S 解決了浅羽的一些痛點需求：</p>



<ol><li>Android 系統，方便同步歌曲，甚至可以流媒體；</li><li>藍芽訊號的質量和穩定性都不錯；</li><li>有 4.4mm 平衡輸出接口，方便不換線使用，畢竟連 MDR-1A<sub>M2</sub> 都帶平衡線了；</li></ol>



<p>另外還有一些意想不到的體驗改善：</p>



<ul><li>體積小巧，重量合理；</li><li>HiBy Link 比用山靈音樂 app 遠程操控的穩定性、功能性更優；</li><li>按鍵手感好，（不帶皮套的情況下）便於盲操控；</li><li>對第三方播放器應用程式的支援好；</li><li>3.5mm 接口支援帶麥克風、帶線控的耳機，聲道不偏離，線控可以正常播放、暫停、換曲；</li></ul>



<p>實際使用 R5S 一週後，感覺這臺播放器基本可以滿足浅羽現階段的所有隨身需求，唯一弱於 Q1 的就是續航。但是這並不意味着 R5S 的續航就很弱，畢竟在運行了 Android 系統的前提下，<strong>關閉 Wi-Fi 播放歌曲能堅持十餘小時</strong>、<strong>待機基本不耗電</strong>，這樣的成績放在同等級播放器中已經令人滿意。</p>



<p>當然這樣的對比確實不公平甚至沒有可比性，因爲兩者無論是定位還是價位都截然不同。不過既然是升級，就要解決實際的問題，並且做到整體體驗升級。從這個出發點來看，這次盲狙 R5S 無疑是成功的。</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F01%2F%25e6%25b5%25b7%25e8%25b2%259d-hiby-r5-saber-r5s-%25e4%25be%25bf%25e6%2594%259c%25e5%25bc%258f%25e6%2592%25ad%25e6%2594%25be%25e5%2599%25a8%25e4%25bd%25bf%25e7%2594%25a8%25e6%2584%259f%25e5%258f%2597%25e5%258f%258a%25e7%25b0%25a1%25e5%2596%25ae%25e5%25b0%258d%25e6%25af%2594%25e5%25b1%25b1%25e9%259d%2588-q1%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e6%2525b5%2525b7%2525e8%2525b2%25259d-hiby-r5-saber-r5s-%2525e4%2525be%2525bf%2525e6%252594%25259c%2525e5%2525bc%25258f%2525e6%252592%2525ad%2525e6%252594%2525be%2525e5%252599%2525a8%2525e4%2525bd%2525bf%2525e7%252594%2525a8%2525e6%252584%25259f%2525e5%25258f%252597%2525e5%25258f%25258a%2525e7%2525b0%2525a1%2525e5%252596%2525ae%2525e5%2525b0%25258d%2525e6%2525af%252594%2525e5%2525b1%2525b1%2525e9%25259d%252588-q1&amp;action_name=%E6%B5%B7%E8%B2%9D+HiBy+R5+Saber+%28R5S%29+%E4%BE%BF%E6%94%9C%E5%BC%8F%E6%92%AD%E6%94%BE%E5%99%A8%E4%BD%BF%E7%94%A8%E6%84%9F%E5%8F%97%E5%8F%8A%E7%B0%A1%E5%96%AE%E5%B0%8D%E6%AF%94%E5%B1%B1%E9%9D%88+Q1&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2239" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>5    </span>
</div><div>
    <a data-post-id="2239" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            近半年來，浅羽一直在用山靈 Q1 當隨身前端，原因無它，只是因爲小巧可愛又漂亮。當時新品發表時，山靈 Q1 鵝卵石般的造型非常吸引眼球，加之森林綠色與浅羽的小米 MIX 3 綠色相近，沒多想就下單了，替換一下用了許久的索尼 NW-A15 初音未來限定版。不過雖然山靈 Q1 是一
            
        </summary>
        
        <category term="想法"/>
        
        <category term="開箱"/>
        
        <category term="#SafeForLife"/>
        
        <category term="國產"/>
        
        <category term="數位電子"/>
        
        <category term="音樂"/>
        
    </entry>
    
    <entry>
        <title>KubeEdge入门与实践</title>
        <link href="https://icebound.cc/2021/01/23/kubeedge_guide.html"/>
        <id>https://icebound.cc/2021/01/23/kubeedge_guide.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-01-23T13:33:07+00:00</published>
        <updated>2021-01-23T13:33:07+00:00</updated>
        
        <content type="html"><![CDATA[<p>刚刚接触，所有信息来源于文档和实践，如有错误请直接指出！ 首先说一个前提：KubeEdge有两个部分：Clou […]</p>
<p>The post <a href="https://icebound.cc/2021/01/23/kubeedge_guide.html">KubeEdge入门与实践</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            刚刚接触，所有信息来源于文档和实践，如有错误请直接指出！ 首先说一个前提：KubeEdge有两个部分：Clou […] The post KubeEdge入门与实践 first appeared on Icebound.
            
        </summary>
        
        <category term="文章分类"/>
        
        <category term="电脑常识"/>
        
        <category term="K8S"/>
        
        <category term="KubeEdge"/>
        
        <category term="边缘计算"/>
        
    </entry>
    
    <entry>
        <title>Linux常见问题排查</title>
        <link href="https://icebound.cc/2021/01/21/linuxproblem.html"/>
        <id>https://icebound.cc/2021/01/21/linuxproblem.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-01-21T14:56:15+00:00</published>
        <updated>2021-01-21T14:56:15+00:00</updated>
        
        <content type="html"><![CDATA[<p>最近搞毕设遇到许多linux问题，在这里记录一下。 大概可以包括平常用到的各种指令、Ubuntu疑难排查，树莓 […]</p>
<p>The post <a href="https://icebound.cc/2021/01/21/linuxproblem.html">Linux常见问题排查</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            最近搞毕设遇到许多linux问题，在这里记录一下。 大概可以包括平常用到的各种指令、Ubuntu疑难排查，树莓 […] The post Linux常见问题排查 first appeared on Icebound.
            
        </summary>
        
        <category term="文章分类"/>
        
        <category term="电脑常识"/>
        
        <category term="Linux"/>
        
        <category term="树莓派"/>
        
    </entry>
    
    <entry>
        <title>KubeEdge国内Ubuntu部署</title>
        <link href="https://icebound.cc/2021/01/20/kubeedge-ubuntu.html"/>
        <id>https://icebound.cc/2021/01/20/kubeedge-ubuntu.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-01-20T04:36:46+00:00</published>
        <updated>2021-01-20T04:36:46+00:00</updated>
        
        <content type="html"><![CDATA[<p>KubeEdge及其依赖本身部署难度极低，国外各路大神都已经做好了一键脚本，不幸的是国内的网络环境极差，各种被 […]</p>
<p>The post <a href="https://icebound.cc/2021/01/20/kubeedge-ubuntu.html">KubeEdge国内Ubuntu部署</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            KubeEdge及其依赖本身部署难度极低，国外各路大神都已经做好了一键脚本，不幸的是国内的网络环境极差，各种被 […] The post KubeEdge国内Ubuntu部署 first appeared on Icebound.
            
        </summary>
        
        <category term="文章分类"/>
        
        <category term="电脑常识"/>
        
        <category term="K8S"/>
        
        <category term="KubeEdge"/>
        
        <category term="Linux"/>
        
        <category term="边缘计算"/>
        
    </entry>
    
    <entry>
        <title>我的2020</title>
        <link href="https://icebound.cc/2021/01/18/my2020.html"/>
        <id>https://icebound.cc/2021/01/18/my2020.html</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2021-01-18T15:47:35+00:00</published>
        <updated>2021-01-18T15:47:35+00:00</updated>
        
        <content type="html"><![CDATA[<p>一转眼，2020年就过去了。去年的这个时候，我大概在石家庄家里憋着隔离，一年以后，我还是在家里隔离。感觉什么也 […]</p>
<p>The post <a href="https://icebound.cc/2021/01/18/my2020.html">我的2020</a> first appeared on <a href="https://icebound.cc">Icebound</a>.</p>]]></content>
        
        <summary type="html">
            
            一转眼，2020年就过去了。去年的这个时候，我大概在石家庄家里憋着隔离，一年以后，我还是在家里隔离。感觉什么也 […] The post 我的2020 first appeared on Icebound.
            
        </summary>
        
        <category term="人生感悟"/>
        
        <category term="文章分类"/>
        
        <category term="GRE"/>
        
        <category term="学习"/>
        
        <category term="实习"/>
        
        <category term="托福"/>
        
    </entry>
    
    <entry>
        <title>修復 OpenWRT 上 Clash（OpenClash）影響 Port Forwarding 的問題</title>
        <link href="https://asaba.sakuragawa.moe/2021/01/%e4%bf%ae%e5%be%a9-openwrt-%e4%b8%8a-clash%ef%bc%88openclash%ef%bc%89%e5%bd%b1%e9%9f%bf-port-forwarding-%e7%9a%84%e5%95%8f%e9%a1%8c/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-openwrt-%25e4%25b8%258a-clash%25ef%25bc%2588openclash%25ef%25bc%2589%25e5%25bd%25b1%25e9%259f%25bf-port-forwarding-%25e7%259a%2584%25e5%2595%258f%25e9%25a1%258c"/>
        <id>https://asaba.sakuragawa.moe/2021/01/%e4%bf%ae%e5%be%a9-openwrt-%e4%b8%8a-clash%ef%bc%88openclash%ef%bc%89%e5%bd%b1%e9%9f%bf-port-forwarding-%e7%9a%84%e5%95%8f%e9%a1%8c/?pk_campaign=feed&amp;pk_kwd=%25e4%25bf%25ae%25e5%25be%25a9-openwrt-%25e4%25b8%258a-clash%25ef%25bc%2588openclash%25ef%25bc%2589%25e5%25bd%25b1%25e9%259f%25bf-port-forwarding-%25e7%259a%2584%25e5%2595%258f%25e9%25a1%258c</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2021-01-01T21:02:10+00:00</published>
        <updated>2021-01-01T21:02:10+00:00</updated>
        
        <content type="html"><![CDATA[<h6></h6>



<p>透明代理是個好東西。隨着技術的發展，一些老的工具逐漸體現出各種問題並停止維護，浅羽終於也更換到了基於 Clash 包裝的 OpenClash。雖然 Clash 本身有一些爭議，但配合 OpenClash 使用 LuCI 加上網路上的規則，稍加自定就很獲得不錯的使用體驗，只有一個最大的問題——無論如何都無法連線家中的 VPN 伺服器。</p>



<p>浅羽的 VPN 伺服器並沒有直接架設在 OpenWRT 上，而是位於區域網路內 <code>192.168.0.2</code> 上並透過 port forwarding 接受外部連線。起初浅羽以爲是 port forwarding 及 firewall 設定問題，但幾經調整都無果。偶然查看了 VPN 伺服器的日誌，才發現客戶端其實已經與伺服器取得連線，卻因 <code>TLS handshake timeout</code> 無法成功認證。回想近期對網路的調整，浅羽開始懷疑 Clash 的問題，於是增加了一條 <code>SRC-PORT,1194,DIRECT</code> 規則，並在 Clash 中觀察到也已經直接連線，但客戶端依然提示連線失敗。</p>



<p>透過搜尋工作，浅羽找到並參考了一些相關的問題報告：</p>



<ul><li><a href="https://github.com/vernesong/OpenClash/issues/525" target="_blank">vernesong/OpenClash#525：开启OpenClash之后防火墙的端口转发失效</a></li><li><a href="https://github.com/vernesong/OpenClash/issues/146" target="_blank">vernesong/OpenClash#146：关于 tun 模式和端口转发的问题</a></li><li><a href="https://github.com/Dreamacro/clash/issues/432" target="_blank">Dreamacro/clash#432：开启clash后，由外网访问内网服务，无法建立连接，connection refused</a></li></ul>



<p>其中有<a href="https://github.com/Dreamacro/clash/issues/432#issuecomment-572043785" target="_blank">回覆</a>提到：</p>



<blockquote><p>@neroanelli 分析的挺对的，就是包来回的路径不一样。SYN 通过主路由直接发到内网机器上，SYN ACK 发给Clash了，除非 Clash 使用 Raw Socket 特别处理这样的数据包，否则 Clash 没有任何办法处理此类 SYN ACK。</p></blockquote>



<p>同時有幾位評論者都指出：在 <code>mangle</code> 表中增加規則過濾不希望經過 Clash 的流量可以解決問題。那麼按這個思路在 OpenWRT 上的 <code>iptables</code> 增加一條規則，匹配 host 與 port，使相關流量直接從 <code>PREROUTING</code> 鏈 <code>RETURN</code>：</p>



<pre><code># iptables -t mangle -I PREROUTING -p udp -s 192.168.0.2 -m multiport --sports 1194,51820 -j RETURN</code></pre>



<p>確認一下規則生效並且排在 Clash 相關規則前：</p>



<pre><code># iptables -t mangle -L PREROUTING
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
RETURN     udp  --  192.168.0.2          anywhere             multiport sports openvpn,51820
openclash  all  --  anywhere</code></pre>



<p>再在客戶端嘗試一下就可以成功連線了，同時訪問區域網路及使用透明代理都沒有問題。</p>



<hr />



<p>總要一邊一邊地刪除加入防火牆規則非常麻煩，如果遇到不在家中、VPN 又連線不上的情況就更惱火了。那麼有什麼辦法可以在 Clash 重新啓動之後自動修改好防火牆規則呢？</p>



<p>研究一下 OpenClash 包裝的規則，主要的啓動和停止都寫在 <code>luci-app-openclash/root/etc/init.d/openclash</code> 中，其中在 <a href="https://github.com/vernesong/OpenClash/blob/51e3e82376e82a3e613c73a25879657898a55710/luci-app-openclash/root/etc/init.d/openclash#L1198"><code>set_firewall()</code></a> 函式中主要處理了防火牆規則的增加。因此在函式最後添加上幾句：</p>



<pre><code>iptables -t mangle -I PREROUTING -p udp -s 192.168.0.2 --sport 1194 -j RETURN
iptables -t mangle -I PREROUTING -p udp -s 192.168.0.2 --sport 51820 -j RETURN</code></pre>



<p>順便在 <a href="https://github.com/vernesong/OpenClash/blob/51e3e82376e82a3e613c73a25879657898a55710/luci-app-openclash/root/etc/init.d/openclash#L1486"><code>revert_firewall()</code></a> 函數最後也添加相反的指令：</p>



<pre><code>   iptables -t mangle -D PREROUTING -p udp -s 192.168.0.2 --sport 51820 -j RETURN
   iptables -t mangle -D PREROUTING -p udp -s 192.168.0.2 --sport 1194 -j RETURN
   # 爲什麼縮進是三個空格？</code></pre>



<p>這樣最起碼 Clash 重新啓動時不會把自己擋在家門外了。</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2021%2F01%2F%25e4%25bf%25ae%25e5%25be%25a9-openwrt-%25e4%25b8%258a-clash%25ef%25bc%2588openclash%25ef%25bc%2589%25e5%25bd%25b1%25e9%259f%25bf-port-forwarding-%25e7%259a%2584%25e5%2595%258f%25e9%25a1%258c%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e4%2525bf%2525ae%2525e5%2525be%2525a9-openwrt-%2525e4%2525b8%25258a-clash%2525ef%2525bc%252588openclash%2525ef%2525bc%252589%2525e5%2525bd%2525b1%2525e9%25259f%2525bf-port-forwarding-%2525e7%25259a%252584%2525e5%252595%25258f%2525e9%2525a1%25258c&amp;action_name=%E4%BF%AE%E5%BE%A9+OpenWRT+%E4%B8%8A+Clash%EF%BC%88OpenClash%EF%BC%89%E5%BD%B1%E9%9F%BF+Port+Forwarding+%E7%9A%84%E5%95%8F%E9%A1%8C&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2202" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>7    </span>
</div><div>
    <a data-post-id="2202" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
                透明代理是個好東西。隨着技術的發展，一些老的工具逐漸體現出各種問題並停止維護，浅羽終於也更換到了基於 Clash 包裝的 OpenClash。雖然 Clash 本身有一些爭議，但配合 OpenClash 使用 LuCI 加上網路上的規則，稍加自定就很獲得不錯的使用體驗，
            
        </summary>
        
        <category term="折騰"/>
        
        <category term="#SafeForLife"/>
        
        <category term="Linux"/>
        
        <category term="Network"/>
        
        <category term="OpenWRT"/>
        
    </entry>
    
    <entry>
        <title>櫻川貓咪咖啡廳企劃二部外送事業筆記</title>
        <link href="https://asaba.sakuragawa.moe/2020/12/%e6%ab%bb%e5%b7%9d%e8%b2%93%e5%92%aa%e5%92%96%e5%95%a1%e5%bb%b3%e4%bc%81%e5%8a%83%e4%ba%8c%e9%83%a8%e5%a4%96%e9%80%81%e4%ba%8b%e6%a5%ad%e7%ad%86%e8%a8%98/?pk_campaign=feed&amp;pk_kwd=%25e6%25ab%25bb%25e5%25b7%259d%25e8%25b2%2593%25e5%2592%25aa%25e5%2592%2596%25e5%2595%25a1%25e5%25bb%25b3%25e4%25bc%2581%25e5%258a%2583%25e4%25ba%258c%25e9%2583%25a8%25e5%25a4%2596%25e9%2580%2581%25e4%25ba%258b%25e6%25a5%25ad%25e7%25ad%2586%25e8%25a8%2598"/>
        <id>https://asaba.sakuragawa.moe/2020/12/%e6%ab%bb%e5%b7%9d%e8%b2%93%e5%92%aa%e5%92%96%e5%95%a1%e5%bb%b3%e4%bc%81%e5%8a%83%e4%ba%8c%e9%83%a8%e5%a4%96%e9%80%81%e4%ba%8b%e6%a5%ad%e7%ad%86%e8%a8%98/?pk_campaign=feed&amp;pk_kwd=%25e6%25ab%25bb%25e5%25b7%259d%25e8%25b2%2593%25e5%2592%25aa%25e5%2592%2596%25e5%2595%25a1%25e5%25bb%25b3%25e4%25bc%2581%25e5%258a%2583%25e4%25ba%258c%25e9%2583%25a8%25e5%25a4%2596%25e9%2580%2581%25e4%25ba%258b%25e6%25a5%25ad%25e7%25ad%2586%25e8%25a8%2598</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2020-12-28T18:50:04+00:00</published>
        <updated>2020-12-28T18:50:04+00:00</updated>
        
        <content type="html"><![CDATA[<p>貓咪咖啡廳產業競爭激烈，雖然每隻貓性格不一，吸引點也不同，但對於一般消費者而言無法藉此帶來根本性的競爭力，也無法有效吸引新客戶。爲達到開拓新市場、差異化競爭的目的，現由企劃二部組建外送事業組並負責籌劃外送事宜。</p>



<p>…………</p>



<p>外送事業可解決客戶「出門遠」「出門難」的問題，匹配並有效滿足客戶「足不出戶」的需求。舉例一個典型場景：客戶由於感情需求，需要貓咪陪伴；但此時戶外溫度不足 10 攝氏度，穿戴出門不但麻煩，而且路途遙遠要忍受寒冷，更有可能到達之後已經興味索然。此時若直接利用外送服務，可在家中等待，直接在溫暖的房間中享受貓咪的陪伴。如此可以提高客戶的消費意願及最終的消費轉化率。</p>



<p>傳統貓咪咖啡廳的消費盈利點主要爲收取一次性門票、酒水消費、貓咪用品消費等。外送雖然免去店面租金、水電等成本，但又引入人員、調度成本，並且無法透過酒水消費盈利。不過，外送仍然可以販賣特定口味貓咪零食等，可在客戶點單時消費，也可由外送員事先攜帶部分、客戶現場消費。</p>



<hr />



<p>外送服務流程大致如下：</p>



<ol><li>確認貓咪出臺情況；</li><li>客戶選擇心儀的貓咪並選擇時間；</li><li>外送員使用航空箱將貓咪及貓糧、手套、清潔用品等送達；</li><li>外送員全程記錄貓咪狀態並指導客人與貓咪互動；</li><li>外送員使用航空箱將貓咪送回。</li></ol>



<hr />



<p>…………</p>



<p>貓咪有固定的互動玩耍時間和休息時間，應考慮到貓咪的習性，儘量做到生活及工作的平衡。貓咪每天的精力有限，只能接待有限數量的客戶，並且由於貓咪品種、外觀、性格各異，受客戶歡迎程度也不同，費用也應作出調整適應不同的客戶。宗上，擬按天、分上下午出臺，並根據受客戶喜愛程度及消費轉化率分爲普通貓咪、專家貓咪、特需貓咪，分級制定接待價格。</p>



<p>同時，貓咪與客戶應有雙向選擇的權利，因此可設置相處期與預約制度。對於貓咪不喜歡的客戶，相處期結束前可以拒絕服務，並當場做退號退款處理，同時可視情況後續不再接待；對於貓咪喜歡的客戶，則可主動預約後續接待。</p>



<p>…………</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2020%2F12%2F%25e6%25ab%25bb%25e5%25b7%259d%25e8%25b2%2593%25e5%2592%25aa%25e5%2592%2596%25e5%2595%25a1%25e5%25bb%25b3%25e4%25bc%2581%25e5%258a%2583%25e4%25ba%258c%25e9%2583%25a8%25e5%25a4%2596%25e9%2580%2581%25e4%25ba%258b%25e6%25a5%25ad%25e7%25ad%2586%25e8%25a8%2598%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e6%2525ab%2525bb%2525e5%2525b7%25259d%2525e8%2525b2%252593%2525e5%252592%2525aa%2525e5%252592%252596%2525e5%252595%2525a1%2525e5%2525bb%2525b3%2525e4%2525bc%252581%2525e5%25258a%252583%2525e4%2525ba%25258c%2525e9%252583%2525a8%2525e5%2525a4%252596%2525e9%252580%252581%2525e4%2525ba%25258b%2525e6%2525a5%2525ad%2525e7%2525ad%252586%2525e8%2525a8%252598&amp;action_name=%E6%AB%BB%E5%B7%9D%E8%B2%93%E5%92%AA%E5%92%96%E5%95%A1%E5%BB%B3%E4%BC%81%E5%8A%83%E4%BA%8C%E9%83%A8%E5%A4%96%E9%80%81%E4%BA%8B%E6%A5%AD%E7%AD%86%E8%A8%98&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2200" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>    </span>
</div><div>
    <a data-post-id="2200" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            貓咪咖啡廳產業競爭激烈，雖然每隻貓性格不一，吸引點也不同，但對於一般消費者而言無法藉此帶來根本性的競爭力，也無法有效吸引新客戶。爲達到開拓新市場、差異化競爭的目的，現由企劃二部組建外送事業組並負責籌劃外送事宜。    …………    外送事業可解決客戶「出門遠」「出門難」的問題
            
        </summary>
        
        <category term="想法"/>
        
        <category term="#SafeForLife"/>
        
    </entry>
    
    <entry>
        <title>ARM 平臺 DiskStation Manager (DSM) 的一些集錦</title>
        <link href="https://asaba.sakuragawa.moe/2020/12/arm-%e5%b9%b3%e8%87%ba-diskstation-manager-dsm-%e7%9a%84%e4%b8%80%e4%ba%9b%e9%9b%86%e9%8c%a6/?pk_campaign=feed&amp;pk_kwd=arm-%25e5%25b9%25b3%25e8%2587%25ba-diskstation-manager-dsm-%25e7%259a%2584%25e4%25b8%2580%25e4%25ba%259b%25e9%259b%2586%25e9%258c%25a6"/>
        <id>https://asaba.sakuragawa.moe/2020/12/arm-%e5%b9%b3%e8%87%ba-diskstation-manager-dsm-%e7%9a%84%e4%b8%80%e4%ba%9b%e9%9b%86%e9%8c%a6/?pk_campaign=feed&amp;pk_kwd=arm-%25e5%25b9%25b3%25e8%2587%25ba-diskstation-manager-dsm-%25e7%259a%2584%25e4%25b8%2580%25e4%25ba%259b%25e9%259b%2586%25e9%258c%25a6</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2020-12-19T17:56:00+00:00</published>
        <updated>2020-12-19T17:56:00+00:00</updated>
        
        <content type="html"><![CDATA[<p>ARM 平臺的 DSM 效能普遍不強，加上官方的限制，整體可玩性確實無法與 x86 平臺相比。但由於 DSM 本身基於 Linux 的特點及第三方的努力，還有一些有意思的事情可以做，多少還能更有趣甚至實用一些。</p>



<h1>套件</h1>



<h2>添加社羣源</h2>



<ul><li><a href="https://synocommunity.com/#easy-install" target="_blank">SynoCommunity</a><ul><li>SC 是最大的 Synology 第三方套件社羣，不僅打包的套件覆蓋了幾乎所有可支援的硬體平臺，並且開放了自己的<a href="https://github.com/SynoCommunity/spksrc" target="_blank">打包系統</a>，簡單修改就可以增加自己的套件。</li></ul></li><li><a href="https://www.cphub.net/" target="_blank">Community Package Hub</a><ul><li>CPHub 主要被用來建立 <a href="https://github.com/Entware/Entware" target="_blank">Entware</a> 環境，不過很遺憾的是沒有 ARM 平臺（至少是 Marvell）可用的包。</li></ul></li></ul>



<h2>修改安裝官方套件</h2>



<p>出於定位和等級劃分原因，<strong>ARM 平臺的 DiskStation 上只提供較少的套件</strong>；而即使同是 ARM 架構，還要再分三六九等，搭載 Alpine 處理器的機種獲得了最多的套件，其次是使用 Realtek RTD1296 的 DS420j、DS220j，而使用 Marvell ARMADA 平臺的 DS120j、DS119j 則只有最基礎的一些套件。比如 Syncthing 就只提供了 <code>i686</code>、<code>alpine</code>、<code>alpine4k</code> 和 <code>armv8</code> 版本，而雖然明面上標註着 <code>armv8</code>，但實際適用的平臺是 <code>rtd1296</code>。不知是考慮到記憶體較少還是其他原因，群暉官方並未提供對應版本的套件包；然而 <strong>Marvell ARMADA 也是 <code>armv8</code> 平臺</strong>，理論上也應可以運行，只是<strong>需要做一些手腳</strong>。</p>



<p>首先去<a href="https://archive.synology.com/download/Package/spk/" target="_blank">群暉官方存檔伺服器</a>下載所需要套件的 armv8 版本。以浅羽打算安裝的 Syncthing 爲例，需要下載 <code>syncthing.net/1.3.4.1/syncthing.net-armv8-1.3.4.1.spk</code>。使用 7-zip 打開 <code>.spk</code> 套件包，提取 <code>INFO</code> 檔案並打開，可以看到一系列標註：</p>



<pre><code>package="syncthing.net"
version="1.7.1"
maintainer="Syncthing Community"
maintainer_url="https://www.syncthing.net/"
distributor="Kastelo Inc."
distributor_url="https://www.kastelo.net/"
arch="rtd1296"
....</code></pre>



<p>重點在於 <code>arch="rtd1296"</code> 一行，這裏標註了支援的硬體平臺。對應 DS120j 的處理器，這裏改成 <code>arch="armada37xx"</code> 或者 <code>arch="armv8"</code> 均可，浅羽改成後者。隨後在套件管理器中選擇手動安裝並上傳對應的 <code>spk</code> 檔案，<strong>套件管理器會提示「套件損毀」</strong>，不過<strong>忽略後仍可以成功安裝並且正常運行</strong>。</p>



<h1>系統美化</h1>



<h2>登入背景自動更換 Bing Wallpaper</h2>



<p>運用 Bing 的 API 及對 DSM 的一些瞭解，在控制台 – 任務排程表中新增排程任務，並選擇「使用者定義指令碼」，增加以下指令稿：</p>



<pre><code>#!/bin/bash
# 如需收集每日美图去掉下面注释设置保存文件夹路径
# 在 FileStation 里面右键文件夹属性可以看到路径
#savepath="/volume1/wallpaper"
#dsmuser="admin"
pic=$(wget -t 5 --no-check-certificate -qO- "https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1")
echo $pic | grep -q enddate || exit 1
link=$(echo https://www.bing.com$(echo $pic | sed 's/.\+"url"[:" ]\+//g' | sed 's/".\+//g'))
date=$(echo $pic | sed 's/.\+enddate[": ]\+//g' | grep -Eo 2[0-9]{7} | head -1)
tmpfile=/tmp/$date"_bing.jpg"
wget -t 5 --no-check-certificate $link -qO $tmpfile
if [ ! -s $tmpfile ] ; then
    exit 2
fi
rm -f /usr/syno/etc/login_background*.jpg
cp -f $tmpfile /usr/syno/etc/login_background.jpg &amp;&gt;/dev/null
cp -f $tmpfile /usr/syno/etc/login_background_hd.jpg &amp;&gt;/dev/null
title=$(echo $pic | sed 's/.\+"title":"//g' | sed 's/".\+//g')
copyright=$(echo $pic | sed 's/.\+"copyright[:" ]\+//g' | sed 's/".\+//g')
word=$(echo $copyright | sed 's/(.\+//g')
if  [ ! -n "$title" ] ; then
    cninfo=$(echo $copyright | sed 's/，/"/g' | sed 's/,/"/g' | sed 's/(/"/g' | sed 's/ //g' | sed 's/\//_/g' | sed 's/)//g')
    title=$(echo $cninfo | cut -d'"' -f1)
    word=$(echo $cninfo | cut -d'"' -f2)
fi
sed -i s/login_background_customize=.*//g /etc/synoinfo.conf
echo "login_background_customize=\"yes\""&gt;&gt;/etc/synoinfo.conf
sed -i s/login_welcome_title=.*//g /etc/synoinfo.conf
echo "login_welcome_title=\"$title\""&gt;&gt;/etc/synoinfo.conf
sed -i s/login_welcome_msg=.*//g /etc/synoinfo.conf
echo "login_welcome_msg=\"$word\""&gt;&gt;/etc/synoinfo.conf
if [ ! -z $savepath ] ; then
    cp -f $tmpfile $savepath/$date@$title-$word.jpg
fi
if [ ! -z $dsmuser ] ; then
    cp -f $tmpfile /usr/syno/etc/preference/$dsmuser/wallpaper &amp;&gt;/dev/null
    chown $dsmuser /usr/syno/etc/preference/$dsmuser/wallpaper
fi
rm -f /tmp/*_bing.jpg
</code></pre>



<ul><li>參考：<a href="https://03k.org/dsm-bing.html" target="_blank">巧用计划任务修改群晖登录壁纸 – kissshot</a></li></ul>



<h1>DSM 降級</h1>



<p>在 SSH 中執行 <code>sudo vim /etc.defaults/VERSION</code>，把版本號修改到比目標版本低一些。比如浅羽現在計劃降級回 DSM 6.2.3-25426，上一版本是 6.2.2-24922：</p>



<pre><code>majorversion="6"
minorversion="1"
major="6"
minor="1"
micro="0"
productversion="6.1.0"
buildphase="GM"  
buildnumber="23456"
smallfixnumber="0"
nano="0"
base="23456"
builddate="1998/11/08"
buildtime="18:39:13"
unique="synology_armada37xx_ds120j"
extractsize=689888
partitionversionlimit=0
</code></pre>



<p>重新開機後，直接訪問 <code>http://${IP}:5000</code>，應可看到「硬碟搬移」畫面。此時直接上傳老版本的 pat 檔案安裝 DSM，中途會失敗。需要使用 <code>telnet</code> 登入後再修改一下系統版本。</p>



<div><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/12/Screenshot_20201123_163610.png" />更新到一半後一定會失敗</div>



<blockquote><p>SynologyNAS login: <code>root</code><br />Password: <code>101-0101</code><br />…</p></blockquote>



<p>再次選擇 pat 檔並上載安裝，就可以正確安裝並等待重新啓動了。</p>



<p>那爲什麼不一開始在 Web Assistant 頁面就改好版本直接安裝呢？因爲只有下載完畢開始安裝的時候 Telnet 才會開啓……</p>



<ul><li>參考：<a href="https://www.chiphell.com/thread-2217125-1-1.html" target="_blank">白群晖DSM6.2降级DSM5.2记录 – savioler</a></li></ul>



<p></p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2020%2F12%2Farm-%25e5%25b9%25b3%25e8%2587%25ba-diskstation-manager-dsm-%25e7%259a%2584%25e4%25b8%2580%25e4%25ba%259b%25e9%259b%2586%25e9%258c%25a6%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3Darm-%2525e5%2525b9%2525b3%2525e8%252587%2525ba-diskstation-manager-dsm-%2525e7%25259a%252584%2525e4%2525b8%252580%2525e4%2525ba%25259b%2525e9%25259b%252586%2525e9%25258c%2525a6&amp;action_name=ARM+%E5%B9%B3%E8%87%BA+DiskStation+Manager+%28DSM%29+%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%86%E9%8C%A6&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2196" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>    </span>
</div><div>
    <a data-post-id="2196" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            ARM 平臺的 DSM 效能普遍不強，加上官方的限制，整體可玩性確實無法與 x86 平臺相比。但由於 DSM 本身基於 Linux 的特點及第三方的努力，還有一些有意思的事情可以做，多少還能更有趣甚至實用一些。    套件    添加社羣源    SynoCommunitySC
            
        </summary>
        
        <category term="折騰"/>
        
        <category term="#SafeForLife"/>
        
        <category term="Network"/>
        
        <category term="OS"/>
        
        <category term="Software"/>
        
    </entry>
    
    <entry>
        <title>写在中国宪法日</title>
        <link href="https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/"/>
        <id>https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>            <p>他从996的公司下班骑着ofo回到了蛋壳租的公寓看杨超越丁真——CyberPunk</p>          </blockquote><h1><a href="https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/#引言"></a>引言</h1><p>今天是12月4日，中国宪法日。同时也是香风智乃的生日，虽然宪法离我非常遥远，我也不看点兔，但今天着实也是于我而言重要的一天。在这一天，我持续三年的初恋正式宣告终结。现在找点空位在这里倒垃圾，顺便键政一下。<br />就结果而言，人的感情其实相当脆弱，三年的感情也可能在短短几小时内毁于一旦。常言道：“知人知面不知心”，人的价值观远远不是短短三年就能看清的。既然已经结束，我也不想发表什么言论，骂她啊啥的不过是幼稚的行为，根本上她也只是受害者，今天是想来谈谈事情的前因后果以及对时事的一些思考。</p><a></a><h1><a href="https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/#起因"></a>起因</h1><p>我前女友对于肖战是完全的不感冒，我个人老二次元了，自然也不会关心这方面的事情。我曾经一度认为饭圈文化离我们很远，直到丁真的出现。自从丁真火了之后，她便被其疯狂圈粉，手机壁纸也从小栗旬换成了丁真，每日高强度在论坛和anti对线，一口一个“🍋🐔”。丁真，一个远在理塘的人，我自然犯不着去吃他的醋，但是由此而言产生的争论才是真正破裂的原因。</p><p>昨日，华春莹连发三条推特为其站台，在每天中午的键政时间中，我自然为这种行为表示了担忧。没想到就因为这个原因，我也被贴上了“酸，嫉妒”的标签，一瞬间她仿佛不再是那个熟悉的她，而是化身微博女拳师。由此产生了一些争论，最后造成了感情的破裂，个中细节，家长里短，在此略过不谈。</p><h1><a href="https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/#思考"></a>思考</h1><p>主要是想谈谈对于“丁真现象”的思考。大部分人对于丁真的恶意来源应该都是认为其“德不配位”吧，一个文盲却能爆红于网络，由此产生了“酸”、“嫉妒”的感情，大有早年间“仇富”的影子。但是其实矛头不应该对准丁真，他不过就是一个淳朴的放牛娃罢了，文盲的问题更不应该苛责他，而是去质问当地主管教育部门的官员。真正应该思考的是，为什么？为什么他一个文盲就都能火起来，靠脸吗？</p><img src="https://blog.gaojianli.me/2020/12/04/%E5%86%99%E5%9C%A8%E4%B8%AD%E5%9B%BD%E5%AE%AA%E6%B3%95%E6%97%A5/%E4%B8%81%E7%9C%9F%E9%9C%B8%E5%8D%A0%E7%83%AD%E6%90%9C.jpg" /><p>不幸的是，是的，就是靠脸。这几年，娱乐界的明星门槛日益降低，从老一辈艺术家德艺双馨，到流行歌手作词作曲，他们的成功，虽然可能容易一些，但都付出了自己的努力。无论是学习乐理，声乐，还是自己作词作曲，我们都可以说成是努力带来的回报，他们所有的获得都可勉强放置在“劳有所得”这一大框架下。然而从杨超越开始，这一切都变了。无需任何努力仅凭一张脸就可以成立自己公司，作为“特殊人才”落户上海。也许是尝到甜头后更加变本加厉，这一次更加简单粗暴。把一个文盲摆在台前，狠狠地打一打你们这些“读书改变命运”的人的脸。我和我的小伙伴们小时候的理想都是军人，警察，科学家，如果我的孩子说出：“我不读书，我要当网红！”，那是多么可怕的场景！</p><p>每当我谈起这个问题的时候，她的回答都是“人家可不是什么都没干，人家可是国企员工。”这么一看，我突然觉得我的舍友非常可笑，可悲。他为了拿到一个家乡国企的岗位，每天四处奔波，在贵州和北京之间不断往返，顶着干眼症，圆锥角膜的风险努力复习。更忘不了他提到“这个岗位报名有700多，简历筛选完只有40个人进笔试”时的那一抹庆幸。是啊，读书有什么用呢？读了10多年书之后仅仅是得到了和700个人竞争同一岗位的资格，而别人仅凭一张脸就能取得。几年前我们还在嘲笑日本小学生的梦想时是成为野兽先辈那样的人，现如今我们的下一代竟然也要陷入同样的境地。</p><p>对此，我女朋友的回答是“命”，丁真命中注定富贵。我难以想象这是一个正在备考考研政治的人能说出来的话。马克思说过，“阶级决定个人命运”，丁真是什么阶级，这是他的命运吗？改变他命运的当然不成冥冥之中的天命，而是背后的资本。古人云：“时来天地皆同力，运去英雄不自由。”这首诗的当今版本是“资来天地皆同力，资去英雄不自由”，资本可以随时随地地捧红一个人，也可以随时随地踩死一个人。</p><p>如今，国家为丁真站台，天地同力，我也不敢逆天而行发表什么意见。只是，当资本越来越为所欲为，试探底线的时候，是否应该警惕呢？从“东林书院”到“湖畔大学”；从敬新磨到杨超越；从包身工到996。以史为鉴，可以知兴替，望诸君不要放弃理想。</p><p>では、諸君は。</p>]]></content>
        
        <summary type="html">
            
                        他从996的公司下班骑着ofo回到了蛋壳租的公寓看杨超越丁真——CyberPunk          引言今天是12月4日，中国宪法日。同时也是香风智乃的生日，虽然宪法离我非常遥远，我也不看点兔，但今天着实也是于我而言重要的一天。在这一天，我持续三年的初
            
        </summary>
        
        <category term="杂谈"/>
        
    </entry>
    
    <entry>
        <title>礦渣「貓盤」與輕量個人 NAS</title>
        <link href="https://asaba.sakuragawa.moe/2020/11/%e7%a4%a6%e6%b8%a3%e3%80%8c%e8%b2%93%e7%9b%a4%e3%80%8d%e8%88%87%e8%bc%95%e9%87%8f%e5%80%8b%e4%ba%ba-nas/?pk_campaign=feed&amp;pk_kwd=%25e7%25a4%25a6%25e6%25b8%25a3%25e3%2580%258c%25e8%25b2%2593%25e7%259b%25a4%25e3%2580%258d%25e8%2588%2587%25e8%25bc%2595%25e9%2587%258f%25e5%2580%258b%25e4%25ba%25ba-nas"/>
        <id>https://asaba.sakuragawa.moe/2020/11/%e7%a4%a6%e6%b8%a3%e3%80%8c%e8%b2%93%e7%9b%a4%e3%80%8d%e8%88%87%e8%bc%95%e9%87%8f%e5%80%8b%e4%ba%ba-nas/?pk_campaign=feed&amp;pk_kwd=%25e7%25a4%25a6%25e6%25b8%25a3%25e3%2580%258c%25e8%25b2%2593%25e7%259b%25a4%25e3%2580%258d%25e8%2588%2587%25e8%25bc%2595%25e9%2587%258f%25e5%2580%258b%25e4%25ba%25ba-nas</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2020-11-30T11:30:51+00:00</published>
        <updated>2020-11-30T11:30:51+00:00</updated>
        
        <content type="html"><![CDATA[<h1>爲什麼買</h1>



<blockquote><p><s><strong>用貓盤，變貓娘！</strong></s></p></blockquote>



<p><strong>好看。</strong></p>



<p>話又說回來，貓盤本身就定位「<em>共享智能硬盘</em>」「<em>智能硬盘</em>」，目標是「<em>让硬盘变身网盘</em>」。加上不太多見的 2.5 吋單磁碟槽配置，用貓盤做一個<strong>小巧好看的便宜玩具 NAS</strong> 似乎就更理所當然了。</p>



<h1>開箱與硬體</h1>



<p>考慮到買的主要原因是「好看」，<strong>浅羽並不打算購買到處是劃痕磕碰、缺蓋子少螺絲的「九成新」</strong>。但實際上白色款似乎是買不到全新了，浅羽最後還是忍痛高價購入了箱說全的二手白色款。據商家說明，成色有 95 新以上，安裝好群暉系統並洗白，同時保證「不掉 IP」。</p>



<p>貓盤本身造型非常傢俱化，本身是圓柱造型。<strong>黑色與白色的貓盤機身工藝上有所區別，前者爲磨砂質感的磨砂塑料，後者則是鏡面烤漆</strong>，兩者都在頂部設計了一圈鑲嵌金色裝飾環，<s>像極了電磁爐</s>。再加上 RGB LED，<strong>外觀方面可以說是「礦渣無敵手」</strong>。</p>



<img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/11/PXL_20201130_094143395-scaled.jpg" />貓盤體積小的好處就是可以到處亂塞



<p>不過除去外觀，貓盤的核心硬體也算得上是 ARM NAS 的典範：</p>



<ul><li>Marvell ARMADA 3700 (88F3720) SoC<ul><li>Dual 64-bit ARM v8 Cortex-A53 processor</li></ul></li><li>512MB DDR3L non-ECC RAM</li><li>8GB eMMC</li><li>USB 2.0 4 PIN Male Header (inside)</li></ul>



<p>除去 <a href="http://espressobin.net/tech-spec/" target="_blank">ESPRESSObin 開發板</a>，市面上還有不少同樣方案的商業產品，光是 NAS 品類就有 <a href="https://www.onespace.net.cn/" target="_blank">OneSpace</a> X3Plus 和 Synology DiskStation DS120j 兩款，核心硬體上可謂是一模一樣。這也讓自帶系統相對封閉、功能羸弱的貓盤有了更多的可能性。</p>



<img src="https://www.onespace.net.cn/pic/home_2.jpg" />



<p>另外貓盤還有大小之分，二者除了前者體積更大、能容納 3.5″ 硬碟外並無硬體和功能上的分別。不過<strong>貓盤（小貓盤）使用 5V DC 電源</strong>；<strong>貓盤 Plus（大貓盤）則使用 12V DC 供電</strong>，可以由輸入直接驅動 3.5″ 硬碟，理論上會對硬碟壽命以及資料安全有積極作用。另外還有一種<strong>沒有了上蓋（硬碟防塵蓋）的貓盤 Plus，網路普遍稱爲「中貓盤」</strong>，實質也與大貓盤沒有區別。</p>



<h1>灌入非官方韌體</h1>



<p>貓盤自己的系統固然簡陋（夠用），但高度相似的硬體也爲非官方系統打下了基礎。根據網路資料，早起背面標有「Halos」字樣的貓盤甚至可以直接灌入經過修改的開機韌體後同樣灌入 OneSpace 的系統。<strong>OneSpace 的系統本身已有一定可玩性</strong>，除去基礎的存儲功能還開放了 MariaDB 資料庫、PHP 等應用，有些像早期的「網路空間」。實際上，<strong>OneSpace 的系統除去少數自己開發定製的組件，其餘都是整合流行的免費應用以提供服務</strong>，整體更像是預先設定好的 Linux 系統。</p>



<p>最近灌入黑群暉的研究成果也已經公開，變成了「貓群暉」，售價也再次迎來一波飛漲。作爲家用 NAS 系統軟體方面的龍頭老大，旗下的 DSM 雖然是封閉原始碼的定製系統，但整體的功能性毋庸置疑。只可惜 <strong>Container Station 暫時沒有開放給 ARM 機種</strong>，雖然不等於完全不能使用容器，但作業系統的價值就顯得低了。尤其是當 DSM 7 更新正式釋出後，由於<a href="https://help.synology.com/developer-guide/privilege/preface.html" target="_blank">系統降低了套件的運行權限</a>，許多套件暫時只能使用容器方式運行，原本對應套件就少的 ARM 平臺 DSM 只會更加缺乏功能。</p>



<p>具體灌入各種系統的資料網路上有很多可供參考，浅羽就不再贅述了。當然更主要的原因是浅羽選擇了灌好系統的成品，沒有實際操作過。如果後續再折騰，後續再另外寫分享。</p>



<h1>效能與使用體驗</h1>



<p>貓盤與許多家用網路裝置一樣是 <strong>ARM 架構裝置</strong><s>，本質上與 Pi NAS 無異</s>。通常印象中 ARM 架構的處理器在計算效能上會比 x86 處理器更低一些，但這同時也<strong>受目標場景與設計功耗的影響</strong>，單純比較效能並不公平。強如 QNAP TS-532X 使用一顆 Amazon 旗下公司 <a href="https://deviwiki.com/wiki/Annapurna_Labs" target="_blank">AnnapurnaLabs 設計的 Alpine</a> AL324 四核心 ARM® Cortex-A57 也一樣驅動了雙萬兆 NAS 系統。</p>



<p>浅羽拿到這臺貓盤已經灌入了 DSM。雖說這套硬體在群暉家族裏是最入門的款式，但<strong>處理器效能尚能堪用</strong>，安裝一些常用套件後，CPU 平日在 30% 左右，RAM 則會在 50% 左右。如果趕上 Syncthing 在同步，那麼 CPU 就要逼近佔滿了，不過實際同步的速度在正常預期附近，<strong>操作也能保持流暢</strong>。</p>



<p>貓盤在 SoC 上裝設了巨大的散熱片，同時還配有一個側出風扇幫助散熱片和硬碟進行主動散熱的。浅羽放入了一塊<s>淘汰的</s> WD Blue WD5000LPVX 500G 2.5″ SATA 機械硬碟並連續運作數日，<strong>硬碟溫度最高也保持在 41°C 左右</strong>，散熱應付一般的 2.5 吋硬碟綽綽有餘；整體系統的熱量也維持在 40°C。風扇的就是雙線風扇，應該不支援調速。浅羽把貓盤放在顯示器下，距離大約半米的情況下，在安靜環境中還是略可耳聞偏中高頻的工作噪音；不過<strong>如果放在電視櫃或者機櫃裏就完全沒有噪音問題了</strong>。</p>



<p>受硬體和產品定位的雙重制約，DSM 下只開放使用 <code>ext4</code> 檔案系統，並且不存在什麼「存儲池設定」一類的嚮導精靈，直接是 Basic 單碟存儲。畢竟只有單槽位的設計，<strong>安全性上肯定就沒有額外保障了</strong>，不過畢竟是「輕量 NAS」、「玩具 NAS」，群暉系統配 iPad，摸魚沒有大問題。</p>



<h1>入手上車總結</h1>



<p><strong>貓盤的很多設計可能與常理上的 NAS 相異</strong>，但並不是百害而無一利，又不是百利而無一害。所以這一次的總結，浅羽要把正反兩面話一次都說了。</p>



<table><thead><tr><th>特點</th><th>相對優點</th><th>相對缺陷</th></tr></thead><tbody><tr><td>ARM 架構</td><td>本體功耗較低</td><td>速度慢；可玩性受限</td></tr><tr><td>2.5 吋單槽設計</td><td>體積小巧；靜音</td><td>擴充性受限</td></tr><tr><td>可用多種系統</td><td>適應用途多</td><td>非原廠系統有穩定性隱患</td></tr><tr><td>圓形外觀設計</td><td>獨特美觀；散熱空間大</td><td>空間利用率略低</td></tr></tbody></table>



<hr />



<h1>附加參考資料</h1>



<ul><li>綜合<ul><li><a href="https://bbs.nas66.com/forum.php?mod=viewthread&amp;tid=668" target="_blank">【原创】关于猫盘刷机的一些事项！ – 矿渣社区</a></li><li><a href="https://koolshare.cn/thread-170378-1-1.html" target="_blank">【黑群】另类黑群设备猫盘（ARM） – 网络设备 – KoolShare</a></li></ul></li><li>群暉 DSM<ul><li><a href="https://post.smzdm.com/p/a6lnwp3o/" target="_blank">群晖小白猫盘NAS折腾记</a></li><li><a href="https://post.smzdm.com/p/a83946ll/" target="_blank">群晖 篇一：超详细猫盘单群晖固件刷机教程_NAS存储_什么值得买</a></li><li><a href="https://bbs.nas66.com/thread-7843-1-1.html" target="_blank">全洗白！DS120固件，混点渣金买魔盒TT – 矿渣社区 – 猫盘 – 硬件专区</a></li><li><a href="https://zhuanlan.zhihu.com/p/104139410" target="_blank">将猫盘固件从 DS119J 升级为 DS120J</a></li><li><a href="https://zhuanlan.zhihu.com/p/111714577" target="_blank">猫盘群晖从 DS120J 降级到 DS119J</a></li><li><a href="https://post.smzdm.com/p/and2oqvv/" target="_blank">猫盘ARM群晖 玩机总结贴 一贴玩转猫盘_NAS存储_什么值得买</a></li></ul></li><li>OneSpace 系統<ul><li><a href="https://post.smzdm.com/p/aekznr74/" target="_blank">猫盘轻量化NAS 免TTL细致刷机教程_NAS存储_什么值得买</a></li></ul></li></ul>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2020%2F11%2F%25e7%25a4%25a6%25e6%25b8%25a3%25e3%2580%258c%25e8%25b2%2593%25e7%259b%25a4%25e3%2580%258d%25e8%2588%2587%25e8%25bc%2595%25e9%2587%258f%25e5%2580%258b%25e4%25ba%25ba-nas%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e7%2525a4%2525a6%2525e6%2525b8%2525a3%2525e3%252580%25258c%2525e8%2525b2%252593%2525e7%25259b%2525a4%2525e3%252580%25258d%2525e8%252588%252587%2525e8%2525bc%252595%2525e9%252587%25258f%2525e5%252580%25258b%2525e4%2525ba%2525ba-nas&amp;action_name=%E7%A4%A6%E6%B8%A3%E3%80%8C%E8%B2%93%E7%9B%A4%E3%80%8D%E8%88%87%E8%BC%95%E9%87%8F%E5%80%8B%E4%BA%BA+NAS&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2180" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>3    </span>
</div><div>
    <a data-post-id="2180" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            爲什麼買    用貓盤，變貓娘！    好看。    話又說回來，貓盤本身就定位「共享智能硬盘」「智能硬盘」，目標是「让硬盘变身网盘」。加上不太多見的 2.5 吋單磁碟槽配置，用貓盤做一個小巧好看的便宜玩具 NAS 似乎就更理所當然了。    開箱與硬體    考慮到買的主要原
            
        </summary>
        
        <category term="折騰"/>
        
        <category term="開箱"/>
        
        <category term="#SafeForLife"/>
        
        <category term="Network"/>
        
        <category term="作死"/>
        
        <category term="國產"/>
        
    </entry>
    
    <entry>
        <title>搭建一个短网址系统</title>
        <link href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/"/>
        <id>https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#起"></a>起</h1><p>前阵子，在Xice的推荐下，我入手了一个3位<code>.eu</code>域名<code>u2b.eu</code>。他作为一个老羊毛党了，给我推荐的域名价格自然也十分离谱，<a href="https://www.icdsoft.com/en/domains" target="_blank">10年只要20刀</a>，反过来看看我正在使用的<code>gaojianli.me</code>，一年12刀的价格完美阐释了什么叫做没有对比就没有伤害。</p><blockquote><p>值得注意的是，<code>.eu</code>的域名要求欧盟（前）成员国居民的身份才能注册，因此一开始想当然拿了美国人身份注册的我险些打水漂，所幸最后通过一张PS的燃气账单侥幸蒙混过去，可谓是十分惊险。</p></blockquote><p>虽然如此，作为冲动消费捡垃圾的典型，拿下了这个域名其实也不知道做什么。<strong>虽然不知道有什么用，但是太便宜了先买了吧。</strong>抱着这种思想我没少买奇奇怪怪的玩意儿，而这个三位的域名看起来也是这样一个“鸡肋”。说有用吧，虽然是3位域名，但是为了追求3位导致了其基本就是随机的字符串，含义不明；说没用那毕竟还是个3位的顶级域名，<del>还能谐音碰瓷Youtube</del>。</p><p>在闲置了一阵子之后，姑且想到了一个用途，你不是短吗？那就来做个短网址系统吧！</p><a></a><h1><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#承"></a>承</h1><p>在我印象中，短网址这种烂大街的东西有不少的开源实现，但是最近闲的也是闲的，与其用别人的，不如自己来造个轮子吧。</p><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#规划"></a>规划</h2><p>首先来规划一下项目，难得能自己做个东西，便想用尽可能用一些新技术，因此没有选择劳模Node.js，而是打算尝鲜下微软的<code>ASP .NET Core</code>，这东西据说能完美跨平台运行在Linux上，满足我的需求不是问题。</p><p>因为要考虑到一个封装成API的可能，因此一定是前后端分离的架构。前端最初的时候是想尝试一下<a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-3.1" target="_blank">Razor</a>的，C#编译成wasm的方式还挺新颖的。但是写了2行就发现这东西是巨坑，因为它是！基！于！Bootstrap的！！这是多少年前的UI库了，组件全部用CSS来描述，写得十分痛苦和不便，果然火不起来是有理由的，还是老老实实Vue.js吧。</p><p>在做这个的时候，恰逢Vue 3.X 出世，也本想尝试一下<a href="https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api" target="_blank">Composition API</a>配合<a href="https://github.com/vitejs/vite" target="_blank">Vite</a>体验一把抛弃Webpack的感觉，<strong>然而</strong>，当我兴致冲冲搭建好了脚手架之后遇到了一个更严重问题：<strong>没有组件库</strong>。这连BootStrap都没有，更凄惨了！<del>写CSS是不可能写CSS的，这辈子也不可能手写的。</del> 最后，还是选择了劳模组合Vue2+Vuetify，也算是一大缺憾。</p><p>在架构之前还是了解了一下网上的常见方案，在现有方案中有人提出了一些建议：</p><blockquote><p>看了楼主代码.没上缓存(热点 url),没处理同一 url 连续两次转换出现不同结果的情况</p></blockquote><p>对于上面的意见，分开来探讨一下吧：</p><ul><li>对于意见2，目前很多现存的短网址都不支持这种功能（例如<code>goo.gl</code>），其理由也非常简单：不同的用户每次提交的URL都是一次不同的业务，如果合并了难以完成统计，撤销等功能。同时还给添加徒增工作量，每次添加时都会进行一次全表查询，纵有索引也会极大地浪费性能。</li><li>对于意见1，我的意见是请了解一下<a href="https://baike.baidu.com/item/%E8%BF%87%E6%97%A9%E4%BC%98%E5%8C%96/23734966?fr=aladdin" target="_blank">这个</a>。现如今，是个项目就无脑上集群、Redis，完全不顾是否真的有这个需求，私以为也是一种提前优化。对于单用户来说，由于短链接跳转使用的是HTTP 301 永久性转移(Permanently Moved)，第二次访问时会直接被浏览器所缓存；对于多用户来说，热点URL的概率同时被数百人访问的概率也非常低（每个人只需访问一次），更多的访问是离散的，增加Redis也不能增加太多性能。</li></ul><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#总结"></a>总结</h2><p>因此，总结一下所选解决方案如下：</p><table><thead><tr><th>分类</th><th>解决方案</th></tr></thead><tbody><tr><td>后端</td><td>ASP .NET Core</td></tr><tr><td>数据库</td><td>MySQL</td></tr><tr><td>前端</td><td>Vue.js</td></tr><tr><td>组件库</td><td><a href="https://vuetifyjs.com/" target="_blank">Vuetify</a></td></tr><tr><td>缓存</td><td>无</td></tr></tbody></table><h1><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#转"></a>转</h1><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#新时代的ASP初体验"></a>新时代的ASP初体验</h2><p>既然冒着踩坑的风险选择了<br />长久以来，提到ASP我想到的都是一众<code>.asp</code>、<code>.aspx</code>结尾的网站，广泛分布在各大机关单位学校中，伴随着的关键词还有：卡，慢，IE6，<del>大马</del>等,，但是在实际开发中微软着实给我了一个惊喜，非复吴下阿软矣。</p><p>在实际的开发体验中，ASP.NET开发体验比我预想中的好得多，得益于宇宙第一IDE的加持，代码模板非常齐全，可以直接<code>Controller</code>为单位新建代码，以<code>Controller</code>的前缀命名的路由避免了写一大坨<code>router.js</code>，通过<code>Attribute</code>的传参更是免去了一大堆类似<code>var a=request.body.a</code>这种提取参数的代码。</p><p>从设计模式上来说，数据库的访问应该与<code>Controller</code>分离，实现封装、解耦。但是得益于LINQ的强大威力，数据库的访问被压缩到了一行语句，考虑到本项目复杂度，此时再进行封装反而有过度设计的嫌疑了，因此直接LINQ写到<code>Controller</code>里算了。如下是实现短网址跳转的代码，可见不论是查询数据库还是中URL中传参都是十分简洁的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /></pre></td><td><pre><span>[<span>HttpGet(<span>"{shorten}"</span>)</span>]</span><br /><span><span><span>public</span> <span>void</span> <span>Forward</span>(<span><span>string</span> shorten, [FromServices] UrlContext dbContext</span>)</span></span><br /><span><span></span>{</span><br /><span>    <span>var</span> longUrl = <span>from</span> urls <span>in</span> dbContext.Urls</span><br /><span>                    <span>where</span> urls.shortUrl == shorten</span><br /><span>                    <span>select</span> urls.longUrl;</span><br /><span>    <span>if</span> (longUrl.Count() == <span>0</span>)</span><br /><span>    {</span><br /><span>        Response.Redirect(Configuration.GetSection(<span>"SiteSettings"</span>)[<span>"homePage"</span>]);</span><br /><span>    }</span><br /><span>    <span>else</span></span><br /><span>    {</span><br /><span>        Response.Redirect(longUrl.Single());</span><br /><span>    }</span><br /><span>}</span><br /></pre></td></tr></table><p>总而言之，ASP.NET Core我相当看好，尽管是微软的技术所以前景不容乐观，各位开发者还是学习Java前途更加光明。但是作为简单的项目来说其比Koa完善，同时配置比Java的Spring方便（不用写XML真是人间之鉴），Nuget还能直接高速访问不用代理，好处真是太多了。我花了2天时间通过自己摸索+VS的自动提示便基本熟悉了此框架并完成了此项目（有够简单就是了），换做是Spring上手应该很难这么快的吧。</p><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#短网址Hash算法"></a>短网址Hash算法</h2><p>关于这个网上也有很多讨论了，我对比后选择了“62进制法”。其核心是将长网址存入数据库后获得一个id，将id从10进制转换为62进制字符串，再加上一些随机字符串防止碰撞，最后得到缩短后的地址。</p><p>由于我直接将id设置为MySQL里的自增字段，因此连随机字符串都不需要了，直接把id拿来用就行了，反正也不存在碰撞的可能。进制转换代码是我从网上抄的Java代码改写的，<s>众所周知C#曾经有个名字叫J++</s>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /></pre></td><td><pre><span><span>public</span> <span>static</span> <span>char</span>[] alphaBet = { <span>'q'</span>, <span>'w'</span>, <span>'e'</span>, <span>'r'</span>, <span>'t'</span>, <span>'y'</span>, <span>'u'</span>, <span>'i'</span>, <span>'o'</span>, <span>'p'</span>, <span>'a'</span>, <span>'s'</span>, <span>'d'</span>, <span>'f'</span>, <span>'g'</span>, <span>'h'</span>, <span>'j'</span>, <span>'k'</span>, <span>'l'</span>, <span>'z'</span>, <span>'x'</span>, <span>'c'</span>, <span>'v'</span>, <span>'b'</span>, <span>'n'</span>, <span>'m'</span>, <span>'0'</span>, <span>'1'</span>, <span>'2'</span>, <span>'3'</span>, <span>'4'</span>, <span>'5'</span>, <span>'6'</span>, <span>'7'</span>, <span>'8'</span>, <span>'9'</span>, <span>'Q'</span>, <span>'W'</span>, <span>'E'</span>, <span>'R'</span>, <span>'T'</span>, <span>'Y'</span>, <span>'U'</span>, <span>'I'</span>, <span>'O'</span>, <span>'P'</span>, <span>'A'</span>, <span>'S'</span>, <span>'D'</span>, <span>'F'</span>, <span>'G'</span>, <span>'H'</span>, <span>'J'</span>, <span>'K'</span>, <span>'L'</span>, <span>'Z'</span>, <span>'X'</span>, <span>'C'</span>, <span>'V'</span>, <span>'B'</span>, <span>'N'</span>, <span>'M'</span> };</span><br /><span><span><span>public</span> <span>static</span> <span>string</span> <span>getShorted</span>(<span><span>long</span> id</span>)</span></span><br /><span><span></span>{</span><br /><span>    <span>var</span> rest = id;</span><br /><span>    Stack&lt;<span>char</span>&gt; stack = <span>new</span> Stack&lt;<span>char</span>&gt;();</span><br /><span>    StringBuilder result = <span>new</span> StringBuilder(<span>0</span>);</span><br /><span>    <span>while</span> (rest != <span>0</span>)</span><br /><span>    {</span><br /><span>        stack.Push(alphaBet[rest - (rest / <span>62</span>) * <span>62</span>]);</span><br /><span>        rest = rest / <span>62</span>;</span><br /><span>    }</span><br /><span>    <span>for</span> (; stack.Count() != <span>0</span>;)</span><br /><span>    {</span><br /><span>        result.Append(stack.Pop());</span><br /><span>    }</span><br /><span>    <span>return</span> result.ToString();</span><br /><span>}</span><br /></pre></td></tr></table><h1><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#合"></a>合</h1><p>至于前端部分就是普普通通的Vue.js应用，没什么好说的。写完之后编译、部署一气呵成，成果如下，欢迎体验：</p><ul><li>前端页面： <a href="https://short.u2b.eu" target="_blank">https://short.u2b.eu</a></li><li>缩短网址格式：<code>https://u2b.eu/{short}</code> ，例如 <a href="https://u2b.eu/i" target="_blank">https://u2b.eu/i</a> 对应 <a href="https://www.zhihu.com/" target="_blank">知乎</a></li></ul><p>值得注意的是Debian 10源中的<code>Mariadb</code>是链接<code>yaSSL</code>编译的，不支持TLS1.2及以上版本，在.NET Core 3.0以上版本的runtime上会报错，其解决方法是安装<code>Mariadb</code>官方源中的版本，其使用OpenSSL编译可以正常支持TLS1.2。</p><p>Update 2020.12.13:<br />懒癌终于治好了之后终于弄好了docker部署，接下来直接运行下面命令就可以部署啦：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>docker run -d -e ConnectionStrings__SqlConnection=<span>"server=&lt;ip to the db&gt;;port=&lt;db port&gt;;database=shortUrl;uid=shorturl;pwd=&lt;pwd&gt;;CharSet=utf8"</span> \</span><br /><span>-e SiteSettings__origin=<span>"https://short.u2b.eu"</span> \</span><br /><span>-e SiteSettings__homePage=<span>"https://short.u2b.eu"</span> \</span><br /><span>-e SiteSettings__prefix=<span>"https://u2b.eu"</span> \</span><br /><span>-p 5000:5000 \</span><br /><span>--name url_shorter \</span><br /><span>--restart=always \</span><br /><span>url_shorter</span><br /></pre></td></tr></table><p>では、諸君は。</p><h1><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#附录"></a>附录</h1><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#项目源代码"></a>项目源代码</h2><ul><li>后端：<a href="https://github.com/Gaojianli/UrlShorter" target="_blank">https://github.com/Gaojianli/UrlShorter</a></li><li>前端：<a href="https://github.com/Gaojianli/UrlShorter-web" target="_blank">https://github.com/Gaojianli/UrlShorter-web</a></li></ul><h2><a href="https://blog.gaojianli.me/2020/10/23/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/#Codespaces"></a>Codespaces</h2><p>由于偷懒，本文没有使用常规的VSCode写作，而是直接使用了Github的在线VSCode：<a href="https://github.com/features/codespaces/" target="_blank">Codespaces</a>，虽然很早我就排到了Codespaces的使用权，但是实际使用这是第一次，这里就顺便谈谈感想。</p><p>先说优点吧，其本质上是一个Ubuntu 18.04的容器，分配了1c4g的资源，里面运行了<code>vscode remote server</code>，然后浏览器远程连接之。好处是可以不用克隆代码和折腾Git，随到随写，哪怕是iPad也可以随时随地编程。</p><p><strong>但是</strong>，理想很美好，现实很骨感，实际体验那叫一个差。后悔，总之就是非常后悔，除了随时随地的掉线（2秒掉一次）外（Update 2020.12.13:别让它失焦，否则必定掉线），延迟也难以忍受。输入可能有优化和提前渲染，输入的时候完全体会不到延迟，但是一旦要编辑那就是噩梦。<strong>每次退格键</strong>都要触发一次服务器通讯，大概延迟在2s左右，在这等待期间如果你移动了光标，不好意思，你的删除内容会马上跳转到现光标所在位置上，导致意外删除。换言之，你的所有操作并不是按顺序进入队列中，而是按照js的微任务执行顺序来操作。好家伙，同步的文本编辑任务在它这里变成异步了，因此每当网络波动你就不得不停下来，等待操作执行完毕，以免发生意外操作。</p><p>关于这个功能，我觉得要么是大陆网络的问题，要么就只是个体验版，白嫖要什么自行车。猜想Github实际设计应该是让企业self hosted，然后再在内网中使用吧，就结果而言，完全不具备安装成PWA应用使用的可能性。</p>]]></content>
        
        <summary type="html">
            
            起前阵子，在Xice的推荐下，我入手了一个3位.eu域名u2b.eu。他作为一个老羊毛党了，给我推荐的域名价格自然也十分离谱，10年只要20刀，反过来看看我正在使用的gaojianli.me，一年12刀的价格完美阐释了什么叫做没有对比就没有伤害。值得注意的是，.eu的域名要求欧
            
        </summary>
        
        <category term="短网址"/>
        
        <category term="域名"/>
        
    </entry>
    
    <entry>
        <title>学术报告: Hamming classifier: from one-hot to multi-hot classification</title>
        <link href="http://www.pris.net.cn/archives/7352"/>
        <id>http://www.pris.net.cn/archives/7352</id>
        
        <author>
            <name>李春光 (Chun-Guang LI)</name>
        </author>
        
        <published>2020-10-08T16:44:39+00:00</published>
        <updated>2020-10-08T16:44:39+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>报告题目</strong>：Hamming classifier: from one-hot to multi-hot classification</p>



<p><strong>报告时间</strong>：10月10日 上午10:00-11:00</p>



<p><strong>报告地点</strong>：教三 811会议室</p>



<p><strong>报告简介</strong>：肖嵘博士，平安财产险科技中心首席研究员、人工智能部总经理，国家特聘专家，深圳市孔雀A类人才，负责人工智能技术在保险领域的创新研究。肖嵘于2001年获南京大学计算机博士学位，曾供职于微软亚洲研究院和微软雷德蒙研究院18年。</p>



<p><strong>报告摘要</strong>：对于多分类问题，很多神经网络优化的是LR(Logistic Regression)的损失函数。这样的模型在处理大规模分类的问题时存在一定的局限性。在本次报告中，我们通过对LR损失函数的分析，揭示了模型输出特征在高维空间的分布特性，并在此基础上引入LSH（Locality Sensitive Hashing）算法对样本的类别进行了编码。这种编码方式，不仅能够显著降低模型复杂度，而且可以表征不同类别之间(语义)关系。基于这种编码方式，我们提出一种汉明分类器(Hamming Classifier)算法，并应用于OCR和NLP领域的识别问题中；该方法在基本不影响识别精度性能的情况下，可以显著降低模型尺寸。</p>]]></content>
        
        <summary type="html">
            
            报告题目：Hamming classifier: from one-hot to multi-hot classification    报告时间：10月10日 上午10:00-11:00    报告地点：教三 811会议室    报告简介：肖嵘博士，平安财产险科技中心首席研究
            
        </summary>
        
        <category term="PRIS快讯"/>
        
    </entry>
    
    <entry>
        <title>Dusk of the Madness OVERTIME 私有源</title>
        <link href="http://blog.vitechliu.com/default/Dusk_of_the_Madness_OVERTIME.html"/>
        <id>http://blog.vitechliu.com/default/Dusk_of_the_Madness_OVERTIME.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2020-09-23T13:09:00+00:00</published>
        <updated>2020-09-23T13:09:00+00:00</updated>
        
        <content type="html"><![CDATA[<p>https://www.bilibili.com/video/BV14y4y1k7J6 已经有过审</p>]]></content>
        
        <summary type="html">
            
            https://www.bilibili.com/video/BV14y4y1k7J6 已经有过审
            
        </summary>
        
    </entry>
    
    <entry>
        <title>價格確實很美：小蟻 42.5mm f/1.8 鏡頭動爪玩及一些觀點</title>
        <link href="https://asaba.sakuragawa.moe/2020/08/%e5%83%b9%e6%a0%bc%e7%a2%ba%e5%af%a6%e5%be%88%e7%be%8e%ef%bc%9a%e5%b0%8f%e8%9f%bb-42-5mm-f-1-8-%e9%8f%a1%e9%a0%ad%e5%8b%95%e7%88%aa%e7%8e%a9%e5%8f%8a%e4%b8%80%e4%ba%9b%e8%a7%80%e9%bb%9e/?pk_campaign=feed&amp;pk_kwd=%25e5%2583%25b9%25e6%25a0%25bc%25e7%25a2%25ba%25e5%25af%25a6%25e5%25be%2588%25e7%25be%258e%25ef%25bc%259a%25e5%25b0%258f%25e8%259f%25bb-42-5mm-f-1-8-%25e9%258f%25a1%25e9%25a0%25ad%25e5%258b%2595%25e7%2588%25aa%25e7%258e%25a9%25e5%258f%258a%25e4%25b8%2580%25e4%25ba%259b%25e8%25a7%2580%25e9%25bb%259e"/>
        <id>https://asaba.sakuragawa.moe/2020/08/%e5%83%b9%e6%a0%bc%e7%a2%ba%e5%af%a6%e5%be%88%e7%be%8e%ef%bc%9a%e5%b0%8f%e8%9f%bb-42-5mm-f-1-8-%e9%8f%a1%e9%a0%ad%e5%8b%95%e7%88%aa%e7%8e%a9%e5%8f%8a%e4%b8%80%e4%ba%9b%e8%a7%80%e9%bb%9e/?pk_campaign=feed&amp;pk_kwd=%25e5%2583%25b9%25e6%25a0%25bc%25e7%25a2%25ba%25e5%25af%25a6%25e5%25be%2588%25e7%25be%258e%25ef%25bc%259a%25e5%25b0%258f%25e8%259f%25bb-42-5mm-f-1-8-%25e9%258f%25a1%25e9%25a0%25ad%25e5%258b%2595%25e7%2588%25aa%25e7%258e%25a9%25e5%258f%258a%25e4%25b8%2580%25e4%25ba%259b%25e8%25a7%2580%25e9%25bb%259e</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2020-08-03T09:30:02+00:00</published>
        <updated>2020-08-03T09:30:02+00:00</updated>
        
        <content type="html"><![CDATA[<h1>年輕人的第一支副廠鏡頭</h1>



<p>小蟻科技在 2017 年發表的無反相機小蟻微單 M1，除去 MFT 接環和高仿 Leica T 的精緻機身，低廉的價格也是不可忽視的一大亮點。與相機一同發表的是小蟻品牌的第一批、也是唯一兩支鏡頭：小蟻 42.5mm f/1.8 及 12-40mm f/3.5-5.6，其中後者定位標準變焦鏡頭，而前者定位人像、小微距鏡頭。</p>



<p>小蟻 42.5mm f/1.8 鏡頭擁有 85mm(35mm eqv.) 視角及 f/1.8 大光圈，同時近新品的普遍流通價格卻只要 CNY 300 不到，堪稱是 MFT 系統最便宜自動人像鏡，並且網路上「大多好評」。既然價格低廉、評價不低，那浅羽就入手一支試試罷。</p>



<h1>外觀造工有推有噓</h1>



<p>浅羽從某著名撕逼平臺上購入了一枚號稱 9 新的鏡頭，實際收到的時候確實是個驚喜：說是表面有劃傷的鏡頭，實際上是大片的磕碰、擦傷。好在鏡頭工作正常，鏡片也只是微灰，「又不是不能用」。鏡頭本身的外觀設計不差，雖然是<strong>塑料鏡身</strong>，但噴漆細膩、質感十足，搭配粉色的 GF9 機身非常和諧。塑料鏡身也帶來了<strong>輕巧</strong>的優勢。鏡頭可以使用 49mm 直徑濾鏡，但前玉設計得非常小片。前部兩側則是略有伸出，<strong>官方沒有配置遮光罩</strong>、也<strong>沒有遮光罩卡扣</strong>，如果需要的話只能透過螺紋接上通用遮光罩。側邊僅有一枚撥扭，可以在正常與微距模式間切換，這也是鏡頭唯一的可操作部分——因爲那有漂亮金屬壓花效果的<strong>對焦環，僅僅是個裝飾</strong>，並不能真正使用。</p>



<ul><li><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200708-113939-scaled.jpg" /></li><li><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200708-114318-scaled.jpg" /></li></ul>質感不差但操控性欠奉



<h1>鏡頭使用的一些提示</h1>



<p>小蟻微單及鏡頭均使用 MFT 接環，<strong>理論上可以與其他 MFT 系統互操作</strong>，GF10 當然也在其中。不過，以浅羽的經驗來說，小蟻 42.5mm f/1.8 接上 Lumix GF10 後雖然<strong>可以正常自動對焦、測光</strong>，但釋放快門時<strong>無論快門時長都只能使用電子快門</strong>。而後來新購入的 Lumix G 42.5mm f/1.7 就可以正常使用機械快門釋放。</p>



<p>因爲這個問題，浅羽搜尋了一些資料，但都沒有發現相關的線索。後來猜想是否是鏡頭韌體版本問題，檢查後發現鏡頭帶有 1.0 版本，而最新版本已是 1.1。經過查閱和嘗試，<strong>Panasonic 機身可以正常爲小蟻鏡頭更新韌體</strong>，但有說 Olympus 機身用家就沒有那麼幸運了，如果有嘗試過的讀者可以留言。</p>



<ul><li><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200619-012736-scaled.jpg" /></li><li><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200619-012800-scaled.jpg" /></li></ul>Lumix GF10 可以正常爲小蟻 42.5mm f/1.8 更新韌體



<p>非常可惜的是，<strong>更新韌體後只能使用電子快門的問題還是沒能得到解決</strong>。由於浅羽習慣靠快門聲音和微震來判斷曝光是否已經結束，因此只好開啓最低音量的數位快門聲；但仍是用得不順爪。</p>



<h1>實拍效果驚中有喜</h1>



<p>首先必須肯定的是，小蟻 42.5mm f/1.8 的對<strong>焦速度和精度至少都達到了 MFT 系統的主流水平</strong>。光線充足時，拍攝敏捷的動物可能還不太夠用，但一般的抓拍街景基本不會有問題了；但<strong>暗光對焦會比較猶豫</strong>，與 Panasonic 機身的也許也有關係。鏡頭<strong>在開放光圈時銳度還算不錯</strong>，一般的中距拍攝下<strong>細節和質感都體現得很好</strong>，尤其是<strong>中心到邊緣的一致性</strong>感覺都不錯。</p>



<div><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200703-195738-4096x1513.jpg" />傍晚貓片 | f/1.8, 1/30s, ISO 1600 on Lumix GF10</div>



<p>不過 f/1.8 一定不是最佳工作光圈，甚至可能不是可用光圈——這不是經驗，而是面對大光比時<strong>全開光圈出現了嚴重的色散</strong>。這一缺陷對於中長焦風景攝影或者街拍來說也許問題不大——因爲<strong>收到 f/4 後表現就會好上不少</strong>；但對於一顆主打「輕鬆虛化背景」的「人像鏡頭」來說，實在不是太容易接受的問題。</p>



<div><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200705-195040.jpg" />紫氣東來 | f/1.8, 1/640s, ISO 1600 on Lumix GF10（部分裁切）</div>



<p>小微距也是這支鏡頭的一個賣點，鏡身上甚至專門提供了微距模式的切換按鈕。<strong>切換到 Macro 模式後，鏡頭的最大光圈會縮小到 f/3.5</strong>（機身可偵測到光圈變化），同時<strong>最近對焦距離會從 50cm 縮短到 25cm</strong>。由於鏡身的對焦環是裝飾，因此從機身上切換到 MF 後還<strong>需要用機身控制手動對焦</strong>，所幸 GF10 提供了此項功能，否則真是「對焦基本靠走」。最大光圈變小後，銳度有提升，但<strong>綠邊還是比較明顯</strong>。並且由於<strong>鏡頭沒有內建防手震</strong>，最好使用帶 IBIS 的機身或着想辦法保持快門速度，才能好好利用鏡頭提供的 0.5x 小微距。</p>



<div><img src="https://asaba.sakuragawa.moe/wp-content/uploads/2020/08/SKG-20200703-190154-4096x1513.jpg" />雨後蝸牛 | f/3.5, 1/100s, ISO 640 on Lumix GF10</div>



<h1>價格與需求的選擇題</h1>



<p>小蟻 42.5mm f/1.8 即使有着這樣那樣的問題，但因爲大光圈、兼顧人像與小微距、<strong>堪用的銳度</strong>還是獲得了不錯的評價。不可忽視的是，作爲一支原定價不到四位數、流通價格更是低至 3 折的自動鏡頭，這支鏡頭<strong>尤其低廉的流通價也影響到它的評價向好</strong>。</p>



<p>客觀地說，這支鏡頭的<strong>色散嚴重</strong>、<strong>焦外表現不好看</strong>、<strong>沒有內建防手震</strong>、<strong>沒有實體控制環</strong>等等問題，都影響到它成爲一支更好的鏡頭。當然，對於從手機拍照轉來的用家來說，差異更大的視角和淺景深的震撼是這些缺點無法掩蓋的。何況<strong>還算不錯的外觀</strong>、<strong>輕量</strong>和自動對焦方面其實算是有加到分。</p>



<p>以浅羽自己來說，因爲無法接受到色散問題和只能使用電子快門的問題，<strong>整體上會更推 Lumix G 42.5mm f/1.7</strong>，當然有需求、能接受體積、重量和價格用家也可以選擇 DG 42.5mm f/1.2。後兩支的價格當然更高（並且顯然不在一個數量級上），但可以更好的畫面表現與操控感，同時都有內建 Power O.I.S。不過，對於許多還用着 GX1、E-PL5 等低價 MFT 機身，甚至是小蟻機身的用家來說，應該會樂見這樣一支廉價但可圈可點的自動鏡頭。</p>
<img src="https://analytics.sakuragawa.moe/piwik.php?idsite=2&amp;rec=1&amp;url=https%3A%2F%2Fasaba.sakuragawa.moe%2F2020%2F08%2F%25e5%2583%25b9%25e6%25a0%25bc%25e7%25a2%25ba%25e5%25af%25a6%25e5%25be%2588%25e7%25be%258e%25ef%25bc%259a%25e5%25b0%258f%25e8%259f%25bb-42-5mm-f-1-8-%25e9%258f%25a1%25e9%25a0%25ad%25e5%258b%2595%25e7%2588%25aa%25e7%258e%25a9%25e5%258f%258a%25e4%25b8%2580%25e4%25ba%259b%25e8%25a7%2580%25e9%25bb%259e%2F%3Fpk_campaign%3Dfeed%26pk_kwd%3D%2525e5%252583%2525b9%2525e6%2525a0%2525bc%2525e7%2525a2%2525ba%2525e5%2525af%2525a6%2525e5%2525be%252588%2525e7%2525be%25258e%2525ef%2525bc%25259a%2525e5%2525b0%25258f%2525e8%25259f%2525bb-42-5mm-f-1-8-%2525e9%25258f%2525a1%2525e9%2525a0%2525ad%2525e5%25258b%252595%2525e7%252588%2525aa%2525e7%25258e%2525a9%2525e5%25258f%25258a%2525e4%2525b8%252580%2525e4%2525ba%25259b%2525e8%2525a7%252580%2525e9%2525bb%25259e&amp;action_name=%E5%83%B9%E6%A0%BC%E7%A2%BA%E5%AF%A6%E5%BE%88%E7%BE%8E%EF%BC%9A%E5%B0%8F%E8%9F%BB+42.5mm+f%2F1.8+%E9%8F%A1%E9%A0%AD%E5%8B%95%E7%88%AA%E7%8E%A9%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%A7%80%E9%BB%9E&amp;urlref=https%3A%2F%2Fasaba.sakuragawa.moe%2Ffeed%2F" /><div>
    <div>
    <a data-post-id="2132" data-trigger-type="like" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span>1    </span>
</div><div>
    <a data-post-id="2132" data-trigger-type="dislike" data-restriction="cookie" data-already-liked="0">
                           <i></i>
                    </a>
    <span></span>
</div></div>]]></content>
        
        <summary type="html">
            
            年輕人的第一支副廠鏡頭    小蟻科技在 2017 年發表的無反相機小蟻微單 M1，除去 MFT 接環和高仿 Leica T 的精緻機身，低廉的價格也是不可忽視的一大亮點。與相機一同發表的是小蟻品牌的第一批、也是唯一兩支鏡頭：小蟻 42.5mm f/1.8 及 12-40mm 
            
        </summary>
        
        <category term="開箱"/>
        
        <category term="#SafeForLife"/>
        
        <category term="器材"/>
        
        <category term="國產"/>
        
        <category term="攝影術"/>
        
        <category term="數位電子"/>
        
    </entry>
    
    <entry>
        <title>艰难的博客找回过程</title>
        <link href="https://blog.gaojianli.me/2020/06/22/%E8%89%B0%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%89%BE%E5%9B%9E%E8%BF%87%E7%A8%8B/"/>
        <id>https://blog.gaojianli.me/2020/06/22/%E8%89%B0%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%89%BE%E5%9B%9E%E8%BF%87%E7%A8%8B/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2020/06/22/%E8%89%B0%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%89%BE%E5%9B%9E%E8%BF%87%E7%A8%8B/#起因"></a>起因</h1><p>一直以来，我的博客都是通过hexo本地生成，生成文件上传Github，服务器pull的方式进行部署的。这么久都没遇到什么太大的问题，博客的相关源代码也都放在了我的文档里。然在2019年10月的时候，我的Surface Book出现了屏幕和底座接触不良的情况，USB和键盘经常失去响应。考虑到保修即将在12月份失效，因此选择了送修。</p><a></a><p>在备份数据的时候，我精心备份了所有的游戏，照片和代码，却唯独跳过了“我的文档”。感谢QQ等软件把自己的数据放到我的文档里面（日你大坝），给我留下了“我的文档就是个存放软件数据的目录，没什么无关紧要的东西”这种错误印象。“<strong>不会真的有人把文档放到我的文档吧？不会吧，不会吧？</strong>”我这么想着，在仔细观察了一下我的文档的目录后只备份了一些游戏的存档后就送修了。</p><p>然而，事实证明真的有人把东西放到“我的文档”，而且这个人就是我。天知道我在哪天整理文件的时候鬼迷心窍地把博客的源代码放到了“我的文档”。对于巨硬这种公司来说，送修自然意味着数据丢失。事实上我不但丢失了所有数据，连原有的划痕都被一并“修复”了，很大概率巨硬是直接给我换了一台设备，找回数据就是做梦。（另外本次送修还导致我更换了ssh私钥，错过了某加密货币的drop，直接损失</p><p>说来惭愧，在送修之后我就再也没有抽出时间写博客，因此我竟然没有第一时间发现这一事情。直到今年2月在Telegram和群友吹b的时候突然想起来，才突然发现自己的博客已经GG了。由于重新整理非常费时费力，因此直到这几天才腾出时间来整理。</p><h1><a href="https://blog.gaojianli.me/2020/06/22/%E8%89%B0%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%89%BE%E5%9B%9E%E8%BF%87%E7%A8%8B/#防范措施"></a>防范措施</h1><p>为了避免重蹈覆辙，最好的方法就是直接把源代码传到Git上，正好Github Action发布后还没用过（一直以来都在用Gitlab pipeline)，就来试试用Github Action来部署吧。 </p><p>首先生成一个Deply key</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>ssh-keygen -t rsa -C "823805669hehe@gmail.com"</span><br /></pre></td></tr></table><p>对于这种需求，当然不是只有我一个人，大家都喜欢薅微软的羊毛，这里已经有一个库了<a href="https://github.com/sma11black/hexo-action" target="_blank">sma11black/hexo-action</a><br />添加到相应的编译后仓库里，在源代码文件夹里面新增<code>action.yml</code>:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /></pre></td><td><pre><span><span>name:</span> <span>Deploy</span> <span># workflow name</span></span><br /><span></span><br /><span><span>on:</span></span><br /><span>  <span>[push]</span> <span># 触发事件</span></span><br /><span></span><br /><span><span>jobs:</span></span><br /><span>  <span>build:</span> <span># job1 id</span></span><br /><span>    <span>runs-on:</span> <span>ubuntu-latest</span> <span># 运行环境为最新版 Ubuntu</span></span><br /><span>    <span>name:</span> <span>A</span> <span>job</span> <span>to</span> <span>deploy</span> <span>blog.</span></span><br /><span>    <span>steps:</span></span><br /><span>    <span>-</span> <span>name:</span> <span>Checkout</span> <span># step1 获取源码</span></span><br /><span>      <span>uses:</span> <span>actions/checkout@v1</span> <span># 使用 actions/checkout@v1</span></span><br /><span>      <span>with:</span> <span># 条件</span></span><br /><span>        <span>submodules:</span> <span>true</span> <span># Checkout private submodules(themes or something else). 当有子模块时切换分支？</span></span><br /><span></span><br /><span>    <span># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) 缓存压缩 node_modules，不用每次下载，使用时解压，可以加快工作流的执行过程，超过 7 天没有使用将删除压缩包。</span></span><br /><span>    <span>-</span> <span>name:</span> <span>Cache</span> <span>node</span> <span>modules</span> <span># step2</span></span><br /><span>      <span>uses:</span> <span>actions/cache@v1</span></span><br /><span>      <span>id:</span> <span>cache</span></span><br /><span>      <span>with:</span></span><br /><span>        <span>path:</span> <span>node_modules</span></span><br /><span>        <span>key:</span> <span>${{</span> <span>runner.os</span> <span>}}-node-${{</span> <span>hashFiles('**/package-lock.json')</span> <span>}}</span></span><br /><span>        <span>restore-keys:</span> <span>|</span></span><br /><span>          <span>${{</span> <span>runner.os</span> <span>}}-node-</span></span><br /><span>    <span>-</span> <span>name:</span> <span>Install</span> <span>Dependencies</span> <span># step3 name</span></span><br /><span>      <span>if:</span> <span>steps.cache.outputs.cache-hit</span> <span>!=</span> <span>'true'</span> <span># 如果变量 cache-hit 不等于 true</span></span><br /><span>      <span>run:</span> <span>npm</span> <span>install</span> <span># 安装 node modules 相关依赖</span></span><br /><span></span><br /><span>    <span># Deploy hexo blog website.</span></span><br /><span>    <span>-</span> <span>name:</span> <span>Deploy</span> <span># step4</span></span><br /><span>      <span>id:</span> <span>deploy</span></span><br /><span>      <span>uses:</span> <span>sma11black/hexo-action@v1.0.1</span></span><br /><span>      <span>with:</span></span><br /><span>        <span>deploy_key:</span> <span>${{</span> <span>secrets.DEPLOY_KEY</span> <span>}}</span></span><br /><span>        <span>user_name:</span> <span>Gaojianli</span></span><br /><span>        <span>user_email:</span> <span>823805669hehe@gmail.com</span></span><br /><span>    <span>-</span> <span>name:</span> <span>Get</span> <span>the</span> <span>output</span></span><br /><span>      <span>run:</span> <span>|</span></span><br /><span>        <span>echo</span> <span>"$<span>{{ steps.deploy.outputs.notify }}</span>"</span></span><br /></pre></td></tr></table><p>接下来push上去看看效果吧：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>fatal: could not read Username for 'https://github.com': No such device or address</span><br /></pre></td></tr></table><p>???这是什么问题？检查再三,我也确认我的确填写了这一字段，最终我找到了这个<a href="https://github.com/sma11black/hexo-action/issues/5" target="_blank">issue</a>，其大意大概就是得用SSH的方式登录，行吧。修改<code>_config.yml</code>如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>deploy:</span></span><br /><span>  <span>type:</span> <span>'git'</span></span><br /><span>  <span>repo:</span> <span>git@github.com:Gaojianli/gaojianli.github.io.git</span></span><br /><span>  <span>branch:</span> <span>master</span></span><br /></pre></td></tr></table><p>再次push上去看看：<br /><img src="https://blog.gaojianli.me/success.png" /><br />成功！</p><h1><a href="https://blog.gaojianli.me/2020/06/22/%E8%89%B0%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%89%BE%E5%9B%9E%E8%BF%87%E7%A8%8B/#结语"></a>结语</h1><p>我在<a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/">Libuv初探</a>一文曾经写道：</p><blockquote><p>在生活中，有很多事情不是不能做，只是需要一个契机。有了这个契机，我就能有足够的动力去完成之。</p></blockquote><p>这次的博客丢失，也算是一次契机吧！第一次使用了Github Actions，同时也避免了数据的再次丢失，总的来说还是可喜可贺。接下来的就等一个Codespaces正式上线吧，以后连本地都不需要留存博客代码了，真正把hexo用成wordpress（笑）<br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            起因一直以来，我的博客都是通过hexo本地生成，生成文件上传Github，服务器pull的方式进行部署的。这么久都没遇到什么太大的问题，博客的相关源代码也都放在了我的文档里。然在2019年10月的时候，我的Surface Book出现了屏幕和底座接触不良的情况，USB和键盘经常
            
        </summary>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>乱域-LZR第四代特效素材包更新</title>
        <link href="http://blog.vitechliu.com/Flash/madness_v4_effects_lzr.html"/>
        <id>http://blog.vitechliu.com/Flash/madness_v4_effects_lzr.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2020-06-21T08:25:00+00:00</published>
        <updated>2020-06-21T08:25:00+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>版权声明</strong></p>
<ul>
<li>禁止未经许可对本特效包的分发、修改等。作者QQ:1010086485</li>
<li>目前V4特效包仍处于内测阶段，禁止未经许可将其使用于正式项目（如solo、正式联合等）</li>
<li>欢迎对特效需求等提出相关意见</li>
</ul>
<hr />
<p>下载：（6月21日更新）<br />
<a href="http://madness-file.vitechliu.com/LZR%E7%AC%AC%E5%9B%9B%E4%BB%A3%E7%89%B9%E6%95%88%E7%B4%A0%E6%9D%90%E5%8C%850621.fla">LZR第四代特效素材包-0621测试</a><br />
<a href="http://madness-file.vitechliu.com/LZR%E7%AC%AC%E5%9B%9B%E4%BB%A3%E7%89%B9%E6%95%88%E7%B4%A0%E6%9D%90%E5%8C%850612.fla">LZR第四代特效素材包-0612测试</a></p>
<p>注：素材包使用Adobe Animate cc制作，理论上CS6可以转码使用，但是可能丢失数据。尽量使用Adobe Animate cc系列软件。</p>]]></content>
        
        <summary type="html">
            
            版权声明  禁止未经许可对本特效包的分发、修改等。作者QQ:1010086485 目前V4特效包仍处于内测阶段，禁止未经许可将其使用于正式项目（如solo、正式联合等） 欢迎对特效需求等提出相关意见   下载：（6月21日更新） LZR第四代特效素材包-0621测试 LZR第四
            
        </summary>
        
    </entry>
    
    <entry>
        <title>Vite 原理浅析</title>
        <link href="https://molunerfinn.com/learn-vite/"/>
        <id>https://molunerfinn.com/learn-vite/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>已经好久没有写博客了。本文不说 Vue3.0 了，相信已经有很多文章在说它了。而前一段时间尤大开源的 <a href="https://github.com/vuejs/vite" target="_blank">Vite</a> 则是一个更加吸引我的东西，它的总体思路是很不错的，早期源码的学习成本也比较低，于是就趁着假期学习一番。</p><p>本文撰写于 Vite-0.9.1 版本。</p><a></a><h2><a href="https://molunerfinn.com/learn-vite/#什么是-Vite"></a>什么是 Vite</h2><p>借用作者的原话：</p><blockquote><p>Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。</p></blockquote><p>注意到两个点：</p><ul><li>一个是 Vite 主要对应的场景是开发模式，原理是拦截浏览器发出的 ES imports 请求并做相应处理。（生产模式是用 rollup 打包）</li><li>一个是 Vite 在开发模式下不需要打包，只需要编译浏览器发出的 HTTP 请求对应的文件即可，所以热更新速度很快。</li></ul><p>因此，要实现上述目标，需要要求项目里只使用原生 ES imports，如果使用了 require 将失效，所以要用它完全替代掉 Webpack 就目前来说还是不太现实的。上面也说了，生产模式下的打包不是 Vite 自身提供的，因此生产模式下如果你想要用 Webpack 打包也依然是可以的。从这个角度来说，Vite 可能更像是替代了 webpack-dev-server 的一个东西。</p><h3><a href="https://molunerfinn.com/learn-vite/#modules-模块"></a>modules 模块</h3><p>Vite 的实现离不开现代浏览器原生支持的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank">模块功能</a>。如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>&lt;<span>script</span> <span>type</span>=<span>"module"</span>&gt;</span></span><br /><span><span><span>import</span> { a } <span>from</span> <span>'./a.js'</span></span></span><br /><span><span>&lt;/<span>script</span>&gt;</span></span><br /></pre></td></tr></table><p>当声明一个 <code>script</code> 标签类型为 <code>module</code> 时，浏览器将对其内部的 <code>import</code> 引用发起 <code>HTTP</code> 请求获取模块内容。比如上述，浏览器将发起一个对 <code>HOST/a.js</code> 的 HTTP 请求，获取到内容之后再执行。</p><p>Vite 劫持了这些请求，并在后端进行相应的处理（比如将 Vue 文件拆分成 <code>template</code>、<code>style</code>、<code>script</code> 三个部分），然后再返回给浏览器。</p><p>由于浏览器只会对用到的模块发起 HTTP 请求，所以 Vite 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 HTTP 请求的模块即可。这里是不是有点按需加载的味道？</p><h3><a href="https://molunerfinn.com/learn-vite/#编译和打包的区别"></a>编译和打包的区别</h3><p>看到这里，可能有些朋友不免有些疑问，编译和打包有什么区别？为什么 Vite 号称「热更新的速度不会随着模块增多而变慢」？</p><p>简单举个例子，有三个文件 <code>a.js</code>、<code>b.js</code>、<code>c.js</code></p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>// a.js</span></span><br /><span><span>const</span> a = <span><span>()</span> =&gt;</span> { ... }</span><br /><span><span>export</span> { a }</span><br /><span></span><br /><span><span>// b.js</span></span><br /><span><span>const</span> b = <span><span>()</span> =&gt;</span> { ... }</span><br /><span><span>export</span> { b }</span><br /></pre></td></tr></table><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span>// c.js</span></span><br /><span><span>import</span> { a } <span>from</span> <span>'./a'</span></span><br /><span><span>import</span> { b } <span>from</span> <span>'./b'</span></span><br /><span></span><br /><span><span>const</span> c = <span><span>()</span> =&gt;</span> {</span><br /><span>  <span>return</span> a() + b()</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> { c }</span><br /></pre></td></tr></table><p>如果以 c 文件为入口，那么打包就会变成如下（结果进行了简化处理）：（假定打包文件名为 <code>bundle.js</code>)</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>// bundle.js</span></span><br /><span><span>const</span> a = <span><span>()</span> =&gt;</span> { ... }</span><br /><span><span>const</span> b = <span><span>()</span> =&gt;</span> { ... }</span><br /><span><span>const</span> c = <span><span>()</span> =&gt;</span> {</span><br /><span>  <span>return</span> a() + b()</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> { c }</span><br /></pre></td></tr></table><p><strong>值得注意的是，打包也需要有编译的步骤。</strong></p><p>Webpack 的热更新原理简单来说就是，一旦发生某个依赖（比如上面的 <code>a.js</code> ）改变，就将这个依赖所处的 <code>module</code> 的更新，并将新的 <code>module</code> 发送给浏览器重新执行。由于我们只打了一个 <code>bundle.js</code>，所以热更新的话也会重新打这个 <code>bundle.js</code>。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。</p><p>而如果是像 Vite 这种只编译不打包会是什么情况呢？</p><p>只是编译的话，最终产出的依然是 <code>a.js</code>、<code>b.js</code>、<code>c.js</code> 三个文件，只有编译耗时。由于入口是 <code>c.js</code>，浏览器解析到 <code>import { a } from './a'</code> 时，会发起 HTTP 请求 <code>a.js</code> （b 同理），就算不用打包，也可以加载到所需要的代码，因此省去了合并代码的时间。</p><p>在热更新的时候，如果 <code>a</code> 发生了改变，只需要更新 <code>a</code> 以及用到 <code>a</code> 的 <code>c</code>。由于 <code>b</code> 没有发生改变，所以 Vite 无需重新编译 <code>b</code>，可以从缓存中直接拿编译的结果。这样一来，修改一个文件 <code>a</code>，只会重新编译这个文件 <code>a</code> 以及浏览器当前用到这个文件 <code>a</code> 的文件，而其余文件都无需重新编译。所以理论上热更新的速度不会随着文件增加而变慢。</p><p>当然这样做有没有不好的地方？有，初始化的时候如果浏览器请求的模块过多，也会带来初始化的性能问题。不过如果你能遇到初始化过慢的这个问题，相信热更新的速度会弥补很多。当然我相信以后尤大也会解决这个问题。</p><h2><a href="https://molunerfinn.com/learn-vite/#Vite-运行-Web-应用的实现"></a>Vite 运行 Web 应用的实现</h2><p>上面说了这么多的铺垫，可能还不够直观，我们可以先跑一个 Vite 项目来实际看看。</p><p>按照官网的说明，可以输入如下命令（<code>&lt;project-name&gt;</code> 为自己想要的目录名即可）</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span>$ npx create-vite-app &lt;project-name&gt;</span><br /><span>$ <span>cd</span> &lt;project-name&gt;</span><br /><span>$ npm install</span><br /><span>$ npm run dev</span><br /></pre></td></tr></table><p>如果一切都正常你将在 <code>localhost:3000</code>（Vite 的服务器起的端口） 看到这个界面：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503152836.png" /></p><p>并得到如下的代码结构：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>.</span><br /><span>├── App.vue // 页面的主要逻辑</span><br /><span>├── index.html // 默认打开的页面以及 Vue 组件挂载</span><br /><span>├── node_modules</span><br /><span>└── package.json</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/learn-vite/#拦截-HTTP-请求"></a>拦截 HTTP 请求</h3><p>接下来开始说一下 Vite 实现的核心——拦截浏览器对模块的请求并返回处理后的结果。</p><p>我们知道，由于是在 <code>localhost:3000</code> 打开的网页，所以浏览器发起的第一个请求自然是请求 <code>localhost:3000/</code>，这个请求发送到 Vite 后端之后经过静态资源服务器的处理，会进而请求到 <code>/index.html</code>，此时 Vite 就开始对这个请求做拦截和处理了。</p><p>首先，<code>index.html</code> 里的源码是这样的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>&lt;<span>div</span> <span>id</span>=<span>"app"</span>&gt;</span><span>&lt;/<span>div</span>&gt;</span></span><br /><span><span>&lt;<span>script</span> <span>type</span>=<span>"module"</span>&gt;</span></span><br /><span><span><span>import</span> { createApp } <span>from</span> <span>'vue'</span></span></span><br /><span><span><span>import</span> App <span>from</span> <span>'./App.vue'</span></span></span><br /><span></span><br /><span><span>createApp(App).mount(<span>'#app'</span>)</span></span><br /><span><span>&lt;/<span>script</span>&gt;</span></span><br /></pre></td></tr></table><p>但是在浏览器里它是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503153404.png" /></p><p>注意到什么不同了吗？是的， <code>import { createApp } from 'vue'</code> 换成了 <code>import { createApp } from '/@modules/vue</code>。</p><p>这里就不得不说浏览器对 <code>import</code> 的模块发起请求时的一些局限了，平时我们写代码，如果不是引用相对路径的模块，而是引用 <code>node_modules</code> 的模块，都是直接 <code>import xxx from 'xxx'</code>，由 Webpack 等工具来帮我们找这个模块的具体路径。但是浏览器不知道你项目里有 <code>node_modules</code>，它只能通过相对路径去寻找模块。</p><p>因此 Vite 在拦截的请求里，对直接引用 <code>node_modules</code> 的模块都做了路径的替换，换成了 <code>/@modules/</code> 并返回回去。而后浏览器收到后，会发起对 <code>/@modules/xxx</code> 的请求，然后被 Vite 再次拦截，并由 Vite 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。</p><h3><a href="https://molunerfinn.com/learn-vite/#imports-替换"></a>imports 替换</h3><h4><a href="https://molunerfinn.com/learn-vite/#普通-JS-import-替换"></a>普通 JS import 替换</h4><p>上面说的这步替换来自 <code>src/node/serverPluginModuleRewrite.ts</code>:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /></pre></td><td><pre><span><span>// 只取关键代码：</span></span><br /><span><span>// Vite 使用 Koa 作为内置的服务器</span></span><br /><span><span>// 如果请求的路径是 /index.html</span></span><br /><span><span>if</span> (ctx.path === <span>'/index.html'</span>) {</span><br /><span>  <span>// ...</span></span><br /><span>  <span>const</span> html = <span>await</span> readBody(ctx.body)</span><br /><span>  ctx.body = html.replace(</span><br /><span>    /(<span><span>&lt;<span>script\b[^</span>&gt;</span>]*&gt;)([\s\S]*?)<span>&lt;<span>\</span>/<span>script</span>&gt;</span>/gm, // 正则匹配</span></span><br /><span><span>    (_, openTag, script) =&gt; {</span></span><br /><span><span>      // also inject __DEV__ flag</span></span><br /><span><span>      const devFlag = hasInjectedDevFlag ? `` : devInjectionCode</span></span><br /><span><span>      hasInjectedDevFlag = true</span></span><br /><span><span>       // 替换 html 的 import 路径</span></span><br /><span><span>      return `${devFlag}${openTag}${rewriteImports(</span></span><br /><span><span>        script,</span></span><br /><span><span>        '/index.html',</span></span><br /><span><span>        resolver</span></span><br /><span><span>      )}<span>&lt;/<span>script</span>&gt;</span></span><span>`</span></span><br /><span><span>    }</span></span><br /><span><span>  )</span></span><br /><span><span>  // ...</span></span><br /><span><span>}</span></span><br /></pre></td></tr></table><p>如果并没有在 <code>script</code> 标签内部直接写 <code>import</code>，而是用 <code>src</code> 的形式引用的话如下：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>&lt;script type=<span>"module"</span> src=<span>"/main.js"</span>&gt;&lt;<span>/script&gt;</span></span><br /></pre></td></tr></table><p>那么就会在浏览器发起对 <code>main.js</code> 请求的时候进行处理：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span><span>// 只取关键代码：</span></span><br /><span><span>if</span> (</span><br /><span>  ctx.response.is(<span>'js'</span>) &amp;&amp;</span><br /><span>  <span>// ...</span></span><br /><span>) {</span><br /><span>  <span>// ...</span></span><br /><span>  <span>const</span> content = <span>await</span> readBody(ctx.body)</span><br /><span>  <span>await</span> initLexer</span><br /><span>  <span>// 重写 js 文件里的 import</span></span><br /><span>  ctx.body = rewriteImports(</span><br /><span>    content,</span><br /><span>    ctx.url.replace(<span>/(&amp;|\?)t=\d+/</span>, <span>''</span>),</span><br /><span>    resolver,</span><br /><span>    ctx.query.t</span><br /><span>  )</span><br /><span>  <span>// 写入缓存，之后可以从缓存中直接读取</span></span><br /><span>  rewriteCache.set(content, ctx.body)</span><br /><span>}</span><br /></pre></td></tr></table><p>替换逻辑 <code>rewriteImports</code> 就不展开了，用的是 <code>es-module-lexer</code> 来进行的语法分析获取 <code>imports</code> 数组，然后再做的替换。</p><h4><a href="https://molunerfinn.com/learn-vite/#vue-文件的替换"></a>*.vue 文件的替换</h4><p>如果 <code>import</code> 的是 <code>.vue</code> 文件，将会做更进一步的替换：</p><p>原本的 <code>App.vue</code> 文件长这样：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /></pre></td><td><pre><span><span>&lt;<span>template</span>&gt;</span></span><br /><span>  <span>&lt;<span>h1</span>&gt;</span>Hello Vite + Vue 3!<span>&lt;/<span>h1</span>&gt;</span></span><br /><span>  <span>&lt;<span>p</span>&gt;</span>Edit ./App.vue to test hot module replacement (HMR).<span>&lt;/<span>p</span>&gt;</span></span><br /><span>  <span>&lt;<span>p</span>&gt;</span></span><br /><span>    <span>&lt;<span>span</span>&gt;</span>Count is: {{ count }}<span>&lt;/<span>span</span>&gt;</span></span><br /><span>    <span>&lt;<span>button</span> @<span>click</span>=<span>"count++"</span>&gt;</span>increment<span>&lt;/<span>button</span>&gt;</span></span><br /><span>  <span>&lt;/<span>p</span>&gt;</span></span><br /><span><span>&lt;/<span>template</span>&gt;</span></span><br /><span></span><br /><span><span>&lt;<span>script</span>&gt;</span></span><br /><span><span><span>export</span> <span>default</span> {</span></span><br /><span><span>  data: <span><span>()</span> =&gt;</span> ({ <span>count</span>: <span>0</span> }),</span></span><br /><span>}</span><br /><span><span>&lt;/<span>script</span>&gt;</span></span><br /><span></span><br /><span><span>&lt;<span>style</span> <span>scoped</span>&gt;</span></span><br /><span>h1 {</span><br /><span><span>  <span>color</span>: <span>#4fc08d</span>;</span></span><br /><span>}</span><br /><span></span><br /><span>h1, p {</span><br /><span>  font-family: Arial, Helvetica, sans-serif;</span><br /><span>}</span><br /><span><span>&lt;/<span>style</span>&gt;</span></span><br /></pre></td></tr></table><p>替换后长这样：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span><span>// localhost:3000/App.vue</span></span><br /><span><span>import</span> { updateStyle } <span>from</span> <span>"/@hmr"</span></span><br /><span></span><br /><span><span>// 抽出 script 逻辑</span></span><br /><span><span>const</span> __script = {</span><br /><span>  data: <span><span>()</span> =&gt;</span> ({ <span>count</span>: <span>0</span> }),</span><br /><span>}</span><br /><span></span><br /><span><span>// 将 style 拆分成 /App.vue?type=style 请求，由浏览器继续发起请求获取样式</span></span><br /><span>updateStyle(<span>"c44b8200-0"</span>, <span>"/App.vue?type=style&amp;index=0&amp;t=1588490870523"</span>)</span><br /><span>__script.__scopeId = <span>"data-v-c44b8200"</span> <span>// 样式的 scopeId</span></span><br /><span></span><br /><span><span>// 将 template 拆分成 /App.vue?type=template 请求，由浏览器继续发起请求获取 render function</span></span><br /><span><span>import</span> { render <span>as</span> __render } <span>from</span> <span>"/App.vue?type=template&amp;t=1588490870523&amp;t=1588490870523"</span></span><br /><span>__script.render = __render <span>// render 方法挂载，用于 createApp 时渲染</span></span><br /><span>__script.__hmrId = <span>"/App.vue"</span> <span>// 记录 HMR 的 id，用于热更新</span></span><br /><span>__script.__file = <span>"/XXX/web/vite-test/App.vue"</span> <span>// 记录文件的原始的路径，后续热更新能用到</span></span><br /><span><span>export</span> <span>default</span> __script</span><br /></pre></td></tr></table><p>这样就把原本一个 <code>.vue</code> 的文件拆成了三个请求（分别对应 <code>script</code>、<code>style</code> 和<code>template</code>） ，浏览器会先收到包含 <code>script</code> 逻辑的 <code>App.vue</code> 的响应，然后解析到 <code>template</code> 和 <code>style</code> 的路径后，会再次发起 HTTP 请求来请求对应的资源，此时 Vite 对其拦截并再次处理后返回相应的内容。</p><p>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503171228.png" /></p><p>不得不说这个思路是非常巧妙的。</p><p>这一步的拆分来自 <code>src/node/serverPluginVue.ts</code>，核心逻辑是根据 URL 的 query 参数来做不同的处理（简化分析如下）：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /></pre></td><td><pre><span><span>// 如果没有 query 的 type，比如直接请求的 /App.vue</span></span><br /><span><span>if</span> (!query.type) {</span><br /><span>  ctx.type = <span>'js'</span></span><br /><span>  ctx.body = compileSFCMain(descriptor, filePath, publicPath) <span>// 编译 App.vue，编译成上面说的带有 script 内容，以及 template 和 style 链接的形式。</span></span><br /><span>  <span>return</span> etagCacheCheck(ctx) <span>// ETAG 缓存检测相关逻辑</span></span><br /><span>}</span><br /><span></span><br /><span><span>// 如果 query 的 type 是 template，比如 /App.vue?type=template&amp;xxx</span></span><br /><span><span>if</span> (query.type === <span>'template'</span>) {</span><br /><span>  ctx.type = <span>'js'</span></span><br /><span>  ctx.body = compileSFCTemplate( <span>// 编译 template 生成 render function</span></span><br /><span>    <span>// ...</span></span><br /><span>  )</span><br /><span>  <span>return</span> etagCacheCheck(ctx)</span><br /><span>}</span><br /><span></span><br /><span><span>// 如果 query 的 type 是 style，比如 /App.vue?type=style&amp;xxx</span></span><br /><span><span>if</span> (query.type === <span>'style'</span>) {</span><br /><span>  <span>const</span> index = <span>Number</span>(query.index)</span><br /><span>  <span>const</span> styleBlock = descriptor.styles[index]</span><br /><span>  <span>const</span> result = <span>await</span> compileSFCStyle( <span>// 编译 style</span></span><br /><span>    <span>// ...</span></span><br /><span>  )</span><br /><span>  <span>if</span> (query.module != <span>null</span>) { <span>// 如果是 css module</span></span><br /><span>    ctx.type = <span>'js'</span></span><br /><span>    ctx.body = <span>`export default <span>${<span>JSON</span>.stringify(result.modules)}</span>`</span></span><br /><span>  } <span>else</span> { <span>// 正常 css</span></span><br /><span>    ctx.type = <span>'css'</span></span><br /><span>    ctx.body = result.code</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><h2><a href="https://molunerfinn.com/learn-vite/#modules-路径解析"></a>@modules/* 路径解析</h2><p>上面只涉及到了替换的逻辑，解析的逻辑来自 <code>src/node/serverPluginModuleResolve.ts</code>。这一步就相对简单了，核心逻辑就是去 <code>node_modules</code> 里找有没有对应的模块，有的话就返回，没有的话就报 404：（省略了很多逻辑，比如对 <code>web_modules</code> 的处理、缓存的处理等）</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>// ...</span></span><br /><span><span>try</span> {</span><br /><span>  <span>const</span> file = resolve(root, id) <span>// id 是模块的名字，比如 axios</span></span><br /><span>  <span>return</span> serve(id, file, <span>'node_modules'</span>) <span>// 从 node_modules 中找到真正的模块内容并返回</span></span><br /><span>} <span>catch</span> (e) {</span><br /><span>  <span>console</span>.error(</span><br /><span>    chalk.red(<span>`[vite] Error while resolving node_modules with id "<span>${id}</span>":`</span>)</span><br /><span>  )</span><br /><span>  <span>console</span>.error(e)</span><br /><span>  ctx.status = <span>404</span> <span>// 如果没找到就 404</span></span><br /><span>}</span><br /></pre></td></tr></table><h2><a href="https://molunerfinn.com/learn-vite/#Vite-热更新的实现"></a>Vite 热更新的实现</h2><p>上面已经说完了 Vite 是如何运行一个 Web 应用的，包括如何拦截请求、替换内容、返回处理后的结果。接下来说一下 Vite 热更新的实现，同样实现的非常巧妙。</p><p>我们知道，如果要实现热更新，那么就需要浏览器和服务器建立某种通信机制，这样浏览器才能收到通知进行热更新。Vite 的是通过 <code>WebSocket</code> 来实现的热更新通信。</p><h3><a href="https://molunerfinn.com/learn-vite/#客户端"></a>客户端</h3><p>客户端的代码在 <code>src/client/client.ts</code>，主要是创建 <code>WebSocket</code> 客户端，监听来自服务端的 HMR 消息推送。</p><p>Vite 的 WS 客户端目前监听这几种消息：</p><ul><li><code>connected</code>: WebSocket 连接成功</li><li><code>vue-reload</code>: Vue 组件重新加载（当你修改了 script 里的内容时）</li><li><code>vue-rerender</code>: Vue 组件重新渲染（当你修改了 template 里的内容时）</li><li><code>style-update</code>: 样式更新</li><li><code>style-remove</code>: 样式移除</li><li><code>js-update</code>: js 文件更新</li><li><code>full-reload</code>: fallback 机制，网页重刷新</li></ul><p>其中针对 Vue 组件本身的一些更新，都可以直接调用 <code>HMRRuntime</code> 提供的方法，非常方便。其余的更新逻辑，基本上都是利用了 <code>timestamp</code> 刷新缓存重新执行的方法来达到更新的目的。</p><p>核心逻辑如下，我感觉非常清晰明了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /></pre></td><td><pre><span><span>import</span> { HMRRuntime } <span>from</span> <span>'vue'</span> <span>// 来自 Vue3.0 的 HMRRuntime</span></span><br /><span></span><br /><span><span>console</span>.log(<span>'[vite] connecting...'</span>)</span><br /><span></span><br /><span>declare <span>var</span> __VUE_HMR_RUNTIME__: HMRRuntime</span><br /><span></span><br /><span><span>const</span> socket = <span>new</span> WebSocket(<span>`ws://<span>${location.host}</span>`</span>)</span><br /><span></span><br /><span><span>// Listen for messages</span></span><br /><span>socket.addEventListener(<span>'message'</span>, ({ data }) =&gt; {</span><br /><span>  <span>const</span> { type, path, id, index, timestamp, customData } = <span>JSON</span>.parse(data)</span><br /><span>  <span>switch</span> (type) {</span><br /><span>    <span>case</span> <span>'connected'</span>:</span><br /><span>      <span>console</span>.log(<span>`[vite] connected.`</span>)</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'vue-reload'</span>:</span><br /><span>      <span>import</span>(<span>`<span>${path}</span>?t=<span>${timestamp}</span>`</span>).then(<span>(<span>m</span>) =&gt;</span> {</span><br /><span>        __VUE_HMR_RUNTIME__.reload(path, m.default)</span><br /><span>        <span>console</span>.log(<span>`[vite] <span>${path}</span> reloaded.`</span>) <span>// 调用 HMRRUNTIME 的方法更新</span></span><br /><span>      })</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'vue-rerender'</span>:</span><br /><span>      <span>import</span>(<span>`<span>${path}</span>?type=template&amp;t=<span>${timestamp}</span>`</span>).then(<span>(<span>m</span>) =&gt;</span> {</span><br /><span>        __VUE_HMR_RUNTIME__.rerender(path, m.render)</span><br /><span>        <span>console</span>.log(<span>`[vite] <span>${path}</span> template updated.`</span>) <span>// 调用 HMRRUNTIME 的方法更新</span></span><br /><span>      })</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'style-update'</span>:</span><br /><span>      updateStyle(id, <span>`<span>${path}</span>?type=style&amp;index=<span>${index}</span>&amp;t=<span>${timestamp}</span>`</span>) <span>// 重新加载 style 的 URL</span></span><br /><span>      <span>console</span>.log(</span><br /><span>        <span>`[vite] <span>${path}</span> style<span>${index &gt; <span>0</span> ? <span>`#<span>${index}</span>`</span> : <span>``</span>}</span> updated.`</span></span><br /><span>      )</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'style-remove'</span>:</span><br /><span>      <span>const</span> link = <span>document</span>.getElementById(<span>`vite-css-<span>${id}</span>`</span>)</span><br /><span>      <span>if</span> (link) {</span><br /><span>        <span>document</span>.head.removeChild(link) <span>// 删除 style</span></span><br /><span>      }</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'js-update'</span>:</span><br /><span>      <span>const</span> update = jsUpdateMap.get(path)</span><br /><span>      <span>if</span> (update) {</span><br /><span>        update(timestamp) <span>// 用新的时间戳加载并执行 js，达到更新的目的</span></span><br /><span>        <span>console</span>.log(<span>`[vite]: js module reloaded: `</span>, path)</span><br /><span>      } <span>else</span> {</span><br /><span>        <span>console</span>.error(</span><br /><span>          <span>`[vite] got js update notification but no client callback was registered. Something is wrong.`</span></span><br /><span>        )</span><br /><span>      }</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'custom'</span>:</span><br /><span>      <span>const</span> cbs = customUpdateMap.get(id)</span><br /><span>      <span>if</span> (cbs) {</span><br /><span>        cbs.forEach(<span>(<span>cb</span>) =&gt;</span> cb(customData))</span><br /><span>      }</span><br /><span>      <span>break</span></span><br /><span>    <span>case</span> <span>'full-reload'</span>:</span><br /><span>      location.reload()</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/learn-vite/#服务端"></a>服务端</h3><p>服务端的实现位于 <code>src/node/serverPluginHmr.ts</code>。核心是监听项目文件的变更，然后根据不同文件类型（目前只有 <code>vue</code> 和 <code>js</code>）来做不同的处理：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>watcher.on(<span>'change'</span>, <span>async</span> (file) =&gt; {</span><br /><span>  <span>const</span> timestamp = <span>Date</span>.now() <span>// 更新时间戳</span></span><br /><span>  <span>if</span> (file.endsWith(<span>'.vue'</span>)) {</span><br /><span>    handleVueReload(file, timestamp)</span><br /><span>  } <span>else</span> <span>if</span> (file.endsWith(<span>'.js'</span>)) {</span><br /><span>    handleJSReload(file, timestamp)</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><p>对于 <code>Vue</code> 文件的热更新而言，主要是重新编译 <code>Vue</code> 文件，检测 <code>template</code> 、<code>script</code> 、<code>style</code> 的改动，如果有改动就通过 WS 服务端发起对应的热更新请求。</p><p>简单的源码分析如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /><span>68</span><br /><span>69</span><br /><span>70</span><br /><span>71</span><br /><span>72</span><br /><span>73</span><br /><span>74</span><br /><span>75</span><br /><span>76</span><br /><span>77</span><br /><span>78</span><br /><span>79</span><br /><span>80</span><br /></pre></td><td><pre><span><span>async</span> <span><span>function</span> <span>handleVueReload</span>(<span></span></span></span><br /><span><span><span>    file: string,</span></span></span><br /><span><span><span>    timestamp: number = Date.now(</span>),</span></span><br /><span><span>    <span>content</span>?: <span>string</span></span></span><br /><span><span>) </span>{</span><br /><span>  <span>const</span> publicPath = resolver.fileToRequest(file) <span>// 获取文件的路径</span></span><br /><span>  <span>const</span> cacheEntry = vueCache.get(file) <span>// 获取缓存里的内容</span></span><br /><span></span><br /><span>  debugHmr(<span>`busting Vue cache for <span>${file}</span>`</span>)</span><br /><span>  vueCache.del(file) <span>// 发生变动了因此之前的缓存可以删除</span></span><br /><span></span><br /><span>  <span>const</span> descriptor = <span>await</span> parseSFC(root, file, content) <span>// 编译 Vue 文件</span></span><br /><span></span><br /><span>  <span>const</span> prevDescriptor = cacheEntry &amp;&amp; cacheEntry.descriptor <span>// 获取前一次的缓存</span></span><br /><span></span><br /><span>  <span>if</span> (!prevDescriptor) {</span><br /><span>    <span>// 这个文件之前从未被访问过（本次是第一次访问），也就没必要热更新</span></span><br /><span>    <span>return</span></span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 设置两个标志位，用于判断是需要 reload 还是 rerender</span></span><br /><span>  <span>let</span> needReload = <span>false</span></span><br /><span>  <span>let</span> needRerender = <span>false</span></span><br /><span></span><br /><span>  <span>// 如果 script 部分不同则需要 reload</span></span><br /><span>  <span>if</span> (!isEqual(descriptor.script, prevDescriptor.script)) {</span><br /><span>    needReload = <span>true</span></span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 如果 template 部分不同则需要 rerender</span></span><br /><span>  <span>if</span> (!isEqual(descriptor.template, prevDescriptor.template)) {</span><br /><span>    needRerender = <span>true</span></span><br /><span>  }</span><br /><span></span><br /><span>  <span>const</span> styleId = hash_sum(publicPath)</span><br /><span>  <span>// 获取之前的 style 以及下一次（或者说热更新）的 style</span></span><br /><span>  <span>const</span> prevStyles = prevDescriptor.styles || []</span><br /><span>  <span>const</span> nextStyles = descriptor.styles || []</span><br /><span></span><br /><span>  <span>// 如果不需要 reload，则查看是否需要更新 style</span></span><br /><span>  <span>if</span> (!needReload) {</span><br /><span>    nextStyles.forEach(<span>(<span>_, i</span>) =&gt;</span> {</span><br /><span>      <span>if</span> (!prevStyles[i] || !isEqual(prevStyles[i], nextStyles[i])) {</span><br /><span>        send({</span><br /><span>          type: <span>'style-update'</span>,</span><br /><span>          path: publicPath,</span><br /><span>          index: i,</span><br /><span>          id: <span>`<span>${styleId}</span>-<span>${i}</span>`</span>,</span><br /><span>          timestamp</span><br /><span>        })</span><br /><span>      }</span><br /><span>    })</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 如果 style 标签及内容删掉了，则需要发送 `style-remove` 的通知</span></span><br /><span>  prevStyles.slice(nextStyles.length).forEach(<span>(<span>_, i</span>) =&gt;</span> {</span><br /><span>    send({</span><br /><span>      type: <span>'style-remove'</span>,</span><br /><span>      path: publicPath,</span><br /><span>      id: <span>`<span>${styleId}</span>-<span>${i + nextStyles.length}</span>`</span>,</span><br /><span>      timestamp</span><br /><span>    })</span><br /><span>  })</span><br /><span></span><br /><span>  <span>// 如果需要 reload 发送 `vue-reload` 通知</span></span><br /><span>  <span>if</span> (needReload) {</span><br /><span>    send({</span><br /><span>      type: <span>'vue-reload'</span>,</span><br /><span>      path: publicPath,</span><br /><span>      timestamp</span><br /><span>    })</span><br /><span>  } <span>else</span> <span>if</span> (needRerender) {</span><br /><span>    <span>// 否则发送 `vue-rerender` 通知</span></span><br /><span>    send({</span><br /><span>      type: <span>'vue-rerender'</span>,</span><br /><span>      path: publicPath,</span><br /><span>      timestamp</span><br /><span>    })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>对于热更新 <code>js</code> 文件而言，会递归地查找引用这个文件的 <code>importer</code>。比如是某个 <code>Vue</code> 文件所引用了这个 <code>js</code>，就会被查找出来。假如最终发现找不到引用者，则会返回 <code>hasDeadEnd: true</code>。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>const</span> vueImporters = <span>new</span> <span>Set</span>&lt;string&gt;() <span>// 查找并存放需要热更新的 Vue 文件</span></span><br /><span><span>const</span> jsHotImporters = <span>new</span> <span>Set</span>&lt;string&gt;() <span>// 查找并存放需要热更新的 js 文件</span></span><br /><span><span>const</span> hasDeadEnd = walkImportChain(</span><br /><span>  publicPath,</span><br /><span>  importers,</span><br /><span>  vueImporters,</span><br /><span>  jsHotImporters</span><br /><span>)</span><br /></pre></td></tr></table><p>如果 <code>hasDeadEnd</code> 为 <code>true</code>，则直接发送 <code>full-reload</code>。如果 <code>vueImporters</code> 或 <code>jsHotImporters</code> 里查找到需要热更新的文件，则发起热更新通知：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /></pre></td><td><pre><span><span>if</span> (hasDeadEnd) {</span><br /><span>  send({</span><br /><span>    type: <span>'full-reload'</span>,</span><br /><span>    timestamp</span><br /><span>  })</span><br /><span>} <span>else</span> {</span><br /><span>  vueImporters.forEach(<span>(<span>vueImporter</span>) =&gt;</span> {</span><br /><span>    send({</span><br /><span>      type: <span>'vue-reload'</span>,</span><br /><span>      path: vueImporter,</span><br /><span>      timestamp</span><br /><span>    })</span><br /><span>  })</span><br /><span>  jsHotImporters.forEach(<span>(<span>jsImporter</span>) =&gt;</span> {</span><br /><span>    send({</span><br /><span>      type: <span>'js-update'</span>,</span><br /><span>      path: jsImporter,</span><br /><span>      timestamp</span><br /><span>    })</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/learn-vite/#客户端逻辑的注入"></a>客户端逻辑的注入</h3><p>写到这里，还有一个问题是，我们在自己的代码里并没有引入 <code>HRM</code> 的 <code>client</code> 代码，Vite 是如何把 <code>client</code> 代码注入的呢？</p><p>回到上面的一张图，Vite 重写 <code>App.vue</code> 文件的内容并返回时：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503171228.png" /></p><p>注意这张图里的代码区第一句话 <code>import { updateStyle } from '/@hmr'</code>，并且在左侧请求列表中也有一个对 <code>@hmr</code> 文件的请求。这个请求是啥呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/20200503201312.png" /></p><p>可以发现，这个请求就是上面说的客户端逻辑的 <code>client.ts</code> 的内容。</p><p>在 <code>src/node/serverPluginHmr.ts</code> 里，有针对 <code>@hmr</code> 文件的解析处理：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span><span>export</span> <span>const</span> hmrClientFilePath = path.resolve(__dirname, <span>'./client.js'</span>)</span><br /><span><span>export</span> <span>const</span> hmrClientId = <span>'@hmr'</span></span><br /><span><span>export</span> <span>const</span> hmrClientPublicPath = <span>`/<span>${hmrClientId}</span>`</span></span><br /><span></span><br /><span>app.use(<span>async</span> (ctx, next) =&gt; {</span><br /><span>  <span>if</span> (ctx.path !== hmrClientPublicPath) { <span>// 请求路径如果不是 @hmr 就跳过</span></span><br /><span>    <span>return</span> next()</span><br /><span>  }</span><br /><span>  debugHmr(<span>'serving hmr client'</span>)</span><br /><span>  ctx.type = <span>'js'</span></span><br /><span>  <span>await</span> cachedRead(ctx, hmrClientFilePath) <span>// 返回 client.js 的内容</span></span><br /><span>})</span><br /></pre></td></tr></table><p>至此，热更新的整体流程已经解析完毕。</p><h2><a href="https://molunerfinn.com/learn-vite/#小结"></a>小结</h2><p>这个项目最近在以惊人的速度迭代着，因此没过多久以后再回头看这篇文章，可能代码、实现已经过时。不过 Vite 的整体思路是非常棒的，在早期源码不多的情况下，能学到更贴近作者原始想法的东西，也算是很不错的收获。希望本文能给你学习 Vite 一些参考，有错误也欢迎大家指出。</p>]]></content>
        
        <summary type="html">
            
            已经好久没有写博客了。本文不说 Vue3.0 了，相信已经有很多文章在说它了。而前一段时间尤大开源的 Vite 则是一个更加吸引我的东西，它的总体思路是很不错的，早期源码的学习成本也比较低，于是就趁着假期学习一番。本文撰写于 Vite-0.9.1 版本。什么是 Vite借用作者
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Vite"/>
        
    </entry>
    
    <entry>
        <title>Typora 支持 PicGo 来上传图片了</title>
        <link href="https://molunerfinn.com/typora-supports-picgo/"/>
        <id>https://molunerfinn.com/typora-supports-picgo/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>Typora 最近的一次更新支持图片自定义图片上传服务了，增加了对 <a href="https://github.com/gee1k/uPic" target="_blank">uPic</a>，<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> 以及自定义上传命令的支持。其中针对 PicGo 和 PicGo-Core 都做了兼容，可以说非常有诚意了。本文会简单介绍一下如何配置并使用。</p><a></a><h2><a href="https://molunerfinn.com/typora-supports-picgo/#自定义图片上传服务的设置"></a>自定义图片上传服务的设置</h2><p>更新 Typora 的最新版，可以在设置-图像处找到自定义图片上传服务的设置区域：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/typora-image-setting.png" /></p><p>Typora 官方关于图像自定义上传相关的配置、介绍的页面 <a href="https://support.typora.io/Upload-Image/" target="_blank">在这里</a>。</p><p>如上图，你可以选择自己喜欢用的图片上传工具，可选的工具如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/upload.png" /></p><p>同时 Typora 提供了上传测试功能，如下图你可以找到 <code>Test Uploader</code> 按钮来测试你的上传功能是否正常：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/typora-test-upload.png" /></p><p>Typora 会上传的图片就是它家的 Logo 了，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/image-20200226192722744.png" /></p><p>当测试成功之后，还别忘了开启图片自动上传功能：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/typora-image-settings.png" /></p><p>注意选则第三项，即允许通过读取 YAML 配置来决定是否自动上传图片。经过测试，在 macOS 上必须开启这个选项，同时在文章的顶部写下如下的 YAML 配置：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>---</span></span><br /><span><span>typora-copy-images-to:</span> <span>upload</span></span><br /><span><span>---</span></span><br /></pre></td></tr></table><p>这样才可以开启自动上传图片的功能。应该是 Typora 的一个 bug，后续版本不知道会不会修复。</p><h2><a href="https://molunerfinn.com/typora-supports-picgo/#自动上传图片的效果"></a>自动上传图片的效果</h2><p>说了这么多，Typora 里引入图片即上传的效果是怎么样的呢？我录制了一个 gif：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/typora-upload-image-gif-v2.gif" /></p><p>可以说整体效果还是比较流畅的。</p><p>同时如果你未开启自动上传图片的功能，把图片拖入 Typora 或者粘贴到 Typora，右键图片看到一个上传图片的选项：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/upload-image-with-context-menu.png" /></p><p>这样也能根据你配置的上传服务来上传图片。</p><h2><a href="https://molunerfinn.com/typora-supports-picgo/#使用-PicGo-上传的相关说明"></a>使用 PicGo 上传的相关说明</h2><p>Typora 支持了两种 PicGo 的上传模式，作为 PicGo 的开发者，我觉得有有必要跟朋友们说说区别。Typora 支持的两种 PicGo 上传模式分别是：PicGo-Core（命令行）以及 PicGo.app（图形界面）</p><h3><a href="https://molunerfinn.com/typora-supports-picgo/#1-PicGo-app"></a>1. PicGo.app</h3><p><a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo.app</a> 就是用户平时经常使用的图形化界面的 PicGo。而 Typora 对接的上传服务来自于 PicGo v2.2.0+提供的 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/advance.html#picgo-server" target="_blank">PicGo-Server</a> 的功能，它是一个小型的 HTTP 服务器，会默认开启 36677 端口来监听上传的请求。而 Typora 则会往 36677 端口发送请求来上传图片。所以如果你的 PicGo 版本过低或者 PicGo-Server 功能没有开启，或者端口不是 36677，都无法通过 Typora 的这个功能上传图片。</p><h3><a href="https://molunerfinn.com/typora-supports-picgo/#2-PicGo-Core"></a>2. PicGo-Core</h3><p>这个是 PicGo 底层依赖的 <a href="https://github.com/PicGo/PicGo-Core" target="_blank">核心库</a>，是 PicGo 上传图片、插件机制的核心。它是一个 npm 包，意味着你可以通过 npm 全局安装来实现上传。同时 Typora 也提供了预编译的二进制文件，它是把 PicGo-Core 所有依赖都打包成了一个可执行的文件。</p><p>Typora 对这两种 PicGo-Core 的用法都支持，官方的文档对此有详细的 <a href="https://support.typora.io/Upload-Image/#config-picgo-core" target="_blank">配置说明</a>。不过需要注意的是 macOS 由于系统的原因，不支持预编译的二进制文件那个使用方法，而只能使用 npm 全局安装的方式，再通过 <code>custom command</code> 自定义命令的方式来使用 PicGo-Core：</p><p><img src="https://cdn.jsdelivr.net/gh/Molunerfinn/test/blog/custom.png" /></p><h3><a href="https://molunerfinn.com/typora-supports-picgo/#3-二者的区别"></a>3. 二者的区别</h3><p>官方 <a href="https://support.typora.io/Upload-Image/#difference-between-picgoapp-and-picgo-core-command-line" target="_blank">文档</a> 里对二者的区别有做出描述，我觉得写得挺到位的。不过还是跟大家聊聊这二者的区别：</p><ol><li>使用 PicGo.app 模式上传意味着 PicGo 需要开启常驻后台。如果对性能要求比较高的用户可能不太能接受。</li><li>用 PicGo-Core 来上传只有运行时的消耗，上传结束后会自动销毁进程，性能方面会更好。</li><li>PicGo-Core 上传的配置跟 PicGo 用的不是同一个文件，因此如果需要用 PicGo-Core 来上传需要重新配置一遍。</li><li>PicGo 提供了更多的功能，比如上传前重命名、上传的历史记录等</li><li>PicGo 的一些插件只有 GUI 版本支持，而不支持 PicGo-Core，所以如果需要使用插件功能，更推荐使用 PicGo。不过 PicGo 只在语言设定为中文版的 Typora 里才能使用，因为目前 PicGo 没有英文文档、英文界面。</li></ol><p><strong>跪求 T T 有兴趣的小伙伴一起来翻译，如果对 PicGo 的国际化有意向的小伙伴，可以加入官方 <a href="https://gitter.im/picgo-all/PicGo?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link" target="_blank">gitter</a> 频道一起来聊。</strong></p><p>就我自己的使用来说，我是更喜欢直接用 PicGo 来上传的，因为配置什么的不用再调了，可视化界面也更容易操作~</p><h2><a href="https://molunerfinn.com/typora-supports-picgo/#小结"></a>小结</h2><p>前不久 PicGo2.0 发布的时候，PicGo-Core 还收到了来自 Typora 官方的 PR。我以为需要好几个月的时间才能支持自定义图床，没想到支持来得这么快。我觉得对于一个 Markdown 编辑器而言，图片的管理、上传一定是一种刚需。而此次开放了自定义上传的功能，想必也是戳中了很多 Typora 用户的痛点。另外这次 PicGo 能够作为官方指定的上传工具，我觉得非常开心，同时它也是 Typora 三个平台都支持的上传工具（uPic 和 iPic 都很棒，不过只支持 macOS），希望有了这个功能以后能够给你们带来更好码字体验~</p>]]></content>
        
        <summary type="html">
            
            Typora 最近的一次更新支持图片自定义图片上传服务了，增加了对 uPic，PicGo 以及自定义上传命令的支持。其中针对 PicGo 和 PicGo-Core 都做了兼容，可以说非常有诚意了。本文会简单介绍一下如何配置并使用。自定义图片上传服务的设置更新 Typora 的最
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="随笔"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
    </entry>
    
    <entry>
        <title>家居自动化</title>
        <link href="https://binux.blog/2020/01/home-assistant/"/>
        <id>https://binux.blog/2020/01/home-assistant/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2020-01-05T05:02:31+00:00</published>
        <updated>2020-01-05T05:02:31+00:00</updated>
        
        <content type="html"><![CDATA[<p>从 Google Assistant, Amazon Alexa, Apple Homekit 到米家，智能家居自动化已经不是什么新鲜的概念了。对于我来说，入坑的契机也非常简单：我不想下床关灯。然后随着想要自动化的场景增加，智能设备（可编程设备）就越来越多。这篇文章就根据自动场景介绍一下我现在的一些方案（本文无任何 affiliate ）。</p><h2><a href="https://binux.blog/2020/01/home-assistant/#Hub"></a>Hub</h2><p>首先，在配置场景之前，需要选择一个 Hub —— 作为自动化中心，连接传感器和操作控制器（例如灯，插座，IR 遥控器等）。你可以选择 Google Home，Alexa，Homekit 这样大厂的方案，不过这里我还是推荐 <a href="https://www.home-assistant.io/" target="_blank">Home Assistant</a> 这样的开源方案：</p><ul><li>更多的<a href="https://www.home-assistant.io/integrations/" target="_blank">接入设备支持</a>（你甚至可以同时接入 Alexa 和 Google Assistant 的设备）</li><li>更自由的自动化配置（例如 Google Assistant 不支持延迟触发；你甚至可以写 shell 脚本）</li><li>更好的隐私保护（Home Assistant 的设备支持大多来源于逆向设备 API，能不联网就不联网）</li></ul><p>我在 Synology DS218+ 上以 docker 运行 Home Assistant。</p><p>不过无论你选择什么方案，在这之后购买传感器和控制器的时候都需要注意你的 Hub 是否支持设备接入。考虑到价格，我的设备主要是 TP-Link 的插座加上米家的传感器，我会在具体场景中详细列出。</p><h2><a href="https://binux.blog/2020/01/home-assistant/#自动化场景"></a>自动化场景</h2><h3><a href="https://binux.blog/2020/01/home-assistant/#Hey-Google-Good-Night"></a>Hey Google, Good Night</h3><p>首先就是我入坑的第一个场景，在床上关上家中所有的灯。我用到的设备有：</p><ul><li><a href="https://store.google.com/us/product/google_home_mini" target="_blank">Google Home Mini</a></li><li><a href="https://www.kasasmart.com/us/products/smart-plugs/kasa-smart-plug-energy-monitoring-hs110" target="_blank">TP-Link Smart Plug HS110</a></li><li><a href="https://www.kasasmart.com/us/products/smart-switches/kasa-smart-wi-fi-light-switch-hs200" target="_blank">TP-Link Smart Switch HS200</a></li></ul><p>由于美国的房子没有灯，对的，没·有·灯。默认的开关控制的插座不一定在我想要的位置。这时候就可以用一个 Smart Plug 接一个落地灯。而对于其他自带的例如浴室厨房灯，就通过替换 Smart Switch 控制。</p><p>设置方面也很简单，直接在 Google Home 的 Routines 中关掉所有的开关就好了。</p><h3><a href="https://binux.blog/2020/01/home-assistant/#自动开关厕所灯"></a>自动开关厕所灯</h3><p>这也是很常见的使用场景，红外感应人进入就开灯，然后延迟关灯，用到的设备有：</p><ul><li><a href="https://www.mi.com/wangguan" target="_blank">米家多功能网关</a></li><li><a href="https://item.mi.com/product/5005.html" target="_blank">米家人体传感器</a></li><li><a href="https://www.kasasmart.com/us/products/smart-switches/kasa-smart-wi-fi-light-switch-hs200" target="_blank">TP-Link Smart Switch HS200</a></li></ul><p>首先跟着<a href="https://www.home-assistant.io/integrations/xiaomi_aqara/" target="_blank">文档</a>将米家多功能网关接入 Home Assistant，然后就可以添加 Automation 了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /></pre></td><td><pre><span>- id: '1561354113814'</span><br /><span>  alias: Turn On Bathroom</span><br /><span>  trigger:</span><br /><span>  - entity_id: binary_sensor.xiaomi_motion_sensor</span><br /><span>    platform: state</span><br /><span>    to: 'on'</span><br /><span>  condition: []</span><br /><span>  action:</span><br /><span>  - data:</span><br /><span>      entity_id: switch.bathroom_light</span><br /><span>    service: switch.turn_on</span><br /><span>- id: '1560102516271'</span><br /><span>  alias: Turn Off Bathroom</span><br /><span>  trigger:</span><br /><span>  - entity_id: switch.bathroom_light</span><br /><span>    for: 00:10:00</span><br /><span>    platform: state</span><br /><span>    to: 'on'</span><br /><span>  - entity_id: binary_sensor.xiaomi_motion_sensor</span><br /><span>    for: 00:10:00</span><br /><span>    platform: state</span><br /><span>    to: 'off'</span><br /><span>  condition:</span><br /><span>  - condition: template</span><br /><span>    value_template: '{{ is_state("switch.bathroom_light", "on") and as_timestamp(now())</span><br /><span>      - as_timestamp(states.switch.bathroom_light.last_changed) &gt; 600 }}'</span><br /><span>  - condition: template</span><br /><span>    value_template: '{{ is_state("binary_sensor.xiaomi_motion_sensor", "off") and</span><br /><span>      as_timestamp(now()) - as_timestamp(states.binary_sensor.xiaomi_motion_sensor.last_changed)</span><br /><span>      &gt; 600 }}'</span><br /><span>  action:</span><br /><span>  - alias: ''</span><br /><span>    data:</span><br /><span>      entity_id: switch.bathroom_light</span><br /><span>    service: switch.turn_off</span><br /></pre></td></tr></table><h3><a href="https://binux.blog/2020/01/home-assistant/#进门自动开灯"></a>进门自动开灯</h3><p>这可以有两个方案，一个是用摄像头检测到人就开灯，或者用 Smart Lock 的开锁事件。</p><ul><li><a href="https://wyze.com/wyze-cam.html" target="_blank">Wyze Cam</a></li><li><a href="https://august.com/products/august-smart-lock-pro-connect" target="_blank">August Smart Lock Pro</a></li><li><a href="https://www.kasasmart.com/us/products/smart-switches/kasa-smart-wi-fi-light-switch-hs200" target="_blank">TP-Link Smart Switch HS200</a></li></ul><p>Wyze Cam 就是<a href="https://www.mi.com/xiaofang" target="_blank">小方智能摄像机</a> 的国外版本，你可以用<a href="https://github.com/EliasKotlyar/Xiaomi-Dafang-Hacks" target="_blank">开源的固件</a>。如果直接用它自带的。接入 Home Assistant 需要通过 ifttt。August Lock 就能直接支持了。</p><p>设置自动化和上面类似，condition 里面可以设置只在下班时间或者太阳落山后时才开灯。这里就贴配置了。总的来说 Smart Lock 比摄像头的方案要稳定得多，误触也少。</p><h3><a href="https://binux.blog/2020/01/home-assistant/#Hey-Google-True-on-Projector"></a>Hey Google, True on Projector</h3><p>由于经常搬家，我都是用投影代替电视的。毕竟同样的尺寸，投影机容易搬多了。然后我现在的投影机是没有内置音响的，所以我还有一个 soundbar。这个场景就是，当我打开投影的时候，同时打开音响，关闭客厅灯，然后 PC 的输出切换到投影上，再打开 Plex。这里面用到的是：</p><ul><li><a href="https://store.google.com/us/product/google_home_mini" target="_blank">Google Home Mini</a></li><li><a href="https://item.mi.com/product/9465.html" target="_blank">米家万能遥控器</a></li><li><a href="https://github.com/KjetilSv/Win10As" target="_blank">Win10As</a></li></ul><p>首先是将这几个设备接入 Home Assistant，参考 <a href="https://www.home-assistant.io/integrations/remote.xiaomi_miio/" target="_blank">Xiaomi IR Remote</a> 和 <a href="https://www.home-assistant.io/integrations/mqtt/" target="_blank">mqtt</a> 的文档就好了。</p><p>然后是控制投影的开关，当米家万能遥控器接入 Home Assistant 后，可以通过 <code>xiaomi_miio.remote_learn_command</code> 指令学习投影遥控的开关机代码，然后在 Home Assistant 中建立一个虚拟开关：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /></pre></td><td><pre><span>remote:</span><br /><span>  - platform: xiaomi_miio</span><br /><span>    host: 192.168.1.104</span><br /><span>    token: dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxb</span><br /><span>    commands:</span><br /><span>      project_on:</span><br /><span>        command:</span><br /><span>        - raw:nMwmkwlk0mkxmEsms4mEsmM2m0wlk2AMKYzYBYgCDmoDLTUA85gAOUyAXkB+wOfAhkBDwEPAQYGSAXOCE8IQwQVCNsAcghfAI8AjwPImM2mYDPg7tMIA</span><br /><span>      project_off:</span><br /><span>        command:</span><br /><span>        - raw:nMwmMwlk0mk1mEsms3mEsmM2AEIAjJqAywA/gD+Bz4DPgIeAh4CHgy+BB4EHgMeAh4BHgReAz4A6TCAA</span><br /><span></span><br /><span>switch:</span><br /><span>  - platform: template</span><br /><span>    switches:</span><br /><span>      projector:</span><br /><span>        value_template: "{{ states('input_boolean.projector') }}"</span><br /><span>        turn_on:</span><br /><span>          - service: remote.send_command</span><br /><span>            data:</span><br /><span>              command:</span><br /><span>              - project_on</span><br /><span>              entity_id: remote.xiaomi_miio_192_168_1_104</span><br /><span>          - service: input_boolean.turn_on</span><br /><span>            entity_id: input_boolean.projector</span><br /><span>        turn_off:</span><br /><span>          - service: remote.send_command</span><br /><span>            data:</span><br /><span>              command:</span><br /><span>              - project_off</span><br /><span>              entity_id: remote.xiaomi_miio_192_168_1_104</span><br /><span>          - service: input_boolean.turn_off</span><br /><span>            entity_id: input_boolean.projector</span><br /><span></span><br /><span>input_boolean:</span><br /><span>  projector: {}</span><br /></pre></td></tr></table><p>音响也是一样，依葫芦画瓢就好了。</p><p>然后是 PC 这边，这里用了一个一个开源程序 <a href="https://github.com/KjetilSv/Win10As" target="_blank">Win10As</a> 然后通过 <a href="https://www.home-assistant.io/integrations/mqtt/" target="_blank">mqtt</a> 协议和 Home Assistant 连接。</p><p>设置三个指令：</p><table><thead><tr><th>name</th><th>cmdtext</th><th>cmdparameters</th></tr></thead><tbody><tr><td>exec/plex</td><td>D:\plex.bat</td><td>1</td></tr><tr><td>display/pc</td><td>D:\DisplaySwitch.exe</td><td>/internal</td></tr><tr><td>display/projector</td><td>D:\DisplaySwitch.exe</td><td>/external</td></tr></tbody></table><p>其中 plex.bat：<code>start "" /B "C:\Program Files\Plex\Plex Media Player\PlexMediaPlayer.exe" --tv --fullscreen</code><br />DisplaySwitch.exe 位于 <code>C:\Windows\System32\DisplaySwitch.exe</code> 不知道为什么从 Win10As 中无法访问这个程序，不过把它拷贝出来也是一样用的。</p><p>然后可以在 Home Assistant 中加一个 pc_screen 的 switch：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /></pre></td><td><pre><span>switch:</span><br /><span>  - platform: template</span><br /><span>      pc_screen:</span><br /><span>        value_template: "{{ states('input_boolean.pc_screen') }}"</span><br /><span>        turn_on:</span><br /><span>          - service: mqtt.publish</span><br /><span>            data:</span><br /><span>              topic: GAMEBOX/display/pc</span><br /><span>          - service: input_boolean.turn_on</span><br /><span>            entity_id: input_boolean.pc_screen</span><br /><span>        turn_off:</span><br /><span>          - service: mqtt.publish</span><br /><span>            data:</span><br /><span>              topic: GAMEBOX/display/projector</span><br /><span>          - service: input_boolean.turn_on</span><br /><span>            entity_id: input_boolean.pc_screen</span><br /><span></span><br /><span>input_boolean:</span><br /><span>  pc_screen: {}</span><br /></pre></td></tr></table><p>然后就可以通过 Automation 把它们串起来了。由于是 WebUI 就能配置的，我就不贴出来了。注意一点是在打开投影机到切换 PC 输出之间加一个延迟，等到投影 ready 再切换，切换后再加个延迟再启动 Plex 就能保证 Plex 在投影的窗口前台全屏显示了。</p><h2><a href="https://binux.blog/2020/01/home-assistant/#总结"></a>总结</h2><p>其他的例如</p><ul><li>Hey Google, Turn on XXX 等单独的开关</li><li>Good Night 的时候同时关电脑，关投影</li><li>Google Assistant 控制 Alexa 设备</li><li>监控本月流量有没有超过 1T，在 80% 关掉 PT 上传</li><li>通过路由器监控接入设备，判断人在家的时候关闭摄像头监控</li><li>当阳台摄像头检测到移动，Google Home Mini 的喇叭鸣警笛。</li><li>当按照某种特定的顺序打开灯的时候，自动打开门，以防止出门忘带手机（前提是你能让 Google Home Mini 听到在门外的你）</li></ul><p>由于都是重用现有设备这里就不介绍了，这些都能通过 Home Assistant 接入后用 Automation 完成。</p><p>总之「智能家居」中的「智能」其实就是一个语音识别加上一个个预定的场景，很蠢，但是，<strong>真香</strong>。当习惯了叫一句 Hey Google 就能躺着沙发上开关各种设备之后，就再也回不去找各种遥控器了。比起一个「懂你」然后随时监听上传的设备，一个<a href="https://github.com/synesthesiam/rhasspy" target="_blank">离线语音识别</a>，加自定义的场景可能能更快地满足你对自动化的需要。</p><p>如果你有家居自动化的点子或者方案也可以留言交流，(´▽`ʃ♡ƪ)</p>]]></content>
        
        <summary type="html">
            
            从 Google Assistant, Amazon Alexa, Apple Homekit 到米家，智能家居自动化已经不是什么新鲜的概念了。对于我来说，入坑的契机也非常简单：我不想下床关灯。然后随着想要自动化的场景增加，智能设备（可编程设备）就越来越多。这篇文章就根据自动场
            
        </summary>
        
        <category term="home-assistant"/>
        
        <category term="google-assistant"/>
        
        <category term="alexa"/>
        
        <category term="米家"/>
        
    </entry>
    
    <entry>
        <title>Munin配置</title>
        <link href="https://linkthis.me/2019/09/11/the-config-of-munin/"/>
        <id>https://linkthis.me/2019/09/11/the-config-of-munin/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>多看README。</p>
</blockquote>

<p>高价破网石头盘，那这破机器到底有多烂呢？所以我们需要一个工具来监控一下，为了简便，选择了基本功能比较齐全且无需数据库的<code>Munin</code><del>界面重回Win98</del>。<br /></p>

<h3>Munin</h3>

<p>通过包管理器直接安装：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>apt <span>install </span>munin
</pre></td></tr></tbody></table></code></pre></div></div>

<p>直接安装<code>Munin</code>时会自动安装<code>munin-node</code>，其它需要监控的机器则只需安装<code>munin-node</code>。<br /></p>

<h4>基本配置</h4>

<p><code>Munin</code>的配置文件为<code>/etc/munin/munin.conf</code>，有详细的注释。一般需取消的注释如下：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre>dbdir   /var/lib/munin // 数据库存放地址
htmldir /var/cache/munin/www //页面存放地址
logdir /var/log/munin // 日志存放地址
rundir  /var/run/munin // 运行时pid存放地址
tmpldir /etc/munin/templates // 网页模板
</pre></td></tr></tbody></table></code></pre></div></div>

<p>节点配置模板：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>[</span>localhost]
    address 127.0.0.1
    use_node_name <span>yes</span> // 定义节点名称
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>munin</code>默认配置的<code>cron</code>任务5分钟执行一次，可以自行调整。手动生成网页需执行：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>su munin <span>--shell</span><span>=</span>/bin/bash
munin-cron
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>munin-node</code>的配置文件为<code>/etc/munin/munin-node.conf</code>，默认配置的<code>cron</code>任务5分钟执行一次，有详细的注释。</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>allow ^192<span>\.</span>168<span>\.</span>1<span>\.</span>2<span>$</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>应允许需要使用的IP地址和端口。</p>

<h4>CGI动态绘制图形</h4>

<p>使用<code>spawn-fcgi</code>产生<code>FastCGI</code>进程：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>apt <span>install </span>spawn-fcgi
</pre></td></tr></tbody></table></code></pre></div></div>

<p>创建<code>Systemd</code>脚本每次开机自动生成相关进程：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>[</span>Unit]
<span>Description</span><span>=</span>Munin FastCGI Graph
<span>Documentation</span><span>=</span>man:spawn-fcgi

<span>[</span>Service]
<span>Type</span><span>=</span>forking
<span>PIDFile</span><span>=</span>/var/run/munin/fcgi-graph.pid
<span>ExecStart</span><span>=</span>/usr/bin/spawn-fcgi <span>-s</span> /var/run/munin/fastcgi-graph.sock <span>-U</span> www-data <span>-u</span> munin <span>-g</span> munin /usr/lib/munin/cgi/munin-cgi-graph <span>-P</span> /var/run/munin/fcgi-graph.pid

<span>[</span>Install]
<span>WantedBy</span><span>=</span>multi-user.target
</pre></td></tr></tbody></table></code></pre></div></div>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>[</span>Unit]
<span>Description</span><span>=</span>Munin FastCGI HTML
<span>Documentation</span><span>=</span>man:spawn-fcgi

<span>[</span>Service]
<span>Type</span><span>=</span>forking
<span>PIDFile</span><span>=</span>/var/run/munin/fcgi-html.pid
<span>ExecStart</span><span>=</span>/usr/bin/spawn-fcgi <span>-s</span> /var/run/munin/fastcgi-html.sock  <span>-U</span> www-data <span>-u</span> munin <span>-g</span> munin /usr/lib/munin/cgi/munin-cgi-html <span>-P</span> /var/run/munin/fcgi-html.pid

<span>[</span>Install]
<span>WantedBy</span><span>=</span>multi-user.target
</pre></td></tr></tbody></table></code></pre></div></div>

<p>同时应修改<code>munin.conf</code>文件</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>html_strategy cgi
</pre></td></tr></tbody></table></code></pre></div></div>

<p>而<code>graph_strategy</code>应该被<strong>注释掉</strong>。<br />
注意，<code>/var/log/munin/munin-cgi-*.log</code>文件可能由<code>www-data</code>用户所有，则需修改对应日志文件的权限，并编辑<code>/etc/logrotate.d/munin</code>；且<code>CGI HTML</code>可能<strong>存在一些BUG</strong>，请谨慎启用。<br />
之后执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre>systemctl daemon-reload
systemctl <span>enable </span>munin-fcgi-graph.service
systemctl <span>enable </span>munin-fcgi-html.service
systemctl start munin-fcgi-graph.service
systemctl start munin-fcgi-html.service
systemctl restart munin-node.service
</pre></td></tr></tbody></table></code></pre></div></div>

<h3>Nginx配置</h3>

<p>如果使用了<code>CGI</code>来生成图片，需要在<code>Nginx</code>的配置中额外添加以下内容：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre>location ^~ /munin-cgi/munin-cgi-graph/ <span>{</span>
    fastcgi_split_path_info ^<span>(</span>/munin-cgi/munin-cgi-graph<span>)(</span>.<span>*</span><span>)</span><span>;</span>
    fastcgi_param PATH_INFO <span>$fastcgi_path_info</span><span>;</span>
    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock<span>;</span>
    include fastcgi_params<span>;</span>
<span>}</span>

location /munin/static/ <span>{</span>
    <span>alias</span> /etc/munin/static/<span>;</span>
<span>}</span>

location /munin/ <span>{</span>
    fastcgi_split_path_info ^<span>(</span>/munin<span>)(</span>.<span>*</span><span>)</span><span>;</span>
    fastcgi_param PATH_INFO <span>$fastcgi_path_info</span><span>;</span>
    fastcgi_pass unix:/var/run/munin/fastcgi-html.sock<span>;</span>
    include fastcgi_params<span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果不想<code>Munin</code>的监控被直接访问，可以配置<code>auth_basic</code>进行简单的密码认证。</p>

<h3>Munin插件</h3>

<p><code>Munin</code>本身自带了一定数量的插件，并且在安装时会自动配置完成，可以提供所在节点的基本信息。<br />
<a href="http://gallery.munin-monitoring.org/" target="_blank">Munin Plugin Gallery</a>提供了自带和大部分非官方插件的说明，可以根据需求自行配置。<br />
需要注意<code>Munin 2.0</code>的官方自带插件较旧，功能上可能不如第三方插件完善；在使用第三方插件时应首先选择官方<a href="https://github.com/munin-monitoring/contrib" target="_blank">contrib</a>，其对插件进行了修改，更加方便使用，而且部分插件的作者并没有对插件进行维护，其本身已经年久失修。<br />
配置插件时需要注意插件自身的<strong>权限</strong>，且大多数插件的配置说明大部分位于插件文件的开头，需仔细阅读。新增插件配置完成之后执行：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>munin-run
systemctl restart munin-node.service
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>Munin 3.0的界面真好看。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               多看README。   高价破网石头盘，那这破机器到底有多烂呢？所以我们需要一个工具来监控一下，为了简便，选择了基本功能比较齐全且无需数据库的Munin界面重回Win98。  Munin  通过包管理器直接安装：  1 apt install munin   直接安装Mu
            
        </summary>
        
        <category term="Munin"/>
        
        <category term="记录"/>
        
        <category term="工具"/>
        
    </entry>
    
    <entry>
        <title>RSShub配置记录</title>
        <link href="https://linkthis.me/2019/05/29/the-note-of-rsshub/"/>
        <id>https://linkthis.me/2019/05/29/the-note-of-rsshub/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>天下没有免费的午餐。</p>
</blockquote>

<p>RSS能够快速聚合自己想要的消息，可是很多网站出于各种原因并不提供RSS源。所以需要像<a href="https://github.com/DIYgod/RSSHub" target="_blank">RSShub</a>这样的生成器来生成自己所需的RSS源。<br /></p>

<h3>安装NodeJS</h3>

<p>NodeJS如果需要版本控制的话，最好使用<code>nvm</code>来安装。不过由于只是单纯的使用，所以直接使用包管理器安装即可。<br />
如果需要较新或者对某版本有偏好，可以采用<a href="https://github.com/nodesource/distributions" target="_blank"><code>NodeSource</code></a>提供的版本：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>curl <span>-sL</span> https://deb.nodesource.com/setup_10.x | bash -
apt-get <span>install</span> <span>-y</span> nodejs
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在Debian上需以<strong><code>root</code></strong>用户执行命令。然后安装<code>yarn</code>替代<code>npm</code>：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>curl <span>-sL</span> https://dl.yarnpkg.com/debian/pubkey.gpg | <span>sudo </span>apt-key add -
<span>echo</span> <span>"deb https://dl.yarnpkg.com/debian/ stable main"</span> | <span>sudo tee</span> /etc/apt/sources.list.d/yarn.list
apt-get update <span>&amp;&amp;</span> <span>sudo </span>apt-get <span>install </span>yarn
</pre></td></tr></tbody></table></code></pre></div></div>

<h3>部署安装</h3>

<p>下载<code>RSShub</code>源码至想要的目录：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>git clone https://github.com/DIYgod/RSSHub.git
</pre></td></tr></tbody></table></code></pre></div></div>

<p>下载完成后安装所需依赖：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>yarn <span>install</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>安装过程大概不会超过2分钟；以后更新源代码之后需<strong>重新</strong>执行安装步骤。<br />
安装完成之后执行：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>yarn start
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在浏览器中打开<code>http://127.0.0.1:1200/</code>或<code>http://IP:1200/</code>，访问成功则安装完成。</p>

<h3>Systemd配置</h3>

<p>为了让<code>RSShub</code>在退出终端后继续运行并方便之后的管理，使用<code>Systemd</code>对其进行操作。
执行<code>vi /etc/systemd/system/rsshub.service</code>创建对应文件，可参考以下内容：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>[</span>Unit]
<span>Description</span><span>=</span>Rsshub
<span>After</span><span>=</span>network.target
<span>Wants</span><span>=</span>network.target

<span>[</span>Service]
<span>Type</span><span>=</span>simple
<span>WorkingDirectory</span><span>=</span>/home/RSSHub
<span>ExecStart</span><span>=</span>/bin/bash <span>-c</span> <span>'yarn start'</span>
<span>Restart</span><span>=</span>on-failure
<span>#User=nobody</span>
<span>#Group=nogroup</span>

<span>[</span>Install]
<span>WantedBy</span><span>=</span>multi-user.target
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>User</code>和<code>Group</code>可以省略，如需配置请注意<strong>权限问题</strong>。<br />
然后执行以下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>systemctl daemon-reload          <span>##重载Systemd脚本</span>
systemctl <span>enable </span>rsshub.service  <span>##开机启动访问</span>
systemctl start rsshub.service
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果需要自动更新源码等功能，则需另外配置资源钩子。</p>

<h3>Nginx配置</h3>

<p>为了避免每次输入IP的麻烦和安全性，配置Nginx作为代理；可以采用二次目录或者二级域名。<br />
参考示例如下：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td><pre>server <span>{</span>
    listen 443 ssl http2<span>;</span>
    listen <span>[</span>::]:443 ssl http2<span>;</span>
    server_name rsshub.example.com<span>;</span>

    access_log /var/log/nginx/access.log<span>;</span>
    error_log /var/log/nginx/error.log warn<span>;</span>

    ssl_certificate /var/www/ssl/fullchain.cer<span>;</span>
    ssl_certificate_key /var/www/ssl/example.com.key<span>;</span>
    ssl_session_timeout 1d<span>;</span>
    ssl_session_cache shared:SSL:50m<span>;</span>
    ssl_session_tickets off<span>;</span>

    ssl_dhparam /var/www/ssl/dhparam.pem<span>;</span>

    ssl_protocols TLSv1.2 TLSv1.3<span>;</span>
    ssl_ciphers <span>'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256'</span><span>;</span>
    ssl_prefer_server_ciphers on<span>;</span>

    location / <span>{</span>
        proxy_pass http://127.0.0.1:1200<span>;</span>
        proxy_set_header Host <span>$host</span><span>;</span>
        proxy_redirect off<span>;</span>
        proxy_set_header X-Real-IP <span>$remote_addr</span><span>;</span>
        proxy_set_header X-Forwarded-For <span>$proxy_add_x_forwarded_for</span><span>;</span>
        proxy_set_header X-Forwarded-Proto <span>$scheme</span><span>;</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Nginx还有许多可以配置的相关选项，如有需要可以自行添加。</p>

<h3>Rsshub简单配置</h3>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>listenInaddrAny: parseInt<span>(</span>process.env.LISTEN_INADDR_ANY<span>)</span> <span>||</span> 0
debugInfo: process.env.DEBUG_INFO <span>||</span> <span>false</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>不允许公网连接；关闭调试信息。<br />
其中一些网站需要配置用户名、密码、API或者COOKIE才能生成对应的RSS链接；需要配置的选项均可在<code>config.js</code>内找到。<br />
如果使用<code>Systemd</code>进行管理，则应在脚本内添加<code>Environment</code>加入所需的环境变量方可生效：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>Environment</span><span>=</span><span>LISTEN_INADDR_ANY</span><span>=</span>0 <span>YOUTUBE_KEY</span><span>=</span>youtube_date_v3
</pre></td></tr></tbody></table></code></pre></div></div>

<p>其它参数<a href="https://docs.rsshub.app/install/#%E9%85%8D%E7%BD%AE" target="_blank">配置</a>参见官方文档。</p>

<blockquote>
  <p>垃圾Heroku，浪费时间。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               天下没有免费的午餐。   RSS能够快速聚合自己想要的消息，可是很多网站出于各种原因并不提供RSS源。所以需要像RSShub这样的生成器来生成自己所需的RSS源。  安装NodeJS  NodeJS如果需要版本控制的话，最好使用nvm来安装。不过由于只是单纯的使用，所以直
            
        </summary>
        
        <category term="RSS"/>
        
        <category term="记录"/>
        
        <category term="工具"/>
        
    </entry>
    
    <entry>
        <title>mpv使用记录</title>
        <link href="https://linkthis.me/2019/05/18/the-note-of-mpv/"/>
        <id>https://linkthis.me/2019/05/18/the-note-of-mpv/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>偷懒一时爽，查错火葬场。</p>
</blockquote>

<p>MPV是一个开源的跨平台播放器，对各类平台和高画质都有不错的支持<del>然而并不能一套配置通用所有平台</del>。<br /></p>

<h3>文件夹简介</h3>

<p>Windows上MPV安装包的解包位置没有特殊限制，不过需要注意该文件夹需要有写入权限；之后的更新执行文件夹下的<code>updater.bat</code>即可。Linux上如果通过包管理器进行安装，默认配置位于<code>~/.config/mpv/</code>；不过由于官方版本号已经半年多没有更新，所以自行同步代码编译安装的配置文件夹取决于自己的设置。<br />
Windows下的各项配置文件或文件夹建议保存在自己创建的<code>portable_config</code>文件夹内，而Linux无需单独创建文件夹。通常MPV的功能配置文件或文件夹有以下几个：</p>

<ul>
  <li>scripts</li>
  <li>shaders</li>
  <li>encoding-profiles</li>
  <li>input.conf</li>
  <li>mpv.conf</li>
</ul>

<p><code>script</code>文件夹存放各种用来附加功能的脚本；<code>shaders</code>文件夹用来存放第三方着色器；<code>input.conf</code>用来自定义快捷键；<code>encoding-profiles</code>用于调整编码等，一般无需修改；<code>mpv.conf</code>则是MPV的主配置文件，用于对视频、音频、字幕等进行设置。<br />
当然还有其它文件夹，不过此类文件夹通常根据需求来创建。<br /></p>

<h3>主配置文件</h3>

<p>以下所有配置均位于<code>mpv.conf</code>文件中。<br /></p>

<h4>视频</h4>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>hwdec</span><span>=</span>no
<span>profile</span><span>=</span>gpu-hq
icc-profile-auto
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果不是为长时间续航、避免风扇噪音或者硬解4K等特殊需求，在显卡能力足够的情况下为了避免奇怪的问题，关闭硬解；开启MPV默认的高质量渲染；如果还有更高的需求，可以结合之后的脚本对特定类型的视频开启针对性选项；默认开启色彩管理。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>gpu-api<span>=</span>vulkan
</pre></td></tr></tbody></table></code></pre></div></div>

<p>MPV支持<code>vulkan</code>、<code>d3d11</code>和<code>opengl</code>三种API，应根据使用平台的支持情况进行选择；在最近版本的MPV中使用<code>vulkan</code>会导致OSD显示的系统占用百分比全部为0，为已知<strong>BUG</strong>。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>video-sync<span>=</span>display-resample
interpolation
<span>tscale</span><span>=</span>oversample
</pre></td></tr></tbody></table></code></pre></div></div>

<p>强制锁定显示器刷新频率，使视频与音频尽量同步播放，其它类型同步选项参考此<a href="https://mpv.io/manual/master/#options-video-sync" target="_blank">链接</a>；<code>tscale</code>有多种值可选，各种算法参见此<a href="https://mpv.io/manual/master/#options-tscale" target="_blank">链接</a>。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>blend-subtitles<span>=</span>video
</pre></td></tr></tbody></table></code></pre></div></div>

<p>将字幕渲染到视频源分辨率并随视频一起缩放并进行色彩管理，可以在某种程度上避免字母模糊的情况，但是有的情况则是由于<code>libass</code>与<code>XySubFilter</code>对字幕渲染方式的不一致造成的问题<del>或许是两种之中某一个的BUG</del>。</p>

<h4>音频</h4>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>ao</span><span>=</span>wasapi
audio-exclusive<span>=</span><span>yes</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>选择音频输出方式和是否为独占模式，需根据对应平台选择。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>audio-normalize-downmix<span>=</span><span>yes</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>声音忽大忽小时开启规格化。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>audio-file-auto<span>=</span>fuzzy
alang <span>=</span> jpn, jp, ja, en, eng
</pre></td></tr></tbody></table></code></pre></div></div>

<p>音轨文件的加载方式；音轨语言的优先级设置。</p>

<h4>字幕</h4>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre>sub-auto<span>=</span>fuzzy
sub-file-paths-append <span>=</span> sub
sub-file-paths-append <span>=</span> subs
sub-file-paths-append <span>=</span> subtitles
slang <span>=</span> chs, sc, gb, zh-CN, zh-Hans, zh
</pre></td></tr></tbody></table></code></pre></div></div>

<p>外挂字幕的加载方式和加载时应查找的文件夹；字幕语言的优先级设置。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>#sub-ass-vsfilter-aspect-compat=no</span>
<span>#sub-ass-vsfilter-blur-compat=no</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>字幕是否拉伸或者模糊，当字幕渲染出现问题时启用。</p>

<h4>其它</h4>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>screenshot-format           <span>=</span> png
screenshot-tag-colorspace   <span>=</span> <span>yes
</span>screenshot-high-bit-depth   <span>=</span> <span>yes
</span>screenshot-template         <span>=</span> <span>"%F-%{estimated-frame-number:%P}"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>设置截图时图片保存的格式和命名规则等。<br /></p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>save-position-on-quit         <span># 记忆上次播放的位置</span>
keep-open                     <span># 播放结束后不退出</span>
ontop                         <span># 在全屏的情况下，更容易进入全屏独占</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>一些播放相关的配置。</p>

<h3>脚本</h3>

<p>MPV功能较为单一，需要通过外加<a href="https://github.com/mpv-player/mpv/wiki/User-Scripts" target="_blank">脚本</a>实现更多的功能，以下是一些脚本的介绍：</p>

<ul>
  <li><a href="https://github.com/mpv-player/mpv/blob/master/TOOLS/lua/autoload.lua" target="_blank">autoload</a>：自动加载当前播放文件目录里的视频文件到播放列表</li>
  <li><a href="https://github.com/mpv-player/mpv/blob/master/TOOLS/lua/pause-when-minimize.lua" target="_blank">pause-when-minimize</a>：最小化时自动暂停，恢复时自动开始播放</li>
  <li><a href="https://github.com/mpv-player/mpv/blob/master/TOOLS/lua/autodeint.lua" target="_blank">autodeint</a>：自动判断是否需要反交错</li>
  <li><a href="https://github.com/wiiaboo/mpv-scripts/blob/master/auto-profiles.lua" target="_blank">auto-profiles</a>：根据设置采用不同的播放配置</li>
  <li><a href="https://github.com/nmoorthy1/mpv-Change-OSD-Media-Title" target="_blank">mpv-Change-OSD-Media-Title</a>：显示文件名、已观看百分比、当前章节和OSD中的丢弃帧数，并在其中一个值发生更改时更新</li>
  <li><a href="https://github.com/TheAMM/mpv_crop_script" target="_blank">mpv_crop_script</a>：直接在mpv中进行屏幕截图，且无需外部依赖</li>
</ul>

<p>在使用脚本时应阅读相关的<strong>README</strong>文件，其中可能提供了针对脚本的额外配置选项，有部分脚本还需要修改<code>input.conf</code>来添加对应的快捷键。</p>

<h3>着色器</h3>

<p>通过使用外加的<a href="https://github.com/mpv-player/mpv/wiki/User-Scripts#user-shaders" target="_blank">着色器</a>提升观感，结合自己的机器的情况和喜好组合即可，以下是一些着色器的介绍：</p>

<ul>
  <li><a href="https://github.com/bjin/mpv-prescalers/tree/master" target="_blank">nnedi3 and ravu</a>：需要注意，虽然通常情况下<code>gather</code>和<code>compute</code>下的着色器的处理速度更快，但要求的<code>OpenGL</code>版本更高，只能在其工作时没有蓝屏且没有明显失真的情况下使用；<code>vulkan</code>内的着色器<strong>只能</strong>在<code>gpu-api=vulkan</code>或者<code>gpu-api=d3d11</code>的情况下使用；配置文件中，<code>glsl-shaders="~~/shaders/ravu-r3.hook"</code>只会被执行一次，如果需要放大4倍，则需书写同一个命令两次。</li>
  <li><a href="https://github.com/igv/FSRCNN-TensorFlow/releases" target="_blank">FSRCNN</a>：在放大图像时可以使用<code>FSRCNNX_x2_56-16-4-1.glsl</code>，但其速度太慢，不适合MPV。</li>
  <li><a href="https://gist.github.com/igv" target="_blank">SSimDownscaler, SSimSuperRes, Krig, Adaptive Sharpen, etc.</a>：<code>SSimSuperRes.glsl</code>最好搭配<code>dscale=mitchell</code>使用，<code>SSimDownscaler.glsl</code>则与<code>dscale=mitchell</code>和<code>linear-downscaling=no</code>组合使用；<code>adaptive-sharpen.glsl</code>应视情况手动开启。</li>
</ul>

<p>在使用这些着色器应仔细查看其<strong>README</strong>文件，并保持更新，以便获得更好的体验<del>是全新的BUG或者倒车</del>；而且需要注意文件格式是否正确，否则可能无法正常使用。</p>

<blockquote>
  <p>善用<code>wiki</code>和<code>issue</code>，珍惜看片时间。<br />
珍爱生命，远离无用LOG。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               偷懒一时爽，查错火葬场。   MPV是一个开源的跨平台播放器，对各类平台和高画质都有不错的支持然而并不能一套配置通用所有平台。  文件夹简介  Windows上MPV安装包的解包位置没有特殊限制，不过需要注意该文件夹需要有写入权限；之后的更新执行文件夹下的updater.
            
        </summary>
        
        <category term="MPV"/>
        
        <category term="记录"/>
        
    </entry>
    
    <entry>
        <title>学术讲座通知​：From Shuffled Linear Regression to Homomorphic Sensing</title>
        <link href="http://www.pris.net.cn/archives/5464"/>
        <id>http://www.pris.net.cn/archives/5464</id>
        
        <author>
            <name>李春光 (Chun-Guang LI)</name>
        </author>
        
        <published>2019-05-13T15:58:34+00:00</published>
        <updated>2019-05-13T15:58:34+00:00</updated>
        
        <content type="html"><![CDATA[<p>题目：From Shuffled Linear Regression to Homomorphic Sensing<br />
报告人：Dr. Manolis Tsakiris, 上海科技大学<br />
时间：2019年5月30日14:00-15:30 (星期四)<br />
地点：教三 308  主持人：李春光</p>
<p>摘要：<br />
A recent line of research termed Shuffled Linear Regression has been exploring under great generality the recovery of signals from permuted measurements; a challenging problem in diverse fields of data science and machine learning. In its simplest form it consists of solving a linear system of equations for which the right-hand-side vector has been permuted. In the first part of this talk I will present a provably correct method based on algebraic geometry together with its associated algorithm, the latter being a first working solution to this open problem, able to handle thousands of noisy fully permuted measurements in milliseconds. In the second part of the talk I will discuss the issue of uniqueness of the solution, in a general context which I have termed Homomorphic Sensing*. Given a linear subspace and a finite set of linear transformations I will present dimension conditions of algebraic-geometric nature guaranteeing that points in the subspace are uniquely determined from their homomorphic image under some transformation in the set. As a special case, this theory explains the operational regime of Unlabeled Sensing, in which the goal is unique recovery of signals from both permuted and subsampled measurements.<br />
*Has been accepted by ICML2019. Preprint: https://arxiv.org/abs/1901.07852</p>
<p>报告人简介:<br />
Manolis Tsakiris is an electrical engineering and computer science graduate of the National Technical University of Athens, Greece. He holds an M.S. degree in signal processing from Imperial College London, UK, and a Ph.D. degree from Johns Hopkins University, USA, in theoretical machine learning, under the supervision of Prof. Rene Vidal. Since August 2017 he is an assistant professor at the School of Information Science and Technology (SIST) at ShanghaiTech University. His main research interests are subspace learning methods and related problems in algebraic geometry. For more information, please visit his <a href="http://sist.shanghaitech.edu.cn/sist_en/">homepage</a>.</p>
<p>本次报告为学术前沿报告，欢迎各位老师和学生积极参加！</p>]]></content>
        
        <summary type="html">
            
            题目：From Shuffled Linear Regression to Homomorphic Sensing 报告人：Dr. Manolis Tsakiris, 上海科技大学 时间：2019年5月30日14:00-15:30 (星期四) 地点：教三 308  主持人：李春
            
        </summary>
        
        <category term="PRIS快讯"/>
        
    </entry>
    
    <entry>
        <title>Libuv初探</title>
        <link href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/"/>
        <id>https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#前言"></a>前言</h1><p>作为一个Node.js玩家，<a href="http://libuv.org/" target="_blank">libuv</a>的鼎鼎大名可谓是如雷贯耳。在我的印象中，libuv就是个“封装了ICOP/epoll等的超级牛逼的基于事件循环的库”，换句话说，就是“我知道你很牛逼，但是我啥都不知道”。<br />在生活中，有很多事情不是不能做，只是需要一个契机。有了这个契机，我就能有足够的动力去完成之。而我这学期的C++专业选修课大作业便给了我这个契机：</p><blockquote><p>题目三（10分）<br />在题目二的基础上，将游戏由本地单机，扩展为服务器多人游戏平台，使用客户端/服务器的方式，同一时间可以多人登录系统。将所有闯关者、出题者信息保存在服务器。<br />要求：</p><ul><li>必须在题目二基础上进行修改。</li><li>使用socket进行通信。</li><li>需要完成服务器端程序，以及客户端程序。客户端可以启动多个同时与服务器交互，要求服务器具有并发处理能力。</li></ul></blockquote><h1><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#从入门到放弃"></a>从入门到放弃</h1><p>其实一开始，我曾经被libuv吓退过，究其原因就是那一大堆<code>uv_</code>开头的指针，而代码写出来大概是这个画风：<br /><a href="https://github.com/nikhilm/uvbook/blob/master/code/pipe-echo-server/main.c" target="_blank">Echo-Server</a></p><a></a><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /><span>68</span><br /><span>69</span><br /><span>70</span><br /><span>71</span><br /><span>72</span><br /><span>73</span><br /><span>74</span><br /><span>75</span><br /><span>76</span><br /><span>77</span><br /><span>78</span><br /><span>79</span><br /><span>80</span><br /><span>81</span><br /><span>82</span><br /><span>83</span><br /><span>84</span><br /><span>85</span><br /><span>86</span><br /><span>87</span><br /><span>88</span><br /></pre></td><td><pre><span><span>#<span>include</span> <span>&lt;stdio.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;stdlib.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;string.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;uv.h&gt;</span></span></span><br /><span></span><br /><span><span>uv_loop_t</span> *loop;</span><br /><span></span><br /><span><span>typedef</span> <span><span>struct</span> {</span></span><br /><span>    <span>uv_write_t</span> req;</span><br /><span>    <span>uv_buf_t</span> buf;</span><br /><span>} <span>write_req_t</span>;</span><br /><span></span><br /><span><span><span>void</span> <span>free_write_req</span><span>(<span>uv_write_t</span> *req)</span> </span>{</span><br /><span>    <span>write_req_t</span> *wr = (<span>write_req_t</span>*) req;</span><br /><span>    <span>free</span>(wr-&gt;buf.base);</span><br /><span>    <span>free</span>(wr);</span><br /><span>}</span><br /><span></span><br /><span><span><span>void</span> <span>alloc_buffer</span><span>(<span>uv_handle_t</span> *handle, <span>size_t</span> suggested_size, <span>uv_buf_t</span> *buf)</span> </span>{</span><br /><span>  buf-&gt;base = <span>malloc</span>(suggested_size);</span><br /><span>  buf-&gt;len = suggested_size;</span><br /><span>}</span><br /><span></span><br /><span><span><span>void</span> <span>echo_write</span><span>(<span>uv_write_t</span> *req, <span>int</span> status)</span> </span>{</span><br /><span>    <span>if</span> (status &lt; <span>0</span>) {</span><br /><span>        <span>fprintf</span>(<span>stderr</span>, <span>"Write error %s\n"</span>, uv_err_name(status));</span><br /><span>    }</span><br /><span>    free_write_req(req);</span><br /><span>}</span><br /><span></span><br /><span><span><span>void</span> <span>echo_read</span><span>(<span>uv_stream_t</span> *client, <span>ssize_t</span> nread, <span>const</span> <span>uv_buf_t</span> *buf)</span> </span>{</span><br /><span>    <span>if</span> (nread &gt; <span>0</span>) {</span><br /><span>        <span>write_req_t</span> *req = (<span>write_req_t</span>*) <span>malloc</span>(<span>sizeof</span>(<span>write_req_t</span>));</span><br /><span>        req-&gt;buf = uv_buf_init(buf-&gt;base, nread);</span><br /><span>        uv_write((<span>uv_write_t</span>*) req, client, &amp;req-&gt;buf, <span>1</span>, echo_write);</span><br /><span>        <span>return</span>;</span><br /><span>    }</span><br /><span></span><br /><span>    <span>if</span> (nread &lt; <span>0</span>) {</span><br /><span>        <span>if</span> (nread != UV_EOF)</span><br /><span>            <span>fprintf</span>(<span>stderr</span>, <span>"Read error %s\n"</span>, uv_err_name(nread));</span><br /><span>        uv_close((<span>uv_handle_t</span>*) client, <span>NULL</span>);</span><br /><span>    }</span><br /><span></span><br /><span>    <span>free</span>(buf-&gt;base);</span><br /><span>}</span><br /><span></span><br /><span><span><span>void</span> <span>on_new_connection</span><span>(<span>uv_stream_t</span> *server, <span>int</span> status)</span> </span>{</span><br /><span>    <span>if</span> (status == <span>-1</span>) {</span><br /><span>        <span>// error!</span></span><br /><span>        <span>return</span>;</span><br /><span>    }</span><br /><span></span><br /><span>    <span>uv_pipe_t</span> *client = (<span>uv_pipe_t</span>*) <span>malloc</span>(<span>sizeof</span>(<span>uv_pipe_t</span>));</span><br /><span>    uv_pipe_init(loop, client, <span>0</span>);</span><br /><span>    <span>if</span> (uv_accept(server, (<span>uv_stream_t</span>*) client) == <span>0</span>) {</span><br /><span>        uv_read_start((<span>uv_stream_t</span>*) client, alloc_buffer, echo_read);</span><br /><span>    }</span><br /><span>    <span>else</span> {</span><br /><span>        uv_close((<span>uv_handle_t</span>*) client, <span>NULL</span>);</span><br /><span>    }</span><br /><span>}</span><br /><span></span><br /><span><span><span>void</span> <span>remove_sock</span><span>(<span>int</span> sig)</span> </span>{</span><br /><span>    <span>uv_fs_t</span> req;</span><br /><span>    uv_fs_unlink(loop, &amp;req, <span>"echo.sock"</span>, <span>NULL</span>);</span><br /><span>    <span>exit</span>(<span>0</span>);</span><br /><span>}</span><br /><span></span><br /><span><span><span>int</span> <span>main</span><span>()</span> </span>{</span><br /><span>    loop = uv_default_loop();</span><br /><span></span><br /><span>    <span>uv_pipe_t</span> server;</span><br /><span>    uv_pipe_init(loop, &amp;server, <span>0</span>);</span><br /><span></span><br /><span>    signal(SIGINT, remove_sock);</span><br /><span></span><br /><span>    <span>int</span> r;</span><br /><span>    <span>if</span> ((r = uv_pipe_bind(&amp;server, <span>"echo.sock"</span>))) {</span><br /><span>        <span>fprintf</span>(<span>stderr</span>, <span>"Bind error %s\n"</span>, uv_err_name(r));</span><br /><span>        <span>return</span> <span>1</span>;</span><br /><span>    }</span><br /><span>    <span>if</span> ((r = uv_listen((<span>uv_stream_t</span>*) &amp;server, <span>128</span>, on_new_connection))) {</span><br /><span>        <span>fprintf</span>(<span>stderr</span>, <span>"Listen error %s\n"</span>, uv_err_name(r));</span><br /><span>        <span>return</span> <span>2</span>;</span><br /><span>    }</span><br /><span>    <span>return</span> uv_run(loop, UV_RUN_DEFAULT);</span><br /><span>}</span><br /></pre></td></tr></table><p>这堆结构体是什么？？？光这一堆指针就足够劝退了吧！尤其是需要进行回调，还涉及到了各种函数指针，简直是恶心到不能再恶心了。不过这也没办法，谁叫人家只是个C语言库呢。</p><h2><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#绝处逢生"></a>绝处逢生</h2><p>幸而天无绝人之路，在关于<code>libuv</code>少的可怜的文档中，我发现了这个Wrapper:<a href="https://github.com/skypjack/uvw" target="_blank">UVW</a></p><blockquote><p>uvw is a header-only, event based, tiny and easy to use libuv wrapper in modern C++.<br />The basic idea is to hide completely the C-ish interface of libuv behind a graceful C++ API. Currently, no uv_*_t data structure is actually exposed by the library.<br />Note that uvw stays true to the API of libuv and it doesn’t add anything to its interface. For the same reasons, users of the library must follow the same rules who are used to follow with libuv.<br />As an example, a handle should be initialized before any other operation and closed once it is no longer in use.</p></blockquote><p>字面意思，一个<code>header-only</code>的库，对<code>libuv</code>的C风格API进行了封装，并转换成了C++14的语法。看起来非常的香，但是吃起来就有些咯牙了——本来关于<code>libuv</code>的资料就非常之少，如果再使用了这个库的话，你能够获得的资料就更少了。<br />别无他法，只有按照它<code>doxygen</code>生成的文档结合它的单元测试一点点来啃了。<br />接下来我们的例子都来源于<a href="https://github.com/Gaojianli/Word-Clear/blob/master/Server/src/Server.cpp" target="_blank">Server.cpp</a></p><h3><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#创建循环"></a>创建循环</h3><p>在使用任何基于事件循环的功能之前，你得先有一个循环才行。得益于良好的封装，创建循环变得非常的简单，仅仅需要短短的一行：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>auto</span> loop = uvw::Loop::getDefault();<span>//创建循环</span></span><br /><span>listen(*loop);<span>//绑定监听事件</span></span><br /><span>loop-&gt;run();<span>//运行循环</span></span><br /></pre></td></tr></table><h3><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#监听事件绑定"></a>监听事件绑定</h3><p>UVW将<code>libuv</code>中几乎所有的对象（结构体）都封装到了<code>loop</code>对象之中，取用只需要调用<code>loop::resource&lt;T&gt;()</code>即可。因为我们主要需要绑定的是针对<code>socket</code>的监听，所以首先我们要创建一个<code>TCPHandle</code>：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>std</span>::<span>shared_ptr</span>&lt;uvw::TCPHandle&gt; tcp = loop.resource&lt;uvw::TCPHandle&gt;();</span><br /></pre></td></tr></table><p>由于是整个过程是异步的，我们无法在适当的时候释放这个handle，因此必须使用智能指针shared_ptr进行托管。</p><p>创建好了Handle，就可以开始绑定事件了！但是在开始之前，要先提一个问题：还记得在Node.js里面是怎么绑定事件的吗?</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>event.on(<span>'someEvent'</span>, data =&gt;{</span><br /><span>    <span>//do some thing</span></span><br /><span>});</span><br /></pre></td></tr></table><p>上述代码中<code>someEvent</code>是事件的名字，而第二个参数则是事件触发时将要执行的回调函数。有了这份基础，我们来理解<code>uvw</code>中的事件监听就非常容易了。<br />在UVW中，事件绑定主要有两种方法:<code>on</code>和<code>once</code>。前者就是普通的监听，后者除了只能触发一次之外，和前者并没有太大区别。<br /><code>on</code>方法的原型长这样:</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>Connection&lt;E&gt; uvw::Emitter&lt; T &gt;::on (Listener&lt;E&gt; f)</span><br /></pre></td></tr></table><p>如果看不懂上面那一堆模板的话，可以直接看这个例子:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>tcp-&gt;on&lt;uvw::ErrorEvent&gt;([](<span>const</span> uvw::ErrorEvent &amp; event, uvw::TCPHandle&amp;) {</span><br /><span><span>cout</span> &lt;&lt; <span>"Error occurred:"</span> &lt;&lt; event.what() &lt;&lt; <span>endl</span>;</span><br /><span>});</span><br /></pre></td></tr></table><p>在这个例子中，监听的事件是<code>uvw::ErrorEvent</code>，而后面那个lambda表达式就是所谓回调函数。这句话的功能就是在发生错误的时候打印出错误来。怎么样，和上面的Node.js是不是非常相似？顺带一提，这句话在Javascript中会这么写: <del>JS是万物之母!</del></p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>tcp.on(<span>"error"</span>,<span>console</span>.log);</span><br /></pre></td></tr></table><h3><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#连接事件绑定"></a>连接事件绑定</h3><p>那么，现在我们已经知道了如何绑定事件，那么就疯狂来绑定吧：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /></pre></td><td><pre><span>tcp-&gt;on&lt;uvw::ListenEvent&gt;([](<span>const</span> uvw::ListenEvent&amp;, uvw::TCPHandle &amp; srv) {<span>//监听事件，当客户端连接时会触发</span></span><br /><span><span>std</span>::<span>shared_ptr</span>&lt;uvw::TCPHandle&gt; client = srv.loop().resource&lt;uvw::TCPHandle&gt;();<span>//获取一个客户端的Handle</span></span><br /><span>srv.accept(*client);</span><br /><span>#ifdef DEBUG <span>//调试模式下显示客户端连接信息和断开信息</span></span><br /><span>uvw::Addr remote = client-&gt;peer();</span><br /><span><span>std</span>::<span>cout</span> &lt;&lt; <span>std</span>::<span>endl</span></span><br /><span>&lt;&lt; remote.ip &lt;&lt; <span>":"</span> &lt;&lt; remote.port &lt;&lt; <span>" Connected"</span> &lt;&lt; <span>std</span>::<span>endl</span>;</span><br /><span>client-&gt;on&lt;uvw::CloseEvent&gt;([remote](<span>const</span> uvw::CloseEvent&amp;, uvw::TCPHandle&amp;) {<span>//连接关闭时触发的事件</span></span><br /><span><span>std</span>::<span>cout</span> &lt;&lt; <span>"Connection from "</span> &lt;&lt; remote.ip &lt;&lt; <span>" closed."</span> &lt;&lt; <span>std</span>::<span>endl</span></span><br /><span>&lt;&lt; <span>std</span>::<span>endl</span>;</span><br /><span>});</span><br /><span>#endif <span>// DEBUG</span></span><br /><span>client-&gt;on&lt;uvw::EndEvent&gt;([](<span>const</span> uvw::EndEvent&amp;, uvw::TCPHandle &amp; client) {</span><br /><span>client.close();<span>//连接结束关闭连接</span></span><br /><span>});</span><br /><span>client-&gt;on&lt;uvw::ErrorEvent&gt;([](<span>const</span> uvw::ErrorEvent &amp; event, uvw::TCPHandle &amp; client) {</span><br /><span><span>cout</span> &lt;&lt; <span>"Error occurred:"</span> &lt;&lt; event.what() &lt;&lt; <span>endl</span>;<span>//错误监听</span></span><br /><span>client.close();</span><br /><span>});</span><br /><span>client-&gt;on&lt;uvw::DataEvent&gt;([](<span>const</span> uvw::DataEvent &amp; event, uvw::TCPHandle &amp; client) {<span>//接收到数据</span></span><br /><span><span>if</span> (event.length == <span>0</span>)</span><br /><span><span>return</span>;</span><br /><span><span>auto</span> temp = <span>new</span> <span>char</span>[event.length + <span>1</span>];</span><br /><span>memcpy_s(temp, event.length, event.data.get(), event.length);</span><br /><span>temp[event.length] = <span>'\0'</span>;<span>//向数据流尾部追加\0使之被截断为字符串</span></span><br /><span><span>auto</span> response = handler::mainHandler(temp, client);<span>//移交请求给业务代码</span></span><br /><span><span>auto</span> toWrite = <span>new</span> <span>char</span>[response.size()];</span><br /><span>memcpy_s(toWrite, response.size(), response.c_str(), response.size());</span><br /><span>client.tryWrite(toWrite, (<span>unsigned</span>)response.size());<span>//copy后写回Client</span></span><br /><span><span>delete</span>[] toWrite;</span><br /><span><span>delete</span>[] temp;</span><br /><span>});</span><br /><span>client-&gt;read();</span><br /><span>});</span><br /></pre></td></tr></table><p>上述的<code>DataEvent</code>也和Node.js中的</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>readerStream.on(<span>'data'</span>, chunk =&gt; {</span><br /><span>   data += chunk;</span><br /><span>});</span><br /></pre></td></tr></table><p>非常相似，毕竟socket本质上也是文件描述符。总而言之，通过UVW我们便可将不熟悉的C++开发变成我们熟悉的Node后端开发，所谓“知己知彼百战不殆”，若不知彼将其化为知的“彼”即可。</p><h3><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#绑定端口"></a>绑定端口</h3><p>当然，前面我们只是绑定好了相应的事件，还差最后一点微小的工作：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>tcp-&gt;bind&lt;uvw::IPv6&gt;(<span>"[::]"</span>, port);<span>//监听0.0.0.0:port和[::]:port</span></span><br /><span>tcp-&gt;listen();</span><br /></pre></td></tr></table><p>值得注意的是：不同于Nginx，在libuv中监听IPv6端口即可同时完成对IPv4和IPv6的双栈监听，若要IPv6 Only还需要显式加入<code>TCPHandle::Bind::IPV6ONLY</code>的Flag。</p><h1><a href="https://blog.gaojianli.me/2019/05/11/Libuv%E5%88%9D%E6%8E%A2/#结语"></a>结语</h1><p>本文所有代码可以在这里下载：<a href="https://github.com/Gaojianli/Word-Clear" target="_blank">https://github.com/Gaojianli/Word-Clear</a><br />事实证明，纵使是<code>libuv</code>这种库也并不是什么洪水猛兽。令和元年，站在巨人的肩膀上的我们面前，面前并不存在什么完全无法跨越的高峰，<strong>需要的仅仅是个契机</strong>。而所谓契机，在我看来仅仅是个打破自己惰性的借口罢了。<del>自己主动研究是不可能研究的，只有布置了作业才能去看看这样子</del><br />今日写在这里，引以为鉴。<br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            前言作为一个Node.js玩家，libuv的鼎鼎大名可谓是如雷贯耳。在我的印象中，libuv就是个“封装了ICOP/epoll等的超级牛逼的基于事件循环的库”，换句话说，就是“我知道你很牛逼，但是我啥都不知道”。在生活中，有很多事情不是不能做，只是需要一个契机。有了这个契机，我
            
        </summary>
        
        <category term="编程"/>
        
        <category term="C/C++"/>
        
    </entry>
    
    <entry>
        <title>用setTimeout和clearTimeout简单实现setInterval与clearInterval</title>
        <link href="https://molunerfinn.com/setTimeout-hack-setInterval/"/>
        <id>https://molunerfinn.com/setTimeout-hack-setInterval/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>这个问题其实是前一段时间舍友的一道面试题。我觉得类似用<code>reduce实现map</code>、用<code>xxx实现yyy</code>的题目其实都挺有意思，考察融会贯通的本领。不过相比之下这道题可能更有实际意义。比如我们经常会用 <code>setTimeout</code> 来实现倒计时。下面来说说我对这个问题的思考。</p><a></a><h2><a href="https://molunerfinn.com/setTimeout-hack-setInterval/#简单版本"></a>简单版本</h2><p>首先我们先用 <code>setTimeout</code> 实现一个简单版本的 <code>setInterval</code>。</p><p><code>setInterval</code> 需要不停循环调用，这让我们想到了递归调用自身：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>const</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb() <span>// 执行传入的回调函数</span></span><br /><span>    setTimeout(<span><span>()</span> =&gt;</span> {</span><br /><span>      fn() <span>// 递归调用自己</span></span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  setTimeout(fn, time)</span><br /><span>}</span><br /></pre></td></tr></table><p>让我们来写段代码测试一下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>mySetInterval(<span><span>()</span> =&gt;</span> {</span><br /><span>  <span>console</span>.log(<span>new</span> <span>Date</span>())</span><br /><span>}, <span>1000</span>)</span><br /></pre></td></tr></table><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/setTimeout-1.gif" /></p><p>嗯，没啥问题，实现了我们想要的功能。。。等一下，怎么停下来？总不能执行了就不管了吧。。。</p><h2><a href="https://molunerfinn.com/setTimeout-hack-setInterval/#clearInterval的实现"></a>clearInterval的实现</h2><p>平时如果用到了 <code>setInterval</code> 的同学应该都知道 <code>clearInterval</code> 的存在（不然你怎么停下 <code>interval</code> 呢）。</p><p><code>clearInterval</code> 的用法是 <code>clearInterval(id)</code>。而这个 <code>id</code> 是 <code>setInterval</code>的返回值，通过这个 <code>id</code> 值就能够清除指定的定时器。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span><span>const</span> id = setInterval(<span><span>()</span> =&gt;</span> {</span><br /><span>  <span>// ...</span></span><br /><span>}, <span>1000</span>)</span><br /><span><span>// ...</span></span><br /><span>clearInterval(id)</span><br /></pre></td></tr></table><p>不过你有没有想到 <code>clearInterval</code> 是如何实现的？回答这个问题之前，我们需要先实现 <code>mySetInterval</code> 的返回值。</p><h3><a href="https://molunerfinn.com/setTimeout-hack-setInterval/#mySetInterval的返回值"></a>mySetInterval的返回值</h3><p>回到我们简单版本的 <code>mySetInterval</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>const</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb() <span>// 执行传入的回调函数</span></span><br /><span>    setTimeout(<span><span>()</span> =&gt;</span> {</span><br /><span>      fn() <span>// 递归调用自己</span></span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  setTimeout(fn, time)</span><br /><span>}</span><br /></pre></td></tr></table><p>现在它的返回值因为没有显示指定，所以是 <code>undefined</code>。因此第一步，我们先要返回一个 <code>id</code> 出去。</p><p>那么直接 <code>return setTimeout(fn, time)</code> 可以吗？因为我们知道 <code>setTimeout</code> 也会返回一个id，那么初步构想就是通过 <code>setTimeout</code> 返回的 <code>id</code>，然后调用 <code>clearTimeout(id)</code> 来实现我们的 <code>myClearInterval</code>。</p><p>如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /></pre></td><td><pre><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>const</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb() <span>// 执行传入的回调函数</span></span><br /><span>    setTimeout(<span><span>()</span> =&gt;</span> { <span>// 第二个、第三个...</span></span><br /><span>      fn() <span>// 递归调用自己</span></span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  <span>return</span> setTimeout(fn, time) <span>// 第一个setTimeout</span></span><br /><span>}</span><br /><span></span><br /><span><span>const</span> id = mySetInterval(<span><span>()</span> =&gt;</span> {</span><br /><span>  <span>console</span>.log(<span>new</span> <span>Date</span>())</span><br /><span>}, <span>1000</span>)</span><br /><span></span><br /><span>setTimeout(<span><span>()</span> =&gt;</span> { <span>// 2秒后清除定时器</span></span><br /><span>  clearTimeout(id)</span><br /><span>}, <span>2000</span>)</span><br /></pre></td></tr></table><p>这显然是不行的。因为 <code>mySetInterval</code> 返回的 <code>id</code> 是第一个 <code>setTimeout</code> 的 <code>id</code>，然而2秒后，要 <code>clearTimeout</code> 时，递归执行的第二个、第三个 <code>setTimeout</code> 等等的 <code>id</code> 已经不再是第一个 <code>id</code> 了。因此此时无法清除。</p><p>所以我们需要每次执行 <code>setTimeout</code>的时候把新的 <code>id</code> 存下来。怎么存？我们应该会想到用闭包：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>let</span> timeId</span><br /><span>  <span>const</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb() <span>// 执行传入的回调函数</span></span><br /><span>    timeId = setTimeout(<span><span>()</span> =&gt;</span> { <span>// 闭包更新timeId</span></span><br /><span>      fn() <span>// 递归调用自己</span></span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  timeId = setTimeout(fn, time) <span>// 第一个setTimeout</span></span><br /><span>  <span>return</span> timeId</span><br /><span>}</span><br /></pre></td></tr></table><p>很不错，到这步我们已经能够将 <code>timeId</code> 进行更新了。不过还有问题，那就是执行 <code>mySetInterval</code> 的时候返回的 <code>id</code> 依然不是最新的 <code>timeId</code>。因为 <code>timeId</code> 只在 <code>fn</code> 内部被更新了，在外部并不知道它的更新。那有什么办法让 <code>timeId</code> 的更新也让外部知道呢？</p><p>有的，答案就是用全局变量。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>let</span> timeId <span>// 全局变量</span></span><br /><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>const</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb() <span>// 执行传入的回调函数</span></span><br /><span>    timeId = setTimeout(<span><span>()</span> =&gt;</span> { <span>// 闭包更新timeId</span></span><br /><span>      fn() <span>// 递归调用自己</span></span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  timeId = setTimeout(fn, time) <span>// 第一个setTimeout</span></span><br /><span>  <span>return</span> timeId</span><br /><span>}</span><br /></pre></td></tr></table><p>但是这样有个问题，由于 <code>timeId</code> 是<code>Number</code>类型，当我们这样使用的时候：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>const</span> id = mySetInterval(<span><span>()</span> =&gt;</span> { <span>// 此处id是Number类型，是值的拷贝而不是引用</span></span><br /><span>  <span>console</span>.log(<span>new</span> <span>Date</span>())</span><br /><span>}, <span>1000</span>)</span><br /><span></span><br /><span>setTimeout(<span><span>()</span> =&gt;</span> { <span>// 2秒后清除定时器</span></span><br /><span>  clearTimeout(id)</span><br /><span>}, <span>2000</span>)</span><br /></pre></td></tr></table><p>由于 <code>id</code> 是 <code>Number</code> 类型，我们拿到的是全局变量 <code>timeId</code> 的值拷贝而不是引用，所以上面那段代码依然无效。不过我们已经可以通过全局变量 <code>timeId</code> 来清除计时器了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>setTimeout(<span><span>()</span> =&gt;</span> { <span>// 2秒后清除定时器</span></span><br /><span>  clearTimeout(timeId) <span>// 全局变量 timeId</span></span><br /><span>}, <span>2000</span>)</span><br /></pre></td></tr></table><p>但是上面的实现，不仅与我们平时使用的 <code>clearInterval</code> 的用法有所出入，并且由于 <code>timeId</code> 是一个 <code>Number</code> 类型的变量，导致同一时刻全局只能有一个 <code>mySetInterval</code> 的 <code>id</code> 存在，也即无法做到清除多个 <code>mySetInterval</code> 的计时器。</p><p>所以我们需要一种类型，既能支持多个 <code>timeId</code> 存在，又能实现 <code>mySetInterval</code> 返回的 <code>id</code> 能够被我们的 <code>myClearInterval</code> 使用。你应该能想到，我们要用一个全局的 <code>Object</code> 来做。</p><p>修改代码如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /></pre></td><td><pre><span><span>let</span> timeMap = {}</span><br /><span><span>let</span> id = <span>0</span> <span>// 简单实现id唯一</span></span><br /><span><span>const</span> mySetInterval = <span>(<span>cb, time</span>) =&gt;</span> {</span><br /><span>  <span>let</span> timeId = id <span>// 将timeId赋予id</span></span><br /><span>  id++ <span>// id 自增实现唯一id</span></span><br /><span>  <span>let</span> fn = <span><span>()</span> =&gt;</span> {</span><br /><span>    cb()</span><br /><span>    timeMap[timeId] = setTimeout(<span><span>()</span> =&gt;</span> {</span><br /><span>      fn()</span><br /><span>    }, time)</span><br /><span>  }</span><br /><span>  timeMap[timeId] = setTimeout(fn, time)</span><br /><span>  <span>return</span> timeId <span>// 返回timeId</span></span><br /><span>}</span><br /></pre></td></tr></table><p>我们的 <code>mySetInterval</code> 依然返回了一个 <code>id</code> 值。只不过这个 <code>id</code> 值是全局变量 <code>timeMap</code> 里的一个键的内容。</p><p>我们每次更新 <code>setTimeout</code> 的 <code>id</code> 并不是去更新 <code>timeId</code>，相应的，我们去更新 <code>timeMap[timeId]</code> 里的值。</p><p>这样实现后，我们调用 <code>mySetInterval</code> 虽然获取到的 <code>timeId</code> 是不变的，但是我们通过 <code>timeMap[timeId]</code> 获取到的真正的 <code>setTimeout</code> 的 <code>id</code> 值是会一直更新的。</p><p>另外为了保证 <code>timeId</code> 的唯一性，在这里我简单用了一个自增的全局变量 <code>id</code> 来保证唯一。</p><p>好了，<code>id</code> 值有了，剩下的就是 <code>myClearInterval</code> 的实现了。</p><h3><a href="https://molunerfinn.com/setTimeout-hack-setInterval/#myClearInterval实现"></a>myClearInterval实现</h3><p>由于我们的 <code>mySetInterval</code> 返回的 <code>timeId</code> 并不是真正的 <code>setTimeout</code> 返回的 <code>id</code> ，所以并不能简单地通过 <code>clearTimeout(timeId)</code> 来清除计时器。</p><p>不过其实原理也是很类似的，我们只要能拿到真正的 <code>id</code> 就行了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>const</span> myClearInterval = <span>(<span>id</span>) =&gt;</span> {</span><br /><span>  clearTimeout(timeMap[id]) <span>// 通过timeMap[id]获取真正的id</span></span><br /><span>  <span>delete</span> timeMap[id]</span><br /><span>}</span><br /></pre></td></tr></table><p>测试一下：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/setTimeout-2.gif" /></p><p>没毛病~</p><p>至此我们就用 <code>setTimeout</code> 和 <code>clearTimeout</code> 简单实现了 <code>setInterval</code> 与<code>clearInterval</code>。当然本文说的是简单实现，毕竟还有一些东西没有完成，比如<code>setTimeout</code> 的 <code>args</code> 参数、Node和浏览器端的 <code>setTimeout</code> 差异等等。也只是一个抛砖引玉，重点在一步步如何实现。感谢阅读~</p>]]></content>
        
        <summary type="html">
            
            这个问题其实是前一段时间舍友的一道面试题。我觉得类似用reduce实现map、用xxx实现yyy的题目其实都挺有意思，考察融会贯通的本领。不过相比之下这道题可能更有实际意义。比如我们经常会用 setTimeout 来实现倒计时。下面来说说我对这个问题的思考。简单版本首先我们先用
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="随笔"/>
        
        <category term="前端"/>
        
    </entry>
    
    <entry>
        <title>我的2019春招（暑期实习）记录</title>
        <link href="https://molunerfinn.com/my-2019-interview-of-summer-internship/"/>
        <id>https://molunerfinn.com/my-2019-interview-of-summer-internship/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>今年的春招（暑期实习）批已经过去大半了，相信不少同学已经拿到了心仪的offer了~本来打算暑假有空再写写这段经历，不过今天晚上正好有空就记录一下吧，希望能给正在或者今后要找前端实习、工作的同学一点点启发和建议。（由于我妹子在北京读书，所以实习的话我只想着申请北京的实习机会，这是本文的大前提）。</p><p>我自己是北邮研二的学生，「主修」前端。我自己的面试经历不多，从1月份到现在总共只面了3家：头条，腾讯·微信和蚂蚁金服·支付宝，很幸运都拿到了offer。其实我觉得主要还是内推对我的帮助特别大，没有内推的话我估计也很难拿offer了。所以经验第一条：<strong>能找内推尽量通过内推来获取面试资格</strong>。帮你内推的学长学姐一般会帮你查看（甚至修改）简历，有的可以直接部门直推给leader，等于省去了HR筛简历的步骤，所以能找到内推就尽量走内推而不是单纯走网申吧。</p><a></a><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#头条"></a>头条</h2><p>1月份的时候有个头条的学长通过邮件联系到我，对我的做的<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>很感兴趣。跟我要了非常简陋的简历，就把我内推了。</p><p>不过后来面试邮件发来后我才知道给我的推的职位是<code>iOS研发工程师</code>。他们组是移动端的组，要招前端，但是可能没有前端名额，就用<code>iOS</code>的职位给我内推了。然后我也就稀里糊涂的去面试了。说实话毕竟是第一次面试，并且当时周边的同学也都没有开始找实习，在仅有的几天时间里我准备的特别不充分。</p><p>头条总共面了我三面，都是视频面。其中一面二面是连着的（一面一结束，马上二面面试官来面我）。由于这个组的性质比较特殊，来面我的面试官都不是写前端的，因此问的网络、计算机相关的问题会更多点。我事后（3月份面完微信和蚂蚁之后）才觉得当时1月份面头条的时候简直回答得一塌糊涂。</p><p>不过感觉自己做的很正确的一件事就是面试完马上把问题记下来了。从中也看出三家公司的侧重点不同。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#头条一面"></a>头条一面</h3><p>头条一面是个年轻的小哥，是做移动端的。先问了我的项目，因为都是前端的他也没太了解，就开始问问题了：</p><ul><li>UTF-8 UTF-16 和 Unicode 什么关系 【当时不会 | 编码规则和字符集】</li><li>TCP三次握手可以理解，为什么需要四次挥手 【四次挥手是2+2】</li><li>常见的HTTP状态码 【相信你们都会】</li><li>GET\POST请求区别 【常规问题】</li><li>HTTP报文分为几部分，分别说了啥，头部尤其重要 【当时说的不全 | 3个部分，以及请求和响应报文的区别】</li><li>HTTPS与TLS或者SSL有了解么，加密是对称加密还是非对称加密 【当时不是特别了解 | 二者都有】</li><li>JS内存管理机制 【标记-清除】</li><li>数组和链表区别和应用场景 【查找-操作】</li><li>动态数组如何实现，查找和插入哪个代价大【当时不会】</li><li>Electron的原理，简单描述 【Node.js+NativeApi+Chromium】</li><li>Vue的原理，简单描述 【Object.defineProperty + Dep + Watcher】</li><li>平时怎么学习新知识，从什么渠道 【博客、掘金、GitHub、StackOverflow等】</li><li>开发项目中遇到最困难、最有挑战的事 【PicGo的插件系统】</li><li>算法题1，求数组里最大和的子数组 【思路说了，没写出来】</li></ul><p>一面算法题虽然思路说对了，但是没写出来的时候我觉得自己已经凉了。结果居然面试官说「你等一下，我去叫二面面试官」。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#头条二面"></a>头条二面</h3><p>和一面就隔了3分钟。二面是交叉面，是另外一个部门的面试官来面的。这个面试官年龄一看就比一面面试官大。简单自我介绍之后，他就开始问我问题了：</p><ul><li>如果我是一个Leader，想要把APP里某个页面的首次开屏渲染时间降低，如何协调前端、服务端、客户端同学。【我说了缓存相关的，不过面试官说不够】</li><li>从输入一个URL到最终用户看到界面，经历那些步骤【常规题】</li><li>对HTTP/2有没有了解，以及QUIC协议【都了解过，稍微说了一下我的认知】</li><li>HTTP缓存，304状态码如何而来【常规题】</li><li>算法题2，单链表是否交叉，如何算重叠个数【说了一下思路，但是不是最优解】</li></ul><p>算法题2现在看来真的超级简单。当时我真的没刷过题，平时对算法训练也很少，所以说的思路能过但是不是最优解。面试官说「行吧」（当时觉得凉了哈哈）。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#头条三面"></a>头条三面</h3><p>三面和二面隔了大概几天吧。其实面完二面觉得还是很悬，结果还是收到HR的三面约时间电话。三面面试官是部门leader了。这个面试相对来说最轻松，基本没有问什么复杂的问题：</p><ul><li>谈项目 【简历上的，主要是PicGo】</li><li>Electron原理 【一面说过了】</li><li>markdown渲染原理 【正则匹配】</li><li>对前端框架的想法 【从开发效率到后期维护还有工程化角度说了自己的认知】</li><li>有什么想问的 【问了以后要做啥】</li></ul><p>由于卡着1月底快过年了，所以HR那边在年前给了我口头offer，年后回来就给我发了正式的offer。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/bytedance.png" /></p><p>作为人生中第一份offer，还是挺激动的。不过不是 <code>前端开发</code> 的职位让我心里一直有点不舒服。我想去的其实是专业的前端团队，以及之后入职后做的东西也不是自己特别喜欢的，所以我在想着年后回学校再找找有没有自己更喜欢的实习岗位。当然头条这个岗位也很棒了！</p><p>经验总结二：<strong>算法、数据结构和计算机、网络基础知识很重要，哪怕是前端研发工程师，也是一名工程师。</strong> 所以我寒假回去后就开始针对自己薄弱的算法和数据结构部分开始了恶补。</p><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#腾讯·微信"></a>腾讯·微信</h2><p>腾讯今年春招（暑期实习）开始的时间特别早，从2月底就开始能网申、内推了。尤其3月份一整个月是提前批，并且4月1号之前没走完流程的同学，都要必须参加4月份的笔试。所以理论上是越早内推越好，越到后面简历越多而且万一4月前流程没走完，就得参加笔试了。</p><p>本来我想着先面几家小一点的公司攒攒经验再去投腾讯和蚂蚁金服的，毕竟这两家门槛还是相当高的。原本打算投北京微信的前端岗，但是问了上一届的一个学长说北京的微信不招前端，于是我的重心就放在蚂蚁金服的北京实习了。不过有件事情的发生打破了我原本的规划。</p><p>我有个在微信工作的学长，听说了我的情况之后帮我从微信HR那边问到北京微信今年招前端的情况，但是HC很少。我一听，呀，好机会。赶紧修改了简历发给了学长。内推后没两天我就收到了北京微信的现场面试邀请，心里还是很忐忑的，毕竟那可是微信啊。而且也是我的第一次现场面试。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信一面"></a>微信一面</h3><p>到现场后，有个年龄跟我相仿的学长找到了我，说「我是你的一面面试官」。微信的现场面试没有我想象中那么拘谨（两个人一间小屋子那种），是在开阔的大厅里，有很多小圆桌，光线也很好。总之面试体验还是很好的。同时我还看到了很多其他来面试的人。</p><p>一面面试官说他也是北邮毕业的，一下子就感觉放松了不少。接下去就基本是他拿着我的简历开始问问题了。</p><ol><li>问实习做了啥 【研究生导师的公司】</li><li>PicGo做了啥 【简述了一下诞生的过程和它的作用】</li><li>Electron是啥，为什么选择用Electron 【用的人多】</li><li>MVVM与Vue的理解 【数据驱动】</li><li>vue的双向绑定的原理 【Object.defineProperty + Dep + Watcher】</li><li>vue的生命周期以及做了啥，用来干嘛的 【beforeCreate、created、mounted等】</li><li>讲讲Virtual Dom 【稍微说了一下理解】</li><li>写过render函数么，跟template有啥区别 【写过，说了一下区别】</li><li>vue的服务端渲染和客户端渲染区别是啥，服务端渲染作用是啥 【SEO友好，首屏渲染速度等】</li><li>讲讲this指针和箭头函数 【常规题】</li><li>const和let与var的区别 【常规题】</li><li>说说webpack、rollup的tree shanking 【说了tree shanking是啥以及如何实现的】</li><li>webpack的loader和plugin区别是啥 【loader处理某一类文件而plugin可以做「任何」事】</li><li>promise的finally如何实现 【说了一下我的想法，但是后来想想有点不对】</li><li>浏览器和Node端的事件循环的区别 【说了一下我的印象，与setTimeout有关】</li></ol><p>一面的问题基本都答上来了，面试官也觉得很满意，就让我等会，叫来了二面面试官，跟我说是专门搞算法的。（心里一凉）</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信二面"></a>微信二面</h3><p>面试官跟我说他是北师毕业的，跟我的学校（北邮）很近（哈哈）。然后说，「我们来到简单的算法题吧，不需要你写，只需要你说说思路」</p><ol><li>算法题：m*n的矩阵，只有0、1，找出最大的只包含1的矩形面积。【说了最蠢的解法…面试官一直引导我也没想出怎么实现更优解】</li><li>PicGo做了啥，为啥star这么多 【讲了一下作用】</li></ol><p>算法题又是没做出来（虽然说了最蠢的解法）心里又是一凉，感觉gg。结果面试官说「小伙子思维还挺灵活」（有么！）然后让我等会，叫来了三面面试官。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信三面"></a>微信三面</h3><p>三面是个女leader，她对我说「前面的面试官对你的评价很高啊」。于是开始问我的个人经历和项目相关。最后问了我什么时候能来？我一听奇怪，我不是投的暑期实习么？然后她说最近有个项目急着要上线，所以缺人，就额外要了一个前端的HC。我说我实验室暑假前并不放人…所以需要再考虑一下。并且这个时候我听闻他们组实际是做AI的，而前端如果我去了也只有两个人。到这时我感觉有点不对劲，不过leader说之后还有一个广州的电面要我准备一下。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信四面"></a>微信四面</h3><p>没过两天就是4面，也是我第一次电话面试。四面就纯粹围绕着我做的项目PicGo开始说了。问的比较注重的部分是我对于PicGo的思考。从开发者和使用者和产品的角度去说明。比如如何维护、如何打磨产品，遇到的问题如何克服，与用户的意见不同时如何应对等等。我感觉更考量我对PicGo的认知和未来的规划，到底是一个用心做的产品还仅仅只是一个star收集者。</p><p>四面面完，没两天三面的leader就打电话过来问我啥时候能去实习。然而在四面面完的这几天里，我就决定了不去了。首先实验室6月底前放不了人；第二个跟我预期的有所出入，我以为是微信的前端团队招实习生（但不是），因为我其实想在前端这块能继续做深入一些，所以就还是把这个offer给拒了。当时想法是如果北京微信这边没有喜欢的岗位，那也没事，好好准备一下蚂蚁金服的面试就好。</p><p>回宿舍我跟舍友一说我把微信的offer拒了，他们只丢过来一句「暴殄天物」。舍得舍得，有舍才有得，后面会再说。</p><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#蚂蚁金服·支付宝"></a>蚂蚁金服·支付宝</h2><p>在面微信的面试阶段前，有个支付宝的北邮师兄通过微信联系上我。他说关注我的<a href="https://github.com/Molunerfinn" target="_blank">GitHub</a>好久了，想给我内推到支付宝的前端团队那边。我自然是开心地答应了。不过我当时想着先完善简历+先把微信面完。不然一下子准备两个大厂的面试，压力大不说，万一时间撞上了反而更尴尬。在拒了微信后我把简历发给了师兄，开始了支付宝那边的内推。</p><p>支付宝这边技术面总共三面+HR一面。全程电话面试。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#支付宝一面"></a>支付宝一面</h3><p>内推没多久，一面面试官就通过微信联系我，跟我约好了面试时间（第二天晚上7点半）并说「我这一面很轻松的」。在面试之前我有听说蚂蚁金服的面试是比较难的，虽然师兄说很简单但也是做好了被挂的准备。</p><p>7点半准时电话响起。面试官说他也是北邮毕业的，让我稍稍有所放松。然后接下来的问题就让我冷汗直冒。</p><ol><li>介绍一下做的项目 【实验室项目+个人项目】</li><li>前端工程化的理解 【流程+规范+自动化等】</li><li>对Webpack做了哪些配置来提速 【很多，具体可以参考我<a href="https://molunerfinn.com/Webpack-Optimize/">这篇文章</a>】</li><li>一段代码输入babel，把结果再输入babel，结果一样么 【我说应该不一样，但是没说出为什么】</li><li>配置过babel哪些属性 【presets，plugins，env等】</li><li>PicGo的插件如何发布、安装，如何确保插件安全性 【通过npm发布，安全性没有考虑很完全，然后跟面试官聊了安全方面的考量】</li><li>Electron如何实现跨进程通信。还有哪些其他跨进程通信的例子 【ipcMain和ipcRenderer，跨进程通信的比如socket等，我了解的不多】</li><li>Electron打包体积、编译速度相关如何考量，怎么优化或者怎么做的 【我是通过CI打包，没通过自己的机器。所以没有特别考虑这方面的。不过不需要用babel转译能节省一些时间】</li><li>为什么选TypeScript来开发，说说对TS的理解 【静态类型、语法检查等】</li><li>TypeScript的interface编译后会占用空间么，enum呢？（运行时和开发时不一样）【前者答出来了，后者不确定】</li><li>说说什么是服务端渲染以及Vue的服务端渲染如何实现 【直出HTML，通过render函数将VirtualDom渲染模板】</li><li>如果Vue2没有实现VirtualDOM，可以做到服务端渲染吗 【可以】</li><li>Vue的diff算法如何实现 【说了一下之前自己看过的实现】</li><li>【算法题】求两个序列里的最长公共子序列 【稀里糊涂说了一通，好像没错，后来想想其实不对】</li><li>简单说说Vue的响应式原理 【Object.defineProperty + Dep + Watcher】</li><li>你有什么要问我的吗 【主要做什么？答：蚂蚁森林，蚂蚁庄园等】</li></ol><p>一面的难度应该是面的这三个大厂以来最难的。面试过程中我还是比较紧张的，不过一开始确实紧张，后面说开了就好多了。面试官面完之后说等二面联系我吧。二面面试官是他们部门的leader。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#支付宝二面"></a>支付宝二面</h3><p>一面面完的第二天面试官就加我了，直接约了当天晚上7点半的电面。（等于昨天一面今天二面…）事前我从内推我的师兄那里了解到二面面试官是很厉害的一个人，所以难度应该会比一面面试官高。听到这个消息不觉咽了一下口水，难受。</p><p>7点半准时电话响起。二面面试官的声音和语气给我的感觉是一开始比较低沉的，感觉比较严肃。然后后面的问题果然「没让我失望」地难。</p><ol><li>学前端的经历？ 【15年开始自学，简单说了一下】</li><li>对计算机的体系结构的认知 【懵了，不知道说啥】</li><li>有没有经历过jQuery时代 【有】</li><li>Webpack优化是怎么做的 【跟一面说的差不多】</li><li>上述的优化是基于什么方向去做的 【从cache、减少文件搜索路径、多进程优化等做的】</li><li>上述的优化有没有量化出问题（比如看看每块耗时多久等等）再针对性地做优化 【用了profile查看了开发阶段的编译耗时，做了一个简单的<a href="https://github.com/Molunerfinn/webpack-dev-compile-optimize" target="_blank">插件</a>做了开发阶段的速度提升，但是原理我也没说地太清楚】</li><li>vue-hot-reload原理是啥 【我只打上来websocket+jsonp做的更新，但是实际上更复杂】</li><li>在vue项目里如果我更新了一个js脚本但是页面不更新，我要怎么让vue-hot-reload去更新 【真不会】</li><li>在vue项目里如果我更新了一个js，但是不想让页面重新刷新，而只是更新我js的执行部分，我要怎么让vue-hot-reload去更新【真不会】</li><li>vue的template是如何转换成render functions的 【说了一下正则匹配，AST，但是不知道是如何有机串起来的】</li><li>接上一问，光是正则匹配是无法解决所有问题的，还需要啥，然后怎么做，要哪些阶段？（AST）【说了大概，但是不知道是如何有机串起来的】</li><li>AST相关知识掌握程度是多少，去哪里了解的 【不多，相关博客，跑了一些DEMO】</li><li>写Electron的时候遇到了哪些问题（解决的或者没解决的都说说）【系统级别的右键菜单实现、插件系统等】</li><li>base64怎么编码的 【常规题】</li><li>从输入一个地址到浏览器展现网页的过程 【常规题】</li><li>DNS查询用TCP来做可以么 【可以，但是慢】</li><li>HTTPS握手加密过程 【常规题，这次会了，面头条的时候还不全会】</li><li>setTimeout和Promise的异步的区别，在浏览器和Node下的区别 【事件循环的区别，我说了具体的例子】</li><li>如何用Jest做的Koa和Vue的测试 【对Koa做了api的测试，对Vue做了界面的单元测试】</li><li>CSS和JS哪个更熟悉？【JS】</li><li>接上问，CSS的transform有哪些属性 【rotate，translate等】</li><li>接上问如何实现一个div既平移又变色？transform的矩阵有了解过么 【没答出transform可以带多个属性，知道矩阵，没写过】</li><li>Vue的响应式原理，以及如果一个变量不在页面上出现过（或者使用过），响应式系统是怎么应对的 【render Watcher没有get到这个变量就不会收集它的依赖】</li><li>父子组件如何分开收集依赖，或者说父子组件如何确保父组件只收集自己的依赖，子组件只收集自己的依赖 【父子组件有自己的生命周期】</li><li>在Watcher内再new一个Watcher后，如何保证依赖收集不会出错 【同一时刻只有一个Watcher在工作】</li><li>问一下算法和数据结构掌握程度 → 说一下快排吧 【说了一下快排原理】</li><li>你上面跟前端无关的知识都是从哪里获取的 【实验室项目、同学、自己捣鼓、博客等】</li><li>你有什么要问我的吗 【这个组杭州和北京的部门做的东西一样么，做什么】</li></ol><p>面完感觉很凉，问题的深度是真的深。之前的面试很少有完全答不上来的，而这次二面对 <code>vue-hot-reload</code> 的问题就基本没有答上来。面试官最后给我的反馈大概还是不错的，所以我就在忐忑中等待三面的通知。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#支付宝三面"></a>支付宝三面</h3><p>过了几天，三面面试官通过电话跟我约了时间，听声音还是很和善的。不过，问题还是依然很有难度啊！问题不多，总共问了三个问题，但是第一问就让我很难受：</p><ol><li>【算法+前端】给定一定数目的粒子，每个粒子有4个属性【位置坐标，半径，速度，加速度】。求问在如下数量下，用什么方式绘制这些运动粒子，用什么数据结构来存储。<ol><li>20个 【DOM，Canvas】</li><li>500个 【DOM，Canvas】</li><li>20000个 → 200w个 【Canvas，但是不够，因为没有必要把200w个点都渲染出来，只需要渲染可视区的。所以问题的关键是如何找到只在可视区出现的圆，这是一道数据结构+算法题。】</li></ol></li><li>接上一题，如果是500个用DOM来绘制的粒子，请问使用Vue或者React的VirtualDom技术来实现，对比用原生操作DOM（假设极致优化）来实现，哪种方案的性能更好。【我说了原生操作，并给出VirtualDom不适合这个例子的理由】</li><li>给定一个APP内的营销页面，用户可能在离线状态下打开APP。如果营销页面的图片已经过期了，应该要被撤下，否则会引起歧义。请问用什么办法能够撤下。如果不能用JS，如果用户修改了客户端时间呢？【问题难度一步步加深，先问常规离线模式实现，然后开始不让用JS，并且客户端时间不准确怎么做。没答全。】</li></ol><p>这个面试总共只有45分钟不到，面试官说不能太长否则影响我的评价。我就说我第一题答得不够好。面试官说「不是不够好兄弟，是很不好！你第二题答得很不错，第三题有所偏差，但是你第一题答地太差了」</p><p>哈哈，当时听完觉得应该是凉了吧~然后面试官最后说了一句，「等之后HR会联系你」。噫，所以还是有戏？</p><p>经验总结三：<strong>只知其然不知其所以然是不行的，要对原理了解更深才能更好地解决问题。</strong></p><p>不过人生总是有所波澜。</p><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信·小程序"></a>微信·小程序</h2><p>在我面支付宝结束前后，微信那边的HR小姐姐联系到我问我为什么把北京的岗位拒了。我说了之前我考虑的理由（主要是团队不符合预期啊啥的）。本来以为跟微信的缘分就这样了。然后HR小姐姐不死心，帮我联系了广州微信小程序的前端部门，问我去不去那边实习。我跟妹子商量了一下，暑期实习去广州两个月也能接受。于是就答应了。不过小程序那边还需要加面<br />。小程序这个部门做的是小程序开发者工具的，我觉得很合我的胃口，正好我也比较喜欢写工具类。</p><p>一波三折，在等待支付宝HR给我电话的这段时间里，我在两天内就拿到了微信小程序的offer。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信·小程序一面"></a>微信·小程序一面</h3><p>三月最后一周的周一下午，我记得很清楚。3点开始一面。面试官给了我一个链接，让我一小时内做完题然后他再跟我电话聊。</p><p>一个小时总共两道题，这两个笔试题做完，面试官电话就过来了，简单问了一些问题：</p><ol><li>对着笔试题的一些提问，比如第一题的this指针问题，第二题的思路问题 【一遍过】</li><li>HTTPS建立连接过程 【常规题】</li><li>前端缓存的认知 【常规题，缓存的类型，不同缓存的作用等等】</li><li>前端安全的认知 【XSS，CSRF等】</li><li>有什么想问的吗 【为啥小程序开发者工具用NW.js而不是Electron】</li></ol><p>面试官问了大概半小时，就说之后二面的leader会联系我。由于笔试题都做出来，所以感觉还是比较良好的。只是不知道二面来得这么快。</p><h3><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#微信·小程序二面"></a>微信·小程序二面</h3><p>二面面试官隔了大概半小时就打电话来了，主要就看着我的<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>这个项目在问，可能是因为技术栈（Electron）和小程序开发者工具（NW.js）比较接近吧。</p><ol><li>为什么选择Electron而不是用网页实现PicGo 【因为需要做配置、插件化、需要用到Node.js的API等】</li><li>介绍一下PicGo</li><li>PicGo如何做的更新策略，如何实现静默更新，如何实现代码级别热更新，如何在读写文件权限不够的情况下热更新 【更新策略其实很简单，后面面试官问的更新策略是我未实现的，但是跟他一起谈了一下思路】</li><li>写PicGo遇到的最大的问题 【插件系统】</li><li>插件系统如何实现 【读配置、加载、生命周期函数等等】</li><li>写PicGo遇到过安全相关的问题么，如何处理 【插件的安全相关】</li><li>写PicGo遇到过性能相关的问题么 【有，相册页图片多会卡顿，说了如何处理等】</li><li>有什么想问的吗 【没啥了】</li></ol><p>面试官的语气非常和善，跟我探讨的时候也是基本以商量的语气。末了还夸了一下这个项目做得还是挺完整的。（其实还有一个很重要的「测试」部分没写。。。）考察的重点问题已经不是功能问题，而且类似安全、更新策略等这些平时可能写东西的时候不会太注意的问题。所以如果只是一个玩具项目，可能确实谈不上来。还好之前很多坑自己踩过，所以跟面试官聊起来也比较愉快。</p><p>经验总结四：<strong>一个好的（开源）项目非常加分。好的意思不是star多，而是你对它的思考、实践多。</strong><br />经验总结五：<strong>如果你有一个做得很好的项目，一定要让面试官看到，并引导他问你的项目来把你熟悉的东西说出来。</strong></p><p>第二天收到HR电话联系说已经通过面试了，第三天就发了Offer。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/wechat-offer.png" /></p><p>由于小程序这个组做的东西是开发者工具，很合我的胃口，于是我就接了这个Offer，而此时我还没接到支付宝的HR电话。微信的这个「抢人」速度是真的快。</p><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#最后"></a>最后</h2><p>支付宝HR电话在后面好久才打来。此时我已经接了小程序的offer了，于是暑期就没办法去支付宝实习了。我说了一下我暑假可能没法去实习，但是秋招还要回北京秋招。所以问能否保留秋招终面资格（跟去年一样）。支付宝的HR给我的反馈就是不一定，不好说。我想想反正如果不保留资格，到时候回北京再面就是了。</p><p>于是前两天终于发来的offer，也只能拒掉了。同时我也只能跟头条的HR说了一下情况，真的很不好意思，秋招还有机会。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/alipay-offer-1.png" /></p><p>我的春招（暑期实习）之旅也就这样结束。其实我大可接受支付宝的offer实习然后直接转正，不过我想着既然有一个更喜欢的机会去尝试一下又何尝不可呢。其实从第一次拒绝微信的offer到后面又接了小程序的offer，我觉得都是因为我想做自己喜欢做的事吧。</p><p>最后经验总结六：<strong>Do what you love, love what you do.</strong></p><p>希望这份经历也能给你带来帮助。</p><h2><a href="https://molunerfinn.com/my-2019-interview-of-summer-internship/#附录"></a>附录</h2><p>我的<a href="https://github.com/Molunerfinn" target="_blank">GitHub</a>，我的<a href="https://molunerfinn.com/">博客</a></p><p>我自己的主要开源项目</p><ul><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> 4328star</li><li><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank">hexo-theme-melody</a> 634star</li><li><a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank">vue-koa-demo</a> 587star</li><li><a href="https://github.com/Molunerfinn/node-github-profile-summary" target="_blank">node-github-profile-summary</a> 243star</li></ul><p>以及<a href="https://github.com/PicGo" target="_blank">PicGo-Group</a>的项目。</p><p>我参与的开源项目</p><ul><li><a href="https://github.com/vuejs/vue-cli" target="_blank">vue-cli</a> 【哈哈只是改了一下文档】</li><li><a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank">amVim-for-VSCode</a> 【加了一些<code>:</code>命令支持】</li><li><a href="https://github.com/PicGo/vs-picgo" target="_blank">vs-picgo</a> 【PicGo的VSCode版】</li></ul><p>等等。</p>]]></content>
        
        <summary type="html">
            
            今年的春招（暑期实习）批已经过去大半了，相信不少同学已经拿到了心仪的offer了~本来打算暑假有空再写写这段经历，不过今天晚上正好有空就记录一下吧，希望能给正在或者今后要找前端实习、工作的同学一点点启发和建议。（由于我妹子在北京读书，所以实习的话我只想着申请北京的实习机会，这是
            
        </summary>
        
        <category term="日志"/>
        
        <category term="随笔"/>
        
        <category term="笔记"/>
        
    </entry>
    
    <entry>
        <title>Electron-vue开发实战7——命令行调用与系统级别右键菜单的实现</title>
        <link href="https://molunerfinn.com/electron-vue-8/"/>
        <id>https://molunerfinn.com/electron-vue-8/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/electron-vue-8/#前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-8/">命令行调用与系统级别右键菜单的实现</a></li><li>想到再写…</li></ol><h2><a href="https://molunerfinn.com/electron-vue-8/#说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(<code>Electron</code>的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。本文主要是基于PicGo v2.1.0版本更新的重要内容做的讲述。</p><a></a><h2><a href="https://molunerfinn.com/electron-vue-8/#命令行调用"></a>命令行调用</h2><p>我们在使用一些<code>Electron</code>开发的应用程序的时候，可以发现有些程序是可以通过命令行唤起的。比如<code>VSCode</code>，在macOS的<code>.bash_profile</code>里可以设置<code>alias code='/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code'</code>，这样就可以在命令行里通过<code>code xxx.js</code>来调用VSCode打开文件了。如果想打开当前目录，可以通过<code>code .</code>，如果想打开某个目录<code>code xxx</code>等等。</p><p>命令行调用里其实还涉及到一个问题，有的时候我们的应用是个「单例应用」，也就是不能「多开」。如何在只能单开的应用里，也实现命令行调用呢？比如<code>PicGo</code>，在软件打开的时候，命令行调用它也能上传图片，而不是打开一个新的<code>PicGo</code>窗口。没事，下面会详细说明。</p><h3><a href="https://molunerfinn.com/electron-vue-8/#实现命令行调用"></a>实现命令行调用</h3><p>首先我们要来实现命令行调用。其实<code>Electron</code>的命令行调用没有什么特殊的地方，与在<code>Node.js</code>端很类似。我以<code>PicGo</code>举例：</p><p>当我们在Windows下安装好了<code>PicGo</code>之后，可以在安装目录里找到<code>PicGo.exe</code>。你有没有想过在命令行里运行这个<code>exe</code>会怎么样呢？在安装目录里打开<code>powershell</code>，输入<code>.\PicGo.exe</code>，你会发现<code>PicGo</code>已经被打开了。如果我是加了一些参数打开会怎么样呢<code>.\PicGo.exe upload</code></p><p>我们可以在<code>main</code>进程里的<code>ready</code>事件里把命令行参数打印出来：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>app.on(<span>'ready'</span>, () =&gt; {</span><br /><span>  <span>console</span>.log(process.argv) <span>// ['D:\\PicGo.exe', 'upload']</span></span><br /><span>})</span><br /></pre></td></tr></table><p>关键出现了，我们可以通过<code>process.argv</code>这个在<code>Node.js</code>端获取命令行参数的关键变量同样获得<code>Electron</code>被命令行打开后的命令行参数。那么我们就可以在<code>main</code>进程的<code>ready</code>阶段通过获取的<code>process.argv</code>参数来实现我们对应的功能。</p><p>对于PicGo而言，如果通过命令行打开它，并且传递了<code>upload xxx.jpg</code>的话，我们就可以认为用户需要调用PicGo来实现上传一张图片。那么我们可以这么做（以下是实例代码）：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /></pre></td><td><pre><span><span>import</span> path <span>from</span> <span>'path'</span></span><br /><span><span>import</span> fs <span>from</span> <span>'fs-extra'</span></span><br /><span><span>const</span> getUploadFiles = <span>(<span>argv = process.argv, cwd = process.cwd(</span>)) =&gt;</span> {</span><br /><span>   files = argv.slice(<span>2</span>) <span>// 过滤['D:\\PicGo.exe', 'upload']这两个参数，直接获取需要上传的图片路径</span></span><br /><span>   <span>let</span> result = []</span><br /><span>   <span>if</span> (files.length &gt; <span>0</span>) { <span>// 如果图片列表不为空</span></span><br /><span>     result = files.map(<span><span>item</span> =&gt;</span> {</span><br /><span>       <span>if</span> (path.isAbsolute(item)) { <span>// 如果是绝对路径</span></span><br /><span>         <span>return</span> {</span><br /><span>           path: item</span><br /><span>         }</span><br /><span>       } <span>else</span> {</span><br /><span>         <span>let</span> tempPath = path.join(cwd, item) <span>// 如果是相对路径，就拼接</span></span><br /><span>         <span>if</span> (fs.existsSync(tempPath)) { <span>// 判断文件是否存在</span></span><br /><span>           <span>return</span> {</span><br /><span>             path: tempPath</span><br /><span>           }</span><br /><span>         } <span>else</span> {</span><br /><span>           <span>return</span> <span>null</span></span><br /><span>         }</span><br /><span>       }</span><br /><span>     }).filter(<span><span>item</span> =&gt;</span> item !== <span>null</span>) <span>// 排除为null的路径</span></span><br /><span>   }</span><br /><span>   <span>return</span> result <span>// 返回结果</span></span><br /><span>}</span><br /></pre></td></tr></table><p>拿到图片列表后就执行自带的上传逻辑即可。下面说说单开应用的命令行调用注意事项。</p><h3><a href="https://molunerfinn.com/electron-vue-8/#实现单例应用的命令行调用"></a>实现单例应用的命令行调用</h3><p><code>Electron</code>的发展很快，本文讲述的<code>Electron</code>版本为当前最新的<code>v4.1.4</code>，所以关于实现单例应用的<code>api</code>也是跟随<a href="https://electronjs.org/docs/api/app" target="_blank">官方文档</a>走的，如果你的Electron版本不是<code>v4.x</code>，那么需要找对应版本的<code>Electron</code>文档。</p><p>当前版本下实现单例应用的官方例子是：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /></pre></td><td><pre><span><span>const</span> { app } = <span>require</span>(<span>'electron'</span>)</span><br /><span><span>let</span> myWindow = <span>null</span></span><br /><span></span><br /><span><span>const</span> gotTheLock = app.requestSingleInstanceLock() <span>// 拿到单例锁</span></span><br /><span></span><br /><span><span>if</span> (!gotTheLock) { <span>// 如果一个应用二次打开，那么getTheLock为false</span></span><br /><span>  app.quit() <span>// 立即退出二次打开的应用</span></span><br /><span>} <span>else</span> {</span><br /><span>  app.on(<span>'second-instance'</span>, (event, commandLine, workingDirectory) =&gt; { <span>// 一个应用尝试打开第二个实例时触发</span></span><br /><span>    <span>// Someone tried to run a second instance, we should focus our window.</span></span><br /><span>    <span>if</span> (myWindow) {</span><br /><span>      <span>if</span> (myWindow.isMinimized()) myWindow.restore()</span><br /><span>      myWindow.focus()</span><br /><span>    }</span><br /><span>  })</span><br /><span></span><br /><span>  <span>// Create myWindow, load the rest of the app, etc...</span></span><br /><span>  app.on(<span>'ready'</span>, () =&gt; {</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>注意有个<code>second-instance</code>事件。当我们试图在打开一个单例应用之后再打开这个应用的时候，就会触发这个事件。并且这个事件的回调函数里，有<code>commandLine</code>和<code>workingDeirectory</code>，实际上它们就是<code>process.argv</code>和对应的<code>cwd</code>（执行路径）。因此我们可以在这个事件里书写当应用试图被二次打开的时候应该做的事的逻辑。以下依然以PicGo举例：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span>app.on(<span>'second-instance'</span>, (event, commandLine, workingDirectory) =&gt; {</span><br /><span> <span>let</span> files = getUploadFiles(commandLine, workingDirectory)</span><br /><span> <span>if</span> (files === <span>null</span> || files.length &gt; <span>0</span>) { <span>// 如果有文件列表作为参数，说明是命令行启动</span></span><br /><span>   <span>if</span> (files === <span>null</span>) { <span>// 如果为null说明是让PicGo上传剪贴板的图片</span></span><br /><span>     uploadClipboardFiles()</span><br /><span>   } <span>else</span> { <span>// 否则说明是让PicGo上传具体的图片文件</span></span><br /><span>     <span>// ...</span></span><br /><span>     uploadChoosedFiles(win.webContents, files)</span><br /><span>   }</span><br /><span> } <span>else</span> { <span>// 如果files === [] 说明并不是命令行启动或者并没有带额外参数</span></span><br /><span>   <span>if</span> (settingWindow) { <span>// 说明用户是点击了PicGo图标启动，那么这个时候把原有的窗口调出来并focus即可</span></span><br /><span>     <span>if</span> (settingWindow.isMinimized()) {</span><br /><span>       settingWindow.restore()</span><br /><span>     }</span><br /><span>     settingWindow.focus()</span><br /><span>   }</span><br /><span> }</span><br /><span>})</span><br /></pre></td></tr></table><p>这里我们通过读取<code>commandLine</code>参数，来判断用户是用命令行来调用<code>PicGo</code>上传图片的，还是仅仅是通过<code>PicGo</code>的图标再次打开<code>PicGo</code>的。关键的逻辑就是判断<code>commandLine</code>里有没有关键的参数，从而得出是否是从命令行调用我们的应用的。如果用户仅仅是通过<code>PicGo</code>图标再次打开<code>PicGo</code>，那么我们应该把之前打开过的窗口复原并激活，告诉用户你之前已经打开过这个应用了。当然具体的业务逻辑不能一概而论，这里只是我对<code>PicGo</code>的一点理解，只需知道核心是监听<code>second-instance</code>事件即可。</p><p>以下是上述实现的截图，注意命令行输出都只在第一个终端进程里，说明我们实现了单例应用的命令行调用：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/commandline-picgo.gif" /></p><h4><a href="https://molunerfinn.com/electron-vue-8/#macOS的命令行调用"></a>macOS的命令行调用</h4><p>其实这个章节到上面基本结束。不过我想起我演示的是在Windows下做的，相对简单。而macOS下的命令行调用<code>Electron</code>应用会有个坑，所以还是要说一下为好。（由于我没有Linux机器，所以Linux部分就不说明了，有兴趣的朋友可以测试一下跟我反馈！）</p><p>大家都知道<code>macOS</code>的应用基本是放在<code>Application</code>下的，所以我们会很自然想到直接命令行调用它们：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>open /Applications/PicGo.app</span><br /></pre></td></tr></table><p>但是这样做并不能传递参数进去，因为执行命令的是<code>open</code>。</p><p>所以我们需要到更深层次的路径启动<code>PicGo</code>并传递参数进去：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>/Applications/PicGo.app/Contents/MacOS/PicGo upload xxx.jpg</span><br /></pre></td></tr></table><p>只有这样才能像Windows那样类似<code>PicGo.exe</code>来实现调用。</p><p>值得注意的是，<code>Electron</code>的macOS应用想要在生产阶段打开<code>debug</code>模式查看<code>console</code>的输出也是到上述应用的对应目录下：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>/Applications/PicGo.app/Contents/MacOS/PicGo --debug</span><br /></pre></td></tr></table><p>而<code>Widnows</code>相对简单，只需要：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>.\PicGo.exe --debug</span><br /></pre></td></tr></table><p>（Linux请自测）</p><h2><a href="https://molunerfinn.com/electron-vue-8/#系统级别右键菜单"></a>系统级别右键菜单</h2><p>在实现了命令行调用的功能之后，我就在考虑给PicGo加上原生的系统右键菜单。这样做的好处是用户可以直接在一张图片上右键-&gt;通过PicGo上传。例如：</p><p>Windows下：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/windows-context-menu.png" /></p><p>macOS下：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/macos-context-menu.png" /></p><p>接下来说说二者在实现上不同的地方。（Linux没有测试，欢迎有兴趣的小伙伴测试一下跟我说说~）</p><h3><a href="https://molunerfinn.com/electron-vue-8/#Windows"></a>Windows</h3><p>Windows的右键菜单的原理其实很简单，在注册表里写入值就行。篇幅原因不会对Windows注册表的知识做过多的展开。我们只关注往哪里写值，写哪些值才能实现我们要的效果。</p><p>首先我们可以看看VScode是如何实现右键菜单「Open with Code」的。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/vscode-context-menu.png" /></p><p>在系统里按快捷键<code>WIN+R</code>然后输入<code>regedit</code>打开注册表编辑器，我们来找到<code>VSCode</code>的右键菜单所在地：</p><p><code>HKEY_CLASSES_ROOT</code> → <code>*</code> → <code>shell</code> → <code>VSCode</code>:</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/vscode-reg.png" /></p><p>可以看到一个「默认」的属性下的数据为「Open w&amp;ith Code」，这个就是我们看到的菜单名。而一个叫「Icon」的属性下的数据为<code>VSCode</code>的<code>exe</code>安装路径。所以可以认为这个<code>Icon</code>可以获取<code>exe</code>的<code>Icon</code>并显示到菜单上。</p><p>不过这里还没有看到如何将文件路径作为参数传入<code>VScode</code>的。继续看：</p><p><code>HKEY_CLASSES_ROOT</code> → <code>*</code> → <code>shell</code> → <code>VSCode</code> → <code>command</code>:</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/vscode-reg-2.png" /></p><p>在<code>command</code>目录下我们看到了如下数据：</p><p><code>"C:\Users\PiEgg\AppData\Local\Programs\Microsoft VS Code\Code.exe" "%1"</code></p><p>可以看出这个<code>%1</code>就是作为参数传给<code>Code.exe</code>的。有了<code>VSCode</code>作为参考，给自己的<code>Electron</code>应用实现一个系统级别的右键菜单也不难了。有人可能会说我可以在应用启动阶段通过某些<code>npm</code>包（比如<a href="https://www.npmjs.com/package/windows-registry" target="_blank">windows-registry</a>）来实现对注册表的写入。</p><p>不过实际上，在<code>Windows</code>平台，如果你是用<code>electron-builder</code>打包的话有一个更简洁的解决方案，那就是编写<code>NSIS</code>脚本来实现，对此<code>electron-builder</code>官方给出的<a href="https://www.electron.build/configuration/nsis#custom-nsis-script" target="_blank">文档</a>可以一看。</p><p>本文不对<code>NSIS</code>脚本做过多的描述，你只需要知道它是用来生成<code>Windows</code>安装界面的一门脚本语言，你可以通过它来控制安装（卸载）界面都有哪些元素。并且它可以接入安装的生命周期，做一些操作，比如写入注册表。我们利用这个特性，来给PicGo做一个安装阶段写入注册表的操作，实现系统级别的右键菜单。</p><p><code>electron-builder</code>给<code>NSIS</code>暴露的钩子主要有<code>customHeader</code>, <code>preInit</code>, <code>customInit</code>, <code>customInstall</code>, <code>customUnInstall</code>，等等。</p><p>我们可以在<code>customInstall</code>阶段通过获取用户安装PicGo的路径<code>$INSTDIR</code>来实现对注册表关键值的写入。自己书写的<code>installer.nsh</code>默认放在项目的<code>build</code>目录下，那么<code>electron-builder</code>在构建<code>Windows</code>应用的时候将会自动读取这个文件以及<code>package.json</code>里的配置来生成安装界面。</p><p>写入注册表的格式大概是这样：<br /></p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>WriteRegStr &lt;reg-path&gt; &lt;your-reg-path&gt; &lt;attr-name&gt; &lt;value&gt;</span><br /></pre></td></tr></table><p></p><p>以下是PicGo的<code>installer.nsh</code>，仅供参考：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>!macro customInstall</span><br /><span>   WriteRegStr HKCR "*\shell\PicGo" "" "Upload pictures w&amp;ith PicGo"</span><br /><span>   WriteRegStr HKCR "*\shell\PicGo" "Icon" "$INSTDIR\PicGo.exe"</span><br /><span>   WriteRegStr HKCR "*\shell\PicGo\command" "" '"$INSTDIR\PicGo.exe" "upload" "%1"'</span><br /><span>!macroend</span><br /><span>!macro customUninstall</span><br /><span>   DeleteRegKey HKCR "*\shell\PicGo"</span><br /><span>!macroend</span><br /></pre></td></tr></table><p>注意<code>HKCR</code>即是注册表目录<code>HKEY_CLASSES_ROOT</code>的缩写。在写<code>value</code>的时候如果要写多个参数，可以用单引号包起来。<code>attr-name</code>不写即为默认。相信有了<code>VSCode</code>的右键菜单注册表说明，你也能看得懂上面的PicGo的脚本了。同时注意我们应该在卸载阶段将之前写的注册表删除，以免用户卸载了应用之后菜单还在，上述脚本的后面部分是是在做这个事情。</p><p>因为上一章实现了命令行调用，所以我们的菜单就可以通过<code>'"$INSTDIR\PicGo.exe" "upload" "%1"'</code>来实现菜单调用命令了。</p><h3><a href="https://molunerfinn.com/electron-vue-8/#macOS"></a>macOS</h3><p>macOS的话可以通过实现自动化脚本来生成右键菜单。打开<code>automator</code>：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/mac-automator.png" /></p><p>然后新建一个<code>快速操作</code>:</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/automator-quick.png" /></p><p>将快速操作的工作流程限制到<code>图像文件</code>，并且只作用于<code>访达.app</code>里，同时在左侧菜单里找到<code>shell</code>组件，将其拖拽到右侧编辑区：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/automator-quick-1.png" /></p><p>将<code>shell</code>选择成<code>/bin/bash</code>，传递输入选成<code>作为自变量</code>。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/automator.png" /></p><p>然后将默认的内容改成如下(实际上就差不多是之前说的<code>macOS</code>下如何命令行调用<code>Electron</code>应用的写法)：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>/Applications/PicGo.app/Contents/MacOS/PicGo upload <span>"<span>$@</span>"</span> &gt; /dev/null 2&gt;&amp;1 &amp;</span><br /></pre></td></tr></table><p>其中macOS的快捷操作里，是通过<code>"$@"</code>来作为参数传递的。</p><p>如何作为右键菜单？只要把你生成的这个workflow文件（夹），放到<code>~/Library/Services</code>这个目录下就行了。</p><p>这样你就在你右键菜单里看到它：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/macos-context-menu.png" /></p><p>如果你的服务项过多的话，会在服务的二级菜单里看到它：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/macOS-context-menu-2.png" /></p><p>其中，菜单名就是你生成的这个workflow的文件（夹）名。</p><p>那么生成了这个workflow之后，我们如何实现不让用户手动创建，而是自动帮他们放到<code>~/Library/Services</code>目录下呢？macOS没有Windows那么方便的安装工具脚本语言，那么我们可以在<code>main</code>进程里手动来实现这个功能。下面是PicGo的<a href="https://github.com/Molunerfinn/PicGo/blob/dev/src/main/utils/beforeOpen.js" target="_blank">beforeOpen.js</a>，其中我们将我们生成的<code>workflow</code>文件（夹）放到项目的<code>static</code>目录下。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /></pre></td><td><pre><span><span>import</span> fs <span>from</span> <span>'fs-extra'</span></span><br /><span><span>import</span> path <span>from</span> <span>'path'</span></span><br /><span><span>import</span> os <span>from</span> <span>'os'</span></span><br /><span><span>if</span> (process.env.NODE_ENV !== <span>'development'</span>) {</span><br /><span>  global.__static = path.join(__dirname, <span>'/static'</span>).replace(<span>/\\/g</span>, <span>'\\\\'</span>)</span><br /><span>}</span><br /><span><span>if</span> (process.env.DEBUG_ENV === <span>'debug'</span>) {</span><br /><span>  global.__static = path.join(__dirname, <span>'../../../static'</span>).replace(<span>/\\/g</span>, <span>'\\\\'</span>)</span><br /><span>}</span><br /><span><span><span>function</span> <span>beforeOpen</span> (<span></span>) </span>{</span><br /><span>  <span>const</span> dest = <span>`<span>${os.homedir}</span>/Library/Services/Upload pictures with PicGo.workflow`</span></span><br /><span>  <span>if</span> (fs.existsSync(dest)) { <span>// 判断是否存在</span></span><br /><span>    <span>return</span> <span>true</span></span><br /><span>  } <span>else</span> { <span>// 如果不存在就复制过去</span></span><br /><span>    <span>try</span> {</span><br /><span>      fs.copySync(path.join(__static, <span>'Upload pictures with PicGo.workflow'</span>), dest)</span><br /><span>    } <span>catch</span> (e) {</span><br /><span>      <span>console</span>.log(e)</span><br /><span>    }</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> beforeOpen</span><br /></pre></td></tr></table><p>然后在主进程里加入这个方法，并判断是否在macOS下运行：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>// main/index.js</span></span><br /><span><span>import</span> beforeOpen <span>from</span> <span>'./utils/beforeOpen'</span></span><br /><span><span>// ...</span></span><br /><span><span>if</span> (process.platform === <span>'darwin'</span>) {</span><br /><span>  beforeOpen()</span><br /><span>}</span><br /><span><span>// ...</span></span><br /></pre></td></tr></table><p>这样用户在安装PicGo之后，打开软件之后，他的右键菜单就多了一个「Upload pictures with PicGo」项了。</p><h2><a href="https://molunerfinn.com/electron-vue-8/#小结"></a>小结</h2><p>至此，一个<code>Electron</code>应用的命令行调用以及系统级别右键菜单的实现就讲述完了。当然可能还有其他实现的方式，以及更细致的实现（比如还能支持文件夹右键等等）。我在这里也只是一个抛砖引玉，其他的实现或者更好的实现方式需要自己摸索啦。当然本文没有Linux的相关内容，主要是我时间有限并且没有Linux机器，所以也希望有兴趣的朋友自己在Linux下实现了本文的功能后也能跟我说说~</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>和<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。（PS: 下一篇文章应该会讲述一下如何构建一个Electron应用 <strong>可扩展的快捷键系统</strong> 。）</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote><h2><a href="https://molunerfinn.com/electron-vue-8/#参考文献"></a>参考文献</h2><p>感谢这些高质量的文章、问题等：</p><ol><li><a href="https://www.xiebruce.top/17.html" target="_blank">一个还不错的图床工具-PicUploader</a></li><li><a href="https://stackoverflow.com/questions/49552703/passing-command-line-arguments-to-electron-executable-after-installing-an-alrea" target="_blank">Passing command line arguments to electron executable (after installing an already packaged app)</a></li><li><a href="https://github.com/SimulatedGREG/electron-vue/issues/581" target="_blank">Command Line Arguments in Dev Mode</a></li><li><a href="https://electronjs.org/docs/api/app#apprequestsingleinstancelock" target="_blank">Electron app Docs</a></li><li>以及没来得及记录的那些好文章，感谢你们！</li></ol>]]></content>
        
        <summary type="html">
            
            前言前段时间，我用electron-vue开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习el
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>Electron-vue开发实战6——开发插件系统之GUI部分</title>
        <link href="https://molunerfinn.com/electron-vue-7/"/>
        <id>https://molunerfinn.com/electron-vue-7/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/electron-vue-7/#前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2><a href="https://molunerfinn.com/electron-vue-7/#说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(<code>Electron</code>的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。并且如果没有看过前一篇CLI插件系统构建的朋友，需要先行阅读，本文涉及到的部分内容来自上一篇文章。</p><a></a><h2><a href="https://molunerfinn.com/electron-vue-7/#运行时的require"></a>运行时的require</h2><p>我们之前构建的插件系统是基于<code>Node.js</code>端的。对于<code>Electron</code>而言，main进程可以认为拥有<code>Node.js</code>环境，所以我们首先要在main进程里将其引入。而对于PicGo而言，由于上传流程已经完全抽离到<code>PicGo-Core</code>这个库里了，所以原本存在于Electron端的上传部分就可以精简整合成调用<code>PicGo-Core</code>的api来实现上传部分的逻辑了。</p><p>而在引入<code>PicGo-Core</code>的时候会遇到一个问题。在<code>Electron</code>端，由于我使用的脚手架是<code>Electron-vue</code>，它会将<code>main</code>进程和<code>renderer</code>进程都通过<code>Webapck</code>进行打包。由于<code>PicGo-Core</code>用于加载插件的部分使用的是<code>require</code>，在Node.js端很正常没问题。但是Webpack并不知道这些<code>require</code>是在运行时才需要调用的，它会认为这是构建时的「常规」<code>require</code>，也就会在打包的时候把你<code>require</code>的插件也打包进来。这样明显是不合理的，我们是运行时才<code>require</code>插件的，所以需要做一些手段来「绕开」<code>Webpack</code>的打包机制：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>// eslint-disable-next-line</span></span><br /><span><span>const</span> requireFunc = <span>typeof</span> __webpack_require__ === <span>'function'</span> ? __non_webpack_require__ : <span>require</span></span><br /><span><span>const</span> PicGo = requireFunc(<span>'picgo'</span>)</span><br /></pre></td></tr></table><blockquote><p>关于<code>__non_webpack_require__</code>的说明，可以查看<a href="https://webpack.docschina.org/api/module-variables/#__non_webpack_require__-webpack-特有变量-" target="_blank">文档</a>。</p></blockquote><p>打包之后会变成如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>const</span> requireFunc = <span>true</span> ? <span>require</span> : <span>require</span></span><br /><span><span>const</span> PicGo = requireFunc(<span>'picgo'</span>)</span><br /></pre></td></tr></table><p>这样就可以避免PicGo-Core内部的<code>require</code>被<code>Webpack</code>也打包进去了。</p><h2><a href="https://molunerfinn.com/electron-vue-7/#「前后端」分离"></a>「前后端」分离</h2><p><code>Electron</code>的<code>main</code>进程和<code>renderer</code>进程实际上你可以把它们看成我们平时Web开发的后端和前端。二者交流的工具也不再是<code>Ajax</code>，而是<code>ipcMain</code>和<code>ipcRenderer</code>。当然<code>renderer</code>本身能做的事情也不少，只不过这样说一下可能会好理解一点。相应的，我们的插件系统原本实现在<code>Node.js</code>端，是一个没有界面的工具，想要让它拥有「脸面」，其实也不过是在<code>renderer</code>进程里调用来自<code>main</code>进程里的插件系统暴露出来的api而已。这里我们举几个例子来说明。</p><h3><a href="https://molunerfinn.com/electron-vue-7/#简化原有流程"></a>简化原有流程</h3><p>在以前PicGo上传图片需要经过很多步骤：</p><ol><li>通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/main/utils/uploader.js" target="_blank">uploader</a>来接收图片，并通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/datastore/pic-bed-handler.js" target="_blank">pic-bed-handler</a>来指定上传的图床。</li><li>通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/main/utils/img2base64.js" target="_blank">img2base64</a>来把图片统一转成<code>Base64</code>编码。</li><li>通过指定的<code>imgUploader</code>（比如<code>qiniu</code>比如<code>weibo</code>等）来上传到指定的图床。</li></ol><p>而如今整个底层上传流程系统已经被抽离出来，因此我们可以直接使用PicGo-Core实现的api来上传图片，只需定义一个<a href="https://github.com/Molunerfinn/PicGo/blob/dev/src/main/utils/uploader.js" target="_blank">Uploader</a>类即可（下面的代码是简化版本）：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /></pre></td><td><pre><span><span>import</span> {</span><br /><span>  app,</span><br /><span>  Notification,</span><br /><span>  BrowserWindow,</span><br /><span>  ipcMain</span><br /><span>} <span>from</span> <span>'electron'</span></span><br /><span><span>import</span> path <span>from</span> <span>'path'</span></span><br /><span></span><br /><span><span>// eslint-disable-next-line</span></span><br /><span><span>const</span> requireFunc = <span>typeof</span> __webpack_require__ === <span>'function'</span> ? __non_webpack_require__ : <span>require</span></span><br /><span><span>const</span> PicGo = requireFunc(<span>'picgo'</span>)</span><br /><span><span>const</span> STORE_PATH = app.getPath(<span>'userData'</span>)</span><br /><span><span>const</span> CONFIG_PATH = path.join(STORE_PATH, <span>'/data.json'</span>)</span><br /><span></span><br /><span><span><span>class</span> <span>Uploader</span> </span>{</span><br /><span>  <span>constructor</span> (img, webContents, picgo = undefined) {</span><br /><span>    <span>this</span>.img = img</span><br /><span>    <span>this</span>.webContents = webContents</span><br /><span>    <span>this</span>.picgo = picgo</span><br /><span>  }</span><br /><span></span><br /><span>  upload () {</span><br /><span>    <span>const</span> win = BrowserWindow.fromWebContents(<span>this</span>.webContents) <span>// 获取上传的窗口</span></span><br /><span>    <span>const</span> picgo = <span>this</span>.picgo || <span>new</span> PicGo(CONFIG_PATH) <span>// 获取上传的picgo实例</span></span><br /><span>    picgo.config.debug = <span>true</span> <span>// 方便调试</span></span><br /><span>    <span>// for picgo-core</span></span><br /><span>    picgo.config.PICGO_ENV = <span>'GUI'</span></span><br /><span>    <span>let</span> input = <span>this</span>.img <span>// 传入的this.img是一个数组</span></span><br /><span></span><br /><span>    picgo.upload(input) <span>// 上传图片，只用了一句话</span></span><br /><span></span><br /><span>    picgo.on(<span>'notification'</span>, message =&gt; { <span>// 上传成功或者失败提示信息</span></span><br /><span>      <span>const</span> notification = <span>new</span> Notification(message)</span><br /><span>      notification.show()</span><br /><span>    })</span><br /><span></span><br /><span>    picgo.on(<span>'uploadProgress'</span>, progress =&gt; { <span>// 上传进度</span></span><br /><span>      <span>this</span>.webContents.send(<span>'uploadProgress'</span>, progress)</span><br /><span>    })</span><br /><span></span><br /><span>    <span>return</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve</span>) =&gt;</span> { <span>// 返回一个Promise方便调用</span></span><br /><span>      picgo.on(<span>'finished'</span>, ctx =&gt; { <span>// 上传完成的事件</span></span><br /><span>        <span>if</span> (ctx.output.every(<span><span>item</span> =&gt;</span> item.imgUrl)) {</span><br /><span>          resolve(ctx.output)</span><br /><span>        } <span>else</span> {</span><br /><span>          resolve(<span>false</span>)</span><br /><span>        }</span><br /><span>      })</span><br /><span>      picgo.on(<span>'failed'</span>, ctx =&gt; { <span>// 上传失败的事件</span></span><br /><span>        <span>const</span> notification = <span>new</span> Notification({</span><br /><span>          title: <span>'上传失败'</span>,</span><br /><span>          body: <span>'请检查配置和上传的文件是否符合要求'</span></span><br /><span>        })</span><br /><span>        notification.show()</span><br /><span>        resolve(<span>false</span>)</span><br /><span>      })</span><br /><span>    })</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> Uploader</span><br /></pre></td></tr></table><p>可以看出，由于在设计CLI插件系统的时候我们有考虑到设计好插件的生命周期，所以很多功能都可以通过生命周期的钩子、以及相应的一些事件来实现。比如图片上传完成就是通过<code>picgo.on('finished'， callback)</code>监听<code>finished</code>事件来实现的，而上传的进度与进度条显示就是通过<code>picgo.on('progress')</code>来实现的。它们的效果如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif" /></p><p>而且我们还可以通过接入<code>picgo</code>的生命周期，实现一些以前实现起来比较麻烦的功能，比如上传前重命名：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /></pre></td><td><pre><span>picgo.helper.beforeUploadPlugins.register(<span>'renameFn'</span>, {</span><br /><span>  handle: <span>async</span> ctx =&gt; {</span><br /><span>    <span>const</span> rename = picgo.getConfig(<span>'settings.rename'</span>)</span><br /><span>    <span>const</span> autoRename = picgo.getConfig(<span>'settings.autoRename'</span>)</span><br /><span>    <span>await</span> <span>Promise</span>.all(ctx.output.map(<span>async</span> (item, index) =&gt; {</span><br /><span>      <span>let</span> name</span><br /><span>      <span>let</span> fileName</span><br /><span>      <span>if</span> (autoRename) {</span><br /><span>        fileName = dayjs().add(index, <span>'second'</span>).format(<span>'YYYYMMDDHHmmss'</span>) + item.extname</span><br /><span>      } <span>else</span> {</span><br /><span>        fileName = item.fileName</span><br /><span>      }</span><br /><span>      <span>if</span> (rename) { <span>// 如果要重命名</span></span><br /><span>        <span>const</span> <span>window</span> = createRenameWindow(win) <span>// 创建重命名窗口</span></span><br /><span>        <span>await</span> waitForShow(<span>window</span>.webContents) <span>// 等待窗口打开</span></span><br /><span>        <span>window</span>.webContents.send(<span>'rename'</span>, fileName, <span>window</span>.webContents.id) <span>// 给窗口发送相应信息</span></span><br /><span>        name = <span>await</span> waitForRename(<span>window</span>, <span>window</span>.webContents.id) <span>// 获取重新命名后的文件名</span></span><br /><span>      }</span><br /><span>      item.fileName = name || fileName</span><br /><span>    }))</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><p>通过注册一个<code>beforeUploadPlugin</code>，在上传前判断是否需要「上传前重命名」，如果是，就创建窗口并等待用户输入重命名的结果，然后将重命名的<code>name</code>赋值给<code>item.fileName</code>供后续的流程使用。</p><p>我们还可以在<code>beforeTransform</code>阶段通知用户当前正在准备上传了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span>picgo.on(<span>'beforeTransform'</span>, ctx =&gt; {</span><br /><span>  <span>if</span> (ctx.getConfig(<span>'settings.uploadNotification'</span>)) {</span><br /><span>    <span>const</span> notification = <span>new</span> Notification({</span><br /><span>      title: <span>'上传进度'</span>,</span><br /><span>      body: <span>'正在上传'</span></span><br /><span>    })</span><br /><span>    notification.show()</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><p>等等。所以实际上我们只需要在<code>main</code>进程完成相应的api，那么<code>renderer</code>进程做的事只不过是通过<code>ipcRenderer</code>来通过<code>main</code>进程调用这些api而已了。比如：</p><ul><li>当用户拖动图片到上传区域，通过<code>ipcRenderer</code>通知<code>main</code>进程：</li></ul><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>this</span>.$electron.ipcRenderer.send(<span>'uploadChoosedFiles'</span>, sendFiles)</span><br /></pre></td></tr></table><ul><li><code>main</code>进程监听事件并调用<code>Uploader</code>的<code>upload</code>方法：</li></ul><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>ipcMain.on(<span>'uploadChoosedFiles'</span>, <span>async</span> (evt, files) =&gt; {</span><br /><span>  <span>const</span> input = files.map(<span><span>item</span> =&gt;</span> item.path)</span><br /><span>  <span>const</span> imgs = <span>await</span> <span>new</span> Uploader(input, evt.sender).upload() <span>// 由于upload返回的是Promise</span></span><br /><span>  <span>// ...</span></span><br /><span>})</span><br /></pre></td></tr></table><p>就完成了一次「前后端」交互。其他方式上传（比如剪贴板上传）也同理，就不再赘述。</p><h2><a href="https://molunerfinn.com/electron-vue-7/#实现插件管理界面"></a>实现插件管理界面</h2><p>光有插件系统没有插件也不行，所以我们需要实现一个插件管理的界面。而插件管理的功能（比如安装、卸载、更新）已经在CLI版本里实现了，所以这些功能我们只需要通过向上一节里说的调用<code>ipcRenderer</code>和<code>ipcMain</code>来调用相应api即可。</p><h3><a href="https://molunerfinn.com/electron-vue-7/#第三方插件搜索"></a>第三方插件搜索</h3><p>在GUI界面我们需要一个很重要的功能就是「插件搜索」的功能。由于PicGo的插件统一是发布到<a href="https://www.npmjs.com/" target="_blank">npm</a>的，所以其实我们可以通过npm的api来打到搜索插件的目的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /></pre></td><td><pre><span>getSearchResult (val) {</span><br /><span>  <span>// this.$http.get(`https://api.npms.io/v2/search?q=${val}`)</span></span><br /><span>  <span>this</span>.$http.get(<span>`https://registry.npmjs.com/-/v1/search?text=<span>${val}</span>`</span>) <span>// 调用npm的搜索api</span></span><br /><span>    .then(<span><span>res</span> =&gt;</span> {</span><br /><span>      <span>this</span>.pluginList = res.data.objects.map(<span><span>item</span> =&gt;</span> {</span><br /><span>        <span>return</span> <span>this</span>.handleSearchResult(item) <span>// 返回格式化的结果</span></span><br /><span>      })</span><br /><span>      <span>this</span>.loading = <span>false</span></span><br /><span>    })</span><br /><span>    .catch(<span><span>err</span> =&gt;</span> {</span><br /><span>      <span>console</span>.log(err)</span><br /><span>      <span>this</span>.loading = <span>false</span></span><br /><span>    })</span><br /><span>},</span><br /><span>handleSearchResult (item) {</span><br /><span>  <span>const</span> name = item.package.name.replace(<span>/picgo-plugin-/</span>, <span>''</span>)</span><br /><span>  <span>let</span> gui = <span>false</span></span><br /><span>  <span>if</span> (item.package.keywords &amp;&amp; item.package.keywords.length &gt; <span>0</span>) {</span><br /><span>    <span>if</span> (item.package.keywords.includes(<span>'picgo-gui-plugin'</span>)) {</span><br /><span>      gui = <span>true</span></span><br /><span>    }</span><br /><span>  }</span><br /><span>  <span>return</span> {</span><br /><span>    name: name,</span><br /><span>    author: item.package.author.name,</span><br /><span>    description: item.package.description,</span><br /><span>    logo: <span>`https://cdn.jsdelivr.net/npm/<span>${item.package.name}</span>/logo.png`</span>,</span><br /><span>    config: {},</span><br /><span>    homepage: item.package.links ? item.package.links.homepage : <span>''</span>,</span><br /><span>    hasInstall: <span>this</span>.pluginNameList.some(<span><span>plugin</span> =&gt;</span> plugin === item.package.name.replace(<span>/picgo-plugin-/</span>, <span>''</span>)),</span><br /><span>    version: item.package.version,</span><br /><span>    gui,</span><br /><span>    ing: <span>false</span> <span>// installing or uninstalling</span></span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>通过搜索然后把结果显示到界面上就是如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/test/search-plugin.gif" /></p><p>没有安装的插件就会在右下角显示「安装」两个字样。</p><h3><a href="https://molunerfinn.com/electron-vue-7/#本地插件列表"></a>本地插件列表</h3><p>当我们安装好插件之后，需要从本地获取插件列表。这个部分需要做一些处理。由于插件是安装在Node.js端的，所以我们需要通过<code>ipcRenderer</code>去向<code>main</code>进程发起获取插件列表的「请求」：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>this</span>.$electron.ipcRenderer.send(<span>'getPluginList'</span>) <span>// 发起获取插件的「请求」</span></span><br /><span><span>this</span>.$electron.ipcRenderer.on(<span>'pluginList'</span>, (evt, list) =&gt; { <span>// 获取插件列表</span></span><br /><span>  <span>this</span>.pluginList = list</span><br /><span>  <span>this</span>.pluginNameList = list.map(<span><span>item</span> =&gt;</span> item.name)</span><br /><span>  <span>this</span>.loading = <span>false</span></span><br /><span>})</span><br /></pre></td></tr></table><p>而获取插件列表以及相应信息我们需要在<code>main</code>端进行，并发送回去：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span>ipcMain.on(<span>'getPluginList'</span>, event =&gt; {</span><br /><span>  <span>const</span> picgo = <span>new</span> PicGo(CONFIG_PATH)</span><br /><span>  <span>const</span> pluginList = picgo.pluginLoader.getList()</span><br /><span>  <span>const</span> list = []</span><br /><span>  <span>for</span> (<span>let</span> i <span>in</span> pluginList) {</span><br /><span>   <span>// 处理插件相关的信息</span></span><br /><span>  }</span><br /><span>  event.sender.send(<span>'pluginList'</span>, list) <span>// 将插件信息列表发送回去</span></span><br /><span>})</span><br /></pre></td></tr></table><p>注意到由于<code>ipcMain</code>和<code>ipcRenderer</code>里收发数据的时候会自动经过<code>JSON.stringify</code>和<code>JSON.parse</code>，所以对于原来的一些属性是<code>function</code>之类无法被序列化的属性，我们要做一些处理，比如先执行它们得到结果：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>const</span> handleConfigWithFunction = <span><span>config</span> =&gt;</span> {</span><br /><span>  <span>for</span> (<span>let</span> i <span>in</span> config) {</span><br /><span>    <span>if</span> (<span>typeof</span> config[i].default === <span>'function'</span>) {</span><br /><span>      config[i].default = config[i].default()</span><br /><span>    }</span><br /><span>    <span>if</span> (<span>typeof</span> config[i].choices === <span>'function'</span>) {</span><br /><span>      config[i].choices = config[i].choices()</span><br /><span>    }</span><br /><span>  }</span><br /><span>  <span>return</span> config</span><br /><span>}</span><br /></pre></td></tr></table><p>这样，在<code>renderer</code>进程里才能拿到完整的数据。</p><h3><a href="https://molunerfinn.com/electron-vue-7/#插件配置相关"></a>插件配置相关</h3><p>当然光有安装、查看还不够，还需要让插件管理界面拥有其他功能，比如「卸载」、「更新」或者是配置功能，所以在每个安装成功后的插件卡片的右下角有个配置按钮可以弹出相应的菜单：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20190113160001.png" /></p><p>菜单这个部分就是用<code>Electron</code>的<code>Menu</code>模块去实现了（我在之前的文章里已经有涉及，不再赘述），并没有特别复杂的地方。而这里比较关键的地方，就是当我点击<code>配置plugin-xxx</code>的时候，会弹出一个配置的对话框：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/test/20190317161148.png" /></p><p>这个配置对话框内的配置内容来自前文《开发CLI插件系统》里我们要求开发者定义好的<code>config</code>方法返回的配置项。由于插件开发者定义的<code>config</code>内容是<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank">Inquirer.js</a>所要求的格式，便于在CLI环境下使用。但是它和我们平时使用的<code>form</code>表单的一些格式可能有些出入，所以需要「转义」一下，通过原始的<code>config</code>动态生成表单项：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /></pre></td><td><pre><span><span>&lt;<span>div</span> <span>id</span>=<span>"config-form"</span>&gt;</span></span><br /><span>  <span>&lt;<span>el-form</span></span></span><br /><span><span>    <span>label-position</span>=<span>"right"</span></span></span><br /><span><span>    <span>label-width</span>=<span>"120px"</span></span></span><br /><span><span>    <span>:model</span>=<span>"ruleForm"</span></span></span><br /><span><span>    <span>ref</span>=<span>"form"</span></span></span><br /><span><span>    <span>size</span>=<span>"mini"</span></span></span><br /><span><span>  &gt;</span></span><br /><span>    <span>&lt;<span>el-form-item</span></span></span><br /><span><span>      <span>v-for</span>=<span>"(item, index) in configList"</span></span></span><br /><span><span>      <span>:label</span>=<span>"item.name"</span></span></span><br /><span><span>      <span>:required</span>=<span>"item.required"</span></span></span><br /><span><span>      <span>:prop</span>=<span>"item.name"</span></span></span><br /><span><span>      <span>:key</span>=<span>"item.name + index"</span></span></span><br /><span><span>    &gt;</span></span><br /><span>      <span>&lt;<span>el-input</span></span></span><br /><span><span>        <span>v-if</span>=<span>"item.type === 'input' || item.type === 'password'"</span></span></span><br /><span><span>        <span>:type</span>=<span>"item.type === 'password' ? 'password' : 'input'"</span></span></span><br /><span><span>        <span>v-model</span>=<span>"ruleForm[item.name]"</span></span></span><br /><span><span>        <span>:placeholder</span>=<span>"item.message || item.name"</span></span></span><br /><span><span>      &gt;</span><span>&lt;/<span>el-input</span>&gt;</span></span><br /><span>      <span>&lt;<span>el-select</span></span></span><br /><span><span>        <span>v-else-if</span>=<span>"item.type === 'list'"</span></span></span><br /><span><span>        <span>v-model</span>=<span>"ruleForm[item.name]"</span></span></span><br /><span><span>        <span>:placeholder</span>=<span>"item.message || item.name"</span></span></span><br /><span><span>      &gt;</span></span><br /><span>        <span>&lt;<span>el-option</span></span></span><br /><span><span>          <span>v-for</span>=<span>"(choice, idx) in item.choices"</span></span></span><br /><span><span>          <span>:label</span>=<span>"choice.name || choice.value || choice"</span></span></span><br /><span><span>          <span>:key</span>=<span>"choice.name || choice.value || choice"</span></span></span><br /><span><span>          <span>:value</span>=<span>"choice.value || choice"</span></span></span><br /><span><span>        &gt;</span><span>&lt;/<span>el-option</span>&gt;</span></span><br /><span>      <span>&lt;/<span>el-select</span>&gt;</span></span><br /><span>      <span>&lt;<span>el-select</span></span></span><br /><span><span>        <span>v-else-if</span>=<span>"item.type === 'checkbox'"</span></span></span><br /><span><span>        <span>v-model</span>=<span>"ruleForm[item.name]"</span></span></span><br /><span><span>        <span>:placeholder</span>=<span>"item.message || item.name"</span></span></span><br /><span><span>        <span>multiple</span></span></span><br /><span><span>        <span>collapse-tags</span></span></span><br /><span><span>      &gt;</span></span><br /><span>        <span>&lt;<span>el-option</span></span></span><br /><span><span>          <span>v-for</span>=<span>"(choice, idx) in item.choices"</span></span></span><br /><span><span>          <span>:label</span>=<span>"choice.name || choice.value || choice"</span></span></span><br /><span><span>          <span>:key</span>=<span>"choice.value || choice"</span></span></span><br /><span><span>          <span>:value</span>=<span>"choice.value || choice"</span></span></span><br /><span><span>        &gt;</span><span>&lt;/<span>el-option</span>&gt;</span></span><br /><span>      <span>&lt;/<span>el-select</span>&gt;</span></span><br /><span>      <span>&lt;<span>el-switch</span></span></span><br /><span><span>        <span>v-else-if</span>=<span>"item.type === 'confirm'"</span></span></span><br /><span><span>        <span>v-model</span>=<span>"ruleForm[item.name]"</span></span></span><br /><span><span>        <span>active-text</span>=<span>"yes"</span></span></span><br /><span><span>        <span>inactive-text</span>=<span>"no"</span></span></span><br /><span><span>      &gt;</span></span><br /><span>      <span>&lt;/<span>el-switch</span>&gt;</span></span><br /><span>    <span>&lt;/<span>el-form-item</span>&gt;</span></span><br /><span>    <span>&lt;<span>slot</span>&gt;</span><span>&lt;/<span>slot</span>&gt;</span></span><br /><span>  <span>&lt;/<span>el-form</span>&gt;</span></span><br /><span><span>&lt;/<span>div</span>&gt;</span></span><br /></pre></td></tr></table><p>上面是针对<code>config</code>里不同的<code>type</code>转换成不同的Web表单控件的代码。下面是初始化的时候处理<code>config</code>的一些工作：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /></pre></td><td><pre><span>watch: {</span><br /><span>  config: {</span><br /><span>    deep: <span>true</span>,</span><br /><span>    handler (val) {</span><br /><span>      <span>this</span>.ruleForm = <span>Object</span>.assign({}, {})</span><br /><span>      <span>const</span> config = <span>this</span>.$db.read().get(<span>`picBed.<span>${<span>this</span>.id}</span>`</span>).value()</span><br /><span>      <span>if</span> (val.length &gt; <span>0</span>) {</span><br /><span>        <span>this</span>.configList = cloneDeep(val).map(<span><span>item</span> =&gt;</span> {</span><br /><span>          <span>let</span> defaultValue = item.default !== <span>undefined</span></span><br /><span>            ? item.default : item.type === <span>'checkbox'</span></span><br /><span>              ? [] : <span>null</span> <span>// 处理默认值</span></span><br /><span>          <span>if</span> (item.type === <span>'checkbox'</span>) { <span>// 处理checkbox选中值</span></span><br /><span>            <span>const</span> defaults = item.choices.filter(<span><span>i</span> =&gt;</span> {</span><br /><span>              <span>return</span> i.checked</span><br /><span>            }).map(<span><span>i</span> =&gt;</span> i.value)</span><br /><span>            defaultValue = union(defaultValue, defaults)</span><br /><span>          }</span><br /><span>          <span>if</span> (config &amp;&amp; config[item.name] !== <span>undefined</span>) { <span>// 处理默认值</span></span><br /><span>            defaultValue = config[item.name]</span><br /><span>          }</span><br /><span>          <span>this</span>.$<span>set</span>(this.ruleForm, item.name, defaultValue)</span><br /><span>          return item</span><br /><span>        })</span><br /><span>      }</span><br /><span>    },</span><br /><span>    immediate: true // 立即执行</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>经过上述处理，就可以将原本用于CLI的配置项，近乎「无缝」地迁移到Web（GUI）端了。其实这也是vue-cli3的ui版本实现的思路，大同小异。</p><h2><a href="https://molunerfinn.com/electron-vue-7/#实现特有的guiApi"></a>实现特有的guiApi</h2><p>不过既然是GUI软件了，只通过调用CLI实现的功能明显是不够丰富的。因此我也为<code>PicGo</code>实现了一些特有的<code>guiApi</code>提供给插件的开发者，让插件的可玩性更强。当然不同的软件给予插件的GUI能力是不一样的，因此不能一概而论。我仅以<code>PicGo</code>为例，讲述我对于<code>PicGo</code>所提供的<code>guiApi</code>的理解和看法。下面我就来说说这部分是如何实现的。</p><p>由于PicGo本质是一个上传系统，所以用户在上传图片的时候，很多插件底层的东西和功能实际上是看不到的。如果要让插件的功能更加丰富，就需要让插件有自己的「可视化」入口让用户去使用。因此对于PicGo而言，我给予插件的「可视化」入口就放在插件配置的界面里——除了给插件默认的配置菜单之外，还给予插件自己的菜单项供用户使用：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" /></p><p>这个实现也很容易，只要插件在自己的<code>index.js</code>文件里暴露一个<code>guiMenu</code>的选项，就可以生成自己的菜单：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /></pre></td><td><pre><span><span>const</span> guiMenu = <span><span>ctx</span> =&gt;</span> {</span><br /><span>  <span>return</span> [</span><br /><span>    {</span><br /><span>      label: <span>'打开InputBox'</span>,</span><br /><span>      <span>async</span> handle (ctx, guiApi) {</span><br /><span>        <span>// do something...</span></span><br /><span>      }</span><br /><span>    },</span><br /><span>    {</span><br /><span>      label: <span>'打开FileExplorer'</span>,</span><br /><span>      <span>async</span> handle (ctx, guiApi) {</span><br /><span>        <span>// do something...</span></span><br /><span>      }</span><br /><span>    },</span><br /><span>    <span>// ...</span></span><br /><span>  ]</span><br /><span>}</span><br /></pre></td></tr></table><p>可以看到菜单项可以自定义，点击之后的操作也可以自定义，因此给予了插件很大的自由度。可以注意到，在点击菜单的时候会触发<code>handle</code>函数，这个函数里会传入一个<code>guiApi</code>，这个就是本节的重点了。就目前而言，<code>guiApi</code>实现了如下功能：</p><ol><li><code>showInputBox([option])</code> 调用之后打开一个输入弹窗，可以用于接受用户输入。</li><li><code>showFileExplorer([option])</code> 调用之后打开一个文件浏览器，可以得到用户选择的文件（夹）路径。</li><li><code>upload([file])</code> 调用之后使用PicGo底层来上传，可以实现自动更新相册图片、上传成功后自动将URL写入剪贴板。</li><li><code>showNotificaiton(option)</code> 调用之后弹出系统通知窗口。</li></ol><p>上面api我们可以通过诸如<code>guiApi.showInputBox()</code>、<code>guiApi.showFileExplorer()</code>等来实现调用。这里面的例子实现思路都差不多，我简单以<code>guiApi.showFileExplorer()</code>来做讲解。</p><p>当我们在<code>renderer</code>界面点击插件实现的某个菜单之后，实际上是通过调用<code>ipcRenderer</code>向<code>main</code>进程传播了一次事件：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /></pre></td><td><pre><span><span>if</span> (plugin.guiMenu) {</span><br /><span>  menu.push({</span><br /><span>    type: <span>'separator'</span></span><br /><span>  })</span><br /><span>  <span>for</span> (<span>let</span> i <span>of</span> plugin.guiMenu) {</span><br /><span>    menu.push({</span><br /><span>      label: i.label,</span><br /><span>      click () { <span>// 当点击的时候，发送当前的插件名和当前菜单项的名字</span></span><br /><span>        _this.$electron.ipcRenderer.send(<span>'pluginActions'</span>, plugin.name, i.label)</span><br /><span>      }</span><br /><span>    })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>于是在<code>main</code>进程，我们通过监听这个事件，来调用相应的<code>guiApi</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /></pre></td><td><pre><span><span>const</span> handlePluginActions = <span>(<span>ipcMain, CONFIG_PATH</span>) =&gt;</span> {</span><br /><span>  ipcMain.on(<span>'pluginActions'</span>, (event, name, label) =&gt; {</span><br /><span>    <span>const</span> picgo = <span>new</span> PicGo(CONFIG_PATH)</span><br /><span>    <span>const</span> plugin = picgo.pluginLoader.getPlugin(<span>`picgo-plugin-<span>${name}</span>`</span>)</span><br /><span>    <span>const</span> guiApi = <span>new</span> GuiApi(ipcMain, event.sender, picgo) <span>// 实例化guiApi</span></span><br /><span>    <span>if</span> (plugin.guiMenu &amp;&amp; plugin.guiMenu(picgo).length &gt; <span>0</span>) {</span><br /><span>      <span>const</span> menu = plugin.guiMenu(picgo)</span><br /><span>      menu.forEach(<span><span>item</span> =&gt;</span> {</span><br /><span>        <span>if</span> (item.label === label) { <span>// 找到相应的label，执行插件的`handle`</span></span><br /><span>          item.handle(picgo, guiApi)</span><br /><span>        }</span><br /><span>      })</span><br /><span>    }</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>而<code>guiApi</code>的实现类<a href="https://github.com/Molunerfinn/PicGo/blob/dev/src/main/utils/guiApi.js" target="_blank">GuiApi</a>其实特别简单：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /></pre></td><td><pre><span><span>import</span> {</span><br /><span>  dialog,</span><br /><span>  BrowserWindow,</span><br /><span>  clipboard,</span><br /><span>  Notification</span><br /><span>} <span>from</span> <span>'electron'</span></span><br /><span><span>import</span> db <span>from</span> <span>'../../datastore'</span></span><br /><span><span>import</span> Uploader <span>from</span> <span>'./uploader'</span></span><br /><span><span>import</span> pasteTemplate <span>from</span> <span>'./pasteTemplate'</span></span><br /><span><span>const</span> WEBCONTENTS = <span>Symbol</span>(<span>'WEBCONTENTS'</span>)</span><br /><span><span>const</span> IPCMAIN = <span>Symbol</span>(<span>'IPCMAIN'</span>)</span><br /><span><span>const</span> PICGO = <span>Symbol</span>(<span>'PICGO'</span>)</span><br /><span><span><span>class</span> <span>GuiApi</span> </span>{</span><br /><span>  <span>constructor</span> (ipcMain, webcontents, picgo) {</span><br /><span>    <span>this</span>[WEBCONTENTS] = webcontents</span><br /><span>    <span>this</span>[IPCMAIN] = ipcMain</span><br /><span>    <span>this</span>[PICGO] = picgo</span><br /><span>  }</span><br /><span></span><br /><span>  <span>/**</span></span><br /><span><span>   * for plugin show file explorer</span></span><br /><span><span>   * <span>@param <span>{object}</span> <span>options</span></span></span></span><br /><span><span>   */</span></span><br /><span>  showFileExplorer (options) {</span><br /><span>    <span>if</span> (options === <span>undefined</span>) {</span><br /><span>      options = {}</span><br /><span>    }</span><br /><span>    <span>return</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve, reject</span>) =&gt;</span> {</span><br /><span>      dialog.showOpenDialog(BrowserWindow.fromWebContents(<span>this</span>[WEBCONTENTS]), options, filename =&gt; {</span><br /><span>        resolve(filename)</span><br /><span>      })</span><br /><span>    })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>实际上就是去调用一些<code>Electron</code>的方法，甚至是你自己封装的一些方法，返回值是一个新的<code>Promise</code>对象。这样插件开发者就可以通过<code>async</code>和<code>await</code>来方便获取这些方法的返回值了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /></pre></td><td><pre><span><span>const</span> guiMenu = <span><span>ctx</span> =&gt;</span> {</span><br /><span>  <span>return</span> [</span><br /><span>    {</span><br /><span>      label: <span>'打开文件浏览器'</span>,</span><br /><span>      <span>async</span> handle (ctx, guiApi) {</span><br /><span>        <span>// 通过await获取用户所选的文件路径</span></span><br /><span>        <span>const</span> files = <span>await</span> guiApi.showFileExplorer({</span><br /><span>          properties: [<span>'openFile'</span>, <span>'multiSelections'</span>]</span><br /><span>        })</span><br /><span>        <span>console</span>.log(files)</span><br /><span>      }</span><br /><span>    }</span><br /><span>  ]</span><br /><span>}</span><br /></pre></td></tr></table><h2><a href="https://molunerfinn.com/electron-vue-7/#小结"></a>小结</h2><p>至此，一个GUI插件系统的关键部分我们就基本实现了。除了整合了CLI插件系统的几乎所有功能之外，我们还提供了独特的<code>guiApi</code>给插件开发者无限的想象空间，也给用户带来更好的插件体验。可以说插件系统的实现，让<code>PicGo</code>有了更多的可玩性。关于<code>PicGo</code>目前的插件，欢迎查看<a href="https://github.com/PicGo/Awesome-PicGo" target="_blank">Awesome-PicGo</a>的列表。以下罗列一些我觉得比较有用或者有意思的插件：</p><ol><li><a href="https://github.com/Spades-S/vs-picgo" target="_blank">vs-picgo</a> 在VSCode里使用PicGo（无需安装GUI！）</li><li><a href="https://github.com/PicGo/picgo-plugin-pic-migrater" target="_blank">picgo-plugin-pic-migrater</a> 可以迁移你的Markdown里的图片地址到你默认指定的图床，哪怕是本地图片也可以迁移到云端！</li><li><a href="https://github.com/zWingz/picgo-plugin-github-plus" target="_blank">picgo-plugin-github-plus</a> 增强版GitHub图床，支持了同步图床以及同步删除操作（删除本地图片也会把GitHub上的图片删除）</li><li><a href="https://github.com/yuki-xin/picgo-plugin-web-uploader" target="_blank">picgo-plugin-web-uploader</a> 支持<a href="https://github.com/xiebruce/PicUploader" target="_blank">PicUploader</a>配置的图床插件</li><li><a href="https://github.com/chengww5217/picgo-plugin-qingstor-uploader" target="_blank">picgo-plugin-qingstor-uploader</a> 支持青云云存储的图床插件</li><li><a href="https://github.com/chengww5217/picgo-plugin-blog-uploader" target="_blank">picgo-plugin-blog-uploader</a> 支持掘金、简书和CSDN来做图床的图床插件</li></ol><p>如果你也想为PicGo开发插件，欢迎阅读<a href="https://picgo.github.io/PicGo-Core-Doc/zh/" target="_blank">开发文档</a>，PicGo有你更精彩哈哈！</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>和<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote><h2><a href="https://molunerfinn.com/electron-vue-7/#参考文献"></a>参考文献</h2><p>感谢这些高质量的文章：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/38730825" target="_blank">用Node.js开发一个Command Line Interface (CLI)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26895282" target="_blank">Node.js编写CLI的实践</a></li><li><a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism" target="_blank">Node.js模块机制</a></li><li><a href="https://onetwo.ren/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" target="_blank">前端插件系统设计与实现</a></li><li><a href="https://blog.csdn.net/kyfxbl/article/details/47787827" target="_blank">Hexo插件机制分析</a></li><li><a href="http://blog.yunplus.io/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/" target="_blank">如何实现一个简单的插件扩展</a></li><li><a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank">使用NPM发布与维护TypeScript模块</a></li><li><a href="https://github.com/basarat/ts-npm-module" target="_blank">typescript npm 包例子</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/" target="_blank">通过travis-ci发布npm包</a></li><li><a href="https://discuss.atom.io/t/dynamically-load-module-in-plugin-from-local-project-node-modules-folder/42930/2" target="_blank">Dynamic load module in plugin from local project node_modules folder</a></li><li><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html" target="_blank">跟着老司机玩转Node命令行</a></li><li>以及没来得及记录的那些好文章，感谢你们！</li></ol>]]></content>
        
        <summary type="html">
            
            前言前段时间，我用electron-vue开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习el
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>Zerotier Nat 网关出口 和 iptables 调试</title>
        <link href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/"/>
        <id>https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2019-03-03T06:59:53+00:00</published>
        <updated>2019-03-03T06:59:53+00:00</updated>
        
        <content type="html"><![CDATA[<p>每当看到各类教程中的 iptables 指令，在格式参数组合之下可以实现从防火墙，封禁 IP 端口到 NAT 的各种操作，就如同魔法一般，看不明白，却又感到无比强大。想学，但又好像不得要领，稍微不慎可能就再也连不上了。最近配置 Zerotier 的 Nat 网关的时候，看着 <a href="https://zerotier.atlassian.net/wiki/spaces/SD/pages/7110693/Overriding+Default+Route+Full+Tunnel+Mode" target="_blank">教程</a> 中的各种指令，抄过之后完全不通，花了3个晚上之后，逼着搞清楚了怎么 debug ( 打 log ) 后，终于配置成功 (虽然最终失败的原因和 iptables 无关)。</p><h2><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#Zerotier"></a>Zerotier</h2><p>首先介绍下 <a href="https://www.zerotier.com/" target="_blank">Zerotier</a> 和为什么要配置 Nat 网关。</p><p><a href="https://www.zerotier.com/" target="_blank">Zerotier</a> 是一个虚拟局域网软件，可以很简单地将无限量（社区服务器版100台）设备放入同一个虚拟局域网中。这样就能在任何网络环境中，访问家中的 NAS 或其他设备。反过来，如果将一台服务器加入这个局域网中，将它配置为一个 <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank">NAT</a> 网关，只要你加入这个虚拟局域网，就可以通过它连接世界。</p><p>选择 Zerotier 的原因是，它足够简单，只要一个 16 位的 network ID 就能实现组网了，相比我之前用过的 <a href="https://www.tinc-vpn.org/" target="_blank">tinc</a>，不需要节点 IP，不需要挨个配置节点，并且支持的操作系统广泛。</p><p>当然，第一步是<a href="http://www.zerotier.com/download.shtml" target="_blank">安装 Zerotier</a>，然后<a href="https://my.zerotier.com/" target="_blank">注册一个帐号</a>，<a href="https://my.zerotier.com/network" target="_blank">创建一个私人网络</a>。复制 network ID 在本地加入，然后回到网站中通过许可 (<code>Auth?</code>) 就好了。</p><p>当你将本地计算机和一台服务器加入网络后，然后就是根据 <a href="https://zerotier.atlassian.net/wiki/spaces/SD/pages/7110693/Overriding+Default+Route+Full+Tunnel+Mode" target="_blank">这个教程</a> 。运行下面4个命令就行了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span>sudo sysctl -w net.ipv4.ip_forward=1</span><br /><span>sudo iptables -t nat -A POSTROUTING -o eth0 -s 10.6.4.0/22 -j SNAT --to-source 45.32.69.220</span><br /><span>sudo iptables -A FORWARD -i zt+ -s 10.6.4.0/22 -d 0.0.0.0/0 -j ACCEPT</span><br /><span>sudo iptables -A FORWARD -i eth0 -s 0.0.0.0/0 -d 10.6.4.0/0 -j ACCEPT</span><br /></pre></td></tr></table><p>当然了，很明显，这里的 <code>eth0</code>, <code>10.6.4.0/22</code>, <code>45.32.69.220</code> 是需要根据实际环境替换的，<code>zt+</code> 是指的任何以 <code>zt</code> 开头的网络，zerotier 都是以这样的名字创建的，所以不用修改。这都可以通过 <code>ip addr</code> 或者 <code>ifconfig</code> 进行确认。比如在我的环境中，环境是这样的：</p><ul><li>网关外网 IP：123.45.67.89</li><li>zertier 网络: 192.168.11.0/24</li><li>网关 zerotier 网络 IP: 192.168.11.1</li><li>本机 IP：192.168.11.20</li></ul><p>命令是这样的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span>sudo sysctl -w net.ipv4.ip_forward=1</span><br /><span>sudo iptables -t nat -A POSTROUTING -o venet0 -s 192.168.111.0/24 -j SNAT --to-source 123.45.67.89</span><br /><span>sudo iptables -A FORWARD -i zt+ -s 192.168.111.0/24 -d 0.0.0.0/0 -j ACCEPT</span><br /><span>sudo iptables -A FORWARD -i venet0 -s 0.0.0.0/0 -d 192.168.111.0/24 -j ACCEPT</span><br /></pre></td></tr></table><p>当我设置完了这些，然后把这个服务器设置为默认 0.0.0.0/0 的网关之后，我断网了<br /><del>如果这样有用的话，我岂不是就没机会学习 iptables 了。</del>  </p><h2><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#iptables"></a>iptables</h2><p>首先当然是把默认路由改回来。然后，如果只是为了调试，是不需要设置默认路由的，或者说最好不要设置默认路由到这台机器上的，你可以通过</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span># macos</span><br /><span>sudo route add -net 98.76.54.32 192.168.111.1</span><br /><span># linux</span><br /><span># sudo route add -net 98.76.64.32 gw 192.168.111.1</span><br /></pre></td></tr></table><p>设置一条单独的路由，到另一台主机上，然后就可以单独监控调试这条链路的情况了。</p><h3><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#LOG-和-TRACE"></a>LOG 和 TRACE</h3><p>好了，既然现在网络不通，我最想知道的当然是哪断了。</p><h4><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#本机-gt-网关"></a>本机 -&gt; 网关</h4><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>iptables -t raw -A PREROUTING -p TCP -s 192.168.111.20 -j LOG</span><br /></pre></td></tr></table><p>这里就给所有从 本机 发往 网关 的 TCP 数据包打了 LOG，然后 <code>tail -f /var/log/messages</code> （或者 <code>tail -f /var/log/kern.log</code>) 追踪日志。<br />现在你可以从本地往测试服务器发个请求： <code>curl 98.76.54.32</code>，如果在日志中看到</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>Mar  2 15:53:14 myserver kernel: [5377966.960574] IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=45807 DF PROTO=TCP SPT=64408 DPT=80 WINDOW=65535 RES=0x00 SYN URGP=0</span><br /></pre></td></tr></table><p>那么就可以确认网关确实收到这个包了</p><h4><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#网关-gt-网站"></a>网关 -&gt; 网站</h4><p>然后可以用 TRACE 追踪这个包是否触发了 NAT。</p><blockquote><p>在一些环境中，你可能需要开启 TRACE 内核支持，参考 <a href="https://serverfault.com/questions/385937/how-to-enable-iptables-trace-target-on-debian-squeeze-6" target="_blank">How to Enable IPtables TRACE Target on Debian Squeeze (6)</a></p></blockquote><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>iptables -t raw -A PREROUTING -p TCP -s 192.168.111.20 -j TRACE</span><br /></pre></td></tr></table><p>你会看到</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>Mar  2 15:58:11 myserver kernel: [5378263.921579] IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921611] TRACE: raw:PREROUTING:policy:3 IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921645] TRACE: mangle:PREROUTING:policy:1 IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921672] TRACE: nat:PREROUTING:policy:1 IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921698] TRACE: mangle:FORWARD:policy:1 IN=zthnhi321 OUT=venet0 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921719] TRACE: filter:FORWARD:rule:1 IN=zthnhi321 OUT=venet0 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921741] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=venet0 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /><span>Mar  2 15:58:11 myserver kernel: [5378263.921763] TRACE: nat:POSTROUTING:rule:1 IN= OUT=venet0 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=32766 DF PROTO=TCP SPT=65087 DPT=80 SEQ=3874826404 ACK=0 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0 OPT (02040ACA2C84454E80103030501000004010800000020000)</span><br /></pre></td></tr></table><p>表明这个包分别经过了</p><ul><li>raw:PREROUTING:policy:3</li><li>mangle:PREROUTING:policy:1</li><li>nat:PREROUTING:policy:1</li><li>mangle:FORWARD:policy:1</li><li>filter:FORWARD:rule:1</li><li>mangle:POSTROUTING:policy:1</li><li>nat:POSTROUTING:rule:1</li></ul><p>你可以通过</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>iptables -t nat -nvL --line-numbers</span><br /></pre></td></tr></table><p>查看对应的规则编号。在这里，可以看到 <code>filter:FORWARD:rule:1</code> 和 <code>nat:POSTROUTING:rule:1</code> 被触发了。即</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>sudo iptables -A FORWARD -i zt+ -s 192.168.111.0/24 -d 0.0.0.0/0 -j ACCEPT</span><br /><span>sudo iptables -t nat -A POSTROUTING -o venet0 -s 192.168.111.0/24 -j SNAT --to-source 123.45.67.89</span><br /></pre></td></tr></table><blockquote><p>另外如果你尝试过执行 <code>iptables -t nat -A POSTROUTING -i zt+ -o venet0</code> ，会收到 <code>Can't use -i with POSTROUTING</code> 报错。从 TRACE 中可以看出 <code>nat:POSTROUTING:rule:1</code> 中 <code>IN=</code> 是空的。所以在 <code>POSTROUTING</code> 表中是不能使用 <code>-i</code> 指定入包接口的。</p></blockquote><h4><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#网站-gt-网关-gt-本机"></a>网站 -&gt; 网关 -&gt; 本机</h4><p>这次我们一步到位</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>iptables -t raw -A PREROUTING -p TCP -s 98.76.54.32 -j LOG</span><br /><span>iptables -t raw -A PREROUTING -p TCP -s 98.76.54.32 -j TRACE</span><br /></pre></td></tr></table><p>另外为了防止日志太多，这里可以把刚才添加的那条 TRACE 删掉：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>iptables -t raw -D PREROUTING -p TCP -s 192.168.111.20 -j TRACE</span><br /></pre></td></tr></table><p>再次 <code>curl 98.76.54.32</code> 就能看到包返回了</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span>Mar  3 14:04:55 myserver kernel: [5457820.771146] IN=zthnhi321 OUT= MAC=88:55:bb:99:88:88:88:66:11:dd:ff:bb:00:00 SRC=192.168.111.20 DST=98.76.54.32 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=64965 DF PROTO=TCP SPT=57286 DPT=80 WINDOW=65535 RES=0x00 CWR ECE SYN URGP=0</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771696] IN=venet0 OUT= MAC= SRC=98.76.54.32 DST=123.45.67.89 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771713] TRACE: raw:PREROUTING:policy:4 IN=venet0 OUT= MAC= SRC=98.76.54.32 DST=123.45.67.89 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 SEQ=1319922288 ACK=3993987234 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0 OPT (020401AA7250238401080A2F75F14B4048030307)</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771729] TRACE: mangle:PREROUTING:policy:1 IN=venet0 OUT= MAC= SRC=98.76.54.32 DST=123.45.67.89 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 SEQ=1319922288 ACK=3993987234 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0 OPT (020401AA7250238401080A2F75F14B4048030307)</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771743] TRACE: mangle:FORWARD:policy:1 IN=venet0 OUT=zthnhi321 SRC=98.76.54.32 DST=192.168.111.20 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 SEQ=1319922288 ACK=3993987234 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0 OPT (020401AA7250238401080A2F75F14B4048030307)</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771755] TRACE: filter:FORWARD:rule:2 IN=venet0 OUT=zthnhi321 SRC=98.76.54.32 DST=192.168.111.20 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 SEQ=1319922288 ACK=3993987234 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0 OPT (020401AA7250238401080A2F75F14B4048030307)</span><br /><span>Mar  3 14:04:55 myserver kernel: [5457820.771767] TRACE: mangle:POSTROUTING:policy:1 IN= OUT=zthnhi321 SRC=98.76.54.32 DST=192.168.111.20 LEN=60 TOS=0x00 PREC=0x00 TTL=55 ID=0 DF PROTO=TCP SPT=80 DPT=57286 SEQ=1319922288 ACK=3993987234 WINDOW=14480 RES=0x00 ECE ACK SYN URGP=0 OPT (020401AA7250238401080A2F75F14B4048030307)</span><br /></pre></td></tr></table><p>同理，可以看到数据包在经过 <code>mangle:PREROUTING:policy:1</code> 之后，DST 被改写回了 <code>192.168.111.20</code>。于是一次成功的 NAT 就完成了。</p><p>最后，这里有一张图，显示了数据包都会经过什么表:</p><p><a href="https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Netfilter-packet-flow.svg/512px-Netfilter-packet-flow.svg.png" /></a></p><blockquote><p>之前配置 NAT 网关不成功的原因是：zerotier 防火墙错误设置了如下规则，导致包没法发回本机。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>drop</span><br /><span>not chr ipauth</span><br /><span>;</span><br /></pre></td></tr></table></blockquote><h2><a href="https://binux.blog/2019/03/zerotier-nat-gateway-and-iptables-debug/#网关"></a>网关+</h2><p>既然有网关了，我就想能不能再搞个智能回国网关。，只要我连上这个局域网，就能听网易云音乐了。我用的 vnet.one 用的是 anyconnect 连接，它有一个开源实现 openconnect，于是我<a href="https://stackoverflow.com/questions/38369950/openconnect-not-able-to-connect-to-gateway/42342253" target="_blank">这样</a>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>sudo apt-get install curl vpnc-scripts build-essential libssl-dev libxml2-dev liblz4-dev</span><br /><span>wget ftp://ftp.infradead.org/pub/openconnect/openconnect-8.02.tar.gz</span><br /><span>tar xzf openconnect-8.02.tar.gz</span><br /><span>cd openconnect-8.02</span><br /><span>./configure --without-gnutls --with-vpnc-script=/usr/share/vpnc-scripts/vpnc-script</span><br /><span>make</span><br /><span>sudo make install</span><br /><span>sudo ldconfig /usr/local/lib</span><br /></pre></td></tr></table><p>然后用 <a href="https://github.com/ashi009/bestroutetb" target="_blank">bestroutetb</a> 生成个路由：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>bestroutetb --route.net=US,GB  --route.vpn=CN -p json -o routes.json -f</span><br /><span>jq '.[] | select(.gateway == "vpn") | .prefix + "/" + (.length | tostring)'  routes.json  -c -r &gt; routes.cn</span><br /></pre></td></tr></table><p>整个设置路由的脚本</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /></pre></td><td><pre><span>#!/bin/bash</span><br /><span>source /root/.bashrc</span><br /><span></span><br /><span>DIR=$(dirname $0)</span><br /><span></span><br /><span># Routes that we want to be used by the VPN link</span><br /><span>ROUTES=`cat $DIR/routes.cn`</span><br /><span></span><br /><span># Helpers to create dotted-quad netmask strings.</span><br /><span>MASKS[1]="128.0.0.0"</span><br /><span>MASKS[2]="192.0.0.0"</span><br /><span>MASKS[3]="224.0.0.0"</span><br /><span>MASKS[4]="240.0.0.0"</span><br /><span>MASKS[5]="248.0.0.0"</span><br /><span>MASKS[6]="252.0.0.0"</span><br /><span>MASKS[7]="254.0.0.0"</span><br /><span>MASKS[8]="255.0.0.0"</span><br /><span>MASKS[9]="255.128.0.0"</span><br /><span>MASKS[10]="255.192.0.0"</span><br /><span>MASKS[11]="255.224.0.0"</span><br /><span>MASKS[12]="255.240.0.0"</span><br /><span>MASKS[13]="255.248.0.0"</span><br /><span>MASKS[14]="255.252.0.0"</span><br /><span>MASKS[15]="255.254.0.0"</span><br /><span>MASKS[16]="255.255.0.0"</span><br /><span>MASKS[17]="255.255.128.0"</span><br /><span>MASKS[18]="255.255.192.0"</span><br /><span>MASKS[19]="255.255.224.0"</span><br /><span>MASKS[20]="255.255.240.0"</span><br /><span>MASKS[21]="255.255.248.0"</span><br /><span>MASKS[22]="255.255.252.0"</span><br /><span>MASKS[23]="255.255.254.0"</span><br /><span>MASKS[24]="255.255.255.0"</span><br /><span>MASKS[25]="255.255.255.128"</span><br /><span>MASKS[26]="255.255.255.192"</span><br /><span>MASKS[27]="255.255.255.224"</span><br /><span>MASKS[28]="255.255.255.240"</span><br /><span>MASKS[29]="255.255.255.248"</span><br /><span>MASKS[30]="255.255.255.252"</span><br /><span>MASKS[31]="255.255.255.254"</span><br /><span></span><br /><span>export CISCO_SPLIT_INC=0</span><br /><span></span><br /><span># Create environment variables that vpnc-script uses to configure network</span><br /><span>function addroute()</span><br /><span>{</span><br /><span>    local ROUTE="$1"</span><br /><span>    export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_ADDR=${ROUTE%%/*}</span><br /><span>    export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_MASKLEN=${ROUTE##*/}</span><br /><span>    export CISCO_SPLIT_INC_${CISCO_SPLIT_INC}_MASK=${MASKS[${ROUTE##*/}]}</span><br /><span>    export CISCO_SPLIT_INC=$((${CISCO_SPLIT_INC}+1))</span><br /><span>}</span><br /><span></span><br /><span>for r in $ROUTES; do</span><br /><span>    addroute $r</span><br /><span>done</span><br /><span></span><br /><span>for l in $INTERNAL_IP4_DNS; do</span><br /><span>    if [ $reason = "connect" ]; then</span><br /><span>        iptables -t nat -A PREROUTING -i zt+ -p udp --dport 53 -j DNAT --to $l</span><br /><span>    elif [ $reason = "disconnect" ]; then</span><br /><span>        iptables -t nat -D PREROUTING -i zt+ -p udp --dport 53 -j DNAT --to $l</span><br /><span>    fi</span><br /><span>    break</span><br /><span>done</span><br /><span></span><br /><span>exec /usr/share/vpnc-scripts/vpnc-script</span><br /></pre></td></tr></table><p>整合一下</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>echo "password" | openconnect address.example.org -u username --passwd-on-stdin --non-inter --script /root/openconnect/script.sh</span><br /></pre></td></tr></table><p>完成。只不过，如果要看 bilibili 还需要设置 DNS 到国内，或者设置到网关上（上面的脚本配置了 DNS 转发）。而且 zerotier 只是为了虚拟局域网设计的，不如 anyconnect 能自动设置网关，路由，DNS方便。不过挺好玩的，还学了不少东西，over。</p>]]></content>
        
        <summary type="html">
            
            每当看到各类教程中的 iptables 指令，在格式参数组合之下可以实现从防火墙，封禁 IP 端口到 NAT 的各种操作，就如同魔法一般，看不明白，却又感到无比强大。想学，但又好像不得要领，稍微不慎可能就再也连不上了。最近配置 Zerotier 的 Nat 网关的时候，看着 教
            
        </summary>
        
        <category term="zerotier"/>
        
        <category term="nat gateway"/>
        
        <category term="full tunnel mode"/>
        
        <category term="iptables"/>
        
    </entry>
    
    <entry>
        <title>Electron-vue开发实战5——开发插件系统之CLI部分</title>
        <link href="https://molunerfinn.com/electron-vue-6/"/>
        <id>https://molunerfinn.com/electron-vue-6/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/electron-vue-6/#前言"></a>前言</h2><p><strong>祝大家2019年猪年新年快乐！本文较长，需要一定耐心看完哦~</strong></p><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2><a href="https://molunerfinn.com/electron-vue-6/#说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a></a><p><strong>说在前面，其实这篇文章写起来真的很难。如何构建一个插件系统，我花了半年的时间。要在一篇或者两篇文章里把这个东西说好是真的不容易。所以可能行文上会有一些瑕疵，后续会不断打磨。</strong></p><h2><a href="https://molunerfinn.com/electron-vue-6/#插件系统——容器"></a>插件系统——容器</h2><p>相信很多人平时更多的是给其他框架诸如<code>Vue</code>、<code>React</code>或者<code>Webpack</code>等写插件。我们可以把提供插件系统的框架称为「容器」，通过容器暴露出来的API，插件可以挂载到容器上，或者接入容器的生命周期来实现一些更定制化的功能。</p><p>比如<code>Webpack</code>本质上是一个流程系统，它通过<a href="https://github.com/webpack/tapable" target="_blank">Tapable</a>暴露了很多生命周期的钩子，插件可以通过接入这些生命周期钩子实现流水线作业——比如<code>babel</code>系列的插件把<code>ES6</code>代码转义成<code>ES5</code>；<code>SASS</code>、<code>LESS</code>、<code>Stylus</code>系列的插件把预处理的<code>CSS</code>代码编译成浏览器可识别的正常<code>CSS</code>代码等等。</p><p>我们要实现一个插件系统，本质上也是实现这么一个容器。这个容器以及对应的插件需要具备如下基本特征：</p><ul><li>容器在没有 <strong>第三方插件</strong> 接入的情况下也能 <strong>实现基本功能</strong></li><li>插件具有独立性</li><li>插件可配置可管理</li></ul><p>第一点应该很容易理解。如果一个插件系统因为没有第三方插件的存在就无法运行，那么这个插件系统有什么用呢？不过有别于第三方插件，很多插件系统有自己内置的插件，比如<code>vue-cli</code>、<code>Webpack</code>的一系列内置插件。这个时候插件系统本身的一些功能就会由内置的插件去实现。</p><p>第二点，插件的独立性是指插件本身运行时不会 <strong>主动</strong> 影响其他插件的运作。当然某个插件可以依赖于其他插件的运行结果。</p><p>第三点，插件如果不能配置不能管理，那么从安装插件阶段就会遇到问题。所以容器需要有设计良好的入口给予插件注册。</p><p>接下来的部分，我将结合<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>与<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>来详细说明CLI插件系统与GUI插件系统如何构建与实现。</p><h2><a href="https://molunerfinn.com/electron-vue-6/#CLI插件系统"></a>CLI插件系统</h2><h3><a href="https://molunerfinn.com/electron-vue-6/#概述"></a>概述</h3><p>其实CLI插件系统可以认为是无GUI的插件系统，也就是运行在命令行或者不带有可视化界面的插件系统。为什么我们开发Electron的插件系统，需要扯到CLI插件系统呢？这里需要简单回顾一下Electron的结构：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fncq342rk8j20cs0d63zd" /></p><p>可以看到除了<code>Renderer</code>的界面渲染，大部分的功能是由<code>Main</code>进程提供的。对于PicGo而言，它的底层应该是一个上传流程系统，如下：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/picgo-core-fix.jpg" /></p><ol><li>Input（输入）：接受来自外部的输入，默认是通过路径或者完整的图片base64信息</li><li>Transformer（转换器）：把输入转换成可以被上传器上传的对象（包含图片尺寸、base64、图片名等信息）</li><li>Uploader（上传器）：将来自转换器的输出上传到指定的地方，默认的上传器将会是SM.MS</li><li>Output（输出）：输出上传的结果，通常可以在输出的imgUrl里拿到结果</li></ol><p>所以理论上它的底层应该在Node.js端就能实现。而Electron的<code>Renderer</code>进程只是实现了GUI界面，去调用底层Node.js端实现的流程系统提供的API而已。类似于我们平时在开发网页时候的前后端分离，只不过现在这个后端是基于Node.js实现的插件系统。基于这个思路，我开始着手<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>的实现。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#生命周期"></a>生命周期</h3><p>通常来说一个插件系统都有自己的一个生命周期，比如<code>Vue</code>有<code>beforeCreate</code>、<code>created</code>、<code>mounted</code>等等，<code>Webpack</code>有<code>beforeRun</code>、<code>run</code>、<code>afterCompile</code>等等。这个也是一个插件系统的灵魂所在，通过接入系统的生命周期，赋予了插件更多的自由度。</p><p>因此我们可以先来实现一个生命周期类。代码可以参考<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/core/Lifecycle.ts" target="_blank">Lifecycle.ts</a>。</p><p>生命周期流程可以参考上面的流程图。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /></pre></td><td><pre><span><span>class</span> Lifecycle {</span><br /><span>  <span>// 整个生命周期的入口</span></span><br /><span>  <span>async</span> start (input: <span>any</span>[]): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>    <span>try</span> {</span><br /><span>      <span>await</span> <span>this</span>.beforeTransform(input)</span><br /><span>      <span>await</span> <span>this</span>.doTransform(input)</span><br /><span>      <span>await</span> <span>this</span>.beforeUpload(input)</span><br /><span>      <span>await</span> <span>this</span>.doUpload(input)</span><br /><span>      <span>await</span> <span>this</span>.afterUpload(input)</span><br /><span>    } <span>catch</span> (e) {</span><br /><span>      <span>console</span>.log(e)</span><br /><span>    }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 获取原始输入，转换前</span></span><br /><span>  <span>private</span> <span>async</span> beforeTransform (input) {</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 将输入转换成Uploader可上传的格式</span></span><br /><span>  <span>private</span> <span>async</span> doTransform (input) {</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>  </span><br /><span>  <span>// Uploader上传前</span></span><br /><span>  <span>private</span> <span>async</span> beforeUpload (input) {</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>  </span><br /><span>  <span>// Uploader上传</span></span><br /><span>  <span>private</span> <span>async</span> doUpload (input) {</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>  </span><br /><span>  <span>// Uploader上传完成后</span></span><br /><span>  <span>private</span> <span>async</span> afterUpload (input) {</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>在实际使用中，我们可以通过：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>const</span> lifeCycle = <span>new</span> LifeCycle()</span><br /><span>lifeCycle.start([...])</span><br /></pre></td></tr></table><p>来运行整个上传流程的生命周期。不过到这里我们还没有看到任何跟插件相关的东西。这是为了实现我们说的第一个条件： 容器在没有 <strong>第三方插件</strong> 接入的情况下也能 <strong>实现基本功能</strong>。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#广播事件"></a>广播事件</h3><p>很多时候我们需要将一些事件以某种方式传递出去。就像发布订阅模型一样，由容器发布，由插件订阅。这个时候我们可以直接让<code>Lifecycle</code>这个类继承Node.js自带的<code>EventEmmit</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>class</span> Lifecycle <span>extends</span> EventEmitter {</span><br /><span>  <span>constructor</span> (<span></span>) {</span><br /><span>    <span>super</span>()</span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><p>那么<code>Lifecycle</code>也就拥有了<code>EventEmitter</code>的<code>emit</code>和<code>on</code>方法了。对于容器来说，我们只需要<code>emit</code>事件出去即可。</p><p>比如在<code>PicGo-Core</code>里，上传的整个流程都会往外广播事件，通知插件当前进行到什么阶段，并且将当前的输入或者输出在广播的时候发送出去。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>private</span> <span>async</span> beforeTransform (input) {</span><br /><span> <span>// ...</span></span><br /><span> <span>this</span>.emit(<span>'beforeTransform'</span>, input) <span>// 广播事件</span></span><br /><span>}</span><br /></pre></td></tr></table><p>插件可以自由选择监听想要监听的事件。比如插件想要知道上传结束后的结果（伪代码）：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>plugin.on(<span>'finished'</span>, <span>(<span>output</span>) =&gt;</span> {</span><br /><span>  <span>console</span>.log(output) <span>// 获取output</span></span><br /><span>})</span><br /></pre></td></tr></table><p>在开发PicGo-Core的时候，有一些很有用的事件。在这里我也想分享出来，虽然不是所有插件系统都会有这样的事件，但是结合自己和项目的实际需要，他们有的时候很有用。</p><h4><a href="https://molunerfinn.com/electron-vue-6/#进度事件"></a>进度事件</h4><p>平时我们上传或者下载文件的时候，都会注意一个东西：进度条。同样，在PicGo-Core里也暴露了一个事件，叫做<code>uploadProgress</code>，用于告诉用户当前的上传进度。不过在PicGo-Core，上传进度是从<code>beforeTransform</code>就开始算了，为了方便计算，划分了5个固定的值。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span><span>private</span> <span>async</span> beforeTransform (input) {</span><br /><span>  <span>this</span>.emit(<span>'uploadProgress'</span>, <span>0</span>) <span>// 转换前，进度0</span></span><br /><span>}</span><br /><span><span>private</span> <span>async</span> doTransform (input) {</span><br /><span>  <span>this</span>.emit(<span>'uploadProgress'</span>, <span>30</span>) <span>// 开始转换，进度30</span></span><br /><span>}</span><br /><span><span>private</span> <span>async</span> beforeUpload (input) {</span><br /><span>  <span>this</span>.emit(<span>'uploadProgress'</span>, <span>60</span>) <span>// 开始上传，进度60</span></span><br /><span>}</span><br /><span><span>private</span> <span>async</span> afterUpload (input) {</span><br /><span>  <span>this</span>.emit(<span>'uploadProgress'</span>, <span>100</span>) <span>// 上传完毕，进度100</span></span><br /><span>}</span><br /></pre></td></tr></table><p>如果上传失败的话就返回<code>-1</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span><span>async</span> start (input: <span>any</span>[]): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span> <span>try</span> {</span><br /><span>   <span>await</span> <span>this</span>.beforeTransform(input)</span><br /><span>   <span>await</span> <span>this</span>.doTransform(input)</span><br /><span>   <span>await</span> <span>this</span>.beforeUpload(input)</span><br /><span>   <span>await</span> <span>this</span>.doUpload(input)</span><br /><span>   <span>await</span> <span>this</span>.afterUpload(input)</span><br /><span> } <span>catch</span> (e) {</span><br /><span>   <span>console</span>.log(e)</span><br /><span>   <span>this</span>.emit(<span>'uploadProgress'</span>, <span>-1</span>)</span><br /><span> }</span><br /><span>}</span><br /></pre></td></tr></table><p>通过监听这个事件，PicGo就能做出如下的上传进度条：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/picgo-2.0.gif" /></p><h4><a href="https://molunerfinn.com/electron-vue-6/#系统通知"></a>系统通知</h4><p>如果上传出了问题，或者有些信息需要通过系统级别的通知告诉用户的话，可以发布<code>notification</code>事件。通过监听这个事件可以调用系统通知来发布。插件也可以发布这个事件，让PicGo监听。如上图上传成功后右上角的通知。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#接入生命周期"></a>接入生命周期</h3><p>上部分讲到了生命周期中的事件广播，可以发现事件广播是只管发不管结果的。也就是PicGo-Core只管发布这个事件，至于有没有插件监听，监听后做了什么都不用关心。（怎么有点像UDP一样）。但是实际上很多时候我们需要接入生命周期做一些事情的。</p><p>就拿上传流程来说，我要是想要上传前压缩图片，那么监听<code>beforeUpload</code>事件是做不到的。因为在<code>beforeUpload</code>事件里就算你把图片已经压缩了，恐怕上传的流程早就走完了，<code>emit</code>事件出去后生命周期照旧运行。</p><p>因此我们需要在容器的生命周期里实现一个功能，能够让插件接入它的生命周期，在执行完当前生命周期的插件的动作后，才把结果送往下一个生命周期。可以发现，这里有一个「等待」插件执行的动作。因此PicGo-Core使用最简易而直观的<code>async</code>函数配合<code>await</code>来实现「等待」。</p><p>我们先不用考虑插件是如何注册的，后文会说到。我们先来实现怎么让插件接入生命周期。</p><p>下面以生命周期<code>beforeUpload</code>为例：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>private</span> <span>async</span> beforeUpload (input) {</span><br /><span>  <span>this</span>.ctx.emit(<span>'uploadProgress'</span>, <span>60</span>)</span><br /><span>  <span>this</span>.ctx.emit(<span>'beforeUpload'</span>, input)</span><br /><span>  <span>// ...</span></span><br /><span>  <span>await</span> <span>this</span>.handlePlugins(beforeUploadPlugins.getList(), input) <span>// 执行并「等待」插件执行结束</span></span><br /><span>}</span><br /></pre></td></tr></table><p>可以看到我们通过<code>await</code>等待生命周期方法<code>handlePlugins</code>（下文会说明如何实现）的执行结束。而我们运行的插件列表是通过<code>beforeUploadPlugins.getList()</code>（下文会说明如何实现）获取的，说明这些是只针对<code>beforeUpload</code>这个生命周期的插件。然后将输入<code>input</code>传入<code>handlePlugins</code>让插件们调用即可。</p><p>现在我们实现一下<code>handlePlugins</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span><span>private</span> <span>async</span> handlePlugins (plugins: Plugin[], input: <span>any</span>[]) {</span><br /><span>  <span>await</span> <span>Promise</span>.all(plugins.map(<span>async</span> (plugin: Plugin) =&gt; {</span><br /><span>    <span>await</span> plugin.handle(input)</span><br /><span>  }))</span><br /><span>}</span><br /></pre></td></tr></table><p>我们通过<code>Promise.all</code>以及<code>await</code>来「等待」所有插件执行。这里需要注意的是，每个PicGo插件需要实现一个<code>handle</code>方法来供<code>PicGo-Core</code>调用。可以看到，这里实现我们说的第二个特征： <strong>插件具有独立性</strong>。</p><p>从这里也能看到我们通过<code>async</code>和<code>await</code>构建了一个能够「等待」插件执行结束的环境。这样就解决了光是通过广播事件无法接入插件系统的生命周期的问题。</p><p>不，等等，这里还有一个问题。<code>beforeUploadPlugins.getList()</code>是哪来的？上面只是一个示例代码。实际上PicGo-Core根据上传流程里的不同生命周期预留了五种不同的插件：</p><ul><li>beforeTransformPlugins</li><li>transformer</li><li>beforeUploadPlugins</li><li>uploader</li><li>afterUploadPlugins</li></ul><p>分别在上传的5个周期里调用。虽然这5种插件调用的时机不一样，但是它们的实现是同样的：有同样的注册机制、同样的方法用于获取插件列表、获取插件信息等等。所以我们接下去来实现一个生命周期的插件类。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#生命周期插件类"></a>生命周期插件类</h3><p>这个是插件系统里很关键的一环，这个类的实现了插件应该以什么方式注册到我们的插件系统里，以及插件系统如何获取他们。这块的代码可以参考 <a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/LifecyclePlugins.ts" target="_blank">LifecyclePlugins.ts</a>。</p><p>以下是实现：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /></pre></td><td><pre><span><span>class</span> LifecyclePlugins {</span><br /><span></span><br /><span>  <span>// list就是插件列表。以对象形式呈现。</span></span><br /><span>  list: {</span><br /><span>    [propName: <span>string</span>]: Plugin</span><br /><span>  }</span><br /><span>  <span>constructor</span> (<span></span>) {</span><br /><span>    <span>this</span>.list = {} <span>// 初始化插件列表为{}</span></span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 插件注册的入口</span></span><br /><span>  register (id: <span>string</span>, plugin: Plugin): <span>void</span> {</span><br /><span>    <span>// 如果插件没有提供id，则不予注册</span></span><br /><span>    <span>if</span> (!id) <span>throw</span> <span>new</span> <span>TypeError</span>(<span>'id is required!'</span>)</span><br /><span>    <span>// 如果插件没有handle的方法，则不予注册</span></span><br /><span>    <span>if</span> (<span>typeof</span> plugin.handle !== <span>'function'</span>) <span>throw</span> <span>new</span> <span>TypeError</span>(<span>'plugin.handle must be a function!'</span>)</span><br /><span>    <span>// 如果插件的id重复了，则不予注册</span></span><br /><span>    <span>if</span> (<span>this</span>.list[id]) <span>throw</span> <span>new</span> <span>TypeError</span>(<span>`<span>${<span>this</span>.name}</span> duplicate id: <span>${id}</span>!`</span>)</span><br /><span>    <span>this</span>.list[id] = plugin</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 通过插件ID获取插件</span></span><br /><span>  <span>get</span> (id: <span>string</span>): Plugin {</span><br /><span>    <span>return</span> <span>this</span>.list[id]</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 获取插件列表</span></span><br /><span>  getList (): Plugin[] {</span><br /><span>    <span>return</span> <span>Object</span>.keys(<span>this</span>.list).map(<span>(<span>item: <span>string</span></span>) =&gt;</span> <span>this</span>.list[item])</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 获取插件ID列表</span></span><br /><span>  getIdList (): <span>string</span>[] {</span><br /><span>    <span>return</span> <span>Object</span>.keys(<span>this</span>.list)</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> LifecyclePlugins</span><br /></pre></td></tr></table><p>对于插件而言最重要的是<code>register</code>方法，它是插件注册的入口。通过<code>register</code>注册后，会在<code>Lifecycle</code>内部的<code>list</code>以<code>id:plugin</code>形式里写入这个插件。注意到，PicGo-Core要求每个插件需要实现一个<code>handle</code>的方法，用于之后在生命周期里调用。</p><p>这里用伪代码说明一下插件要如何注册：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>beforeTransformPlugins.register(<span>'test'</span>, {</span><br /><span>  handle (ctx) {</span><br /><span>    <span>console</span>.log(ctx)</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><p>这里我们就注册了一个<code>id</code>叫做<code>test</code>的插件，它是一个<code>beforeTransform</code>阶段的插件，它的作用就是打印传入的信息。</p><p>然后在不同的生命周期里，调用<code>LifeCyclePlugins.getList()</code>的方法就能获取这个生命周期对应的插件的列表了。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#抽离出核心类"></a>抽离出核心类</h3><p>如果仅仅是实现一个能够在Node.js项目里运行的插件系统，上面两个部分基本就够了：</p><ol><li>Lifecyle类负责整个生命周期</li><li>LifecylePlugins类负责插件的注册与调用</li></ol><p>不过一个良好的CLI插件系统还需要至少如下的部分（至少我觉得）：</p><ol><li>可以通过命令行调用</li><li>能够读取配置文件进行额外配置</li><li>命令行一键安装插件</li><li>命令行完成插件配置</li><li>友好的log信息提示</li></ol><blockquote><p>此处可以参考vue-cli3这个工具。</p></blockquote><p>因此我们至少还需要如下的部分：</p><ol><li>命令行操作相关的类</li><li>配置文件操作相关</li><li>插件安装、卸载、更新等相关操作的类</li><li>插件加载相关的类</li><li>日志信息输出相关的类</li></ol><p>这上面的几个部分都跟生命周期类本身没有特别强的耦合关系，所以可以不必将它们都放到生命周期类里实现。</p><p>相对的，我们抽离出一个<code>Core</code>作为核心，将上述这些类包含到这个核心类中，核心类负责命令行命令的注册、插件的加载、优化日志信息以及调用生命周期等等。</p><p>最后再将这个核心类暴露出去，供使用者或者开发者使用。这个就是PicGo-Core的核心 <a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/core/PicGo.ts" target="_blank">PicGo.ts</a> 的实现。</p><p>PicGo本身的实现并不复杂，基本上只是调用上述几个类实例的方法。</p><p>不过注意到这里有一个之前一直没有提到的东西。PicGo-Core除了核心PicGo之外的几个子类里，基本上在<code>constructor</code>构建函数阶段都会传入一个叫做<code>ctx</code>的参数。这个参数是什么？这个参数是PicGo这个类自身的<code>this</code>。通过传入<code>this</code>，PicGo-Core的子类也能使用PicGo核心类暴露出来的方法了。</p><p>比如<code>Logger</code>类实现了美观的命令行日志输出：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/20180912153940.png" /></p><p>那么在其他子类里想要调用<code>Logger</code>的方法也很容易：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>ctx.log.success(<span>'Hello world!'</span>)</span><br /></pre></td></tr></table><p>其中<code>ctx</code>就是我们上面说的，PicGo自身的<code>this</code>指针。</p><p>我们接下去介绍的每个类具体的实现。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#日志输出相关类"></a>日志输出相关类</h3><p>先从这个类开始说起是因为这个类是最简单而且侵入性最小的一个类。有它没它都行，但是有它自然是锦上添花。</p><p>PicGo实现美化日志输出的库是<a href="https://github.com/chalk/chalk" target="_blank">chalk</a>，它的作用就是用来输出花花绿绿的命令行文字：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6368616c6b2f616e73692d7374796c657340383236313639376339356266333462366337373637653263626539393431613835316435393338352f73637265656e73686f742e737667" /></p><p>用起来也很简单：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>const</span> log = chalk.green(<span>'Success'</span>)</span><br /><span><span>console</span>.log(log) <span>// 绿色字体的Success</span></span><br /></pre></td></tr></table><p>我们打算实现4种输出类型，success、warn、info和error：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/20180912153940.png" /></p><p>于是创建如下的类：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /></pre></td><td><pre><span><span>import</span> chalk <span>from</span> <span>'chalk'</span></span><br /><span><span>import</span> PicGo <span>from</span> <span>'../core/PicGo'</span></span><br /><span></span><br /><span><span>class</span> Logger {</span><br /><span>  level: {</span><br /><span>    [propName: <span>string</span>]: <span>string</span></span><br /><span>  }</span><br /><span>  ctx: PicGo</span><br /><span>  <span>constructor</span> (<span>ctx: PicGo</span>) { <span>// 将PicGo的this传入构造函数，使得Logger也能使用PicGo核心类暴露的方法</span></span><br /><span>    <span>this</span>.level = {</span><br /><span>      success: <span>'green'</span>,</span><br /><span>      info: <span>'blue'</span>,</span><br /><span>      warn: <span>'yellow'</span>,</span><br /><span>      error: <span>'red'</span></span><br /><span>    }</span><br /><span>    <span>this</span>.ctx = ctx</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 实际输出函数</span></span><br /><span>  <span>protected</span> handleLog (<span>type</span>: <span>string</span>, msg: <span>string</span> | <span>Error</span>): <span>string</span> | <span>Error</span> | <span>undefined</span> {</span><br /><span>    <span>if</span> (!<span>this</span>.ctx.config.silent) { <span>// 如果不是静默模式，静默模式不输出log</span></span><br /><span>      <span>let</span> log = chalk[<span>this</span>.level[<span>type</span>]](<span>`[PicGo <span>${<span>type</span>.toUpperCase()}</span>]: `</span>)</span><br /><span>      log += msg</span><br /><span>      <span>console</span>.log(log)</span><br /><span>      <span>return</span> msg</span><br /><span>    } <span>else</span> {</span><br /><span>      <span>return</span></span><br /><span>    }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 对应四种不同类型</span></span><br /><span>  success (msg: <span>string</span> | <span>Error</span>): <span>string</span> | <span>Error</span> | <span>undefined</span> {</span><br /><span>    <span>return</span> <span>this</span>.handleLog(<span>'success'</span>, msg)</span><br /><span>  }</span><br /><span></span><br /><span>  info (msg: <span>string</span> | <span>Error</span>): <span>string</span> | <span>Error</span> | <span>undefined</span> {</span><br /><span>    <span>return</span> <span>this</span>.handleLog(<span>'info'</span>, msg)</span><br /><span>  }</span><br /><span></span><br /><span>  error (msg: <span>string</span> | <span>Error</span>): <span>string</span> | <span>Error</span> | <span>undefined</span> {</span><br /><span>    <span>return</span> <span>this</span>.handleLog(<span>'error'</span>, msg)</span><br /><span>  }</span><br /><span></span><br /><span>  warn (msg: <span>string</span> | <span>Error</span>): <span>string</span> | <span>Error</span> | <span>undefined</span> {</span><br /><span>    <span>return</span> <span>this</span>.handleLog(<span>'warn'</span>, msg)</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> Logger</span><br /></pre></td></tr></table><p>之后再将<code>Logger</code>这个类挂载到PicGo核心类上：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span>import</span> Logger <span>from</span> <span>'../lib/Logger'</span></span><br /><span><span>class</span> PicGo {</span><br /><span>  log: Logger</span><br /><span>  <span>constructor</span> (<span></span>) {</span><br /><span>    <span>// ...</span></span><br /><span>    <span>this</span>.log = <span>new</span> Logger(<span>this</span>) <span>// 把this传入Logger，也就是Logger里的ctx</span></span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><p>这样其他挂载到PicGo核心类上的类就能使用<code>ctx.log</code>来调用log里的方法了。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#配置文件相关"></a>配置文件相关</h3><p>很多时候我们的所写的系统也好、插件也好，或多或少需要一些配置之后才能更好地使用。比如<code>vue-cli3</code>的<code>vue.config.js</code>，比如<code>hexo</code>的<code>_config.yml</code>等等。而PicGo也不例外。默认情况下它可以直接使用，但是如果想要做些其他操作，自然就需要配置了。所以配置文件是插件系统很重要的一个组成部分。</p><p>之前我在Electron版的PicGo上使用了<a href="https://github.com/typicode/lowdb" target="_blank">lowdb</a>作为JSON配置文件的读写库，体验不错。为了向前兼容PicGo的配置，写PicGo-Core的时候我依然采用了这个库。关于lowdb的一些具体用法，我在之前的一篇文章里有提及，有兴趣的可以看看——<a href="https://molunerfinn.com/electron-vue-3/">传送门</a>。</p><p>由于lowdb做的是类似MySQL一样的持久化配置，它需要磁盘上一个具体的JSON文件作为载体，所以无法通过创建一个配置对象去初始化配置。因此一切都从这个配置文件展开：</p><p>PicGo-Core采用一个默认的配置文件：<code>homedir()/.picgo/config.json</code>，如果在实例化PicGo没提供配置文件路径那么就会使用这个文件。如果使用者提供了具体的配置文件，那么就会使用所提供的配置文件。</p><p>下面来实现一下PicGo初始化的过程：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /></pre></td><td><pre><span><span>import</span> fs <span>from</span> <span>'fs-extra'</span></span><br /><span><span>class</span> PicGo <span>extends</span> EventEmitter {</span><br /><span>  configPath: <span>string</span></span><br /><span>  <span>private</span> lifecycle: Lifecycle</span><br /><span>  <span>// ...</span></span><br /><span></span><br /><span>  <span>constructor</span> (<span>configPath: <span>string</span> = ''</span>) {</span><br /><span>    <span>super</span>()</span><br /><span>    <span>this</span>.configPath = configPath <span>// 传入configPath</span></span><br /><span>    <span>this</span>.init()</span><br /><span>  }</span><br /><span></span><br /><span>  init () {</span><br /><span>    <span>if</span> (<span>this</span>.configPath === <span>''</span>) { <span>// 如果不提供配置文件路径，就使用默认配置</span></span><br /><span>      <span>this</span>.configPath = homedir() + <span>'/.picgo/config.json'</span></span><br /><span>    }</span><br /><span>    <span>if</span> (path.extname(<span>this</span>.configPath).toUpperCase() !== <span>'.JSON'</span>) { <span>// 如果配置文件的格式不是JSON就返回错误日志</span></span><br /><span>      <span>this</span>.configPath = <span>''</span></span><br /><span>      <span>return</span> <span>this</span>.log.error(<span>'The configuration file only supports JSON format.'</span>)</span><br /><span>    }</span><br /><span>    <span>const</span> exist = fs.pathExistsSync(<span>this</span>.configPath)</span><br /><span>    <span>if</span> (!exist) { <span>// 如果不存在就创建</span></span><br /><span>      fs.ensureFileSync(<span>`<span>${<span>this</span>.configPath}</span>`</span>)</span><br /><span>    }</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><p>那么在实例化PicGo的时候就是如下这样：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>const</span> PicGo = <span>require</span>(<span>'picgo'</span>)</span><br /><span><span>const</span> picgo = <span>new</span> PicGo() <span>// 不提供配置文件就用默认配置文件</span></span><br /><span></span><br /><span><span>// 或者</span></span><br /><span></span><br /><span><span>const</span> picgo = <span>new</span> PicGo(<span>'./xxx.json'</span>) <span>// 提供配置文件就用所提供的配置文件</span></span><br /></pre></td></tr></table><p>有了配置文件之后，我们只需要实现三个基本操作：</p><ol><li>初始化配置</li><li>读取配置</li><li>写入配置（写入配置包括创建、更新、删除等）</li></ol><h4><a href="https://molunerfinn.com/electron-vue-6/#初始化配置"></a>初始化配置</h4><p>一般来说我们的系统都会有一些默认的配置，PicGo也不例外。我们可以选择把默认配置写到代码里，也可以选择把默认配置写到代码里。因为PicGo的配置文件有持久化的需求，所以把一些关键的默认配置写入配置文件是合理的。</p><p>初始化配置的时候会用到<a href="https://github.com/typicode/lowdb" target="_blank">lowdb</a>的一些知识，这里就不展开了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /></pre></td><td><pre><span><span>import</span> lowdb <span>from</span> <span>'lowdb'</span></span><br /><span><span>import</span> FileSync <span>from</span> <span>'lowdb/adapters/FileSync'</span></span><br /><span></span><br /><span><span>const</span> initConfig = (configPath: <span>string</span>): lowdb.LowdbSync&lt;<span>any</span>&gt; =&gt; {</span><br /><span>  <span>const</span> adapter = <span>new</span> FileSync(configPath, { <span>// lowdb的adapter，用于读取配置文件</span></span><br /><span>    deserialize: (data: <span>string</span>): <span><span>Function</span> =&gt;</span> {</span><br /><span>      <span>return</span> (<span>new</span> <span>Function</span>(<span>`return <span>${data}</span>`</span>))()</span><br /><span>    }</span><br /><span>  })</span><br /><span>  <span>const</span> db = lowdb(adapter) <span>// 暴露出来的db对象</span></span><br /><span></span><br /><span>  <span>if</span> (!db.has(<span>'picBed'</span>).value()) { <span>// 如果没有picBed配置</span></span><br /><span>    db.set(<span>'picBed'</span>, { <span>// 就生成一个默认图床为SM.MS的配置</span></span><br /><span>      current: <span>'smms'</span></span><br /><span>    }).write()</span><br /><span>  }</span><br /><span>  <span>if</span> (!db.has(<span>'picgoPlugins'</span>).value()) { <span>// 同理</span></span><br /><span>    db.set(<span>'picgoPlugins'</span>, {}).write()</span><br /><span>  }</span><br /><span></span><br /><span>  <span>return</span> db <span>// 将db暴露出去让外部使用</span></span><br /><span>}</span><br /></pre></td></tr></table><p>那么在PicGo初始化阶段就可以将<code>configPath</code>传入，来实现配置的初始化，以及获取配置。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>init () {</span><br /><span>  <span>// ...</span></span><br /><span>  <span>let</span> db = initConfig(<span>this</span>.configPath)</span><br /><span>  <span>this</span>.config = db.read().value() <span>// 将配置文件内容存入this.config</span></span><br /><span>}</span><br /></pre></td></tr></table><h4><a href="https://molunerfinn.com/electron-vue-6/#读取配置"></a>读取配置</h4><p>一旦初始化配置之后，要获取配置就很容易了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>import</span> { <span>get</span> } <span>from</span> <span>'lodash'</span></span><br /><span>getConfig (name: <span>string</span> = <span>''</span>): <span>any</span> {</span><br /><span>  <span>if</span> (name) { <span>// 如果提供了配置项的名字</span></span><br /><span>    <span>return</span> <span>get</span>(<span>this</span>.config, name) <span>// 返回具体配置项结果</span></span><br /><span>  } <span>else</span> {</span><br /><span>    <span>return</span> <span>this</span>.config <span>// 否则就返回完整配置</span></span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>这里用到了<code>lodash</code>的<code>get</code>方法，主要是为了方便获取如下情况：</p><p>比如配置内容长这样：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>{</span><br /><span>  <span>"a"</span>: {</span><br /><span>    <span>"b"</span>: <span>true</span></span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>往常我们要获取<code>a.b</code>需要：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>let</span> b = <span>this</span>.config.a.b</span><br /></pre></td></tr></table><p>万一遇到<code>a</code>不存在的时候，那么上面那句话就会报错了。因为<code>a</code>不存在，那么<code>a.b</code>就是<code>undefined.b</code>自然会报错了。而用<code>lodash</code>的<code>get</code>方法则可以避免这个问题，并且可以很方便的获取：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>let</span> b = <span>get</span>(<span>this</span>.config, <span>'a.b'</span>)</span><br /></pre></td></tr></table><p>如果<code>a</code>不存在，那么获取到的结果<code>b</code>也不会报错，而是<code>undefined</code>。</p><h4><a href="https://molunerfinn.com/electron-vue-6/#写入配置"></a>写入配置</h4><p>有了上面的铺垫，写入内容也很简单。通过<code>lowdb</code>提供的接口，写入配置如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>const</span> saveConfig = (configPath: <span>string</span>, config: <span>any</span>): <span><span>void</span> =&gt;</span> {</span><br /><span>  <span>const</span> db = initConfig(configPath)</span><br /><span>  <span>Object</span>.keys(config).forEach(<span>(<span>name: <span>string</span></span>) =&gt;</span> {</span><br /><span>    db.read().set(name, config[name]).write()</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>我们可以用：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>saveConfig(<span>this</span>.configPath, { a: { b: <span>true</span> } })</span><br /></pre></td></tr></table><p>或者：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>saveConfig(<span>this</span>.configPath, { <span>'a.b'</span>: <span>true</span> })</span><br /></pre></td></tr></table><p>上面两种写法都会生成如下配置：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>{</span><br /><span>  <span>"a"</span>: {</span><br /><span>    <span>"b"</span>: <span>true</span></span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>可以看到明显后者更简洁点。这多亏了lowdb里由lodash提供的<code>set</code>方法。</p><p>至此我们已经将配置文件相关的操作实现完了。其实可以把这堆操作封装成一个类的，PicGo-Core在一开始实现的时候觉得东西不多不复杂，所以只是抽成了一个小工具来调用的。当然这个不是关键，关键在于实现了配置文件的相关操作后，你的系统和这个系统的插件都能因此受益。系统可以把跟配置文件相关的操作的API暴露给插件使用。接下去我们一步步来完善这个插件系统。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#插件操作类"></a>插件操作类</h3><p>暂时没想好这个类要取的名字是啥，代码里我写的是<code>pluginHandler</code>，那么就叫它插件操作类吧。这个类主要目的就三个：</p><ol><li>通过<code>npm</code>安装插件 —— install</li><li>通过<code>npm</code>卸载插件 —— uninstall</li><li>通过<code>npm</code>更新插件 —— update</li></ol><p>用<code>npm</code>来分发插件，这是大多数Node.js插件系统会选择的解决方案。毕竟在没有自己的插件商店（比如VSCode）的基础上，<code>npm</code>就是一个天然的「插件商店」。当然发布到<code>npm</code>之上好处还有很多，比如可以十分方便地来对插件进行安装、更新和卸载，比如对Node.js用户来说是0成本的上手。这也是<code>pluginHandler</code>这个类要做的事。</p><blockquote><p><code>pluginHandler</code>相关的实现思路来自<a href="https://github.com/feflow/feflow" target="_blank">feflow</a>，特此感谢。</p></blockquote><p>平时我们安装一个npm模块的时候，很简单：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>npm install xxxx --save</span><br /></pre></td></tr></table><p>不过我们是在当前项目目录的上来安装的。PicGo由于引入了配置文件，所以我们可以直接在配置文件所在的目录里进行插件的安装，这样如果你要卸载PicGo，只要把。但是每次都让用户打开PicGo的配置文件所在的路径去安装插件未免太累了。这样也不优雅。</p><p>相对的，如果我们全局安装了<code>picgo</code>之后，在文件系统任何一个角落里只需要通过<code>picgo install xxx</code>就能安装一个<code>picgo</code>的插件，而不需要定位到PicGo的配置文件所在的文件夹，这样用户体验会好不少。这里大家可以类比<code>vue-cli3</code>安装插件的步骤。</p><p>为了实现这个效果，我们需要通过代码的方式去调用<code>npm</code>这个命令。那么Node.js要如何通过代码去实现命令行调用呢？</p><p>这里我们可以使用<a href="https://github.com/moxystudio/node-cross-spawn" target="_blank">cross-spawn</a>来实现跨平台的、通过代码来调用命令行的目的。</p><p><code>spawn</code>这个方法Node.js原生也有（在child_process里），不过<code>cross-spawn</code>解决了一些跨平台的问题。使用上是一样的。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>const</span> spawn = <span>require</span>(<span>'cross-spawn'</span>)</span><br /><span>spawn(<span>'npm'</span>, [<span>'install'</span>, <span>'@vue/cli'</span>, <span>'-g'</span>])</span><br /></pre></td></tr></table><p>可以看到，它的参数是以数组的形式传入的。</p><p>而我们要实现的插件操作，除了主要命令<code>install</code>、<code>update</code>、<code>uninstall</code>不一样之外，其他的参数都是一样的。所以我们抽离出一个<code>execCommand</code>的方法来实现它们背后的公共逻辑：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /></pre></td><td><pre><span>execCommand (cmd: <span>string</span>, modules: <span>string</span>[], where: <span>string</span>, proxy: <span>string</span> = <span>''</span>): <span>Promise</span>&lt;Result&gt; {</span><br /><span>  <span>return</span> <span>new</span> <span>Promise</span>((resolve: <span>any</span>, reject: <span>any</span>): <span><span>void</span> =&gt;</span> {</span><br /><span>    <span>// spawn的命令行参数是以数组形式传入</span></span><br /><span>    <span>// 此处将命令和要安装的插件以数组的形式拼接起来</span></span><br /><span>    <span>// 此处的cmd指的是执行的命令，比如install\uninstall\update</span></span><br /><span>    <span>let</span> args = [cmd].concat(modules).concat(<span>'--color=always'</span>).concat(<span>'--save'</span>)</span><br /><span>    <span>const</span> npm = spawn(<span>'npm'</span>, args, { cwd: where }) <span>// 执行npm，并通过 cwd指定执行的路径——配置文件所在文件夹</span></span><br /><span></span><br /><span>    <span>let</span> output = <span>''</span></span><br /><span>    npm.stdout.on(<span>'data'</span>, <span>(<span>data: <span>string</span></span>) =&gt;</span> {</span><br /><span>      output += data <span>// 获取输出日志</span></span><br /><span>    }).pipe(process.stdout)</span><br /><span></span><br /><span>    npm.stderr.on(<span>'data'</span>, <span>(<span>data: <span>string</span></span>) =&gt;</span> {</span><br /><span>      output += data <span>// 获取报错日志</span></span><br /><span>    }).pipe(process.stderr)</span><br /><span></span><br /><span>    npm.on(<span>'close'</span>, <span>(<span>code: <span>number</span></span>) =&gt;</span> {</span><br /><span>      <span>if</span> (!code) {</span><br /><span>        resolve({ code: <span>0</span>, data: output }) <span>// 如果没有报错就输出正常日志</span></span><br /><span>      } <span>else</span> {</span><br /><span>        reject({ code: code, data: output }) <span>// 如果报错就输出报错日志</span></span><br /><span>      }</span><br /><span>    })</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>关键的部分基本都已经在代码里给出了注释。当然这里还是有一些需要注意的地方。注意这句话：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>const</span> npm = spawn(<span>'npm'</span>, args, { cwd: where }) <span>// 执行npm，并通过 cwd指定执行的路径——配置文件所在文件夹</span></span><br /></pre></td></tr></table><p>里面的<code>{cwd: where}</code>，这个<code>where</code>是会从外部传进来的值，表示这个<code>npm</code>命令会在哪个目录下执行。这个也是我们要做这个插件操作类最关键的地方——不用让用户主动打开配置文件所在目录去安装插件，在系统任何地方都可以轻松安装PicGo的插件。</p><p>接下去我们实现一下<code>install</code>方法，这样另外两个就可以类推了。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span><span>async</span> install (plugins: <span>string</span>[], proxy: <span>string</span>): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>  plugins = plugins.map(<span>(<span>item: <span>string</span></span>) =&gt;</span> <span>'picgo-plugin-'</span> + item)</span><br /><span>   <span>const</span> result = <span>await</span> <span>this</span>.execCommand(<span>'install'</span>, plugins, <span>this</span>.ctx.baseDir, proxy)</span><br /><span>   <span>if</span> (!result.code) {</span><br /><span>     <span>this</span>.ctx.log.success(<span>'插件安装成功'</span>)</span><br /><span>     <span>this</span>.ctx.emit(<span>'installSuccess'</span>, {</span><br /><span>       title: <span>'插件安装成功'</span>,</span><br /><span>       body: plugins</span><br /><span>     })</span><br /><span>   } <span>else</span> {</span><br /><span>     <span>const</span> err = <span>`插件安装失败，失败码为<span>${result.code}</span>，错误日志为<span>${result.data}</span>`</span></span><br /><span>     <span>this</span>.ctx.log.error(err)</span><br /><span>     <span>this</span>.ctx.emit(<span>'failed'</span>, {</span><br /><span>       title: <span>'插件安装失败'</span>,</span><br /><span>       body: err</span><br /><span>    })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>别看代码很多，关键就一句<code>const result = await this.execCommand('install', plugins, this.ctx.baseDir, proxy)</code>，剩下的都是日志输出而已。好了，插件也安装完了，如何加载呢？</p><h3><a href="https://molunerfinn.com/electron-vue-6/#插件加载类"></a>插件加载类</h3><p>上面说了，我们会将插件安装在配置文件所在目录里。值得注意的是，由于<code>npm</code>的特点，如果目录里有个叫做<code>package.json</code>的文件，那么安装插件、更新插件等操作会同时修改<code>package.json</code>文件。因此我们可以通过读取<code>package.json</code>文件来得知当前目录下有什么PicGo的插件。这也是Hexo的插件加载机制里的很重要的一环。</p><blockquote><p><code>pluginLoader</code>相关的实现思路来自<a href="https://github.com/hexojs/hexo" target="_blank">hexo</a>，特此感谢。</p></blockquote><p>关于插件的命名，PicGo这里有个约束（这也是很多插件系统选择的方式），必须以<code>picgo-plugin-</code>开头。这样才能方便插件加载类识别它们。</p><p>这里有一个小坑。如果我们配置文件所在的目录里没有<code>package.json</code>的话，那么执行安装插件的命令会有报错信息。但是我们不想让用户看到这个报错，于是在初始化<code>插件加载类</code>的时候，需要判断一下这个文件存不存在，如果不存在那么我们就要创建一个：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /></pre></td><td><pre><span><span>class</span> PluginLoader {</span><br /><span>  ctx: PicGo</span><br /><span>  list: <span>string</span>[]</span><br /><span>  <span>constructor</span> (<span>ctx: PicGo</span>) {</span><br /><span>    <span>this</span>.ctx = ctx</span><br /><span>    <span>this</span>.list = [] <span>// 插件列表</span></span><br /><span>    <span>this</span>.init()</span><br /><span>  }</span><br /><span></span><br /><span>  init (): <span>void</span> {</span><br /><span>    <span>const</span> packagePath = path.join(<span>this</span>.ctx.baseDir, <span>'package.json'</span>)</span><br /><span>    <span>if</span> (!fs.existsSync(packagePath)) { <span>// 如果不存在</span></span><br /><span>      <span>const</span> pkg = {</span><br /><span>        name: <span>'picgo-plugins'</span>,</span><br /><span>        description: <span>'picgo-plugins'</span>,</span><br /><span>        repository: <span>'https://github.com/Molunerfinn/PicGo-Core'</span>,</span><br /><span>        license: <span>'MIT'</span></span><br /><span>      }</span><br /><span>      fs.writeFileSync(packagePath, <span>JSON</span>.stringify(pkg), <span>'utf8'</span>) <span>// 创建这个文件</span></span><br /><span>    }</span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><p>接下来我们要实现最关键的<code>load</code>方法了。我们需要如下步骤：</p><ol><li>先通过<code>package.json</code>来找到所有合法的插件</li><li>通过<code>require</code>来加载插件</li><li>通过维护<code>picgoPlugins</code>配置来判断插件是否被禁用</li><li>通过执行未被禁用的插件暴露的<code>register</code>方法来实现插件注册</li></ol><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /></pre></td><td><pre><span><span>import</span> PicGo <span>from</span> <span>'../core/PicGo'</span></span><br /><span><span>import</span> fs <span>from</span> <span>'fs-extra'</span></span><br /><span><span>import</span> path <span>from</span> <span>'path'</span></span><br /><span><span>import</span> resolve <span>from</span> <span>'resolve'</span></span><br /><span></span><br /><span>load (): <span>void</span> | <span>boolean</span> {</span><br /><span>  <span>const</span> packagePath = path.join(<span>this</span>.ctx.baseDir, <span>'package.json'</span>)</span><br /><span>  <span>const</span> pluginDir = path.join(<span>this</span>.ctx.baseDir, <span>'node_modules/'</span>)</span><br /><span>    <span>// Thanks to hexo -&gt; https://github.com/hexojs/hexo/blob/master/lib/hexo/load_plugins.js</span></span><br /><span>  <span>if</span> (!fs.existsSync(pluginDir)) { <span>// 如果插件文件夹不存在，返回false</span></span><br /><span>    <span>return</span> <span>false</span></span><br /><span>  }</span><br /><span>  <span>const</span> json = fs.readJSONSync(packagePath) <span>// 读取package.json</span></span><br /><span>  <span>const</span> deps = <span>Object</span>.keys(json.dependencies || {})</span><br /><span>  <span>const</span> devDeps = <span>Object</span>.keys(json.devDependencies || {})</span><br /><span>  <span>// 1.获取插件列表</span></span><br /><span>  <span>const</span> modules = deps.concat(devDeps).filter(<span>(<span>name: <span>string</span></span>) =&gt;</span> {</span><br /><span>    <span>if</span> (!<span>/^picgo-plugin-|^@[^/]+\/picgo-plugin-/</span>.test(name)) <span>return</span> <span>false</span></span><br /><span>    <span>const</span> path = <span>this</span>.resolvePlugin(<span>this</span>.ctx, name) <span>// 获取插件路径</span></span><br /><span>    <span>return</span> fs.existsSync(path)</span><br /><span>  })</span><br /><span>  <span>for</span> (<span>let</span> i <span>in</span> modules) {</span><br /><span>    <span>this</span>.list.push(modules[i]) <span>// 把插件push进插件列表</span></span><br /><span>    <span>if</span> (<span>this</span>.ctx.config.picgoPlugins[modules[i]] || <span>this</span>.ctx.config.picgoPlugins[modules[i]] === <span>undefined</span>) { <span>// 3.判断插件是否被禁用，如果是undefined则为新安装的插件，默认不禁用</span></span><br /><span>      <span>try</span> {</span><br /><span>        <span>this</span>.getPlugin(modules[i]).register() <span>// 4.调用插件的`register`方法进行注册</span></span><br /><span>        <span>const</span> plugin = <span>`picgoPlugins[<span>${modules[i]}</span>]`</span></span><br /><span>        <span>this</span>.ctx.saveConfig( <span>// 将插件设为启用--&gt;让新安装的插件的值从undefined变成true</span></span><br /><span>          {</span><br /><span>            [plugin]: <span>true</span></span><br /><span>          }</span><br /><span>        )</span><br /><span>      } <span>catch</span> (e) {</span><br /><span>        <span>this</span>.ctx.log.error(e)</span><br /><span>        <span>this</span>.ctx.emit(<span>'notification'</span>, {</span><br /><span>          title: <span>`Plugin <span>${modules[i]}</span> Load Error`</span>,</span><br /><span>          body: e</span><br /><span>        })</span><br /><span>      }</span><br /><span>    }</span><br /><span>  }</span><br /><span>}</span><br /><span>resolvePlugin (ctx: PicGo, name: <span>string</span>): <span>string</span> { <span>// 获取插件路径</span></span><br /><span>  <span>try</span> {</span><br /><span>    <span>return</span> resolve.sync(name, { basedir: ctx.baseDir })</span><br /><span>  } <span>catch</span> (err) {</span><br /><span>    <span>return</span> path.join(ctx.baseDir, <span>'node_modules'</span>, name)</span><br /><span>  }</span><br /><span>}</span><br /><span>getPlugin (name: <span>string</span>): <span>any</span> { <span>// 通过插件名获取插件</span></span><br /><span>  <span>const</span> pluginDir = path.join(<span>this</span>.ctx.baseDir, <span>'node_modules/'</span>)</span><br /><span>  <span>return</span> <span>require</span>(pluginDir + name)(<span>this</span>.ctx) <span>// 2.通过require获取插件并传入ctx</span></span><br /><span>}</span><br /></pre></td></tr></table><p><code>load</code>这个方法是整个插件系统加载的最关键的部分。光看上面的步骤和代码可能没办法很好理解。我们下面用一个具体的插件例子来说明。</p><p>假设我写了一个<code>picgo-plugin-xxx</code>的插件。我的代码如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /></pre></td><td><pre><span><span>// 插件系统会传入picgo的ctx，方便插件调用picgo暴露出来的api</span></span><br /><span><span>// 所以我们需要有一个ctx的参数用于接收来自picgo的api</span></span><br /><span><span>module</span>.exports = <span><span>ctx</span> =&gt;</span> {</span><br /><span></span><br /><span>  <span>// 插件系统会调用这个方法来进行插件的注册</span></span><br /><span>  <span>const</span> register = <span><span>()</span> =&gt;</span> {</span><br /><span>    ctx.helper.beforeTransformPlugins.register(<span>'xxx'</span>, {</span><br /><span>      handle (ctx) { <span>// 调用插件的 handle 方法时也会传入 ctx 方便调用api</span></span><br /><span>        <span>console</span>.log(ctx.output)</span><br /><span>      }</span><br /><span>    })</span><br /><span>  }</span><br /><span></span><br /><span>  <span>return</span> {</span><br /><span>    register</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>我们从前文已经大概知道插件运行流程：</p><ol><li>首先运行生命周期</li><li>当运行到某个生命周期，比如这里的<code>beforeTransform</code>，那么这个阶段就去获取<code>beforeTransformPlugins</code>这些插件</li><li><code>beforeTransformPlugins</code>这些插件由<code>ctx.helper.beforeTransformPlugins.register</code>方法注册，并可以通过<code>ctx.helper.beforeTransformPlugins.getList()</code>获取</li><li>拿到插件之后将调用每个<code>beforeTransformPlugins</code>的<code>handle</code>方法，并传入<code>ctx</code>供插件使用</li></ol><p>注意上面的第三步，<code>ctx.helper.beforeTransformPlugins.register</code>这个方法是在什么时候被调用的？答案就是在本小节介绍的插件的加载阶段，<code>pluginLoader</code>调用了每个插件的<code>register</code>方法，那么在插件的<code>register</code>方法里，我们写了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>ctx.helper.beforeTransformPlugins.register(<span>'xxx'</span>, {</span><br /><span>  handle (ctx) { <span>// 调用插件的 handle 方法时也会传入 ctx 方便调用api</span></span><br /><span>    <span>console</span>.log(ctx.output)</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><p>也就是在这个时候，<code>ctx.helper.beforeTransformPlugins.register</code>这个方法被调用。</p><p>于是乎，在生命周期开始之前，整个插件以及每个生命周期的插件已经预先被注册了。所以在生命周期开始运作的时候，只需要通过<code>getList()</code>就可以获取注册过的插件，从而执行整个流程了。</p><p>也因此，我以前在跑<code>Hexo</code>生成博客的时候曾经遇到的问题就得到解释了。我以前安装过一些<code>Hexo</code>的插件，但是不知道为什么总是无法生效。后来发现是安装的时候没有使用<code>--save</code>，导致它们没被写入<code>package.json</code>的依赖字段。而<code>Hexo</code>加载插件的第一步就是从<code>package.json</code>里获取合法的插件列表，如果插件不在<code>package.json</code>里，哪怕在<code>node_modules</code>里有，也不会生效了。</p><p>有了插件，接下去我们讲讲如何在命令行调用和配置了。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#命令行操作类"></a>命令行操作类</h3><p>PicGo的命令行操作类主要依赖于两个库：<a href="https://github.com/tj/commander.js/" target="_blank">commander.js</a>和<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank">Inquirer.js</a>。这两个也是做Node.js命令行应用很常用的库了。前者负责命令行解析、执行相关命令。后者负责提供与用户交互的命令行界面。</p><p>比如你可以输入：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>picgo use uploader</span><br /></pre></td></tr></table><p>这个时候由<code>commander.js</code>去解析这句命令，告诉我们这个时候调用的是<code>use</code>这个命令，参数是<code>uploader</code>，那么就进入<code>Inquirer.js</code>提供的交互式界面了：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/5c529491e27e4.png" /></p><p>如果你用过诸如<code>vue-cli3</code>或者<code>create-react-app</code>等类似的命令行工具一定类似的情况很熟悉。</p><p>首先我们写一个命令行操作类，用于暴露api给其他部分注册命令，此处源码可以参考<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/Commander.ts" target="_blank">Commander.ts</a>。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /></pre></td><td><pre><span><span>import</span> PicGo <span>from</span> <span>'../core/PicGo'</span></span><br /><span><span>import</span> program <span>from</span> <span>'commander'</span></span><br /><span><span>import</span> inquirer <span>from</span> <span>'inquirer'</span></span><br /><span><span>import</span> { Plugin } <span>from</span> <span>'../utils/interfaces'</span></span><br /><span><span>const</span> pkg = <span>require</span>(<span>'../../package.json'</span>)</span><br /><span></span><br /><span><span>class</span> Commander {</span><br /><span>  list: {</span><br /><span>    [propName: <span>string</span>]: Plugin</span><br /><span>  }</span><br /><span>  program: <span>typeof</span> program</span><br /><span>  inquirer: <span>typeof</span> inquirer</span><br /><span>  <span>private</span> ctx: PicGo</span><br /><span></span><br /><span>  <span>constructor</span> (<span>ctx: PicGo</span>) {</span><br /><span>    <span>this</span>.list = {}</span><br /><span>    <span>this</span>.program = program</span><br /><span>    <span>this</span>.inquirer = inquirer</span><br /><span>    <span>this</span>.ctx = ctx</span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> Commander</span><br /></pre></td></tr></table><p>然后我们在PicGo-Core的核心类里将其实例化：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>import</span> Commander <span>from</span> <span>'../lib/Commander'</span></span><br /><span><span>class</span> PicGo <span>extends</span> EventEmitter {</span><br /><span>  <span>// ...</span></span><br /><span>  cmd: Commander</span><br /><span></span><br /><span>  <span>constructor</span> (<span>configPath: <span>string</span> = ''</span>) {</span><br /><span>    <span>super</span>()</span><br /><span>    <span>this</span>.cmd = <span>new</span> Commander(<span>this</span>)</span><br /><span>    <span>// ...</span></span><br /><span>  }</span><br /><span>  <span>// ...</span></span><br /></pre></td></tr></table><p>这样其他部分就可以使用<code>ctx.cmd.program</code>来调用<code>commander.js</code>以及使用<code>ctx.cmd.inquirer</code>来调用<code>Inquirer.js</code>了。</p><p>这两个库的使用，网络上有很多教程了。此处简单举个例子，我们从PicGo最基本的功能——命令行上传图片开始说起。</p><h4><a href="https://molunerfinn.com/electron-vue-6/#命令的注册"></a>命令的注册</h4><p>为了与之前的插件结构统一，我们把命令注册也写到<code>handle</code>函数里。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /></pre></td><td><pre><span><span>import</span> PicGo <span>from</span> <span>'../../core/PicGo'</span></span><br /><span><span>import</span> path <span>from</span> <span>'path'</span></span><br /><span><span>import</span> fs <span>from</span> <span>'fs-extra'</span></span><br /><span></span><br /><span><span>export</span> <span>default</span> {</span><br /><span>  handle: (ctx: PicGo): <span><span>void</span> =&gt;</span> {</span><br /><span>    <span>const</span> cmd = ctx.cmd</span><br /><span>    cmd.program <span>// 此处是一个commander.js实例</span></span><br /><span>      .command(<span>'upload'</span>) <span>// 注册命令 upload</span></span><br /><span>      .description(<span>'upload, go go go'</span>) <span>// 命令的描述</span></span><br /><span>      .arguments(<span>'[input...]'</span>) <span>// 命令的参数</span></span><br /><span>      .alias(<span>'u'</span>) <span>// 命令的别名 u</span></span><br /><span>      .action(<span>async</span> (input: <span>string</span>[]) =&gt; { <span>// 命令执行的函数</span></span><br /><span>        <span>const</span> inputList = input <span>// 获取输入的input</span></span><br /><span>            .map(<span>(<span>item: <span>string</span></span>) =&gt;</span> path.resolve(item))</span><br /><span>            .filter(<span>(<span>item: <span>string</span></span>) =&gt;</span> {</span><br /><span>              <span>const</span> exist = fs.existsSync(item) <span>// 判断输入的地址存不存在</span></span><br /><span>              <span>if</span> (!exist) {</span><br /><span>                ctx.log.warn(<span>`<span>${item}</span> is not existed.`</span>) <span>// 如果不存在就返回警告信息</span></span><br /><span>              }</span><br /><span>              <span>return</span> exist</span><br /><span>            })</span><br /><span>        <span>await</span> ctx.upload(inputList) <span>// 上传图片（调用生命周期的start函数）</span></span><br /><span>      })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>这样我们如果通过某种方式把命令注册进去：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>import</span> PicGo <span>from</span> <span>'../../core/PicGo'</span></span><br /><span><span>import</span> upload <span>from</span> <span>'./upload'</span></span><br /><span><span>// ...</span></span><br /><span></span><br /><span><span>export</span> <span>default</span> (ctx: PicGo): <span><span>void</span> =&gt;</span> {</span><br /><span>  ctx.cmd.register(<span>'upload'</span>, upload) <span>// 此处的注册逻辑跟lifecyclePlugins一致。</span></span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><p>当代码写到这里，可能大家觉得已经大功告成了。实际上还差了最后一步，我们缺少一个入口来接纳我们输入的命令。就比如现在我们写完了命令，也写完了命令的注册，然后我们要怎么在命令行里使用呢？</p><h4><a href="https://molunerfinn.com/electron-vue-6/#命令行的使用"></a>命令行的使用</h4><p>这个时候要简单说下<code>package.json</code>里的两个字段<code>bin</code>和<code>main</code>。其中<code>main</code>字段指向的文件，是你<code>const xxx = require('xxx')</code>的时候拿到的东西。而<code>bin</code>字段指向的文件，就是你在全局安装了之后，可以在命令行里直接输入的命令。</p><p>举个例子，PicGo-Core的<code>bin</code>字段如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>// ...</span></span><br /><span>"bin": {</span><br /><span>  "picgo": "./bin/picgo"</span><br /><span>},</span><br /></pre></td></tr></table><p>那么用户如果全局安装了picgo，就可以通过<code>picgo</code>这个命令来使用picgo了。类似安装<code>@vue/cli</code>之后，可以使用<code>vue</code>这个命令一样。</p><p>那么我们来看看<code>./bin/picgo</code>做了啥。源码在<a href="https://github.com/PicGo/PicGo-Core/blob/dev/bin/picgo" target="_blank">这里</a>。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /></pre></td><td><pre><span><span>#!/usr/bin/env node</span></span><br /><span><span>const</span> path = <span>require</span>(<span>'path'</span>)</span><br /><span><span>const</span> minimist = <span>require</span>(<span>'minimist'</span>)</span><br /><span><span>let</span> argv = minimist(process.argv.slice(<span>2</span>)) <span>// 解析命令行</span></span><br /><span><span>let</span> configPath = argv.c || argv.config || <span>''</span> <span>// 查看是否提供了configPath</span></span><br /><span><span>if</span> (configPath !== <span>true</span> &amp;&amp; configPath !== <span>''</span>) {</span><br /><span>  configPath = path.resolve(configPath)</span><br /><span>} <span>else</span> {</span><br /><span>  configPath = <span>''</span></span><br /><span>}</span><br /><span><span>const</span> PicGo = <span>require</span>(<span>'../dist/index'</span>)</span><br /><span><span>const</span> picgo = <span>new</span> PicGo(configPath) <span>// 实例化picgo</span></span><br /><span>picgo.registerCommands() <span>// 注册命令</span></span><br /><span></span><br /><span><span>try</span> {</span><br /><span>  picgo.cmd.program.parse(process.argv) <span>// 调用commander.js解析命令</span></span><br /><span>} <span>catch</span> (e) {</span><br /><span>  picgo.log.error(e)</span><br /><span>  <span>if</span> (process.argv.includes(<span>'--debug'</span>)) {</span><br /><span>    <span>Promise</span>.reject(e)</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>关键部分就在<code>picgo.cmd.program.parse(process.argv)</code>这句话，这句话调用了<code>commander.js</code>来解析<code>process.argv</code>，也就是命令行里命令以及参数。</p><p>那么我们在开发阶段就可以用<code>./bin/picgo upload</code>这样来调用命令，而在生产环境下，也就是用户全局安装后，就可以通过<code>picgo upload</code>这样来调用命令了。</p><h4><a href="https://molunerfinn.com/electron-vue-6/#配置项的处理"></a>配置项的处理</h4><p>前文提到了，配置项是插件系统里很重要的一个组成部分。不同插件系统的配置项处理不太一样。比如<code>Hexo</code>提供了<code>_config.yml</code>供用户配置，<code>vue-cli3</code>提供了<code>vue.config.js</code>供用户配置。PicGo也提供了<code>config.json</code>供用户配置，不过在此基础上，我想提供一个更方便的方式来让用户直接在命令行里完成配置，而不需要专门打开这个配置文件。</p><p>比如我们可以通过命令行来选择当前上传的图床是什么：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /></pre></td><td><pre><span>$ picgo use</span><br /><span>? Use an uploader (Use arrow keys)</span><br /><span>  smms</span><br /><span>❯ tcyun</span><br /><span>  weibo</span><br /><span>  github</span><br /><span>  qiniu</span><br /><span>  imgur</span><br /><span>  aliyun</span><br /><span>(Move up and down to reveal more choices)</span><br /></pre></td></tr></table><p>这种在命令行里的交互，需要之前提到的<code>Inquirer.js</code>来辅助我们达到这个效果。</p><p>它的用法也很简单，传入一个<code>prompts</code>（可以理解为一个问题数组），然后它会将问题的结果再以对象的形式返回出来，我们通常将这个结果记为<code>answer</code>。</p><p>而PicGo为了简化这个过程，只需要插件提供一个<code>config</code>方法，这个方法只需返回一个合法的<code>prompts</code>问题数组，然后PicGo会自动调用<code>Inquirer.js</code>去执行它，并自动将结果写入配置文件里。</p><p>举个例子，PicGo内置的<code>Imgur</code>图床的<code>config</code>代码如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /></pre></td><td><pre><span><span>const</span> config = (ctx: PicGo): PluginConfig[] =&gt; {</span><br /><span>  <span>let</span> userConfig = ctx.getConfig(<span>'picBed.imgur'</span>)</span><br /><span>  <span>if</span> (!userConfig) {</span><br /><span>    userConfig = {}</span><br /><span>  }</span><br /><span>  <span>const</span> config = [</span><br /><span>    {</span><br /><span>      name: <span>'clientId'</span>,</span><br /><span>      <span>type</span>: <span>'input'</span>,</span><br /><span>      <span>default</span>: userConfig.clientId || <span>''</span>,</span><br /><span>      required: <span>true</span></span><br /><span>    },</span><br /><span>    {</span><br /><span>      name: <span>'proxy'</span>,</span><br /><span>      <span>type</span>: <span>'input'</span>,</span><br /><span>      <span>default</span>: userConfig.proxy || <span>''</span>,</span><br /><span>      required: <span>false</span></span><br /><span>    }</span><br /><span>  ]</span><br /><span>  <span>return</span> config <span>// 这个config就是一个合法的prompts数组</span></span><br /><span>}</span><br /><span><span>export</span> <span>default</span> {</span><br /><span>  <span>// ...</span></span><br /><span>  config</span><br /><span>}</span><br /></pre></td></tr></table><p>然后我们用代码实现能够在命令行里调用它，源码<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/plugins/commander/setting.ts" target="_blank">传送门</a>：</p><blockquote><p>以下代码有所精简</p></blockquote><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /></pre></td><td><pre><span><span>import</span> PicGo <span>from</span> <span>'../../core/PicGo'</span></span><br /><span><span>import</span> { PluginConfig } <span>from</span> <span>'../../utils/interfaces'</span></span><br /><span></span><br /><span><span>// 处理uploader的config数组，然后写入配置文件</span></span><br /><span><span>const</span> handleConfig = <span>async</span> (ctx: PicGo, prompts: PluginConfig, name: <span>string</span>): <span>Promise</span>&lt;<span>void</span>&gt; =&gt; {</span><br /><span>  <span>const</span> answer = <span>await</span> ctx.cmd.inquirer.prompt(prompts)</span><br /><span>  <span>let</span> configName = <span>`picBed.<span>${name}</span>`</span></span><br /><span>  ctx.saveConfig({</span><br /><span>    [configName]: answer</span><br /><span>  })</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> {</span><br /><span>  handle: (ctx: PicGo): <span><span>void</span> =&gt;</span> {</span><br /><span>    <span>const</span> cmd: <span>typeof</span> ctx.cmd = ctx.cmd</span><br /><span>    cmd.program</span><br /><span>      .command(<span>'set'</span>) <span>// 注册一个set命令</span></span><br /><span>      .alias(<span>'config'</span>) <span>// 别名 config</span></span><br /><span>      .description(<span>'configure config of picgo'</span>)</span><br /><span>      .action(<span>async</span> () =&gt; {</span><br /><span>        <span>try</span> {</span><br /><span>          <span>let</span> prompts = [ <span>// prompts问题数组</span></span><br /><span>            {</span><br /><span>              <span>type</span>: <span>'list'</span>,</span><br /><span>              name: <span>'uploader'</span>,</span><br /><span>              choices: ctx.helper.uploader.getIdList(), <span>// 获取Uploader列表</span></span><br /><span>              message: <span>`Choose a(n) uploader`</span>,</span><br /><span>              <span>default</span>: ctx.config.picBed.uploader || ctx.config.picBed.current</span><br /><span>            }</span><br /><span>          ]</span><br /><span>          <span>let</span> answer = <span>await</span> ctx.cmd.inquirer.prompt(prompts) <span>// 等待inquirer处理用户的输入</span></span><br /><span>          <span>const</span> item = ctx.helper.uploader.get(answer.uploader) <span>// 获取用户选择的uploader</span></span><br /><span>          <span>if</span> (item.config) { <span>// 如果uploader提供了config方法</span></span><br /><span>            <span>await</span> handleConfig(ctx, item.config(ctx), answer.uploader) <span>//处理该config方法暴露出的prompts数组</span></span><br /><span>          }</span><br /><span>          ctx.log.success(<span>'Configure config successfully!'</span>)</span><br /><span>        } <span>catch</span> (e) {</span><br /><span>          ctx.log.error(e)</span><br /><span>          <span>if</span> (process.argv.includes(<span>'--debug'</span>)) {</span><br /><span>            <span>Promise</span>.reject(e)</span><br /><span>          }</span><br /><span>        }</span><br /><span>      })</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>上面是针对Uploader的config方法进行的配置处理，对于其他插件也是同理的，就不再赘述。这样我们就实现了能够通过命令行快速对配置文件进行配置，用户体验又是++。</p><h2><a href="https://molunerfinn.com/electron-vue-6/#插件系统发布"></a>插件系统发布</h2><p>讲了那么多，我们都是在本地书写的插件系统，如何发布让别人能够安装使用呢？关于往npm发布模块有很多相关文章，比如参考这篇<a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank">文章</a>。我在这里想讲的是如何发布一个既能在命令行使用，又可以通过比如<code>const picgo = require('picgo')</code>在Node.js项目里使用API调用的库。</p><h3><a href="https://molunerfinn.com/electron-vue-6/#CLI与API调用并存"></a>CLI与API调用并存</h3><p>其实这个上面的部分里也提到了。我们在发布一个npm库的时候通常是在<code>package.json</code>里的<code>main</code>字段指定这个库的入口文件。那么这样使用者就可以通过比如<code>const picgo = require('picgo')</code>在Node.js项目里使用。</p><p>如果我们想要让这个库安装之后能够注册一个命令，那么我们可以在<code>bin</code>字段里指定这个命令已经对应的入口文件。比如：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>// ...</span></span><br /><span>"bin": {</span><br /><span>  "picgo": "./bin/picgo"</span><br /><span>},</span><br /></pre></td></tr></table><p>这样我们在全局安装之后就会在系统里注册一个叫做<code>picgo</code>的命令了。</p><p>当然这个时候<code>bin</code>和<code>main</code>的入口文件通常是不一样的。<code>bin</code>的入口文件需要做好解析命令行的功能。所以通常我们会使用一些命令行解析的库例如<code>minimist</code>或者<code>commander.js</code>等等来解析命令行里的参数。</p><h2><a href="https://molunerfinn.com/electron-vue-6/#小结"></a>小结</h2><p>至此，一个CLI插件系统的关键部分我们就基本实现了。那么我们在Electron项目里，可以在<code>main</code>进程里使用我们所写的插件系统，并通过这个插件暴露的API来打造应用的插件系统了。下一篇文章会详细讲述如何把CLI插件系统整合进Electron，实现GUI插件系统，并加入一些额外的机制，使得在GUI上的插件系统更加灵活而强大。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>和<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote><h2><a href="https://molunerfinn.com/electron-vue-6/#参考文献"></a>参考文献</h2><p>感谢这些高质量的文章：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/38730825" target="_blank">用Node.js开发一个Command Line Interface (CLI)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26895282" target="_blank">Node.js编写CLI的实践</a></li><li><a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism" target="_blank">Node.js模块机制</a></li><li><a href="https://onetwo.ren/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" target="_blank">前端插件系统设计与实现</a></li><li><a href="https://blog.csdn.net/kyfxbl/article/details/47787827" target="_blank">Hexo插件机制分析</a></li><li><a href="http://blog.yunplus.io/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/" target="_blank">如何实现一个简单的插件扩展</a></li><li><a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank">使用NPM发布与维护TypeScript模块</a></li><li><a href="https://github.com/basarat/ts-npm-module" target="_blank">typescript npm 包例子</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/" target="_blank">通过travis-ci发布npm包</a></li><li><a href="https://discuss.atom.io/t/dynamically-load-module-in-plugin-from-local-project-node-modules-folder/42930/2" target="_blank">Dynamic load module in plugin from local project node_modules folder</a></li><li><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html" target="_blank">跟着老司机玩转Node命令行</a></li><li>以及没来得及记录的那些好文章，感谢你们！</li></ol>]]></content>
        
        <summary type="html">
            
            前言祝大家2019年猪年新年快乐！本文较长，需要一定耐心看完哦~前段时间，我用electron-vue开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>2018小结</title>
        <link href="https://molunerfinn.com/2018-summary/"/>
        <id>https://molunerfinn.com/2018-summary/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>终于把研究生开题的事情弄得差不多了，可以抽空写一下2018年的小结了。</p><a></a><p>今年和去年一样，也是格外忙。不仅实验室活多，还要兼顾研究生的开题等。跟去年一样，列一个今年学习成果清单：</p><h1><a href="https://molunerfinn.com/2018-summary/#过去的一年"></a>过去的一年</h1><h2><a href="https://molunerfinn.com/2018-summary/#技术成果"></a>技术成果</h2><ul><li><p><strong>2019.01.13</strong>（插播） <a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> 发布v2.0版本，正式支持插件系统。star数破3200，下载量破26k。【Electron】</p></li><li><p><strong>2018.08.28</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> star数破2000，下载量破12k。【Electron】</p></li><li><p><strong>2018.07.19</strong> <a href="https://github.com/Molunerfinn/PicGo-Core" target="_blank">PicGo-Core</a> 开坑PicGo底层流程系统，将支持插件系统【Node+TypeScript】</p></li><li><p><strong>2018.07.11</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> 更新v1.6版本，支持阿里云OSS，imgur，mini窗口，批量删除等功能。【Electron】</p></li><li><p><strong>2018.05.23</strong> 为VSCode的<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank">amVim-for-VSCode</a>插件提交的支持<code>:</code>呼出<code>Command Palette</code>并实现部分Vim命令的<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank">PR</a>被合并。【TypeScript】</p></li><li><p><strong>2018.05.17</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> star数破800，下载数破5k。【Electron】</p></li><li><p><strong>2018.05.15</strong> 开发推来推趣3期后台时遇到微信二维码支付相关功能的开发，总结了一篇<a href="https://molunerfinn.com/koa2-wechatpay/">《基于Koa2开发微信二维码扫码支付相关流程》</a>的经验文。【Koa】</p></li><li><p><strong>2018.05.09</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a> 更新v1.5版本，支持腾讯云COSv5、GitHub图床、重命名等新功能。【Electron】</p></li><li><p><strong>2018.03.28</strong> <a href="https://github.com/Molunerfinn/node-github-profile-summary" target="_blank">node-github-profile-summary</a>和<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank">vue-koa-demo</a>的Docker话。【Docker】</p></li><li><p><strong>2018.03.10~2018.05.31</strong> 推来推趣3期后台（全栈）迭代。【Vue+Koa+Graphql】</p></li><li><p><strong>2018.03.06</strong> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank">hexo-theme-melody</a> 更新v1.5版本，支持iframe、支持slides等特性。【hexo+hexo-theme】</p></li><li><p><strong>2018.01.17~2018.03.28</strong> 开坑<a href="https://github.com/Molunerfinn/node-github-profile-summary" target="_blank">node-github-profile-summary</a>，可以生成漂亮的GitHub总结报告。【Vue+Koa+Chart.js+Graphql】</p></li><li><p><strong>2018.01.11~2018.05.08</strong> 写了<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue开发实战系列教程</a>，用于记录自己开发PicGo的坑以及帮助新人入门Electron开发。【Electron】</p></li></ul><p>对比去年给自己立的目标：</p><ul><li>算法、数据结构 【一部分】</li><li>Parcel 【没有】</li><li>TypeScript 【用上了】</li><li>Puppeteer自动化测试 【没有】</li><li>PWA 【有新的体验】</li><li>给开源库提PR 【完成】</li><li>github robot 【没有】</li><li>如果可以，学习一下react 【碰了皮毛】</li></ul><p>感觉完成度不够高，不及去年同期对2016年的目标的实现。主要是没有预料到下半年研究生的开题的战线耗时这么久。从2018年8月开始我就没有发过笔记或者技术文章了，真的非常惭愧。</p><h1><a href="https://molunerfinn.com/2018-summary/#期望、目标"></a>期望、目标</h1><p>依然要写下2019年需要学习的东西：</p><ul><li>算法、数据结构</li><li>Flutter入门</li><li>PWA</li><li>学习react</li><li>Puppeteer使用</li></ul><p>感觉把目标缩小点应该完成度会更高。毕竟19年要开始找实习和正式工作+写研究生毕设了。</p><h1><a href="https://molunerfinn.com/2018-summary/#小结"></a>小结</h1><p>这一年来的前端的学习之路，收获还是不少的。比起2017年来说，我感觉最大的收获就是阅读源码的能力提高了。虽然不是什么高深的源码，不过相比之前对阅读源码有恐惧心理的自己，还是好了不少。</p><p>5月份的时候，那段时间我的Mac上的VSCode的Vim插件变得异常卡，可以参考这个<a href="https://github.com/VSCodeVim/Vim/issues/2021" target="_blank">issue</a>。无奈之下只能把官方的Vim插件替换掉，换成了<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank">amVim-for-VSCode</a>，当初刚换上的时候，操作如丝般顺滑！不过当时发现它不支持<code>:</code>带来的一系列操作，比如<code>:w</code>保存，<code>:q</code>退出等。于是我萌生了一个想法，能不能把VSCodeVim的操作移植到amVim上？在阅读了VSCodeVim的源码之后，我也模仿了它的实现，把一部分常用的命令移植到了amVim上，并最终成功被作者<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank">合并</a>。</p><p>这次提交PR的过程，我也发了一篇<a href="https://molunerfinn.com/vscode-extension-develop-1/">文章</a>作为记录。应该说这次经历过后我对阅读源码的恐惧感减轻了不少，这也为之后的<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>的开发带来很大的帮助。</p><p>8月份之后很长的一段时间里，除了在做研究生开题相关的东西，我基本就是在开发<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>了。如果你有用过<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，那么你应该知道它的1.x版本是不支持插件系统的。而且内置的只有有限的8个图床。（如果你不知道<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，欢迎使用，对你的文章写作有很大帮助~）。<code>PicGo</code>里我收到最多的issue，应该就是<code>能否支持XXX图床</code>。如果是一开始写PicGo的时候，我一般会在下一个版本里更新新的图床支持。但是支持到第8个的时候我发现这样无限地支持下去不是一个办法。正巧有个用户提出一个<a href="https://github.com/Molunerfinn/PicGo/issues/26#issuecomment-370105520" target="_blank">想法</a>：能否将对各种图床的支持，做成插件化的管理，类似 Core + Plugins 这样的模式。</p><p>我为此思考了好久，发现这样是可行而且非常合理的。于是我开始找相关的资料——我一开始的想法只是在Electron内部实现一个插件系统。为此我去找了不少例子，比如VSCode、Kap、Atom、Hyper等用Electron写的工具，想看看他们的插件系统是如何实现的。发现他们的实现相对比较复杂。对我来说我是想要实现一个底层的上传流程系统。</p><p>后来我想到了Hexo也是有插件系统的，于是就去阅读了Hexo的插件系统如何实现。在看Hexo插件系统实现的同时，我还发现了另外一个工具<a href="https://segmentfault.com/a/1190000013362598" target="_blank">feflow的插件系统实现</a>。不过我后来发现，feflow的插件体系其实底层大部分是「抄」的hexo的源码的，尤其一个很经典的例子…</p><p><img src="https://i.loli.net/2019/01/18/5c4135bf942d9.png" /></p><p>于是我就把feflow的文章当做hexo插件系统实现的解析文章了哈哈。</p><p>在充分理解了hexo插件如何实现了之后，我也开始着手我自己的<a href="https://github.com/PicGo/PicGo-Core" target="_blank">PicGo-Core</a>了。当然我并没有完全照搬hexo的实现，因为我发现那样的话不利于插件开发者开发插件（主要是语法提示），hexo的插件机制是暴露全局的<code>hexo</code>变量去实现的。</p><p><code>PicGo-Core</code>的流程大概如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-core-fix.jpg" /></p><p>输入路径或者变量等-&gt;经过转换器转换-&gt;上传器上传-&gt;输出结果。中间包含着三个生命周期钩子。这样的话用户开发插件可以只实现其中的某个部分，也可以实现其中的某几个部分，来实现<code>PicGo</code>原先不能实现的一些功能：</p><ol><li>比如上传非图片文件</li><li>比如上传图片前压缩、加水印</li><li>比如通过已知URL上传图片</li></ol><p>等等。</p><p>我也正式使用了<code>TypeScript</code>作为<code>PicGo-Core</code>的开发语言，使用起来一开始确实很不习惯，但是后来越用越顺手，学习新东西的过程大概都是这样吧！</p><p>在开发<code>PicGo-Core</code>的过程中，我也做了很多除了上面流程系统之外的工作。比如：</p><ol><li>要让用户在命令行和Node里都能使用，我为此基于<a href="https://github.com/tj/commander.js/" target="_blank">commander.js</a>和<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank">Inquirer.js</a>给<code>PicGo-Core</code>加上了命令行支持，同样插件也能支持注册命令等操作。</li><li>为了方便其他开发者开发插件，首先我得写好一个插件模板<a href="https://github.com/PicGo/picgo-template-plugin" target="_blank">picgo-template-plugin</a>，并学习了<code>vue-cli2</code>和<code>vue-cli3</code>对于模板生成的实现，写了一个下载模板、生成模板的命令<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/plugins/commander/init.ts" target="_blank">init</a>，好让插件开发者能够快速创建插件模板进行插件开发。</li><li>为了让使用者方便下载使用插件，我写了一个<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/PluginHandler.ts" target="_blank">PluginHandler</a>用于调用<code>npm</code>命令来下载插件。</li><li>除了写代码，还得写文档，没有文档怎么能有其他开发者为你开发插件呢？所以还花了很大的精力写了<code>PicGo-Core</code>的<a href="https://picgo.github.io/PicGo-Core-Doc/zh/" target="_blank">文档</a>，配图、示例一应俱全。</li></ol><p>开发完Node版本的<code>PicGo-Core</code>之后，我还要将它和Electron版本的<code>PicGo</code>整合起来，使得Electron版本的<code>PicGo</code>也能拥有插件系统。并且还得通过<code>ipcMain</code>等方式，将主进程的信息通知给渲染进程，从而渲染出插件页面里的插件列表：</p><p><img src="https://user-images.githubusercontent.com/12621342/50515434-bc9e8180-0adf-11e9-8c71-0e39973c06b1.png" /></p><p>为了让插件开发者能够更好地利用GUI版本的优势，我还为GUI版本的PicGo插件加了GUI插件特有的<code>guiApi</code>、<code>guiMenu</code>等功能：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" /></p><p>这样插件拥有自己的菜单，可以执行自己的操作，那么能做的事就更多了，比如：</p><ol><li>结合GitHub刚刚开放的免费私人仓库，可以通过插件实现PicGo的相册以及配置文件同步。</li><li>结合TinyPng等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）</li><li>结合一些Canvas工具，可以在上传图片前给图片加水印。</li><li>通过指定文件夹，将文件夹内部的markdown里的图片地址进行图床迁移。</li></ol><p>等等。。</p><p>终于，在2019年1月13号，PicGo迎来了2.0版本的<a href="https://github.com/Molunerfinn/PicGo/releases/" target="_blank">更新</a>。</p><p>回顾这些工作，都是我一个人在半年的时间里通过课余的时间做出来的，其实还是很自豪的。更关键的是，通过开放了插件系统，可以让更多的人参与到PicGo软件的完善中来，通过插件可以实现很多本体不提供或者不足的功能，也是让PicGo更加强大的一个条件。我也希望它日后也能形成自己的一个小生态。</p><p>实际上，PicGo-Core以及PicGo2.0发布之后，就已经有第三方开发者开发插件了，速度之快让我始料未及。为此我也迅速加上了<a href="https://github.com/PicGo/Awesome-PicGo" target="_blank">Awesome-PicGo</a>的仓库，这样能让更多的开发者的作品让用户看到：</p><p><img src="https://i.loli.net/2019/01/18/5c413c6300681.png" /></p><p>你已经可以在VSCode里搜索PicGo，就能发现VSCode版的PicGo扩展了，实现了三种在Markdown里快速上传图片的方式：</p><ul><li>通过截图上传</li></ul><p><img src="https://camo.githubusercontent.com/e7898449cadc72bb7045319e4195a5210fef60cf/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656430333335373761302e676966" /></p><ul><li>通过文件浏览器上传</li></ul><p><img src="https://camo.githubusercontent.com/955c32665b55b1ac85ec9696cc51fddcb740076d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656433366430643964332e676966" /></p><ul><li>通过输入文件路径上传</li></ul><p><img src="https://camo.githubusercontent.com/f2cb528b4fcca4e64f6e6bf80d1e25ea47b85483/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656432333836623761632e676966" /></p><p>2019年，我会更新几篇文章，主要讲讲如何实现一个插件系统，如何将Node端实现的插件系统整合到Electron端，如何实现一个模板下载、生成功能，如何实现良好的命令行交互等等。</p><p>2019年也是我找实习、找正式工作的一年，希望今年一切都顺利吧！</p>]]></content>
        
        <summary type="html">
            
            终于把研究生开题的事情弄得差不多了，可以抽空写一下2018年的小结了。今年和去年一样，也是格外忙。不仅实验室活多，还要兼顾研究生的开题等。跟去年一样，列一个今年学习成果清单：过去的一年技术成果2019.01.13（插播） PicGo 发布v2.0版本，正式支持插件系统。star
            
        </summary>
        
        <category term="日志"/>
        
        <category term="随笔"/>
        
    </entry>
    
    <entry>
        <title>图床「神器」PicGo v2.0更新，插件系统终于来了</title>
        <link href="https://molunerfinn.com/picgo-v2.0-update/"/>
        <id>https://molunerfinn.com/picgo-v2.0-update/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/picgo-v2.0-update/#前言"></a>前言</h2><p>距离上次更新(v1.6.2)已经过去了5个月，很抱歉2.0版本来得这么晚。本来想着在18年12月（PicGo一周年的时候）发布2.0版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥你们的无限想象，PicGo也能成为一个极致的效率工具。</p><p>除了发布PicGo 2.0<a href="https://github.com/Molunerfinn/PicGo/releases/" target="_blank">本体</a>，一同发布的还有<a href="https://picgo.github.io/PicGo-Core-Doc/" target="_blank">PicGo-Core</a>（PicGo 2.0的底层，支持CLI和API调用），以及VSCode的PicGo插件<a href="https://github.com/Spades-S/vs-picgo" target="_blank">vs-picgo</a>等。</p><a></a><h3><a href="https://molunerfinn.com/picgo-v2.0-update/#插件系统"></a>插件系统</h3><p>PicGo的底层核心其实是<code>PicGo-Core</code>。这个核心主要就是一个流程系统。(它支持在Node.js环境下全局安装，可以通过命令行上传图片文件、也可以接入Node.js项目中调用api实现上传。)</p><p><code>PicGo-Core</code>的上传流程如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-core-fix.jpg" /></p><p><code>Input</code>一般是文件路径，经过<code>Transformer</code>读取信息，传入<code>Uploader</code>进行上传，最后通过 <code>Output</code> 输出结果。而插件可以接入三个生命周期（<code>beforeTransform</code>、<code>beforeUpload</code>、<code>afterUpload</code>）以及两种部件（<code>Transformer</code>和<code>Uploader</code>）。</p><p>换句话说，如果你书写了合适的<code>Uploader</code>，那么可以上传到不同的图床。如果你书写了合适的<code>Transformer</code>，你可以通过URL先行下载文件再通过<code>Uploader</code>上传等等。</p><p>另外，如果你不想下载PicGo的electron版本，也可以通过npm安装picgo来实现命令行一键上传图片的快速体验。</p><p>PicGo除了<code>PicGo-Core</code>提供的核心功能之外，额外给GUI插件给予一些自主控制权。</p><p>比如插件可以拥有自己的菜单项：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" /></p><p>因此GUI插件除了能够接管<code>PicGo-Core</code>给予的上传流程，还可以通过PicGo提供的guiApi等接口，在插件页面实现一些以前单纯通过<code>上传区</code>实现不了的功能：</p><p>比如可以通过打开一个<code>InputBox</code>获取用户的输入：</p><p><img src="https://i.loli.net/2019/01/12/5c39aa4dab0b4.png" /></p><p>可以通过打开一个路径来执行其他功能（而非只是上传文件）：</p><p><img src="https://i.loli.net/2019/01/12/5c39aea61e80d.gif" /></p><p>甚至还可以直接在插件面板通过调用api实现上传。</p><p>另外插件可以监听相册里图片删除的事件：</p><p><img src="https://i.loli.net/2019/01/12/5c39b3c8746cf.png" /></p><p>这个功能就可以写一个插件来实现相册图片和远端存储里的同步删除了。</p><p>通过如上介绍，我现在甚至就已经能想到插件系统能做出哪些有意思的插件了。</p><p>比如：</p><ol><li>结合GitHub刚刚开放的免费私人仓库，可以通过插件实现PicGo的相册以及配置文件同步。</li><li>结合TinyPng等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）</li><li>结合一些Canvas工具，可以在上传图片前给图片加水印。</li><li>通过指定文件夹，将文件夹内部的markdown里的图片地址进行图床迁移。</li><li>等等。。</li></ol><p>希望这个插件系统能够给PicGo带来更强大的威力，也希望它能够成为你的极致的效率工具。</p><p><strong>需要注意的是，想要使用PicGo 2.0的插件系统，需要先行安装<a href="https://nodejs.org/en/" target="_blank">Node.js</a>环境，因为PicGo的插件安装依赖<code>npm</code>。</strong></p><h2><a href="https://molunerfinn.com/picgo-v2.0-update/#2-0其他更新内容"></a>2.0其他更新内容</h2><p>除了上面说的插件系统，PicGo 2.0还更新了如下内容：</p><ul><li>底层重构了之后，某些图床上传不通过<code>base64</code>值的将会提升不少速度。比如<code>SM.MS</code>图床等。而原本就通过<code>base64</code>上传的图床速度不变。</li><li>增加一些配置项，比如打开配置文件（包括了上传的图片列表）、mini窗口置顶、代理设置等。<br /><img src="https://user-images.githubusercontent.com/12621342/50515474-ea83c600-0adf-11e9-8022-52f4ab9e0ea5.png" /></li><li>在相册页可以选择复制的链接格式，不用再跑去上传页改了。<br /><img src="https://user-images.githubusercontent.com/12621342/50515502-17d07400-0ae0-11e9-80b9-c38f25b64922.png" /></li><li>增加不同页面切换的淡入淡出动画。</li><li>macOS版本配色小幅更新。（Windows版本配色更新Fluent Design效果预计在2.1版本上线）</li><li>更新electron版本从1.8-&gt;4.0，启动速度更快了，性能也更好了。</li></ul><h2><a href="https://molunerfinn.com/picgo-v2.0-update/#Bug-Fixed"></a>Bug Fixed</h2><ul><li>修复：macOS多屏下打开详细窗口时位置错误的<a href="https://github.com/Molunerfinn/PicGo/issues/128" target="_blank">问题</a>。</li><li>修复：多图片上传重命名一致的<a href="https://github.com/Molunerfinn/PicGo/issues/136" target="_blank">问题</a>。</li><li>修复：拖拽图片到软件会自动在软件内部打开这张图片的<a href="https://github.com/Molunerfinn/PicGo/issues/140" target="_blank">bug</a>。</li><li>修复：重命名窗口只出现在屏幕中央而不是跟随主窗口的<a href="https://github.com/Molunerfinn/PicGo/issues/145" target="_blank">bug</a>。</li></ul><h2><a href="https://molunerfinn.com/picgo-v2.0-update/#VSCode的PicGo插件vs-picgo"></a>VSCode的PicGo插件vs-picgo</h2><p>在PicGo-Core发布不久，就有人根据PicGo-Core的API编写了VSCode版的PicGo插件。使用起来也非常方便：</p><ul><li>截图上传</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/1684764986e5edd7?w=891&amp;h=498&amp;f=gif&amp;s=297594" /></p><ul><li>文件浏览器选择文件上传</li></ul><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/vs-picgo-explorer.gif" /></p><ul><li>输入文件路径上传</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/1684765698ad41fe?w=891&amp;h=498&amp;f=gif&amp;s=155843" /></p><p>配置项与PicGo的图床的配置项基本保持一致。在VSCode插件栏搜索PicGo即可下载安装与体验！</p><h2><a href="https://molunerfinn.com/picgo-v2.0-update/#结语"></a>结语</h2><p>PicGo第一个稳定版本是在少数派上发布的，详见<a href="https://sspai.com/post/42310" target="_blank">PicGo：基于 Electron 的图片上传工具</a>。支持macOS、Windows、Linux三平台，开源免费，界面美观，也得到了很多朋友的认可。如果你对它有什么意见或者建议，也欢迎在<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank">issues</a>里指出。如果你喜欢它，不妨给它点个star。如果对你真的很有帮助，不妨请我喝杯咖啡（PicGo的GitHub<a href="https://github.com/Molunerfinn/PicGo" target="_blank">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><blockquote><p>Windows用户请下载<code>.exe</code>文件，macOS用户请下载<code>.dmg</code>文件，Linux用户请下载<code>.AppImage</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
        
        <summary type="html">
            
            前言距离上次更新(v1.6.2)已经过去了5个月，很抱歉2.0版本来得这么晚。本来想着在18年12月（PicGo一周年的时候）发布2.0版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>Rsync使用文档</title>
        <link href="https://linkthis.me/2019/01/11/usage-examples-of-rsync/"/>
        <id>https://linkthis.me/2019/01/11/usage-examples-of-rsync/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>由于太菜导致反复翻车</p>
</blockquote>

<p>Rsync其实还是挺好用的，就是参数有点多，所以留一个记录。<br /></p>

<h3>Rsync服务端配置</h3>

<p>Rsync的主要配置文件有rsyncd.conf（主配置文件）、rsyncd.secrets（密码文件）、rsyncd.motd（rysnc服务器信息）。Rsync不会自动创建对应的配置文件，需要自己手动创建：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>touch</span> /etc/rsyncd.conf
<span>touch</span> /etc/rsyncd.secrets
<span>chmod </span>600 /etc/rsyncd.secrets <span>#此步骤不可忽略，否则会备份失败，而且服务端与客户端均需设置</span>
<span>touch</span> /etc/rsyncd.motd <span>#Rsync服务端欢迎信息，非必须</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后编辑<code>rsyncd.conf</code>进行服务端配置：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td><pre><span># 进程相关全局配置</span>
<span># pid file 守护进程pid文件</span>
<span># address在独立运行时，用于指定的服务器运行的 IP 地址，由xinetd允许rsyncd时忽略此参数</span>
<span># 运行rsync守护进程的用户</span>
uid <span>=</span> root
<span># 运行rsync守护进程的组</span>
gid <span>=</span> root
<span># 若为true，则 rsync 在传输文件之前首先 chroot 到 path 参数所指定的目录下</span>
<span># chroot为yes时必须使用root权限，不能备份指向path外部的符号连接所指向的目录文件</span>
use <span>chroot</span> <span>=</span> <span>yes</span>
<span># 是否检查口令文件的权限</span>
strict modes <span>=</span><span>yes</span>
<span># 默认端口873</span>
port <span>=</span> 873
<span># pid文件的存放位置</span>
pid file <span>=</span> /var/run/rsyncd.pid
<span># 锁文件的存放位置</span>
lock file <span>=</span> /var/run/rsync.lock
<span># 日志相关</span>
<span># log file 指定rsync发送消息日志文件，而不是发送给syslog，如果不填这个参数默认发送给syslog</span>
<span># transfer logging 是否记录传输文件日志</span>
<span># log format 日志文件格式，格式参数请google</span>
<span># syslog facility rsync发送消息给syslog时的消息级别，</span>
<span># timeout连接超时时间</span>
log file <span>=</span> /var/log/rsyncd.log
transfer logging <span>=</span> <span>yes
</span>log format <span>=</span> %t %a %m %f %b
syslog facility <span>=</span> local3
<span>timeout</span> <span>=</span> 300
<span># 只读</span>
<span>read </span>only <span>=</span> <span>yes</span>
<span># 只写</span>
<span>#write only = no</span>
<span># 允许访问rsyncd服务的ip，ip端或者单独ip之间使用空格隔开</span>
hosts allow <span>=</span> 192.168.1.0
<span># 不允许访问rsyncd服务的ip，*为全部拒绝（不覆盖在hosts allow中声明的ip，注意和hosts allow的先后顺序）</span>
<span>#hosts deny = *</span>
<span># 客户端最大连接数</span>
max connections <span>=</span> 4
<span># 欢迎文件路径，非必须</span>
<span>#motd file = /etc/rsyncd/rsyncd.motd</span>
<span># 设置不需要压缩的文件</span>
dont compress   <span>=</span> <span>*</span>.gz <span>*</span>.tgz <span>*</span>.zip <span>*</span>.z <span>*</span>.Z <span>*</span>.rpm <span>*</span>.deb <span>*</span>.bz2

<span># 模块配置（多个）</span>
<span># 模块名称必须使用[]环绕。如要访问bak,则地址应该是xxx@192.168.1.2::bak</span>
<span>[</span>bak]
<span># 模块根目录，必须指定</span>
<span>path</span><span>=</span>/opt/server
<span># 是否允许列出模块里的内容</span>
<span>list</span><span>=</span>no
<span># 忽略错误</span>
<span>#ignore errors</span>
<span># 模块验证用户名称，可使用空格或者逗号隔开多个用户名；如果没有这行，则表明是匿名</span>
auth <span>users</span> <span>=</span> <span>link</span>
<span>#模块验证密码文件 可放在全局配置里</span>
secrets <span>file</span><span>=</span>/etc/rsyncd.secrets
<span># 模块注释</span>
<span>#comment = some description about this moudle</span>
<span># 指定多个由空格隔开的多个文件或目录(相对路径)，并将其添加到 exclude 列表中。</span>
<span>#exclude =</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>auth users</code>与系统用户名无关，仅为Rsyncz自身的用户管理。一个模块<strong>只能</strong>指定一个exclude参数、一个include参数。<code>path</code>如果在末尾不加<code>/</code>表示备份时应包括末尾的目录，加<code>/</code>则只备份目录下的文件。<br />
Rsync的认证口令文件中每一行指定一个用户名，格式为：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>username:passwd
</pre></td></tr></tbody></table></code></pre></div></div>

<p>为了让Rsync长期运行，参考其提供的<code>service</code>文件进行编写：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>[</span>Unit]
<span>Description</span><span>=</span>fast remote file copy program daemon
<span>After</span><span>=</span>network.target
<span>ConditionPathExists</span><span>=</span>/etc/rsyncd.conf

<span>[</span>Service]
<span>Type</span><span>=</span>simple
<span>ExecStart</span><span>=</span>/usr/bin/rsync <span>--daemon</span> <span>--no-detach</span>
<span>Restart</span><span>=</span>always
<span>User</span><span>=</span>root

<span>[</span>Install]
<span>WantedBy</span><span>=</span>multi-user.target
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>--no-detach</code>选项表示Rsync以daemon形式运行时，不从终端中将自己分离出来，工作在前台，应在使用各种daemon管理工具时添加。如果Rsync是由sshd或inetd派生出来的，则该选项无效。<br /></p>

<h3>Rsync客户端配置</h3>

<p>客户端只需要安装Rsync即可，然后创建Rsync的密码文件并添加对应模块的密码：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>echo</span> <span>"passwd"</span> <span>&gt;</span>/etc/rsyncd.secrets
<span>chmod </span>600 /etc/rsyncd.secrets
</pre></td></tr></tbody></table></code></pre></div></div>

<p>客户端的密码文件中<strong>无需</strong>包含<code>auth users</code>，否则会报错。<br />
然后添加对应的定时执行命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>crontab <span>-e</span>
30 0 <span>*</span> <span>*</span> <span>*</span> /usr/bin/rsync <span>-arzvtopg</span> linkthis@1.1.1.4::bak /opt/server <span>--password-file</span><span>=</span>/etc/rsyncd.secrets
</pre></td></tr></tbody></table></code></pre></div></div>

<p>由于是定时执行命令，无法在终端输入密码，所以应在命令中指定密码文件。<br />
使用的参数说明：<br />
<code>-a, --archive</code>：归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD<br />
<code>-r, --recursive</code>：对子目录以递归模式处理<br />
<code>-z, --compress</code>：对备份的文件在传输时进行压缩处理<br />
<code>-v, --verbose</code>：详细模式输出<br />
<code>-t, --times</code>：保留修改时间<br />
<code>-o, --owner</code>：保留所有者<br />
<code>--p, --perms</code>：保留权限<br />
<code>-g, --group</code>：保留组<br />
如果同步的设备之间<strong>权限不同</strong>，应去掉<code>-topg</code>以免发生错误。<br />
Rsync命令繁多，加以组合可以完成不同的同步或备份需求，同步时搭配<code>Inotify</code>可以实现精确的自动化流程。<br /></p>

<blockquote>
  <p>要是我有钱就不会这么折腾了。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               由于太菜导致反复翻车   Rsync其实还是挺好用的，就是参数有点多，所以留一个记录。  Rsync服务端配置  Rsync的主要配置文件有rsyncd.conf（主配置文件）、rsyncd.secrets（密码文件）、rsyncd.motd（rysnc服务器信息）。Rs
            
        </summary>
        
        <category term="Rsync"/>
        
        <category term="记录"/>
        
    </entry>
    
    <entry>
        <title>Telegram RSS机器人</title>
        <link href="https://linkthis.me/2019/01/01/rss-bot-with-telegram/"/>
        <id>https://linkthis.me/2019/01/01/rss-bot-with-telegram/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>信任<code>Systemd</code>的人，最终……</p>
</blockquote>

<p>搭建一个Telegram的RSSBot，可以方便地订阅自己感兴趣的信息源，并实时接收RSS消息推送。<br /></p>

<h3>准备Telegram Bot</h3>

<p>首先需要申请一个Telegram的机器人，即Bot。在Telegram中找到<code>@BotFather</code>，开始对话并根据提示创建一个新的Bot即可，在创建过程中生成的<code>API TOKEN</code>需要记住以便使用。<br />
然后输入<code>mybots</code>找到刚才创建的Bot并选择，点击<code>Edit Bot</code>，选择<code>Edit Commands</code>输入RSSBot的命令：</p>

<pre><code>rss       - 显示当前订阅的 RSS 列表，加 raw 参数显示链接
sub       - 订阅一个 RSS: /sub http://example.com/feed.xml
unsub     - 退订一个 RSS: /unsub http://example.com/feed.xml
unsubthis - 使用此命令回复想要退订的 RSS 消息即可退订, 不支持 Channel
export    - 导出为 OPML
</code></pre>

<h3>安装RSSBot</h3>

<p>使用iovxw开源的<a href="https://github.com/iovxw/rssbot" target="_blank">项目</a>。<br />
选择使用预编译版本以节约时间，Linux版本为<code>musl</code>静态链接, 无需其他依赖。</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>apt <span>install </span>unzip
wget https://github.com/iovxw/rssbot/releases/download/v1.4.3/rssbot-v1.4.3-linux.zip
unzip rssbot-v1.4.3-linux.zip
</pre></td></tr></tbody></table></code></pre></div></div>

<p>解压完成之后即可运行：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>./rssbot DATAFILE TELEGRAM-BOT-TOKEN
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>DATAFILE</code>为数据库保存路径(JSON文件，无需手动创建)。<code>TELEGRAM-BOT-TOKEN</code>为刚才创建的机器人对应的<code>Token</code>。<br /></p>

<h4>Systemd配置</h4>

<p>为了保证RSSbot持续运行和管理，使用<code>Systemd</code>进行操作。<br />
执行<code>vi /etc/systemd/system/rssbot.service</code>，参考以下内容：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>[</span>Unit]
<span>Description</span><span>=</span>A RSS Bot
<span>After</span><span>=</span>network.target
<span>Wants</span><span>=</span>network.target

<span>[</span>Service]
<span>Type</span><span>=</span>simple
<span>WorkingDirectory</span><span>=</span>/home/rss
<span>ExecStart</span><span>=</span>/home/rss/rssbot DATAFILE TELEGRAM-BOT-TOKEN
<span>Restart</span><span>=</span>on-failure
<span>RestartSec</span><span>=</span>10
<span>User</span><span>=</span>rss

<span>[</span>Install]
<span>WantedBy</span><span>=</span>multi-user.target
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后执行：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>systemctl daemon-reload
systemctl <span>enable </span>rssbot
systemctl start rssbot
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果需要定时重启等操作，编写对应的<code>Time</code>文件即可。<br /></p>

<h4>Bot命令示例</h4>

<p>个人订阅：<code>/sub &lt;RSS 地址&gt;</code><br />
频道订阅：<code>/sub @channelname &lt;RSS 地址&gt;</code><br />
查看个人订阅列表：<code>/rss</code><br />
查看个人订阅列表并显示订阅链接：<code>/rss raw</code><br />
如果需要把机器人加入频道，则机器人的身份需要为<strong>管理员</strong>。<br /></p>

<blockquote>
  <p><code>Systemd</code>真香。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               信任Systemd的人，最终……   搭建一个Telegram的RSSBot，可以方便地订阅自己感兴趣的信息源，并实时接收RSS消息推送。  准备Telegram Bot  首先需要申请一个Telegram的机器人，即Bot。在Telegram中找到@BotFather，
            
        </summary>
        
        <category term="Telegram"/>
        
        <category term="RSS"/>
        
    </entry>
    
    <entry>
        <title>Openwrt IPv6 配置</title>
        <link href="https://linkthis.me/2018/12/04/ipv6-on-openwrt/"/>
        <id>https://linkthis.me/2018/12/04/ipv6-on-openwrt/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>从起点出发然后回到起点。</p>
</blockquote>

<h3>OpenWRT IPv6</h3>

<p>之前一直只有教育网或者局部地区测试的IPv6现在已经大范围推开，大部分地区的ISP均<strong>正确部署</strong>了IPv6。通常来说，Openwrt获取IPv6的方式有三种：中继、穿透和NAT，由于ISP已经提供了IPv6和某些方案的缺陷，择优采取中继的方案。<br /></p>

<h3>准备</h3>

<p>首先将光猫的模式调为<strong>桥接</strong>或者<strong>混合</strong>模式，然后通过电脑拨号确认ISP是否已经正确配置IPv6。<br />
然后升级路由器的Openwrt的版本，最好不要低于17.01，否则<code>odhcpd</code>可能会出现问题，当然更老的版本也能正确获取IPv6，不过可能需要每隔一段时间就重启一次<code>odhcpd</code>。<br /></p>

<h3>配置</h3>

<p>从Openwrt 15.xx（即CC版本）开始，<strong>默认</strong>的初始设置中就会含有<code>wan6</code>，无需安装其它软件包。<br />
由于Openwrt默认分配IPv6私网网段，首先应该删除<code>网络&gt;接口</code>页面内<code>IPv6 ULA 前缀</code>配置自动生成的<code>fd</code>开头的<code>/64</code>随机IPv6地址段并保存生效。<del>其实这个时候，在较新版本的Openwrt上面应该已经成功获取了IPv6</del>。<br />
然后我们需要修改<code>/etc/config/dhcp</code>文件，使用无状态地址自动配置（<strong>SLAAC</strong>）IPv6，而不是DHCPv6。配置示例如下：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td><pre>config dhcp <span>'lan'</span>
        option interface <span>'lan'</span>
        option start <span>'100'</span>
        option limit <span>'150'</span>
        option leasetime <span>'12h'</span>
        option dhcpv6 <span>'relay'</span>
        option ra <span>'relay'</span>
        option ndp <span>'relay'</span>
        option ra_management <span>'1'</span>

config dhcp <span>'wan'</span>
        option interface <span>'wan'</span>
        option ignore <span>'1'</span>
        option dhcpv6 <span>'disabled'</span>
        option ndp <span>'relay'</span>
        option ra <span>'relay'</span>
        option master <span>'1'</span>

config dhcp <span>'wan6'</span>
        option dhcpv6 <span>'relay'</span>
        option ra <span>'relay'</span>
        option ndp <span>'relay'</span>
        option master <span>'1'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>配置完成之后需要重启<code>network</code>服务，以便接入终端获取IPv6地址：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>/etc/init.d/network restart
</pre></td></tr></tbody></table></code></pre></div></div>

<p>至此所有的客户端包括路由器均可获得可用的IPv6地址，不过在Windows下面，由于祖传<a href="https://social.technet.microsoft.com/Forums/windows/en-US/b16e7d78-e390-4ada-a24b-3ccba60fa571/no-ipv6-dns-statelessdhcp-since-windows-10-anniversary-update?forum=win10itpronetworking" target="_blank">BUG</a>的原因，可能无法正常使用获取的IPv6，需要在<code>CMD</code>中执行如下命令：</p>

<pre><code>ipconfig /release6
ipconfig /renew6
</code></pre>

<p>之后无需重启，是否有效需要看具体网络配置。<br /></p>

<h3>体验</h3>

<p>体验较差：客户端的地址无法<code>ping</code>通；访问海外地址也出现问题；部分客户端有<strong>1分钟</strong>左右的延时。本质鸡肋，所以只在路由器上面保留了IPv6地址。<br /></p>

<blockquote>
  <p>咸鱼IPv6立即关闭，获取更好的网络体验。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               从起点出发然后回到起点。   OpenWRT IPv6  之前一直只有教育网或者局部地区测试的IPv6现在已经大范围推开，大部分地区的ISP均正确部署了IPv6。通常来说，Openwrt获取IPv6的方式有三种：中继、穿透和NAT，由于ISP已经提供了IPv6和某些方案的
            
        </summary>
        
        <category term="Openwrt"/>
        
        <category term="IPv6"/>
        
    </entry>
    
    <entry>
        <title>ElasticSearch 配置Logstash导入mysql数据库</title>
        <link href="http://blog.vitechliu.com/note/elasticsearch-import-mysql-using-logstash-and-jdbc.html"/>
        <id>http://blog.vitechliu.com/note/elasticsearch-import-mysql-using-logstash-and-jdbc.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2018-11-29T15:21:59+00:00</published>
        <updated>2018-11-29T15:21:59+00:00</updated>
        
        <content type="html"><![CDATA[<p>网上教程不少，但是大多对新手不太友好，细节也不太好，这里针对ElasticSearch小白。</p>
<p>以ElasticSearch 5.6.12 和 LogStash 5.6.13为例。这两个的安装从略。<br />
尽量保证两者版本不要相差太多。考虑到LogStash只作为管道，版本不需要一致。</p>
<p>先到LogStash目录下安装JDBC插件</p>
<pre><code>cd /opt/logstash
bin/plugin install logstash-input-jdbc
</code></pre>
<p>如果是windows下，请自行在可执行文件后加上.bat</p>
<p>安装完之后开始导入，这个导入过程我们编写一个conf文件实现，这里以logstash.conf为例，为了方便可以直接在logstash/bin下创建一个logstash.conf</p>
<pre><code>input {
  jdbc { 
    # "your-database" 是数据库名    
    jdbc_connection_string =&gt; "jdbc:mysql://localhost:3306/your-database"  
    #mysql数据库用户名密码
    jdbc_user =&gt; "root" 
    jdbc_password =&gt; "********"
    #schedule 可选，如果有schedule则会自动同步，这里意思是每一分钟同步一次，没有就只同步一次。具体的见官方文档
    #schedule =&gt; "* * * * *"
    #这里需要使用一个mysql连接库，文末有下载地址，自行下载后随便放一个地方，这里只是举例
    jdbc_driver_library =&gt; "/usr/local/logstash/mysql-connector-java-6.0.5.jar"
    jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"
    #查询，这里只需要select一下即可，比如从your-schema数据表
    statement =&gt; "SELECT * FROM `your-schema`"
    }
  }
output {
  stdout { codec =&gt; json_lines }
  elasticsearch {
  "hosts" =&gt; "localhost:9200"
  #your-index是事件要被写进的索引 如果没有索引就新建一个
  "index" =&gt; "your-index"
  #your-type-name 只是数据集的分类，自定义，同类数据尽量使用同一个type
  "document_type" =&gt; "your-type-name"
  #可选，这里的意思是绑定原mysql表的id列作为主键，可以避免重复
  "document_id" =&gt; "%{id}"
  }
}

</code></pre>
<p>然后执行</p>
<pre><code>cd /opt/logstash/bin
./logstash -f logstash.conf
</code></pre>
<p>可以看到一排输出，然后数据就注入成功了。</p>
<p>顺带一提，如果小白注入完数据发现有unassigned数据，或者说集群健康度不够，是因为现在的节点分片不够存储数据集的1份备份（默认一份）。只需要执行诸如</p>
<pre><code>curl -XPUT 'localhost:9200/your-index/_settings' -d '{"number_of_replicas": 0}'
</code></pre>
<p>将备份数降低即可。</p>
<p><a href="http://central.maven.org/maven2/mysql/mysql-connector-java/6.0.5/mysql-connector-java-6.0.5.jar">一个可用的Maven的mysql-connector-java-6.0.5.jar</a></p>]]></content>
        
        <summary type="html">
            
            网上教程不少，但是大多对新手不太友好，细节也不太好，这里针对ElasticSearch小白。 以ElasticSearch 5.6.12 和 LogStash 5.6.13为例。这两个的安装从略。 尽量保证两者版本不要相差太多。考虑到LogStash只作为管道，版本不需要一致。
            
        </summary>
        
    </entry>
    
    <entry>
        <title>lnmp配置laravel/thinkphp时出现no input file specified的常见问题</title>
        <link href="http://blog.vitechliu.com/note/lnmp-user-ini-cause-no-input-file-specified.html"/>
        <id>http://blog.vitechliu.com/note/lnmp-user-ini-cause-no-input-file-specified.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2018-11-24T14:12:05+00:00</published>
        <updated>2018-11-24T14:12:05+00:00</updated>
        
        <content type="html"><![CDATA[<p>lnmp的域名绑定命令即使到最新的1.5版都是一套不太成熟的做法。<br />
我们每次执行诸如lnmp vhost add时，都会在目录下生成一个类似这样的.user.ini文件</p>
<pre><code>open_basedir=/home/wwwroot/your-project/:/tmp/:/proc/
</code></pre>
<p>.user.ini的作用是覆写php.ini中的部分参数，在这里来说，open_basedir在php.ini中可能有一个全局值，而在这个目录下有一个局部的值会覆盖全局值。</p>
<p>而open_basedir则是造成nginx/php-fpm 报错的罪魁祸首，这么说可能不恰当，因为.user.ini的本意是好的，其机理是限制php访问目录，举例来说，你在这个目录下配置的php文件只能操作/home/wwwroot/your-project/下的文件。</p>
<p>而这样就导致了我们在使用诸如laravel/ThinkPHP框架时的问题。比如我们在home/wwwroot下建立了名为your-project的laravel项目，但是lnmp绑定vhost时，按常理是要绑定到/public目录下的。因为/public下是整个网站的入口，这样一来就产生问题了：.user.ini中会生成/home/wwwroot/your-project/public/:/tmp/:/proc/这样的参数，然而这个项目的php是必须要有要调用/public外文件的权限的！这个问题的产生往往会让人难以排查，因为不管是浏览器输出，亦或是nginx和php-fpm的log都不会给出任何错误信息，一个隐藏在/public下的.user.ini文件很难让新手发觉出问题。</p>
<p>解决方案：</p>
<p>.user.ini被安全锁定了，先使用</p>
<pre><code>chattr -i .user.ini
</code></pre>
<p>将其解锁，然后vim编辑去掉/public，再chattr +i .user.ini加锁。<br />
当然你也可以直接解锁后删掉，这样损失了一定安全性，对于小项目或者本地项目倒没什么意义了。</p>]]></content>
        
        <summary type="html">
            
            lnmp的域名绑定命令即使到最新的1.5版都是一套不太成熟的做法。 我们每次执行诸如lnmp vhost add时，都会在目录下生成一个类似这样的.user.ini文件 open_basedir=/home/wwwroot/your-project/:/tmp/:/proc/ 
            
        </summary>
        
    </entry>
    
    <entry>
        <title>一周一部好电影V【WEEK210 网络迷踪】</title>
        <link href="https://molunerfinn.com/PerfectMoviePerWeek5/"/>
        <id>https://molunerfinn.com/PerfectMoviePerWeek5/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-11-11-WEEK210-网络迷踪"></a>2018-11-11 WEEK210 网络迷踪</h3><p>网络迷踪——————————————Searching<br /><img src="https://img.piegg.cn/week210.jpg?imgslim" /></p><ul><li>导演：阿尼什·查甘蒂</li><li>主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·<br />比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔</li><li>片长：102分钟</li><li>影 片类型：剧情/悬疑/惊悚</li><li>豆 瓣评分：8.7/10(from85,981users)</li><li>IMDB评分：7.8/10(from38,178users)</li></ul><a></a><p>Hi，各位好久不见！（最近在忙毕设开题的事，所以一直没办法按期完成推送。等忙过这一段就能大致恢复正常。）这部电影可以说是小成本制作的典范之作了。全片很有意思，大部分用的镜头来自手机、电脑的前置摄像头，然后配合电脑、手机屏幕的聊天记录、网页记录等来描述故事、展现角色心理状态。很多时候刚敲完的文字，然后想了想又删掉的光标；在屏幕前停留的视线等等都会让你身临其境——因为这些场景在我们当今的生活中，真的司空见惯。</p><p>可以说手机和电脑加上互联网已经占据了很多人一天的大部分。本片也聚焦在当前的网络环境下的人与人之间，父母和孩子之间的关系。我们经常会对父母隐藏自己的某一面，而在互联网上却又是另一副的面孔。所以很多时候本该最了解我们的人，却成了最熟悉的陌生人。当然，意外的惊喜是本片还加入了很不错的悬疑元素，真相大白的那刻，总算把你觉得不对劲的地方说了出来，但是却让你依然感觉很过瘾。好电影，值得一看！</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-10-07-WEEK209-奇迹男孩"></a>2018-10-07 WEEK209 奇迹男孩</h3><p>奇迹男孩——————————————Wonder<br /><img src="https://img.piegg.cn/week209.jpg?imgslim" /></p><ul><li>导演：斯蒂芬·卓博斯基</li><li>主演：雅各布·特伦布莱/朱莉娅·罗伯茨/伊扎贝拉·维多维奇/欧文·威尔逊/诺亚·尤佩/丹妮尔·罗丝·拉塞尔/纳吉·杰特/戴维<br />德·迪格斯/曼迪·帕廷金/布莱斯·吉扎尔/艾尔·麦金农/泰·孔西利奥/詹姆斯·休斯/凯尔·布瑞特科夫/米莉·戴维斯/莉娅·朱厄<br />特/凯琳·布瑞特科夫/利亚姆·迪金森/艾玛·特伦布莱/马克·多兹劳/鲁奇娅·伯纳德/J·道格拉斯·斯图瓦特/阿里·利伯特/埃丽卡<br />·麦基特里克/本杰明·拉特纳/杰森·麦金农/索尼娅·布拉加/吉洁特</li><li>片长：113分钟</li><li>影 片类型：剧情/家庭/儿童</li><li>豆 瓣评分：8.6/10(from211,803users)</li><li>IMDB评分：8.0/10(from89,828users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自美国的《奇迹男孩》。从片名就可以看出是讲述一个小男孩的故事。温馨的故事很多，不过各有各打动人的地方。本片讲述的故事可能并没有什么出奇的地方，甚至你也有可能遇到类似的例子。影片中的的主要角色都有自己的一段独白戏。而从独白戏中，你才可以看到那些角色真实的自己。</p><p>就像行星绕着恒星转一样，我们的生活中也或多或少会围着某个人转。在关心他人的同时不得不遮盖自己的伤疤。但其实很多时候跟对方坦诚相待能获得更好的效果。要成为一个善良的人，要做善良的事。温馨的电影，值得一看~</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-09-23-WEEK208-谍影重重"></a>2018-09-23 WEEK208 谍影重重</h3><p>谍影重重——————————————The Bourne Identity<br /><img src="https://img.piegg.cn/week208.jpg?imgslim" /></p><ul><li>导演：道格·里曼</li><li>主演：马特·达蒙/弗朗卡·波滕特/克里斯·库珀/克里夫·欧文/朱丽娅·斯蒂尔斯/布莱恩·考克斯/阿德沃尔·阿吉纽依-艾格拜吉/加布里埃尔·曼/沃尔顿·戈金斯/约什·汉密尔顿/Orso Maria Guerrini</li><li>片长：119分钟</li><li>影 片类型：动作/悬疑/惊悚</li><li>豆 瓣评分：8.5/10(from215,888users)</li><li>IMDB评分：7.9/10(from461,682users)</li></ul><p>Hi，各位好久不见！继上次看完《碟中谍6》之后，在经过舍友的推荐后我找来了另外一部讲述特工的电影《谍影重重》。跟《碟中谍》系列不同的是，《谍影重重》系列的男主角马特达蒙并没有阿汤哥那样帅到让你印象深刻。相反他一开始并不吸引人。</p><p>如果说《007》的看点是特工+美女，《碟中谍》的看点是阿汤哥的颜和拼命，那么《谍影重重》的看点就真的是一个特工的自我救赎了。我想推荐的并不是这一部电影，而是这整个系列（1、2、3、5部）。并且这里面每一部的水平、评分都很高。可以说是荧幕上「最为真实」的讲述间谍、特工的电影了。在这里面你是能真的学习到一些常人并不会特意关注到的细节。伯恩的招式可能没有那么华丽，但是是招招制敌，干净利落不拖泥带水，剧情的发展也是一波三折，紧凑而牵动人心。作为一部动作、悬疑电影我觉得虽然动作戏不如《碟中谍》那么华丽但是也已经足够帮。</p><p>其实第一部已经做得很出色，没想到第二部、第三部也同样出彩。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-09-16-WEEK207-走到尽头"></a>2018-09-16 WEEK207 走到尽头</h3><p>走到尽头——————————————끝까지 간다<br /><img src="https://img.piegg.cn/week207.jpg?imgslim" /></p><ul><li>导演：金成勋</li><li>主演：李善均/赵震雄/郑满植/申东美/申正根/朴宝剑</li><li>片长：111分钟</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from41,868users)</li><li>IMDB评分：7.2/10(from7,509users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自韩国的《走到尽头》。这部电影我在3年前曾看过一次，不过最近重新又看了一遍依然感觉十分不错。</p><p>从影片一开始就开始就把观众带入非常紧张、刺激的情节，让人不由自主地为主角捏一把汗。而后的矛盾冲突又依然保持着高度的紧张和不突兀的幽默镜头。而随着剧情的推进，不断地反转也是让人看得很是过瘾。可以说是不停地用新的错误掩盖旧的错误。我想虽然电影有所夸张，但是现实中的我们却总会有类似的时刻。环环相扣的剧情在影片的最后达到高潮。开放式的结局也能让你思考良多。而比起我们的电影结局大多是阳光美好而言，这部电影的结局可以说带着一些黑色气息了。好电影，值得一看！</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-09-09-WEEK206-碟中谍6：全面瓦解"></a>2018-09-09 WEEK206 碟中谍6：全面瓦解</h3><p>碟中谍6：全面瓦解——————————————Mission: Impossible - Fallout<br /><img src="https://img.piegg.cn/week206.jpg?imgslim" /></p><ul><li>导演：克里斯托弗·麦奎里</li><li>主演：汤姆·克鲁斯/亨利·卡维尔/文·瑞姆斯/西蒙·佩吉/丽贝卡·弗格森/西恩·哈里斯/安吉拉·贝塞特/凡妮莎·柯比/米歇尔·莫纳汉/韦斯·本特利/费雷德里克·施密特/亚历克·鲍德温/杨亮/克里斯托弗·琼勒/沃尔夫·布利策/拉斐尔·琼勒/安德鲁·卡扎纳夫·平/克里斯多夫·德·舒瓦西/拉裴尔·德普雷/让·巴普蒂斯特·菲永/马克斯·盖勒/奥利维尔·体班德/亚历山大·普尔/阿利克斯·贝纳泽什/乔伊·安沙/维利贝·托皮奇/格雷厄姆·福克斯/卡斯珀·菲利普森/菲恩·乔利/鲁斯·贝恩/奈杰尔·艾伦</li><li>片长：147分钟</li><li>影 片类型：动作/惊悚/冒险</li><li>豆 瓣评分：8.3/10(from164,538users)</li><li>IMDB评分：8.1/10(from118,713users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部最近正在热映的电影《碟中谍6：全面瓦解》。动作片系列，我觉得如今只有《速度与激情》系列能与《碟中谍》系列比拼了。</p><p>阿汤哥依然是拼命三郎。本片全程无尿点。虽然剧情依然是跟核弹有关（哈哈）。不过不管是跳伞、飙车、开飞机甚至是「屋顶跑酷」都让人看得热血沸腾。22年了，阿汤哥依然是那个阿汤哥，不过当年看他电影的人已经长大了。熟悉的片头曲，琳琅满目的「黑科技」，剧情也是不停地反转反转。整部电影几乎一直处于神经紧绷的状态，让人看了大呼过瘾！</p><p>不知道还能再看到阿汤哥的碟中谍多少次，这部好电影，我想你一定要去看看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-08-26-WEEK205-游戏之夜"></a>2018-08-26 WEEK205 游戏之夜</h3><p>游戏之夜——————————————Game Night<br /><img src="https://img.piegg.cn/week205.jpg?imgslim" /></p><ul><li>导演：约翰·弗朗西斯·戴利/乔纳森·M·戈尔茨坦</li><li>主演：杰森·贝特曼/瑞秋·麦克亚当斯/凯尔·钱德勒/ 莎朗·豪根/比利·马格努森/拉蒙尼·莫里斯/凯莉·班伯里/杰西·普莱蒙/ 迈克尔·C·豪尔/丹尼·赫斯顿/切尔西·帕瑞蒂/卡米利·陈/泽瑞克·威廉姆斯/约书亚·米克尔/R·F·戴利</li><li>片长：100分钟</li><li>影 片类型：喜剧/悬疑/犯罪</li><li>豆 瓣评分：7.1/10(from22,632users)</li><li>IMDB评分：7.0/10(from109,979users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的是来自英国的喜剧电影《游戏之夜》。听名字可能并不知道是什么意思，甚至有点「游戏人生」的感觉。但是看完之后却能把你笑得人仰马翻。这部结合了悬疑、犯罪的喜剧电影从分类上来说就让人忍俊不禁。其实同样类型的国内电影还有比如《唐人街探案》系列。不过我更加推荐这一部电影。</p><p>原因？原因在于这部电影的笑点和反转总是让你措手不及，反转会给你会心一击，笑点会让你笑掉下巴。我觉得一部喜剧电影的成功在于它能不用老梗把观众欢笑地送出电影院。而每部喜剧电影或多或少都会有些荤段子。有些电影处理地不好反而让人反感。而这部电影处理起来就让人看完很舒服。它不是什么很高内涵的电影，但是确是一部老少咸宜，适合一群人一起观看一起欢笑的好电影。值得一看~</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-08-05-WEEK204-华盛顿邮报"></a>2018-08-05 WEEK204 华盛顿邮报</h3><p>华盛顿邮报——————————————The Post<br /><img src="https://img.piegg.cn/week204.jpg?imgslim" /></p><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：梅丽尔·斯特里普/汤姆·汉克斯/莎拉·保罗森/鲍勃·奥登科克/崔西·莱茨/布莱德利·惠特福德/布鲁斯·格林伍德/马修·瑞斯/爱丽森·布里/凯莉·库恩/杰西·普莱蒙/大卫·克罗斯/扎克·伍兹/帕特·希利/约翰·鲁/里克·霍姆斯/菲利普·卡斯诺夫/杰茜·缪勒/斯塔克·桑德斯/迈克尔·西里尔·克赖顿/威尔·丹顿/迪尔德丽·罗夫乔/迈克尔·斯图巴</li><li>片长：116分钟</li><li>影 片类型：剧情/惊悚/传记/历史</li><li>豆 瓣评分：8.2/10(from45,185users)</li><li>IMDB评分：7.2/10(from82,885users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的，是来自美国的电影《华盛顿邮报》。我记得此前给大家推荐过《聚焦》，那部电影讲的是波士顿环球报的故事。而本片从片名上你就能看出来，讲述的是华盛顿邮报的故事。同样都是讲报社的电影，两部电影讲出了各自不同的风格，不过同样都很精彩。</p><p>本片基于真实事件改编，剧情总体并不复杂，讲述的是华盛顿邮报揭露美国当时的越战黑幕，与尼克松政府「对着干」的故事。如果说《聚焦》的风格是尽力的克制，那么《华盛顿邮报》的风格就是与之相反的锋芒毕露。美国当时深陷越战泥潭，而政府却把战局的节节败退告知公众于步步胜利。在明知打不赢这场战争的情况下还依然偷偷往越南派兵。如果没有有良知的记着冒死将机密文件从五角大厦里偷出，华盛顿邮报将其公之于众，恐怕越战还将继续持续很久。</p><p>不得不提的是报社与政府之间的较量。他们捍卫着新闻自由，捍卫着美国宪法赋予新闻工作者的权利。「报纸不应为统治者服务，而是应该为被统治者服务」。这部电影虽然讲述的故事发生在40多年前，但是对于当世而言依然有很强烈的警示作用。「如果纽约时报和我们（华盛顿邮报）输了，那么自由新闻才是真的输了。」可以很自然的想到，如果当初华盛顿邮报在于政府的禁令面前败下阵来，那么1年后的水门事件也将同样的被压下来。而曝光水门事件促使尼克松下台的，正是华盛顿邮报。</p><p>看完电影真的非常感动，感动于那些新闻工作者为了国家，为了社会，为了人民在努力追求真相，拼死把真相曝光。可恨在于我们的当下，没有质量、没有深入调查、没有核实来源的假新闻、谣言却铺天盖地。不管是前段时间的「汤兰兰事件」，还是「慈溪被害女生事件」等等新闻，都是为了增加曝光量，却没有考虑到当事人、当事方的感受的新闻。一味追求标题党，撒手把事情甩锅给其他人，让当事人当事方得花十倍百倍的力气去辟谣。这种新闻是可恨的。而那些追求真理，曝光真相的新闻，比如曝光疫苗案、比如毒奶粉案等等的调查记者们，却因为触动了某些人的利益，触动了它们脆弱的神经，遭到掩盖、封杀、甚至人身威胁。演变成现在，我们很多的新闻、很多的细节不得不通过微信公众号、微博截图等等才能看到第一手的材料。因为一旦晚了，就是「该内容已被发布者删除」「该内容因违规无法查看」。这里面也是鱼龙混杂，有的人为了坚持正义，发出的文章无奈被封，而自己的账号也被封禁；有的人为了蹭热点不惜一切代价做出煽情的文章，而变相输出一些谣言。然而人们在这里面获取到信息后通常容易出现广泛传播。当局的做法通常是不论真假一并封杀。</p><p>《中华人民共和国宪法》第二章第三十五条规定：中华人民共和国公民有言论、出版、集会、结社、游行、示威的自由。</p><p>然而今天的真相是我们的「言论自由」是有代价的，通常只要触犯到某些人的利益就会遭到全面的封杀。我不知道它们看过《华盛顿邮报》之后会怎么想，恐怕会很害怕吧。「宜疏不宜堵」「水能载舟亦能覆舟」的道理，小学生都知道。不知道那些口口声声说着「为人民服务」的人，为什么不懂呢。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-07-22-WEEK203-第十二人"></a>2018-07-22 WEEK203 第十二人</h3><p>第十二人——————————————Den 12. mann<br /><img src="https://img.piegg.cn/week203.jpg?imgslim" /></p><ul><li>导演：哈罗德·兹瓦特</li><li>主演：乔纳森·莱斯·梅耶斯/托马斯·古勒斯塔德/玛丽·布洛克胡斯/维加·霍尔/马丁·基弗</li><li>片长：135分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：7.8/10(from2,665users)</li><li>IMDB评分：7.5/10(from4,773users)</li></ul><p>Hi，各位好久不见！好久没给大家推荐战争类型的电影了。本次给大家推荐的是一部来自挪威的电影，讲述了一个12人的小队，最终只有第12个人生还的故事。这部电影最震撼的就是片头说的「这个故事里，最令人难以置信的是，确有其事。」。</p><p>跟敦刻尔克一样，这部电影讲述的不是消灭了多少德军，而是讲述了如何生还（或者「逃跑」）的故事。这个故事讲述的虽然是「一个人」，但是实际上讲的是一群人的故事。「我不是英雄，那些帮助了我的人才是英雄」。这部电影伟大之处在于给予一路上帮助主角的人足够多的镜头和描写。为了帮助主角逃生，很多人甚至会为此付出生命的代价。</p><p>这部取景很「冷」的电影，在冲破国境线的那一刻却格外地热血沸腾。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-07-08-WEEK202-我不是药神"></a>2018-07-08 WEEK202 我不是药神</h3><p>我不是药神——————————————我不是药神<br /><img src="https://img.piegg.cn/week202.jpg?imgslim" /></p><ul><li>导演：文牧野</li><li>主演：徐峥/王传君/周一围/谭卓/章宇/杨新鸣/王佳佳/王砚辉/贾晨飞/龚蓓苾/宁浩/李乃文</li><li>片长：117分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：9.0/10(from350,132users)</li><li>IMDB评分：8.3/10(from372users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是刚上映的大热门《我不是药神》。其实光看名字和海报的时候，我以为只是徐峥的一部常规喜剧电影。然而自从点映以来就有不少朋友给我推荐。于是今天也去电影院看了，发现确实值得上豆瓣9.0的分数。「我们也拍出了韩国那样的电影」。这是我看完感慨最深的一点。</p><p>在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影，真的非常不容易。其实从前年的《湄公河行动》、去年的《战狼2》、今年的《红海行动》之后，我很害怕我们国家以后的「好」电影都只能是这类主旋律的动作片了。我们有《心迷宫》、《暴裂无声》等质量上乘的悬疑电影，也有逗男女老少开心一笑的《泰囧》、《夏洛特烦恼》等优质喜剧片等等。但是我们缺的是直击社会问题，挖掘人性的剧情电影。我们少了多少《辩护人》、少了多少未见的《熔炉》、少了多少难得的《Taxi Driver》。今天一部《我不是药神》让我看到了中国电影的未来还是有希望的。这部基于真实事件改编的电影，从影片一开始就会让你有种深深代入感——因为你也是千千万万中国人之一，这就会是发生在你身边的事。</p><p>不管是配乐、剪辑还是情节的把控，导演和主演们都让我们感到了深深的负责和认真。该给的镜头一个不少，该有的细节一个不缺，该哭的泪点一个不落。你知道这将是中国电影的一个里程碑式的电影么，这么棒的电影真的值得你去一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-06-27-WEEK201-寻梦环游记"></a>2018-06-27 WEEK201 寻梦环游记</h3><p>寻梦环游记——————————————Coco<br /><img src="https://img.piegg.cn/week201.jpg?imgslim" /></p><ul><li>导演：李·昂克里奇/阿德里安·莫利纳</li><li>主演：安东尼·冈萨雷斯/盖尔·加西亚·贝纳尔/本杰明·布拉特/阿兰纳·乌巴奇/芮妮·维克托/杰米·卡米尔/阿方索·阿雷奥/赫 伯特·西古恩萨/加布里埃尔·伊格莱西亚斯/隆巴多·博伊尔/安娜·奥菲丽亚·莫吉亚/娜塔丽·科尔多瓦/赛琳娜·露娜/爱德华·詹姆斯·奥莫斯/索菲亚·伊斯皮诺萨/卡拉·梅迪纳/黛娅娜·欧特里/路易斯·瓦尔德斯/布兰卡·阿拉切利/萨尔瓦多·雷耶斯/切奇·马林/奥克塔维·索利斯/约翰·拉岑贝格</li><li>片长：105分钟</li><li>影 片类型：喜剧/动画/音乐/奇幻</li><li>豆 瓣评分：9.0/10(from509,070users)</li><li>IMDB评分：8.5/10(from188,620users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自皮克斯的动画电影《寻梦环游记》。这部电影在当时上映的时候获得了很高的评价。不过我直到最近才看了它。不得不说确实是一部很赞的电影。关于这部电影有个有趣的段子，引进的时候，由于把审片的人都看哭了，所以本来是不能上映的亡灵题材的电影也过审了。暂且不考虑这个说法的真实性，从这个段子里你也能看出这部电影的硬实力确实很强。<br />这部是一部关于音乐，梦想和爱的电影。故事的构思很巧妙，背景设置在墨西哥也是别有一番风味。电影给我们营造了一个及其绚丽的亡灵世界。在这里大部分的生活是快乐的，不过也有令人揪心的问题——如果在人间没有人还记得你的话那么你将会在亡灵世界里消逝。这点真的非常赞，完美诠释了那句话：「人会死三次，第一次是在他停止呼吸的时候 ，从生物学上说他死了，他失去了思考的能力；第二次是在他下葬的时候，人们来参加他的葬礼，怀念他的过往和人生，然后在社会上他死了，活着的世界里不再会有他的位置；第三次是世界上最后一个记得他的人把他忘记的时候，那时候他才能算是真正的死了，永远的死了。」这个设定也带来了剧情的里的矛盾点和发展点。后续的情节铺开张弛有度，有情理之中也有意料之外。感动人心，好电影值得一看~</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-06-13-WEEK200-燃烧"></a>2018-06-13 WEEK200 燃烧</h3><p>燃烧——————————————버닝<br /><img src="https://img.piegg.cn/week200.png?imgslim" /></p><ul><li>导演：李沧东</li><li>主演：刘亚仁/史蒂文·元/全钟瑞/金秀京/崔承浩/玉子妍</li><li>片长：148分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：8.0/10(from23,263users)</li><li>IMDB评分：7.9/10(from418users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。改编自村上春树的《烧仓房》，不过导演也为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢，很多细节是慢慢地又完整地展现在你面前。而电影里最让人困惑，或者最烧脑，或者说加入了作者最深入的思考的部分，却又是那些可有可无的「线索」。它们有些到最后都没有得到导演给出的解释。开放式的结局，甚至开放式的剧情都是这部电影非常让人难以缓过神来的地方。而平淡地讲述故事的同时，也有着「最美之舞」的唯美画面。</p><p>聚焦着当下韩国年轻人的痛点，在讲述一场可疑的案件的同时，又让你不得不思考，自己活着是一个「little hunger」还是一个「greate hunger」。而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-05-27-WEEK199-国际市场"></a>2018-05-27 WEEK199 国际市场</h3><p>国际市场——————————————국제시장<br /><img src="https://img.piegg.cn/week199.jpg?imgslim" /></p><ul><li>导演：尹齐均</li><li>主演：黄晸玟/金允珍/吴达洙/张荣男/郑镇荣/罗美兰/金瑟祺/郑允浩/Stella Choe</li><li>片长：126分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.3/10(from34,907users)</li><li>IMDB评分：7.8/10(from2,500users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自韩国的《国际市场》。初看这部电影的名字，并不能看出什么名堂。不过这部电影类似于《阿甘正传》一样，描述了一部韩国的现代史。从6·25事件（可以认为是朝鲜战争全面爆发）开始，一直延续到如今。</p><p>这是目前韩国影史票房第二的电影。能获得如此巨大的成功，我想除了过硬的演员素质（黄晸玟、金允珍、吴达洙等实力派演员），编剧和导演对于情节穿插的到位把控，还有就是唤起了很多韩国人对于朝鲜战争过后，韩国从无到有，从落后朝鲜到超过朝鲜的那段历史的回忆。这部电影以主角德秀的成长作为主线，对父亲的承诺，对妹妹的愧疚，对姑姑的感恩等等。并不断加入一些暗藏的线索或者说「彩蛋」，在整体氛围是催人泪下的情况下，还能掺杂着不少喜剧的成分，非常具有这几年韩国高分电影的风格。</p><p>影片末尾的那句，「但是爸，我真的好累啊」让我不禁落泪。这部电影能直击你内心最容易被触动的角落，好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-05-23-WEEK198-暴烈无声"></a>2018-05-23 WEEK198 暴烈无声</h3><p>暴烈无声——————————————Wrath of Silence<br /><img src="https://img.piegg.cn/week198.png?imgslim" /></p><ul><li>导演：忻钰坤</li><li>主演：宋洋/姜武/袁文康/谭卓/王梓尘/安琥</li><li>片长：120分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.3/10(from100,190users)</li><li>IMDB评分：7.2/10(from250users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是来自《心迷宫》导演的第二部佳作《暴烈无声》。好吧依然是一部从名字里看不出说啥的电影。有了《心迷宫》的成功铺垫，《暴烈无声》在经费上也算是大大地改善了。而且宋洋、姜武等实力派演员的出演也是给这部电影添色不少。</p><p>不过相比心迷宫的烧脑，这部电影打出的宣传语是：「烧脑，更烧心」。是的，这部电影虽然是一部悬疑片，但是不仅仅是一部悬疑片。导演其实是想借着这部电影，隐喻现实中的三类人。一类是在社会底层摸爬滚打，有苦说不出，有难没处诉的人；一类是生活过得还可以，努力工作努力养家糊口的中产阶级；一类是生活在社会顶层，物质生活富裕，但是依仗钱、权背地里做些违法乱纪之事的人。</p><p>我们常听「邪不压正，正义或许会迟到，但绝不会缺席」。不过看完这部电影，你会发现其实还是有不少的事，正义的缺席带给你我的，是多么无助，多么的无力。暴烈无声，拳头能换来的，是说不出的绝望。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-05-14-WEEK197-至暗时刻"></a>2018-05-14 WEEK197 至暗时刻</h3><p>至暗时刻——————————————Darkest Hour<br /><img src="https://img.piegg.cn/week197.png?imgslim" /></p><ul><li>导演：乔·赖特</li><li>主演：加里·奥德曼/克里斯汀·斯科特·托马斯/莉莉·詹姆斯/本·门德尔森/斯蒂芬·迪兰/萨缪尔·韦斯特/汉娜·斯蒂尔/罗纳德·皮卡普/乔丹·沃勒/理查德·拉姆斯登/安娜·伯内特/尼古拉斯·琼斯/查理·帕尔默·罗斯韦尔/布赖恩·佩蒂福/菲利普·马丁·布朗/安杰莉克·琼/希尔顿·麦克雷/詹姆斯·伊莱斯/杰瑞米·查亚德/马汀·麦格/迈克尔·海登/迈克尔·博特</li><li>片长：125分钟</li><li>影 片类型：剧情/传记/历史</li><li>豆 瓣评分：8.6/10(from145,583users)</li><li>IMDB评分：7.4/10(from95,095users)</li></ul><p>Hi，各位好久不见。这段时间确实比较忙，一直拖更我表示非常愧疚。本周给大家带来的是一部来自英国的电影《至暗时刻》。别看名字好像阴森恐怖，但是实际上它并不是一部恐怖电影。它是一部讲述英国著名首相丘吉尔的电影。</p><p>丘吉尔在面对重重困难，做出了一系列后世看来非常正确的决策。但是鲜有人知这些决策背后的故事。如果你知道敦刻尔克大撤退，那么你未必知道为了让敦刻尔克的30万英法联军撤回英国，为了多争取时间，牺牲了临近的一个英国旅（4000人）；你未必知道当时的情况下，征用民船已经是无奈之举，而且几乎是千钧一发之际才正好赶上撤军；你也许知道丘吉尔爱抽雪茄，但是你未必知道丘吉尔还嗜酒，个性分明……</p><p>这部电影里，加里·奥德曼把丘吉尔演绎得惟妙惟肖，十分令人印象深刻。也因此大家都在说他要因为出演丘吉尔这个角色拿到奥斯卡小金人了。好电影，值得一看！</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-04-23-WEEK196-1987-黎明到来的那一天"></a>2018-04-23 WEEK196 1987:黎明到来的那一天</h3><p>1987:黎明到来的那一天——————————————일구팔칠<br /><img src="https://img.piegg.cn/week196.jpg?imgslim" /></p><ul><li>导演：张俊焕</li><li>主演：金允锡/河正宇/柳海真/金泰梨/朴喜洵/李熙俊/..</li><li>片长：129分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：无</li><li>IMDB评分：8.0/10(from768users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的一部电影是国内豆瓣都「没有办法出现」的韩国电影《1987:黎明到来的那一天》。因为某些原因这部电影在国内被封杀，所以我也不好说得太多。去看看吧，好电影值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-04-08-WEEK195-头号玩家"></a>2018-04-08 WEEK195 头号玩家</h3><p>头号玩家——————————————Ready Player One<br /><img src="https://img.piegg.cn/week195.jpg?imgslim" /></p><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：泰伊·谢里丹/ 奥利维亚·库克/本·门德尔森/马克·里朗斯/丽娜·维特/森崎温/赵家正/西蒙·佩吉/T·J·米勒/汉娜·乔恩-卡门/拉尔夫·尹爱森/苏珊·林奇/克莱尔·希金斯/劳伦斯·斯佩尔曼/佩蒂塔·维克斯/艾萨克·安德鲁斯</li><li>片长：140分钟</li><li>影 片类型：动作/科幻/冒险</li><li>豆 瓣评分：8.9/10(from311,268users)</li><li>IMDB评分：7.9/10(from68,363users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是最近影院的大热门《头号玩家》。这部电影的豆瓣评分有点「虚高」，不过不可否认确实是一部非常棒的科幻电影。这是斯皮尔伯格送给年轻人、玩家、动漫迷们一份最好的礼物。</p><p>和过往的科幻电影有所不同的是，故事发生在不远的未来，不过科技并没有发展到「变态」的程度。所以电影里的很多东西，包括VR都是在现有的基础上进行的升华。而营造出来的虚拟世界无疑是最吸引眼球的。有人说这部电影是一部彩蛋里插播电影的电影。确实这部电影里彩蛋特别多，但是不用担心，没有人会真的了解所有的彩蛋，所以哪怕你并不关心游戏、动漫、电影，你也能在电影院感受两个半小时的视听盛宴。</p><p>大概最感动的地方就是遇到你所认识、你所熟知的角色、游戏在电影中的一闪而过。你会想起当年在家里打红白机、小霸王的那个年代，你会想起当年守在电视机前只为等待一部好看的动画片的自己。这部电影想要告诉你的也是一样——那些在你脑海中挥之不去的，那些回忆，那些童年才是最真实的。现实世界终究是追求自由追求真实的，在虚拟世界里再如何成功也不过是过眼烟云，现实中的伙伴，生活才是你最应该珍惜的。好电影，值得去一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-03-14-WEEK194-启示录"></a>2018-03-14 WEEK194 启示录</h3><p>启示录——————————————Apocalypto<br /><img src="https://img.piegg.cn/week194.jpg?imgslim" /></p><ul><li>导演：梅尔·吉布森</li><li>主演：鲁迪·杨布拉德/达利娅·埃尔南德斯/乔纳森·布雷维尔/莫里斯·博德耶洛海德/劳尔·特鲁希洛/赫拉多·塔拉塞纳/卡洛斯·伊米里奥·巴厄兹/阿米尔卡尔·拉米瑞兹/伊斯雷尔·康特雷拉斯/伊斯雷尔·里<br />奥斯/玛利亚·迪亚兹/埃斯皮里迪恩·阿科斯塔·卡奇/梅拉·萨布罗/伊阿祖娅·拉里奥斯/艾贝尔·伍尔里奇</li><li>片长：139分钟</li><li>影 片类型：剧情/动作/冒险</li><li>豆 瓣评分：8.5/10(from46,606users)</li><li>IMDB评分：7.8/10(from257,854users)</li></ul><p>Hi，各位好久不见！这部电影是来自公众号的粉丝推荐的一部好电影。很开心来一起分享它！这部电影的背景是玛雅文明衰落时期的故事，但是实际上有些情节又与当时鼎盛的阿兹特克文明有所重合。不过抛去历史背景，这个发生在热带雨林里的故事，却是惊心动魄，让人叹为观止。</p><p>影片的节奏松紧有度。开篇的情节把主要的人物性格、特点都印刻在观众的脑海中。而到了中途，就开始了震撼的追逐。如果从片名里直译的《启示录》里你看不到大致的情节的话，台译版的《阿波卡猎逃》可能就会让你的肾上腺素有所提升。不过如果你读过或者知道圣经里的《启示录》的话，那么这个题目真是太恰当不过了。一场文明的毁灭与新的文明的重生。这是一部让你无法忘却的电影，「文明」世界带去的文明，无非也是野蛮的征服。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-03-14-WEEK193-红海行动"></a>2018-03-14 WEEK193 红海行动</h3><p>红海行动——————————————红海行动<br /><img src="https://img.piegg.cn/week193.jpg?imageslim" /></p><ul><li>导演：林超贤</li><li>主演：张译/黄景瑜/海清/杜江/蒋璐霞/尹昉/王强/郭郁滨/王雨甜/麦亨利/张涵予/王彦霖</li><li>片长：138分钟</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.5/10(from321,371users)</li><li>IMDB评分：7.6/10(from1,254users)</li></ul><p>Hi，各位好久不见！前不久我刚去看了最近大热的《红海行动》。记得当初也给大家推荐过《湄公河行动》和《战狼2》。不得不说这两年来我们自己拍出来的战争、动作片的水准是越来越高了。本片的导演也是《湄公河行动》的导演林超贤。可以说自《湄公河行动》后的两年，真的是卷土重来。并且带来了质量更好，水平更高，更加真实而震撼的场面。</p><p>本片根据真实事件改编，还原度相当高。不仅影片出现的枪械、装备、坦克等都非常写实，而且一些镜头例如汽车炸弹、精密狙击、迫击炮狂轰滥炸等等都有很强的视觉冲击。而最震撼人心的，还有出现的很多「血腥」的场景——以往在国产电影里被剪掉无法搬上荧幕的战争的一些遗体、残骸。而整体剧情也非常紧凑，从头到尾都无尿点啊。而海陆空全面的镜头也让人大呼过瘾。同时，反战的主题也深入人心啊。好电影，值得一看！</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-03-01-WEEK192-弱点"></a>2018-03-01 WEEK192 弱点</h3><p>弱点——————————————The Blind Side<br /><img src="https://img.piegg.cn/week192.jpg?imageslim" /></p><ul><li>导演：约翰·李·汉考克</li><li>主演：桑德拉·布洛克/蒂姆·麦格罗/昆东·亚伦/杰·海德/莉莉·柯林斯/雷·迈克金农/凯西·贝茨</li><li>片长：USA: 129 分钟</li><li>影 片类型：剧情/家庭/传记/运动</li><li>豆 瓣评分：8.4/10(from104,599users)</li><li>IMDB评分：7.7/10(from248,692users)</li></ul><p>Hi，各位好久不见，新年快乐呀！趁新年还未完全过去，赶紧来给大家推荐每周一部的好电影，拖更了好久哈哈。本周给大家推荐的是一部来自美国的温情电影《弱点》。不过我一直觉得翻译有问题，翻译成「盲点」应该更好点。</p><p>这部电影是根据原著《The Blind Side: Evolution of the Game》改编的电影，而原著的原型也是来自于真实的故事。所以说这部电影的真实感让人非常感动——片中的人大多都超出你的想象的好。与大部分的电影不同的是，它的矛盾点、冲突点特别少。虽然在一些细节的处理上有些过快，不过能够在两个小时里塞进一个橄榄球传奇球员从默默无闻青年时代到最后脱颖而出的选秀状元，可以说是真的很不容易了。我在看的时候一直在惯性思考着等着导演「耍把戏」，不过从头到尾都非常地温馨，非常的动人。</p><p>它是一部能够打动你的泪腺的电影，一部好电影，献给新年的第一部推荐。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-02-04-WEEK191-抓住那个家伙"></a>2018-02-04 WEEK191 抓住那个家伙</h3><p>抓住那个家伙——————————————몽타주<br /><img src="https://img.piegg.cn/week191.jpg?imageslim" /></p><ul><li>导演：郑根燮</li><li>主演：金相庆/严正化/宋永彰/曹熙奉/刘承睦/李俊赫/朴哲民</li><li>片长：120分钟</li><li>影 片类型：剧情/惊悚/犯罪</li><li>豆 瓣评分：7.9/10(from25,085users)</li><li>IMDB评分：7.5/10(from3,342users)</li></ul><p>Hi，各位好久不见！本周依然给大家推荐一部有悬疑色彩的犯罪电影。这部来自韩国的电影从一开始就让我们感到一丝伤感。导演很擅长用暗色调渲染这种压抑而忧伤的气氛。所以从一开始我们就逐渐掉进这个陷阱中了。</p><p>整体上电影是双线并进，两条时间线互相交错，以至于到最后汇合的时候碰撞出的火花恐怕要让你拍案叫绝。两起案件，两个真相。和里面的警察一样，我们大多数人都会被眼前的“证据”蒙蔽，相信一些说不过去的“真相”。而很多事情是需要推敲，需要冷静的。</p><p>受害者也是加害者，这样的双重身份在电影里互相交织，让人性这个词又得以从电影剧本里脱颖而出。事实上，这部电影也是一部关于人性的思考，关于悔过的思考。好电影，值得一看~</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-01-28-WEEK190-目击者追凶"></a>2018-01-28 WEEK190 目击者追凶</h3><p>目击者追凶——————————————目擊者<br /><img src="https://img.piegg.cn/week190.jpg?imageslim" /></p><ul><li>导演：程伟豪</li><li>主演：庄凯勋/许玮甯/柯佳嬿/李铭顺/李淳/陈彦允/郑志伟/汤志伟/卜国耕</li><li>片长：117分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.1/10(from55,592users)</li><li>IMDB评分：7.0/10(from1,020users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自台湾的悬疑电影《目击者追凶》。我记得去年我曾推荐过一部大热的西班牙悬疑电影《看不见的客人》，精妙的剧本，峰会路转的剧情让很多人拍案叫绝。而这部来自宝岛台湾的电影也不逊色。</p><p>明线、暗线的堆叠，从一开始就埋下的伏笔。导演在一些细节的处理，比如一些闪回的镜头上做的是真的不错的。一次次小规模的反转铸就了最后令人吃惊而毛骨悚然的结局。这部电影里可以说基本没有“好人”。恐怕唯一的好人就是可怜的阿吉了。而所有其他出现在镜头里的主要角色，都有着外表和内在不同的反差。这也是这部电影可圈可点的地方。</p><p>而一部好的悬疑电影自然是到最后一刻才会完美收官。本片也不例外，片末的“鬼故事”，实在是画龙点睛之笔。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-01-21-WEEK189-无问西东"></a>2018-01-21 WEEK189 无问西东</h3><p>无问西东——————————————Forever Young<br /><img src="https://img.piegg.cn/week189.jpg?imageslim" /></p><ul><li>导演：李芳芳</li><li>主演：章子怡/黄晓明/张震/王力宏/陈楚生/韩童生/王盛德/米雪/保罗·菲利普·克拉克/祖锋/铁政/章泽天</li><li>片长：138分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：7.5/10(from140,810users)</li><li>IMDB评分：6.5/10(from138users)</li></ul><p>Hi，各位好久不见！本次给大家推荐的是一部时隔5年重见天日的电影——《无问西东》。这部电影本来是打算献礼给清华大学建校100周年的，因为某些不可知的原因，一再推迟到如今才能上映。剧中的主演也都在这5年中结婚生子，变化之大也令人感慨。</p><p>既然是献礼给清华大学的电影，剧中自然少不了清华大学的身影。电影分成了4段故事来讲述。每段时间内发生的故事都有鲜明的时代特色。而4个故事之间的关联，也在影片“不经意”之间透露出来。而这样的安排也引起了一堆的不认可。然而我却觉得这样的安排非常棒。和云图的前世今生相比，这样的安排不仅更加贴近真实而且更加动人。</p><p>而每个故事里的主人公的演技我认为在当时，哪怕放到现在也都是非常不错的。就像豆瓣里有人说的，“最棒的王力宏和非常好的黄晓明”。两个小时，4个故事，横跨100年。这样庞大的题材，虽然导演确实在某些细节上处理的有些牵强，不过依旧不改这部电影交出的高分答卷。应对人生的选择，人声的苦难，你该如何继续？如果你没有看过《南渡北归》，你无法明白当年西南联大有多么不容易，当年的那些大家能够给本科生上课是有多么珍贵。电影最后给出的一个个那些年顶尖的学者，真是满满的感动和自豪。无问西东，砥砺前行。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-01-08-WEEK188-三块广告牌"></a>2018-01-08 WEEK188 三块广告牌</h3><p>三块广告牌——————————————Three Billboards Outside Ebbing, Missouri<br /><img src="https://img.piegg.cn/week188.jpg?imageslim" /></p><ul><li>导演：马丁·麦克唐纳</li><li>主演：弗兰西斯·麦克多蒙德/伍迪·哈里森/山姆·洛克威尔/艾比·考尼什/卢卡斯·赫奇斯/彼特·丁拉基/约翰·浩克斯/卡赖伯·兰德里·琼斯/凯瑟琳·牛顿/凯瑞·康顿/泽利科·伊万内克/萨玛拉·维文/克拉克·彼得斯/尼克·西塞</li><li>片长：115分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.7/10(from20,455users)</li><li>IMDB评分：8.3/10(from31,903users)</li></ul><p>Hi，各位好久不见！忙完考试之后终于有时间来写本周的电影推荐了。本周给大家推荐的是去年底在美国上映（中国将在18年3月上映）的电影《三块广告牌》。</p><p>在这部充满美式幽默和美式愤怒的电影里，看到了久违的不靠煽情而让你动容的一部电影。不过我认为，真正让这部电影拥有如此好评的原因在于两点：</p><ol><li>导演（同时也是编剧）的讲故事的功力深厚</li><li>演员（尤其是科恩嫂）的演技强劲</li></ol><p>这部是一部讲述愤怒与善良，爱与恨的电影。愤怒不能解决问题，但是爱可以。影片塑造的多个人物都具有两面性——这也是本部电影最棒的地方。没有一个人是可以用好或者不好来形容的。每个人都有自己的阳光和阴暗面——而一开始我们不免进入了导演给我们设置的俗套。而随着剧情的发展你才会发现这一切都不是那么简单。“坏”警长其实不坏——相反还非常受人敬仰，“烂”警察其实不烂——相反他还自损三千地只为抓犯人等等。</p><p>而在被套路或者反套路的同时，你也逐渐了解到美国社会的诸多矛盾以及人的诸多美好品质。愤怒不能解决问题，但是善良与爱是可以的。好电影，值得一看。</p><hr /><h3><a href="https://molunerfinn.com/PerfectMoviePerWeek5/#2018-01-01-WEEK187-我能说"></a>2018-01-01 WEEK187 我能说</h3><p>我能说——————————————아이 캔 스피크<br /><img src="https://img.piegg.cn/week187.jpg?imageslim" /></p><ul><li>导演：金炫锡</li><li>主演：罗文姬/李帝勋/廉惠兰/朴哲民/李相喜/李知勋/郑妍周/金素真</li><li>片长：119分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.8/10(from19,693users)</li><li>IMDB评分：7.7/10(from195users)</li></ul><p>Hi，各位新年快乐~转眼之间一周一部好电影已经来到了第5个年头。前四个年头通过一周一部好电影我已经推送了186部各种主题，各种类型，各种风格的电影，希望新的一年里能够有更多的好电影能够分享给各位~</p><p>本周给大家推荐的电影是一部去年韩国的电影《我能说》。一部能用喜剧的形式来讲述“慰安妇”这个沉痛主题的电影，真的无不佩服编剧的功力以及演员的水平。两个主演的表演真的太动人了。</p><p>这部电影能分成两部分。前半部分以喜剧为主，讲述一个“鬼怪奶奶”的各种“鬼怪”行径。而前半部分用尽努力“掩盖”的欢乐，在后半段会被导演“无情”地打碎，同时打碎的还有观众的泪腺。而同时引出的是这部电影的主题啊——那些被人们忽略的受害者们，那些无法说出，不愿说出，不想说出自己曾经经历的受害者们。她们真的需要更多我们的关怀和帮助。国内今年的《二十二》也是同样的主题。不同的角度，不过都是同样的出发点和同样的愿望——日本政府的一句道歉。好电影，值得一看。</p>]]></content>
        
        <summary type="html">
            
            2018-11-11 WEEK210 网络迷踪网络迷踪——————————————Searching导演：阿尼什·查甘蒂主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯
            
        </summary>
        
        <category term="日志"/>
        
        <category term="周电"/>
        
        <category term="电影"/>
        
    </entry>
    
    <entry>
        <title>即日起本站域名切换到gaojianli.me</title>
        <link href="https://blog.gaojianli.me/2018/10/15/%E5%8D%B3%E6%97%A5%E8%B5%B7%E6%9C%AC%E7%AB%99%E5%9F%9F%E5%90%8D%E5%88%87%E6%8D%A2%E5%88%B0gaojianli-me/"/>
        <id>https://blog.gaojianli.me/2018/10/15/%E5%8D%B3%E6%97%A5%E8%B5%B7%E6%9C%AC%E7%AB%99%E5%9F%9F%E5%90%8D%E5%88%87%E6%8D%A2%E5%88%B0gaojianli-me/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<p>一直以来，我都使用的是<a href="http://www.freenom.com/" target="_blank">Freenom</a>提供的<code>.tk</code>免费域名，由于功能齐全且续费免费，自然是我区区一个穷学生的首选。虽然一直有小伙伴劝我切换到一个收费域名，而且烈士墙上被无故收走域名惨案的比比皆是。但我由于个人懒惰，在加上<strong>又不是不能用</strong>的人生信条，一直就用了下来。<br />但是就在前不久，<a href="https://blog.xice.wang/2018/10/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%97%9B%E5%A4%B1%E5%9F%9F%E5%90%8D%E7%9A%84%E7%BB%8F%E5%8E%86/" target="_blank">潇</a>却经历了一次惨痛无比的域名回收事件，<code>Freenom</code>在没有任何征兆、事前通知的情况下删除了他的域名（xice.cf)，而再次注册已经提示要收费。而他的国内域名备案迟迟得不到批准，现阶段就连翻墙都存在困难。于我而言，这不啻前车之鉴。与其被黑心厂商突然收走域名，到时候再手忙脚乱地迁移，不如自己慢慢搬迁。而正好，Github的<a href="https://education.github.com/pack" target="_blank">Student developer pack</a>包含了由<a href="https://nc.me/github/auth" target="_blank">Namecheap</a>提供了免费的<code>.me</code>域名一年使用权，就打算先将就用着。因此现阶段不论是博客还是树莓派上的各种服务都会慢慢地搬迁，直至最终弃用<code>gaojianli.tk</code>这一不稳定要素。<br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            一直以来，我都使用的是Freenom提供的.tk免费域名，由于功能齐全且续费免费，自然是我区区一个穷学生的首选。虽然一直有小伙伴劝我切换到一个收费域名，而且烈士墙上被无故收走域名惨案的比比皆是。但我由于个人懒惰，在加上又不是不能用的人生信条，一直就用了下来。但是就在前不久，潇却
            
        </summary>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>少女前线拖尸脚本 和 生成它的可视化工具</title>
        <link href="https://binux.blog/2018/10/girls-frontline-ankulua-vision/"/>
        <id>https://binux.blog/2018/10/girls-frontline-ankulua-vision/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2019-03-03T06:59:37+00:00</published>
        <updated>2019-03-03T06:59:37+00:00</updated>
        
        <content type="html"><![CDATA[<p>最近在玩少女前线，这是一个手机游戏，over。不是，就真的没有什么好讲的嘛，了解的人早有耳闻，不了解的就只要知道这是个手机游戏就好了，嗯。</p><p>然后，我会好好地，正常地，氪金地去玩这个游戏吗？不可能的，玩游戏哪有破解它有意思呢。当年破解 Ingress 是因为它用的 HTTPS 通信的，算是本行。百万亚瑟王是因为别人已经逆向好了，我只是写了一些 bot。现在这么办，玩不了了吗？作为一个不会安卓，不会逆向，不会汇编的菜鸡，那我只好上按键精灵了啊。于是乎，我找到了这个： <a href="http://ankulua-tw.boards.net/thread/2/ankulua" target="_blank">AnkuLua</a></p><blockquote><p>AnkuLua 是一個專注在自動化的Android App<br />基本自動化動作有:</p><ul><li>抓取螢幕並找尋指定圖案 </li><li>對找圖結果採取使用者要的動作(例如點擊、抓放(drag and drop)、打字…等等)</li></ul></blockquote><p>最重要的是，它能运行 lua 脚本！虽然我是一个不会安卓，不会逆向，不会汇编的菜鸡，但是我会 lua 啊。</p><h3><a href="https://binux.blog/2018/10/girls-frontline-ankulua-vision/#ankulua-vision"></a>ankulua-vision</h3><p>不过，在使用过程中发现，找寻指定图案，需要不断截图/裁剪，这样太麻烦了。于是我又用 electron 做了一个可视化的截图资源管理器 <a href="https://github.com/binux/ankulua-vision" target="_blank">ankulua-vision</a>，像这样的：</p><p><img src="https://raw.githack.com/binux/ankulua-vision/master/static/Screenshot.png" /></p><p>基本思路就是，一般游戏是由众多 UI 界面组成的，点击某个按钮能跳转到某个界面上去。那么通过截图，标注<strong>识别区域</strong>，那么程序就能知道游戏现在所处的界面。通过标注<strong>按钮区域</strong>，那么只需要 <code>goto('battle')</code>，程序就能自动规划从当前界面到 battle 的可行路径，然后点啊点啊就完成需要的操作了。这样一方面不需要自己去裁剪图片了，另一方面通过框架代码，在运行过程中能够有更多的错误检查，自动应对可能出现的各种异常。</p><p>理论上，对于点啊点的游戏，是能实现无代码的。即使不能，对于复杂的动作，也可以通过 lua 拓展。</p><p>源码在这里：<a href="https://github.com/binux/ankulua-vision" target="_blank">https://github.com/binux/ankulua-vision</a>  </p><p>你依旧需要在安卓手机或者模拟器中安装 ankulua，然后加载生成的 start.lua 脚本。默认自带了一个简单的循环逻辑，运行后可以直接图形化界面配置运行。当然你也可以通过 lua 脚本拓展，除了 ankulua 本身的 API 可用之外，你也可以使用 <code>stateMachine</code> 这套界面跳转逻辑 API，重用简化步骤。<code>stateMachine</code> 的 API 在 README 中有简略的文档说明。</p><p><img src="https://binux.blog/assets/image/MuMu20181014200018.png" /></p><p>源码使用 GPLv3 或 MIT 许可证，取决于第一个有效 PR（例如 fix typo 不算），如果第一个 PR 之前有商业化需求或者 PR 作者要求，则 MIT。</p><h3><a href="https://binux.blog/2018/10/girls-frontline-ankulua-vision/#少女前线拖尸脚本"></a>少女前线拖尸脚本</h3><p><strong>WARNING: 任何使用脚本的行为都是官方禁止的，我不对下文所述任何内容以及其后果负责</strong></p><p>于是，这里就是 少女前线的拖尸脚本：</p><p><a href="https://github.com/binux/binux_github_com/releases/download/gf/shojo.zip" target="_blank">https://github.com/binux/binux_github_com/releases/download/gf/shojo.zip</a></p><p>同时它也是一个 ankulua-vision 的项目，你可以通过 ankulua-vision 打开这个项目目录，调整截屏或者按钮位置。</p><h4><a href="https://binux.blog/2018/10/girls-frontline-ankulua-vision/#脚本实现的功能"></a>脚本实现的功能</h4><ul><li>43e, 02, 52n 拖尸</li><li>自动重启后勤</li><li>自动强化或者分解人形</li><li>自动修理</li></ul><h4><a href="https://binux.blog/2018/10/girls-frontline-ankulua-vision/#使用方法"></a>使用方法</h4><ol><li>根据 <a href="http://bbs.nga.cn/read.php?tid=13670657" target="_blank">[填坑结束？][失了智]萌新向拖尸教学帖[更新8-1N相关]</a> 一文准备好打手和阵型，一队练级队，二队补给队，52n 还需要 3 队狗粮队。</li><li>解压拷贝脚本到手机中，在 ankulua 中加载 start.lua。</li><li>在启动界面中选择你的两个打手（每轮结束后，两个打手会交换），选择拖尸任务，如果仅自动后勤，选择 null 就好了。</li></ol><p>其中 52n 会在战斗中撤退 5, 8 号位 （见 NGA 文 “43e的说明” 展开部分），02 在选择 m4a1 时会撤退 1, 7 号位。</p><p><img src="https://binux.blog/assets/image/MuMu20181014200007.png" /></p><p>然后开始吧！</p><p><strong>WARNING: 任何使用脚本的行为都是官方禁止的，我不对上文所述任何内容以及其后果负责</strong></p><p>over</p>]]></content>
        
        <summary type="html">
            
            最近在玩少女前线，这是一个手机游戏，over。不是，就真的没有什么好讲的嘛，了解的人早有耳闻，不了解的就只要知道这是个手机游戏就好了，嗯。然后，我会好好地，正常地，氪金地去玩这个游戏吗？不可能的，玩游戏哪有破解它有意思呢。当年破解 Ingress 是因为它用的 HTTPS 通信
            
        </summary>
        
        <category term="少女前线"/>
        
        <category term="ankulua"/>
        
        <category term="ankulua-vision"/>
        
        <category term="安卓"/>
        
        <category term="自动化"/>
        
        <category term="open-source"/>
        
        <category term="github"/>
        
    </entry>
    
    <entry>
        <title>树莓派添加温控风扇（二）</title>
        <link href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
        <id>https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#前言"></a>前言</h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/">上回</a>说到，对于arm64的系统来说，目前并没有一个库可以支持对GPIO的调用。那么接下来摆在我面前的就三条路：<ol><li>修改setup.c，让cpuinfo中包含相应的Hardware信息，随后重新编译内核</li><li>修改wiringPi源码</li><li>放弃使用库</li></ol><h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#可行的方法"></a>可行的方法</h1><p>上面三个选项中，1和2显然是极其不现实的，因此我决定采用第三条路。在之前那个<a href="https://github.com/bamarni/pi64/issues/35" target="_blank">issue</a>中，我看到了这样一种用法：</p><a></a><blockquote><p>At least as root GPIO works in bash on low level:<br />echo “23” &gt; /sys/class/gpio/export<br />echo “out” &gt; /sys/class/gpio/gpio23/direction<br />echo “1” &gt; /sys/class/gpio/gpio23/value<br />…<br />and can be verified by LED.</p></blockquote><p>根据网上的资料，<code>/sys/class/gpio</code>是linux通用的GPIO控制方法，看样子是好好地贯彻了Unix“一切皆文件”的思想。那么接下来简单地测试一下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span># root @ rasp in /sys/class/gpio [19:07:22]</span><br /><span>$ echo 18&gt;export</span><br /><span></span><br /><span># root @ rasp in /sys/class/gpio [19:07:33]</span><br /><span>$ ls</span><br /><span>export  gpio18  gpiochip0  gpiochip100  gpiochip128  unexport</span><br /></pre></td></tr></table><p>可以看到系统自动生成了相关的GPIO目录，进入之后可以看到相关的文件</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span># root @ rasp in /sys/class/gpio/gpio18 [19:10:36]</span><br /><span>$ ls</span><br /><span>active_low  device  direction  edge  power  subsystem  uevent  value</span><br /></pre></td></tr></table><p>相关的命名还是非常简单直观的，向<code>direction</code>中写入信息控制GPIO的输入输出方向，<code>value</code>则控制的是输出值，那么就拿我们先前选定的18号针脚来测试一下吧:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span># root @ rasp in /sys/class/gpio/gpio18 [19:11:31]</span><br /><span>$ echo out&gt;direction</span><br /><span></span><br /><span># root @ rasp in /sys/class/gpio/gpio18 [19:14:50]</span><br /><span>$ echo "1"&gt;value</span><br /></pre></td></tr></table><p>接下来用万用表检测<br /><img src="https://blog.gaojianli.me/volate_check.jpg" /><br />3.28v，确实是1，取消输出不知道为什么向<code>value</code>写入0并不管用，因此只有直接向<code>unexport</code>写入端口号:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span># root @ rasp in /sys/class/gpio [19:29:18]</span><br /><span>$ echo 18&gt;unexport</span><br /><span></span><br /><span># root @ rasp in /sys/class/gpio [19:29:22]</span><br /><span>$ ls</span><br /><span>export  gpiochip0  gpiochip100  gpiochip128  unexport</span><br /></pre></td></tr></table><p>可以看到相关的目录自动被移除了，电压也变成了0</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#代码编写"></a>代码编写</h2><p>实际上逻辑并不复杂，但是要考虑到程序退出之后风扇依旧会旋转，因此要做好信号的捕捉：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /><span>68</span><br /><span>69</span><br /><span>70</span><br /><span>71</span><br /><span>72</span><br /><span>73</span><br /><span>74</span><br /><span>75</span><br /><span>76</span><br /><span>77</span><br /><span>78</span><br /><span>79</span><br /><span>80</span><br /><span>81</span><br /><span>82</span><br /><span>83</span><br /><span>84</span><br /><span>85</span><br /><span>86</span><br /><span>87</span><br /><span>88</span><br /><span>89</span><br /><span>90</span><br /><span>91</span><br /><span>92</span><br /><span>93</span><br /><span>94</span><br /><span>95</span><br /><span>96</span><br /><span>97</span><br /><span>98</span><br /><span>99</span><br /><span>100</span><br /><span>101</span><br /><span>102</span><br /><span>103</span><br /><span>104</span><br /><span>105</span><br /><span>106</span><br /><span>107</span><br /><span>108</span><br /><span>109</span><br /><span>110</span><br /><span>111</span><br /><span>112</span><br /><span>113</span><br /><span>114</span><br /><span>115</span><br /><span>116</span><br /><span>117</span><br /><span>118</span><br /></pre></td><td><pre><span><span>#<span>include</span> <span>&lt;cstdio&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;unistd.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;stdlib.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;sys/stat.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;malloc.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;time.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;sys/types.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;iostream&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;string&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;cstring&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;fcntl.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;signal.h&gt;</span></span></span><br /><span></span><br /><span><span>using</span> <span>namespace</span> <span>std</span>;</span><br /><span></span><br /><span><span>#<span>define</span> TEMP_PATH <span>"/sys/class/thermal/thermal_zone0/temp"</span></span></span><br /><span><span>#<span>define</span> MAX_SIZE 20</span></span><br /><span><span>#<span>define</span> GPIO_PIN 18</span></span><br /><span></span><br /><span><span><span>float</span> <span>getTemp</span><span>()</span></span>;</span><br /><span><span>bool</span> status = <span>false</span>;</span><br /><span><span>char</span> *timenow;</span><br /><span></span><br /><span><span><span>char</span> *<span>getTime</span><span>()</span></span></span><br /><span><span></span>{</span><br /><span><span>free</span>(timenow);</span><br /><span>timenow = (<span>char</span> *)<span>calloc</span>(<span>40</span>, <span>sizeof</span>(<span>char</span>));</span><br /><span><span>time_t</span> rawtime;</span><br /><span><span><span>struct</span> <span>tm</span> *<span>timeinfo</span>;</span></span><br /><span>time(&amp;rawtime);</span><br /><span>timeinfo = localtime(&amp;rawtime);</span><br /><span>*timenow = <span>'['</span>;</span><br /><span><span>strcat</span>(timenow, asctime(timeinfo));</span><br /><span>timenow[<span>strlen</span>(timenow) - <span>1</span>] = <span>'\0'</span>;</span><br /><span><span>strcat</span>(timenow, <span>"] "</span>);</span><br /><span><span>return</span> timenow;</span><br /><span>}</span><br /><span><span><span>void</span> <span>setHigh</span><span>(<span>int</span> gpio_num)</span></span></span><br /><span><span></span>{</span><br /><span><span>string</span> str1 = <span>"echo "</span>;</span><br /><span><span>string</span> str2 = <span>"&gt; /sys/class/gpio"</span>;</span><br /><span>system((str1 + to_string(gpio_num) + str2 + <span>"/export"</span>).c_str());</span><br /><span>system((str1 + <span>"high"</span> + str2 + <span>"/gpio"</span> + to_string(gpio_num) + <span>"/direction"</span>).c_str());</span><br /><span><span>printf</span>(<span>" Fan started.\n"</span>);</span><br /><span>}</span><br /><span><span><span>void</span> <span>removeGPIO</span><span>(<span>int</span> gpio_num)</span></span></span><br /><span><span></span>{</span><br /><span><span>string</span> str1 = <span>"echo "</span>;</span><br /><span><span>string</span> str2 = <span>"&gt; /sys/class/gpio"</span>;</span><br /><span>system((str1 + to_string(gpio_num) + str2 + <span>"/unexport"</span>).c_str());</span><br /><span><span>printf</span>(<span>" Fan stopped.\n"</span>);</span><br /><span>}</span><br /><span><span><span>void</span> <span>sigroutine</span><span>(<span>int</span> sig)</span></span></span><br /><span><span></span>{</span><br /><span><span>if</span> (sig == SIGINT)</span><br /><span><span>printf</span>(<span>"%sGet SIGINT, quiting..."</span>, getTime());</span><br /><span><span>else</span> <span>if</span> (sig == SIGTERM)</span><br /><span><span>printf</span>(<span>"%sGet SIGTERM, quiting..."</span>, getTime());</span><br /><span><span>if</span> (status)</span><br /><span>removeGPIO(GPIO_PIN);</span><br /><span><span>exit</span>(<span>-1</span>);</span><br /><span>}</span><br /><span><span><span>int</span> <span>main</span><span>(<span>int</span> argc, <span>char</span> *argv[])</span></span></span><br /><span><span></span>{</span><br /><span>signal(SIGINT, sigroutine);</span><br /><span>signal(SIGTERM, sigroutine);</span><br /><span><span>if</span> (argc != <span>1</span>)</span><br /><span>{</span><br /><span><span>if</span> (<span>strcmp</span>(argv[<span>1</span>], <span>"stop"</span>) == <span>0</span>)</span><br /><span>{</span><br /><span>removeGPIO(GPIO_PIN);</span><br /><span><span>return</span> <span>0</span>;</span><br /><span>}</span><br /><span>}</span><br /><span><span>float</span> temp;</span><br /><span><span>while</span> (<span>true</span>)</span><br /><span>{</span><br /><span>temp = getTemp();</span><br /><span><span>printf</span>(<span>"%sTemperature is %.2f,"</span>, getTime(), temp);</span><br /><span><span>if</span> (temp &gt; <span>50</span> &amp;&amp; status == <span>false</span>)</span><br /><span>{</span><br /><span>setHigh(GPIO_PIN);</span><br /><span>status = <span>true</span>;</span><br /><span>}</span><br /><span><span>else</span> <span>if</span> (temp &lt; <span>45</span> &amp;&amp; status)</span><br /><span>{</span><br /><span>removeGPIO(GPIO_PIN);</span><br /><span>status = <span>false</span>;</span><br /><span>}</span><br /><span><span>else</span> <span>if</span> (!status)</span><br /><span><span>printf</span>(<span>" nothing to do...\n"</span>);</span><br /><span><span>else</span> <span>if</span> (status)</span><br /><span><span>printf</span>(<span>" keep fan working...\n"</span>);</span><br /><span>sleep(<span>5</span>);</span><br /><span>}</span><br /><span><span>return</span> <span>0</span>;</span><br /><span>}</span><br /><span></span><br /><span><span><span>float</span> <span>getTemp</span><span>(<span>void</span>)</span></span></span><br /><span><span></span>{</span><br /><span><span>int</span> fd;</span><br /><span><span>float</span> temp = <span>0</span>;</span><br /><span><span>char</span> buf[MAX_SIZE];</span><br /><span>fd = <span>open</span>(TEMP_PATH, O_RDONLY);</span><br /><span><span>if</span> (fd &lt; <span>0</span>)</span><br /><span>{</span><br /><span><span>fprintf</span>(<span>stderr</span>, <span>"failed to open thermal_zone0/temp\n"</span>);</span><br /><span><span>return</span> <span>-1</span>;</span><br /><span>}</span><br /><span><span>if</span> (<span>read</span>(fd, buf, MAX_SIZE) &lt; <span>0</span>)</span><br /><span>{</span><br /><span><span>fprintf</span>(<span>stderr</span>, <span>"failed to read temp\n"</span>);</span><br /><span><span>return</span> <span>-1</span>;</span><br /><span>}</span><br /><span>temp = atoi(buf) / <span>1000.0</span>;</span><br /><span><span>close</span>(fd);</span><br /><span><span>return</span> temp;</span><br /><span>}</span><br /></pre></td></tr></table><p>请原谅我极其不优雅不简洁的实现方式和混乱的代码风格，毕竟有太久没碰过了。但是我要说的还是那句话：</p><blockquote>            <p><span>又不是不能用</span></p>          </blockquote><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#再次碰壁"></a>再次碰壁</h2><p>我按照上面的方法接入了风扇，随后echo……嗯，看起来一切正常，也没有报错什么的，除了风扇<strong>*纹丝不动</strong>以外。<br />纹丝不动……<br />纹丝不动……<br />不动……<br />动……<br />……<br />Why？为什么会变成这样呢……第一次有了能调用GPIO的方法。有了能控制风扇开关的代码。两件快乐事情重合在一起。而这两份快乐，又给我带来更多的快乐。得到的，本该是像梦境一般幸福的时间……但是，为什么，会变成这样呢……</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#原因分析及解决方法"></a>原因分析及解决方法</h2><p>咳咳，请不要打我。其实仔细想想原因不难想到，GPIO是一种数字电路，而数字电路的电阻通常大得惊人，电流则是mA级别的，所能做的也仅仅就是点亮LED而已，想要让它驱动风扇实在是强人所难。因此不可避免地，我们就需要对电流进行放大。目前手头只有A42 A331的三极管，β值大约在320左右，勉强可以使用，就就地使用了。电路图大致如下（手残请忽略）：<br /><img src="https://blog.gaojianli.me/Sketch.png" /><br />基极连接GPIO并调至高电平之后，测得发射极和和集电极之间电压为4.66v，带动风扇应该没问题<br /><img src="https://blog.gaojianli.me/volate2.jpg" /><br />接入风扇之后，风扇正常工作，至此，温控风扇连接完毕。</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#自启动"></a>自启动</h2><p>写了一个程序，当然要做成自启动服务了，得益于<code>systemd</code>，编写系统服务变得非常简单，在<code>/etc/systemd/system</code>目录下新建一个<code>autofan.service</code>文件，内容如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span>[Unit]</span><br /><span>Description=Temperature controled fan daemon</span><br /><span></span><br /><span>[Service]</span><br /><span>Type=simple</span><br /><span>PIDFile=/var/run/autofan.pid</span><br /><span>User=root</span><br /><span>ExecStart=/usr/bin/autoFan</span><br /><span></span><br /><span>[Install]</span><br /><span>WantedBy=multi-user.target</span><br /></pre></td></tr></table><p>随后运行<code>systemctl daemon-reload</code>重新加载服务，<code>systemctl start autofan.service</code>启动服务即可。</p><h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%BA%8C%EF%BC%89/#后文"></a>后文</h1><p>虽然成功地实现了风扇的温度控制，但是文中的操控GPIO的方法实在太不优雅了，仅仅是个临时之策，无法大规模运用。当然，也不是没有将之封装成一个库的想法，但时目前并没有太多的需要以及动力，就先这样吧。<del>又不是不能用</del></p><blockquote>            <p>不要重复造轮子<br />——忘了谁说的了</p>          </blockquote><p>では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            前言上回说到，对于arm64的系统来说，目前并没有一个库可以支持对GPIO的调用。那么接下来摆在我面前的就三条路：修改setup.c，让cpuinfo中包含相应的Hardware信息，随后重新编译内核修改wiringPi源码放弃使用库可行的方法上面三个选项中，1和2显然是极其不
            
        </summary>
        
        <category term="树莓派"/>
        
    </entry>
    
    <entry>
        <title>树莓派添加温控风扇（一）</title>
        <link href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
        <id>https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#前言"></a>前言</h1><p>前不久不知道树莓派抽什么风，风扇的噪音突然变得奇大无比，弄得潇叫苦连连。虽然我亲自去听了之后觉得声音远远比不上他的神舟和那台安装了FreeBSD的古董机，但毕竟有求于人，这样下去也不是个办法。稍加分析不难得出，风扇声音大是因为24小时常开导致了积灰和磨损，尤其是前者更是难以避免。而我树莓派大部分时候都处于闲置状态，风扇其实是没必要24小时上线的。那么，能不能让风扇按需启动呢？这样一来可以改善噪音问题，同时树莓派困扰许久的供电不足问题也能够得到相应的改善。</p><a></a><h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#初步思路"></a>初步思路</h1><p>那么，如何用树莓派控制风扇呢？不同于PC主板，树莓派并没有能够直接控制风扇的接口，因此要想控制风扇只有通过那40PIN的GPIO来实现。<br />首先我们来查一下树莓派的引脚：<br /><img src="https://blog.gaojianli.me/pi-gpio.png" /><br />我平时长通使用的就是右侧的4，6号针脚，而需要控制的话，右侧的12号，14号针脚看起来是个理想的选择。</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#安装wiringPi"></a>安装wiringPi</h2><p>在树莓派上想要轻松地使用GPIO针脚需要用到<a href="http://wiringpi.com/" target="_blank">wiringPi</a>这个库，它可以让我们用C或者C++对树莓派的GPIO针脚进行控制。<br />安装过程非常简单，跟着官网教程走就行了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>git clone git://git.drogon.net/wiringPi</span><br /><span>cd wiringPi</span><br /><span>./build</span><br /></pre></td></tr></table><p>竟然不是make略微让我吃惊，不过安装完成没出什么幺蛾子就好<del>(这个flag…)</del>。</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#编写控制代码"></a>编写控制代码</h2><p>其实整个程序的逻辑并不复杂，也就是</p><ol><li>获取温度</li><li>根据预先写好的规则进行判断</li><li>调整GPIO输出</li></ol><p>相关代码如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /></pre></td><td><pre><span><span>#<span>include</span> <span>&lt;wiringPi.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;stdio.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;unistd.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;stdlib.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;sys/stat.h&gt;  </span></span></span><br /><span><span>#<span>include</span> <span>&lt;sys/types.h&gt;</span></span></span><br /><span><span>#<span>include</span> <span>&lt;fcntl.h&gt;  </span></span></span><br /><span><span>#<span>define</span> TEMP_PATH <span>"/sys/class/thermal/thermal_zone0/temp"</span>  </span></span><br /><span><span>#<span>define</span> MAX_SIZE 20  </span></span><br /><span><span>#<span>define</span> GPIO_PIN  18</span></span><br /><span><span><span>float</span> <span>getTemp</span><span>()</span></span>;</span><br /><span><span><span>int</span> <span>main</span><span>(<span>void</span>)</span></span></span><br /><span><span></span>{</span><br /><span><span>if</span> (wiringPiSetupGpio() == <span>-1</span>) <span>//初始化GPIO</span></span><br /><span>{</span><br /><span><span>fprintf</span>(<span>stderr</span>,<span>"Setup wiringPi failed!"</span>);</span><br /><span><span>return</span> <span>-1</span>;</span><br /><span>}</span><br /><span><span>pinMode</span>(GPIO_PIN, <span>OUTPUT</span>);<span>//设定输出模式</span></span><br /><span><span>float</span> temp;</span><br /><span><span>bool</span> status = <span>false</span>;</span><br /><span><span>while</span> (<span>true</span>)</span><br /><span>{</span><br /><span>temp = getTemp();</span><br /><span><span>if</span> (temp &gt; <span>50</span>) {</span><br /><span><span>digitalWrite</span>(GPIO_PIN, <span>1</span>);<span>//开启风扇</span></span><br /><span>status = <span>true</span>;</span><br /><span>}</span><br /><span><span>else</span> <span>if</span>(temp&lt;<span>40</span> &amp;&amp;status)</span><br /><span>{</span><br /><span><span>digitalWrite</span>(GPIO_PIN, <span>0</span>);<span>//关闭风扇</span></span><br /><span>status = <span>false</span>;</span><br /><span>}</span><br /><span><span>delay</span>(<span>5000</span>);</span><br /><span>}</span><br /><span><span>return</span> <span>0</span>;</span><br /><span>}</span><br /><span></span><br /><span><span><span>float</span> <span>getTemp</span><span>(<span>void</span>)</span><span>//获取温度函数</span></span></span><br /><span><span></span>{</span><br /><span><span>int</span> fd;</span><br /><span><span>float</span> temp = <span>0</span>;</span><br /><span><span>char</span> buf[MAX_SIZE];</span><br /><span>fd = <span>open</span>(TEMP_PATH, O_RDONLY);</span><br /><span><span>if</span> (fd &lt; <span>0</span>)</span><br /><span>{</span><br /><span><span>fprintf</span>(<span>stderr</span>, <span>"failed to open thermal_zone0/temp\n"</span>);</span><br /><span><span>return</span> <span>-1</span>;</span><br /><span>}</span><br /><span><span>if</span> (<span>read</span>(fd, buf, MAX_SIZE) &lt; <span>0</span>)</span><br /><span>{</span><br /><span><span>fprintf</span>(<span>stderr</span>, <span>"failed to read temp\n"</span>);</span><br /><span><span>return</span> <span>-1</span>;</span><br /><span>}</span><br /><span>temp = atoi(buf) / <span>1000.0</span>;</span><br /><span><span>close</span>(fd);</span><br /><span><span>return</span> temp;</span><br /><span>}</span><br /></pre></td></tr></table><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#编译"></a>编译</h2><p>这部分就是非常基础了，总之先测试一下：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>g++ main.cpp -lwiringPi</span><br /></pre></td></tr></table><p>看起来并没有遇到什么问题，那么接下来就尝试运行一下吧。</p><h1><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#碰壁"></a>碰壁</h1><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span># root @ rasp in ~/projects/AutoFan [14:43:28]</span><br /><span>$ ./a.out</span><br /><span>Oops: Unable to determine board revision from /proc/cpuinfo</span><br /><span> -&gt; No "Hardware" line</span><br /><span> -&gt;  You'd best google the error to find out why.</span><br /></pre></td></tr></table><p>喵喵喵？这什么鬼。。看起来是不认我的cpuinfo？<br />赶紧<code>cat</code>一下:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /></pre></td><td><pre><span>cat cpuinfo</span><br /><span>processor       : 0</span><br /><span>BogoMIPS        : 38.40</span><br /><span>Features        : fp asimd evtstrm crc32 cpuid</span><br /><span>CPU implementer : 0x41</span><br /><span>CPU architecture: 8</span><br /><span>CPU variant     : 0x0</span><br /><span>CPU part        : 0xd03</span><br /><span>CPU revision    : 4</span><br /><span></span><br /><span>processor       : 1</span><br /><span>BogoMIPS        : 38.40</span><br /><span>Features        : fp asimd evtstrm crc32 cpuid</span><br /><span>CPU implementer : 0x41</span><br /><span>CPU architecture: 8</span><br /><span>CPU variant     : 0x0</span><br /><span>CPU part        : 0xd03</span><br /><span>CPU revision    : 4</span><br /><span></span><br /><span>processor       : 2</span><br /><span>BogoMIPS        : 38.40</span><br /><span>Features        : fp asimd evtstrm crc32 cpuid</span><br /><span>CPU implementer : 0x41</span><br /><span>CPU architecture: 8</span><br /><span>CPU variant     : 0x0</span><br /><span>CPU part        : 0xd03</span><br /><span>CPU revision    : 4</span><br /><span></span><br /><span>processor       : 3</span><br /><span>BogoMIPS        : 38.40</span><br /><span>Features        : fp asimd evtstrm crc32 cpuid</span><br /><span>CPU implementer : 0x41</span><br /><span>CPU architecture: 8</span><br /><span>CPU variant     : 0x0</span><br /><span>CPU part        : 0xd03</span><br /><span>CPU revision    : 4</span><br /></pre></td></tr></table><p>这就奇怪了，确实没有硬件相关的字段。。难道是我内核的问题？之前为了所谓的性能提升，我给树莓派安装的是64位Debian，并不是官方的通用Raspbian。</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#原因"></a>原因</h2><p>在翻了大半天github之后，我找到了这个<a href="https://github.com/bamarni/pi64/issues/35" target="_blank">issue</a>接着又被导引到<a href="https://github.com/raspberrypi/linux/issues/2110" target="_blank">这个</a>，里面这个疑似内核维护者的人写道：</p><blockquote><p>1.We aren’t supporting 64-bit builds, although if there are simple things we can do (like hosting defconfigs for arm64) then we will.<br />2.When we do support arm64 it will be with the absolute minimum number of changes to the upstream kernel (ideally none), and the content of /proc/cpuinfo would not be high on the list of priorities. Board revision number and serial number are concepts that don’t appear to exist in the arm64 architecture, but we will continue to make that information available via /proc/device-tree/system/linux,revision and /proc/device-tree/system/linux,serial, with human-readable versions in /proc/device-tree/model and /proc/device-tree/serial-number</p></blockquote><p>大意就是树莓派linux从未支持过arm64，并且arm64的上游内核决定在cpuinfo里面显示更少的信息，并将版本号等信息移到<code>/proc/device-tree/model</code>等地去，他们决定对上游内核做尽可能少的修改，因此不打算修复这个不算bug的问题。所有我能做的就是等待wiringPi等库更新，以兼容arm64。</p><h2><a href="https://blog.gaojianli.me/2018/09/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B7%BB%E5%8A%A0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87%EF%BC%88%E4%B8%80%EF%BC%89/#后续"></a>后续</h2><p>很遗憾，根据这个issue提出的日期来看，他们是没有兼容的意向的，因此我现在就维持在一种凉凉的状态。只能说，这就是使用小众系统的代价，找不到文档或者社区支持已经是常态，BSD也好，slackware也好，都是这样。<br />对于这种问题来讲目前是没有什么好思路的，今天天色也不早了，问题留到明天再看看吧。<br />つづく</p>]]></content>
        
        <summary type="html">
            
            前言前不久不知道树莓派抽什么风，风扇的噪音突然变得奇大无比，弄得潇叫苦连连。虽然我亲自去听了之后觉得声音远远比不上他的神舟和那台安装了FreeBSD的古董机，但毕竟有求于人，这样下去也不是个办法。稍加分析不难得出，风扇声音大是因为24小时常开导致了积灰和磨损，尤其是前者更是难以
            
        </summary>
        
        <category term="树莓派"/>
        
    </entry>
    
    <entry>
        <title>为博客添加Gitalk评论插件</title>
        <link href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"/>
        <id>https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#前言"></a>前言</h1><p>一直以来都想要给自己的博客弄个评论系统，但是hexo作为一个静态博客，本身是不可能具有这种功能的，只能仰仗第三方插件。这方面的插件也非常多，比如disqus、vline等。但这些插件都存在或多或少问题，比如注册麻烦或者干脆国内不能访问。考虑到我家长城宽带的现实，必须选择一个在各地都能流畅访问的插件，这里我选择了<a href="https://github.com/gitalk/gitalk" target="_blank">Gitalk</a>.</p><h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#简介"></a>简介</h1><p>先来看看官网的简介吧：</p><blockquote><p>Gitalk is a modern comment component based on GitHub Issue and Preact.</p></blockquote><p>顾名思义，这是一个基于GitHub的issue功能构建的评论系统。为了部署方便，我的博客本身也是托管在GitHub上的，而且其CDN也遍布全球各地，即使是长城宽带也能保证访问。此外相信本文的绝大多数读者也都具有GitHub账号，这也省去了大家注册的麻烦。因此，从各种意义上来说，它都是一个理想的插件。</p><a></a><h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#安装"></a>安装</h1><p>官方提供了2种安装方式：直接引用和npm。<br />直接引用：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>&lt;<span>link</span> <span>rel</span>=<span>"stylesheet"</span> <span>href</span>=<span>"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br /><span><span>&lt;<span>script</span> <span>src</span>=<span>"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></span><br /><span></span><br /><span><span>&lt;!-- or --&gt;</span></span><br /><span></span><br /><span><span>&lt;<span>link</span> <span>rel</span>=<span>"stylesheet"</span> <span>href</span>=<span>"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span></span><br /><span><span>&lt;<span>script</span> <span>src</span>=<span>"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></span><br /></pre></td></tr></table><p>npm:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>npm install</span><br /><span>npm i --save gitalk</span><br /></pre></td></tr></table><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>import</span> <span>'gitalk/dist/gitalk.css'</span></span><br /><span><span>import</span> Gitalk <span>from</span> <span>'gitalk'</span></span><br /></pre></td></tr></table><p>就我个人而言我是想使用npm的，但是无奈才疏学浅，研究了半天也没找到该怎么import，只好采用第一种方法了。如果读者找到了方法，还望在评论区不吝赐教。</p><h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#使用"></a>使用</h1><h2><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#创建OAuth应用"></a>创建OAuth应用</h2><p>既然是要让大家在issue里面进行提问，肯定是需要GitHub授权的，因此我们需要先注册一个OAuth应用。虽然理论上来说随便新建一个仓库即可，但是我既然已经有博客这一仓库了，干脆就直接把它注册成GitHub应用算了。<br />注册链接在<a href="https://github.com/settings/applications/new" target="_blank">这里</a>，<code>Application name</code>填写你的仓库名，记得<code>Homepage URL</code>和<code>Authorization callback URL</code>一栏一定要填写博客网址，否则授权后无法正常跳转。完成后请记录下<code>clientID</code>和<code>clientSecret</code>，待会儿要用。已经创建的OAuth应用可以在<a href="https://github.com/settings/developers" target="_blank">设置</a>查看。   </p><h2><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#魔改主题配置文件"></a>魔改主题配置文件</h2><p>主题方面，NexT本身就支持了<a href="http://theme-next.iissnan.com/third-party-services.html#disqus" target="_blank">许多评论插件</a>，但很不幸，Gitalk并不在其中。幸运的是NexT使用统一接口接入评论服务，因此我们只需要修改模板文件即可。</p><div>            <p>拓展阅读：<a href="https://github.com/node-swig/swig-templates" target="_blank">Swig</a>(swig-templates)不是<a href="http://www.swig.org" target="_blank">SWIG</a> (Simplified Wrapper and Interface Generator) ，别弄混了。前者是模板引擎，后者是“简化包以及接口生成器”。</p>          </div><h3><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#新增Gitalk的模板文件"></a>新增Gitalk的模板文件</h3><p>定位到<code>next/layout/_third-party/comments</code>目录下，新建一个名叫<code>gitalk.swig</code>的文件。hexo渲染模板的时候会自动读取该目录下的<code>index.swig</code>文件，然后根据配置文件里面定义的变量和模板文件里面的语句进行条件渲染。因此我们新建的模板文件也应该依葫芦画瓢：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span>{% <span>if</span> not (theme.duoshuo <span>and</span> theme.duoshuo.shortname) <span>and</span> not theme.duoshuo_shortname %}</span><br /><span>    {% <span>if</span> theme.gitalk.enable %}、</span><br /><span>        &lt;link rel=<span>"stylesheet"</span> href=<span>"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br /><span>        &lt;script src=<span>"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br /><span>        &lt;script type=<span>"text/javascript"</span>&gt; </span><br /><span>            <span>var</span> gitalk = <span>new</span> Gitalk({</span><br /><span>                clientID: <span>'{{theme.gitalk.clientID}}'</span>, </span><br /><span>                clientSecret: <span>'{{theme.gitalk.clientSecret}}'</span>,</span><br /><span>                id: <span>'{{page.title}}'</span>, </span><br /><span>                repo: <span>'{{theme.gitalk.repo}}'</span>,</span><br /><span>                owner: <span>'{{theme.gitalk.owner}}'</span>,                     </span><br /><span>                admin: <span>'{{theme.gitalk.admin}}'</span>, </span><br /><span>                distractionFreeMode: {{theme.gitalk.distractionFreeMode}},</span><br /><span>            }) </span><br /><span>            gitalk.render(<span>'gitalk-container'</span>) </span><br /><span>        &lt;/script&gt;  </span><br /><span>    {% <span>endif</span> %} </span><br /><span>{% <span>endif</span> %}</span><br /></pre></td></tr></table><p>上面的代码会在渲染时插入到HTML文件里，因此必须注意script文件引入的顺序，否则可能会出现undefined等错误。<br />随后在同目录下的<code>index.swig</code>文件末尾追加<code>includegitalk.swig</code>:</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>{% <span>include</span> <span>'gitalk.swig'</span> %}</span><br /></pre></td></tr></table><p>不过还没完，上面我们只是新增了Gitalk的调用，还得把它放到页面下方评论区才行。打开<code>next/layout/_partials/comments.swig</code>，在valine的后面追加：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>{% <span>elseif</span> theme.gitalk.enable <span>and</span> theme.gitalk.clientID <span>and</span> theme.gitalk.clientSecret %}</span><br /><span>    &lt;div id=<span>"gitalk-container"</span>&gt;&lt;/div&gt;</span><br /><span>{% <span>endif</span> %}</span><br /></pre></td></tr></table><h2><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#修改配置文件"></a>修改配置文件</h2><p>根据上面的代码我们可以看出，是否渲染主要是根据<code>theme.gitalk.enable</code>和<code>theme.gitalk.distractionFreeMode</code>这两变量来的，并且Gitalk类需要的参数还有<code>theme.gitalk.clientID</code>和<code>theme.gitalk.clientSecret</code>等，那么相应的配置文件应该怎么写就不言而喻了，在主题配置文件<code>_config.yml</code>里面新增如下代码：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span># Gitalk</span></span><br /><span><span>gitalk:</span> </span><br /><span>  <span>enable:</span> <span>true</span></span><br /><span>  <span>clientID:</span> <span>#填写注册时获得的clientID </span></span><br /><span>  <span>clientSecret:</span> <span>#注册时获得的密钥</span></span><br /><span>  <span>repo:</span> <span>#仓库名</span></span><br /><span>  <span>owner:</span> <span>gaojianli</span> <span>#所有者的名字</span></span><br /><span>  <span>admin:</span> <span>gaojianli</span> <span>#管理员名称</span></span><br /><span>  <span>distractionFreeMode:</span> <span>false</span> <span>#这个用于输入框是否具有全屏遮罩</span></span><br /></pre></td></tr></table><p>虽然理论上来说放哪里都成，不过为了方便管理还是和其他评论插件放到一起比较好。其中<code>Admin</code>字段是文章未初始化时显示的管理员的名字。<br />保存之后运行<code>hexo g</code>应该就可以看到效果了。不过这样默认背景是透明的，显得非常突兀，因此我决定给它加上背景。直接调用内置的的class，再略微调整下margin就大功告成了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>{% <span>elseif</span> theme.gitalk.enable <span>and</span> theme.gitalk.clientID <span>and</span> theme.gitalk.clientSecret %}</span><br /><span>    &lt;div class="post-block" id="gitalk-container" style="margin-top:10px"&gt;&lt;/div&gt;</span><br /><span>{% <span>endif</span> %}</span><br /></pre></td></tr></table><h2><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#效果展示"></a>效果展示</h2><p>未登录：<br /><img src="https://blog.gaojianli.me/nologin.png" /><br />商业互吹的评论区:<br /><img src="https://blog.gaojianli.me/logined.png" /></p><h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#一些坑"></a>一些坑</h1><p>新发的文章可能出现如下的情况:<br /><img src="https://blog.gaojianli.me/uninitialized.png" /><br />可能是GitHub的限制吧，其他人通过Gitalk是没法主动创建issue的，换句话说，需要“初始化”。初始化的方法也非常简单：用管理员账号登录GitHub后打开相应的博文即可。</p><h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#追加：一个小Bug"></a>追加：一个小Bug</h1><p>自从撰写这篇文章之后已经过去了许多时间，前不久无意中发现了一个小Bug，那就是在tags页面hexo也渲染了评论区:<br /><img src="https://blog.gaojianli.me/bug.png" /><br />既然是问题那就要解决，正巧今天中午无事，就来好好看看吧。<br />首先我们要知道，NexT主题使用了各种各样的库，其中就有大名鼎鼎的<a href="https://jquery.com/" target="_blank">jQuery</a>，虽然JQ是著名的“<strong>JQ一时爽，维护火葬场</strong>”，但正常人没事也不会去修改主题文件。那么我就图个省事，直接用jQ进行修改吧。<br />思路大概如下：</p><ol><li>修改<code>gitalk.swig</code>，判断当前页面是否为tags页面</li><li>若是，直接移除id为<code>gitalk-container</code>的div即可<br />既然是要判断页面是否存在，因此需要寻找特征元素，在这里我选取的是<code>div.tag-cloud</code>这一元素，因此直接判断是否存在即可，最终代码如下:<table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /></pre></td><td><pre><span>{% <span>if</span> not (theme.duoshuo <span>and</span> theme.duoshuo.shortname) <span>and</span> not theme.duoshuo_shortname %}</span><br /><span>    {% <span>if</span> theme.gitalk.enable %}、</span><br /><span>        &lt;link rel=<span>"stylesheet"</span> href=<span>"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br /><span>        &lt;script src=<span>"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br /><span>        &lt;script type=<span>"text/javascript"</span>&gt; </span><br /><span>        <span>if</span>($(<span>".tag-cloud"</span>).length===<span>0</span>)<span>//判断元素是否存在</span></span><br /><span>        {</span><br /><span>            <span>var</span> gitalk = <span>new</span> Gitalk({</span><br /><span>                clientID: <span>'{{theme.gitalk.clientID}}'</span>, </span><br /><span>                clientSecret: <span>'{{theme.gitalk.clientSecret}}'</span>,</span><br /><span>                id: <span>'{{page.title}}'</span>, </span><br /><span>                repo: <span>'{{theme.gitalk.repo}}'</span>,</span><br /><span>                owner: <span>'{{theme.gitalk.owner}}'</span>,                     </span><br /><span>                admin: <span>'{{theme.gitalk.admin}}'</span>, </span><br /><span>                distractionFreeMode: {{theme.gitalk.distractionFreeMode}},</span><br /><span>            }) </span><br /><span>            gitalk.render(<span>'gitalk-container'</span>) </span><br /><span>        }</span><br /><span>        <span>else</span>  <span>if</span>($(<span>".page-home"</span>).length===<span>0</span>) <span>//判断是否为主页</span></span><br /><span>            $(<span>"#gitalk-container"</span>).remove()<span>//移除相应元素</span></span><br /><span>        &lt;/script&gt;  </span><br /><span>    {% <span>endif</span> %} </span><br /><span>{% <span>endif</span> %}</span><br /></pre></td></tr></table>最终效果可以点击<a href="https://blog.gaojianli.me/tags">这里</a><br />では、諸君は。<h1><a href="https://blog.gaojianli.me/2018/07/24/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/#再更新：2018-07-25"></a>再更新：2018-07-25</h1>经过Xice的<a href="https://blog.xice.wang/2018/07/25/%E4%BD%BF%E7%94%A8valine%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/#%E5%90%8E%E7%BB%AD" target="_blank">提醒</a>，哪儿那么麻烦，直接在<code>tags/index.md</code>里面添加<code>comments: false</code>不就完了！</li></ol>]]></content>
        
        <summary type="html">
            
            前言一直以来都想要给自己的博客弄个评论系统，但是hexo作为一个静态博客，本身是不可能具有这种功能的，只能仰仗第三方插件。这方面的插件也非常多，比如disqus、vline等。但这些插件都存在或多或少问题，比如注册麻烦或者干脆国内不能访问。考虑到我家长城宽带的现实，必须选择一个
            
        </summary>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>搭建自己的Git</title>
        <link href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/"/>
        <id>https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#前言"></a>前言</h1><p>事情的起因非常简单，得益于某位校长的功劳，我的网络访问Github奇慢无比，最近甚至出现了push失败的情况，我连博客都没法好好更新了！<del><strong>（说的好像你更新得很多一样）</strong></del><br />嘛，正好潇在给我孜孜不倦地推荐<a href="https://gitea.io/" target="_blank">Gitea</a>，我就来试试在树莓派上搭建一下吧。<br />首先我们来看官方文档：</p><blockquote><p>易安装<br />您除了可以根据操作系统平台通过 二进制运行，还可以通过 Docker 或 Vagrant，以及 包管理 安装。</p></blockquote><p>嚯，挺厉害嘛，那就图个省事，用Docker安装吧。然而这之后我才知道，这是地狱的开始。</p><h1><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#Docker试探"></a>Docker试探</h1><h2><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#安装"></a>安装</h2><p>官方的教程非常的简单，<del>看起来就和能用一样</del></p><a></a><blockquote><p>我们在 Docker Hub 的 Gitea 组织中提供了自动更新的 Docker 镜像，它会保持最新的稳定版。你也可以用其它 Docker 服务来更新。首先你需要pull镜像：</p></blockquote><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>docker pull gitea/gitea:latest</span><br /><span>sudo mkdir -p /var/lib/gitea //如果要将git和其它数据持久化，你需要创建一个目录来作为数据存储的地方</span><br /><span>docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data gitea/gitea:latest //然后就可以运行 docker 容器了，这很简单。 当然你需要定义端口数数据目录：</span><br /></pre></td></tr></table><p>这时候我才发现我根本就没有安装docker，赶紧apt解决：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>apt install docker</span><br /></pre></td></tr></table><p>然后开始pull，这时又要忍受国内网络的龟速：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /></pre></td><td><pre><span>docker pull gitea/gitea:latest</span><br /><span>latest: Pulling from gitea/gitea</span><br /><span>911c6d0c7995: Pull complete</span><br /><span>fe8708a98e1d: Pull complete</span><br /><span>754e5dc9c218: Pull complete</span><br /><span>99ffba26b3d3: Pull complete</span><br /><span>ee04a0c4cde1: Pull complete</span><br /><span>78a8e5235d3e: Pull complete</span><br /><span>Digest: sha256:6f28b3e5127f29f614b765738cf5e4d673b1a0762d42c095323433c26eef779d</span><br /><span>Status: Downloaded newer image for gitea/gitea:latest</span><br /></pre></td></tr></table><h2><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#受阻"></a>受阻</h2><p>尝试运行一下</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span># root @ rasp in ~ [14:46:44]</span><br /><span>$ docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /mnt/disk/Git:/data gitea/gitea:latest</span><br /><span>ee43cb4883e4d6e75f0eea1c8b90988880c1569b7088bc1f072274f2a2eaf4dc</span><br /></pre></td></tr></table><p>没有回显，不过还是先看看容器跑起来没有:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span># root @ rasp in ~ [14:46:54]</span><br /><span>$ docker logs gitea</span><br /><span>standard_init_linux.go:185: exec user process caused "exec format error"</span><br /></pre></td></tr></table><p>喵喵喵？这尼玛是啥？看起来好像是可执行文件架构不对。。</p><h2><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#原因分析"></a>原因分析</h2><p>兔角龟毛，总之先inspect一下吧</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span># root @ rasp in ~ [14:55:17]</span><br /><span>$ docker inspect gitea/gitea:latest</span><br /></pre></td></tr></table><p>得到如下结果:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /><span>68</span><br /><span>69</span><br /><span>70</span><br /><span>71</span><br /><span>72</span><br /><span>73</span><br /><span>74</span><br /><span>75</span><br /><span>76</span><br /><span>77</span><br /><span>78</span><br /><span>79</span><br /><span>80</span><br /><span>81</span><br /><span>82</span><br /><span>83</span><br /><span>84</span><br /><span>85</span><br /><span>86</span><br /><span>87</span><br /><span>88</span><br /><span>89</span><br /><span>90</span><br /><span>91</span><br /><span>92</span><br /><span>93</span><br /><span>94</span><br /><span>95</span><br /><span>96</span><br /><span>97</span><br /><span>98</span><br /><span>99</span><br /><span>100</span><br /><span>101</span><br /><span>102</span><br /><span>103</span><br /><span>104</span><br /><span>105</span><br /><span>106</span><br /><span>107</span><br /><span>108</span><br /><span>109</span><br /><span>110</span><br /><span>111</span><br /><span>112</span><br /><span>113</span><br /><span>114</span><br /><span>115</span><br /><span>116</span><br /><span>117</span><br /><span>118</span><br /><span>119</span><br /><span>120</span><br /><span>121</span><br /><span>122</span><br /><span>123</span><br /><span>124</span><br /><span>125</span><br /><span>126</span><br /></pre></td><td><pre><span>[</span><br /><span>    {</span><br /><span>        <span>"Id"</span>: <span>"sha256:67ff9596dc004fdbbd87289f854ef8fb2920ab66621155117f618290457f42c9"</span>,</span><br /><span>        <span>"RepoTags"</span>: [</span><br /><span>            <span>"gitea/gitea:latest"</span></span><br /><span>        ],</span><br /><span>        <span>"RepoDigests"</span>: [</span><br /><span>            <span>"gitea/gitea@sha256:6f28b3e5127f29f614b765738cf5e4d673b1a0762d42c095323433c26eef779d"</span></span><br /><span>        ],</span><br /><span>        <span>"Parent"</span>: <span>""</span>,</span><br /><span>        <span>"Comment"</span>: <span>""</span>,</span><br /><span>        <span>"Created"</span>: <span>"2018-07-12T14:14:03.941666864Z"</span>,</span><br /><span>        <span>"Container"</span>: <span>"9c524fa2972be8a9c2e777219e07bdb23c8a21a18cff8d7884f2df6c95795948"</span>,</span><br /><span>        <span>"ContainerConfig"</span>: {</span><br /><span>            <span>"Hostname"</span>: <span>"9c524fa2972b"</span>,</span><br /><span>            <span>"Domainname"</span>: <span>""</span>,</span><br /><span>            <span>"User"</span>: <span>""</span>,</span><br /><span>            <span>"AttachStdin"</span>: <span>false</span>,</span><br /><span>            <span>"AttachStdout"</span>: <span>false</span>,</span><br /><span>            <span>"AttachStderr"</span>: <span>false</span>,</span><br /><span>            <span>"ExposedPorts"</span>: {</span><br /><span>                <span>"22/tcp"</span>: {},</span><br /><span>                <span>"3000/tcp"</span>: {}</span><br /><span>            },</span><br /><span>            <span>"Tty"</span>: <span>false</span>,</span><br /><span>            <span>"OpenStdin"</span>: <span>false</span>,</span><br /><span>            <span>"StdinOnce"</span>: <span>false</span>,</span><br /><span>            <span>"Env"</span>: [</span><br /><span>                <span>"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,</span><br /><span>                <span>"USER=git"</span>,</span><br /><span>                <span>"GITEA_CUSTOM=/data/gitea"</span></span><br /><span>            ],</span><br /><span>            <span>"Cmd"</span>: [</span><br /><span>                <span>"/bin/sh"</span>,</span><br /><span>                <span>"-c"</span>,</span><br /><span>                <span>"#(nop) "</span>,</span><br /><span>                <span>"LABEL org.label-schema.build-date=2018-07-12T14:11:41Z org.label-schema.vcs-ref=659bc727bd12bf219d80d38d8b634bd578ddb84f org.label-schema.vcs-url=https://github.com/go-gitea/gitea.git"</span></span><br /><span>            ],</span><br /><span>            <span>"ArgsEscaped"</span>: <span>true</span>,</span><br /><span>            <span>"Image"</span>: <span>"sha256:5789f396c54923dbf5643737a149337f5fc0c1fd0cc186f41ecc30c96b300e9a"</span>,</span><br /><span>            <span>"Volumes"</span>: {</span><br /><span>                <span>"/data"</span>: {}</span><br /><span>            },</span><br /><span>            <span>"WorkingDir"</span>: <span>""</span>,</span><br /><span>            <span>"Entrypoint"</span>: [</span><br /><span>                <span>"/usr/bin/entrypoint"</span></span><br /><span>            ],</span><br /><span>            <span>"OnBuild"</span>: <span>null</span>,</span><br /><span>            <span>"Labels"</span>: {</span><br /><span>                <span>"maintainer"</span>: <span>"maintainers@gitea.io"</span>,</span><br /><span>                <span>"org.label-schema.build-date"</span>: <span>"2018-07-12T14:11:41Z"</span>,</span><br /><span>                <span>"org.label-schema.vcs-ref"</span>: <span>"659bc727bd12bf219d80d38d8b634bd578ddb84f"</span>,</span><br /><span>                <span>"org.label-schema.vcs-url"</span>: <span>"https://github.com/go-gitea/gitea.git"</span></span><br /><span>            }</span><br /><span>        },</span><br /><span>        <span>"DockerVersion"</span>: <span>"17.12.0-ce"</span>,</span><br /><span>        <span>"Author"</span>: <span>""</span>,</span><br /><span>        <span>"Config"</span>: {</span><br /><span>            <span>"Hostname"</span>: <span>""</span>,</span><br /><span>            <span>"Domainname"</span>: <span>""</span>,</span><br /><span>            <span>"User"</span>: <span>""</span>,</span><br /><span>            <span>"AttachStdin"</span>: <span>false</span>,</span><br /><span>            <span>"AttachStdout"</span>: <span>false</span>,</span><br /><span>            <span>"AttachStderr"</span>: <span>false</span>,</span><br /><span>            <span>"ExposedPorts"</span>: {</span><br /><span>                <span>"22/tcp"</span>: {},</span><br /><span>                <span>"3000/tcp"</span>: {}</span><br /><span>            },</span><br /><span>            <span>"Tty"</span>: <span>false</span>,</span><br /><span>            <span>"OpenStdin"</span>: <span>false</span>,</span><br /><span>            <span>"StdinOnce"</span>: <span>false</span>,</span><br /><span>            <span>"Env"</span>: [</span><br /><span>                <span>"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,</span><br /><span>                <span>"USER=git"</span>,</span><br /><span>                <span>"GITEA_CUSTOM=/data/gitea"</span></span><br /><span>            ],</span><br /><span>            <span>"Cmd"</span>: [</span><br /><span>                <span>"/bin/s6-svscan"</span>,</span><br /><span>                <span>"/etc/s6"</span></span><br /><span>            ],</span><br /><span>            <span>"ArgsEscaped"</span>: <span>true</span>,</span><br /><span>            <span>"Image"</span>: <span>"sha256:5789f396c54923dbf5643737a149337f5fc0c1fd0cc186f41ecc30c96b300e9a"</span>,</span><br /><span>            <span>"Volumes"</span>: {</span><br /><span>                <span>"/data"</span>: {}</span><br /><span>            },</span><br /><span>            <span>"WorkingDir"</span>: <span>""</span>,</span><br /><span>            <span>"Entrypoint"</span>: [</span><br /><span>                <span>"/usr/bin/entrypoint"</span></span><br /><span>            ],</span><br /><span>            <span>"OnBuild"</span>: <span>null</span>,</span><br /><span>            <span>"Labels"</span>: {</span><br /><span>                <span>"maintainer"</span>: <span>"maintainers@gitea.io"</span>,</span><br /><span>                <span>"org.label-schema.build-date"</span>: <span>"2018-07-12T14:11:41Z"</span>,</span><br /><span>                <span>"org.label-schema.vcs-ref"</span>: <span>"659bc727bd12bf219d80d38d8b634bd578ddb84f"</span>,</span><br /><span>                <span>"org.label-schema.vcs-url"</span>: <span>"https://github.com/go-gitea/gitea.git"</span></span><br /><span>            }</span><br /><span>        },</span><br /><span>        <span>"Architecture"</span>: <span>"amd64"</span>,</span><br /><span>        <span>"Os"</span>: <span>"linux"</span>,</span><br /><span>        <span>"Size"</span>: <span>75448364</span>,</span><br /><span>        <span>"VirtualSize"</span>: <span>75448364</span>,</span><br /><span>        <span>"GraphDriver"</span>: {</span><br /><span>            <span>"Data"</span>: {</span><br /><span>                <span>"LowerDir"</span>: <span>"/var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff:/var/lib/docker/overlay2/a0cf2ef094b8fb958037aff40de9cf54cd2c1be580fbe2fe592b5839e1a08cd5/diff:/var/lib/docker/overlay2/29e0cfce429c5eba2e674761d6a27dc914a2432a5b87c4eb7168623f62f0ed35/diff:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff:/var/lib/docker/overlay2/c1e252414cf059e505f719e559a35d5635608c136cdac00bce2ecba73dbf5111/diff"</span>,</span><br /><span>                <span>"MergedDir"</span>: <span>"/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/merged"</span>,</span><br /><span>                <span>"UpperDir"</span>: <span>"/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/diff"</span>,</span><br /><span>                <span>"WorkDir"</span>: <span>"/var/lib/docker/overlay2/196a454e1b7f7f5f0424e1afefd7a5b1b07edce529dca3f5b8a6a591f51de02f/work"</span></span><br /><span>            },</span><br /><span>            <span>"Name"</span>: <span>"overlay2"</span></span><br /><span>        },</span><br /><span>        <span>"RootFS"</span>: {</span><br /><span>            <span>"Type"</span>: <span>"layers"</span>,</span><br /><span>            <span>"Layers"</span>: [</span><br /><span>                <span>"sha256:717b092b8c86356cf976d9c83fa6f0ea67f2bf3148a5bbb7e02026a5d3245e68"</span>,</span><br /><span>                <span>"sha256:0c8bc7fe995df099706fa9de6efe8780873009fa9bd88c1d061a9da42208ce3d"</span>,</span><br /><span>                <span>"sha256:934a2cc01616c95aceffe2f7c906d0608e3d3e69d6c315e6b35980138b72bfa6"</span>,</span><br /><span>                <span>"sha256:13f47d251abf8fb04b518a7f78a626d3aa8edd19690cec8158972ad6297866a7"</span>,</span><br /><span>                <span>"sha256:5e395242ed599a17ffa4225218344a6ac2c336ba774be69ef59d5a4323f0a1e9"</span>,</span><br /><span>                <span>"sha256:dd6e07b2f31502448541c62eb16a27958f3a8cb91fafa8010961a72b209ccc43"</span></span><br /><span>            ]</span><br /><span>        },</span><br /><span>        <span>"Metadata"</span>: {</span><br /><span>            <span>"LastTagTime"</span>: <span>"0001-01-01T00:00:00Z"</span></span><br /><span>        }</span><br /><span>    }</span><br /><span>]</span><br /></pre></td></tr></table><p>进入到LowerDir看一下？</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span># root @ rasp in /var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff/app/gitea [15:18:01]</span><br /><span>$ ls</span><br /><span>gitea</span><br /></pre></td></tr></table><p>只有一个执行文件，这时候需要请出file大法了</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span># root @ rasp in /var/lib/docker/overlay2/9fce26ccc4b7e0aefe663ecb165615aadda2d2437b3ab7cafab599de5d055736/diff/app/gitea [15:18:02]</span><br /><span>$ file gitea</span><br /><span>gitea: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, stripped</span><br /></pre></td></tr></table><p>やっぱり！™这个文档谁写的！头伸过来，看我不来给你加个bug，你写这个文档的时候就没考虑过其他架构的CPU的感受么！你是不是看不起ARM！！</p><h2><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#最后的挣扎"></a>最后的挣扎</h2><p>嘛，既然这样了，摆在我面前也就三条路:</p><ol><li>制作基于ARM64的docker容器</li><li>放弃docker</li><li>玩一些骚操作<br />首先来看看骚操作，既然它的运行依靠的是单文件，那我如果下载arm64的二进制文件手动替换，不就可以运行了么？<br />但是事实狠狠的打了我的脸，前面的替换进行地很顺利，直到…<table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /></pre></td><td><pre><span>root@rasp:/var/lib/docker/overlay2# cd b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin/</span><br /><span>root@rasp:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin# ls</span><br /><span>background        fdreserve     multisubstitute             s6-fdholder-list           s6-ipcserver               s6-svlisten1</span><br /><span>backtick          fdswap        pipeline                    s6-fdholder-listc          s6-ipcserver-access        s6-svok</span><br /><span>bash              forbacktickx  piperw                      s6-fdholder-retrieve       s6-ipcserverd              s6-svscan</span><br /><span>bashbug           foreground    redirfd                     s6-fdholder-retrievec      s6-ipcserver-socketbinder  s6-svscanctl</span><br /><span>cd                forstdin      runblock                    s6-fdholder-setdump        s6lockd                    s6-svstat</span><br /><span>define            forx          s6-accessrules-cdb-from-fs  s6-fdholder-setdumpc       s6-log                     s6-svwait</span><br /><span>dollarat          getcwd        s6-accessrules-fs-from-cdb  s6-fdholder-store          s6-mkfifodir               s6-tai64n</span><br /><span>elgetopt          getpid        s6-applyuidgid              s6-fdholder-storec         s6-notifyoncheck           s6-tai64nlocal</span><br /><span>elgetpositionals  heredoc       s6-cleanfifodir             s6-fdholder-transferdump   s6-setlock                 shift</span><br /><span>elglob            homeof        s6-connlimit                s6-fdholder-transferdumpc  s6-setsid                  trap</span><br /><span>emptyenv          if            s6-envdir                   s6-fghack                  s6-setuidgid               tryexec</span><br /><span>exec              ifelse        s6-envuidgid                s6-ftrig-listen            s6-softlimit               ucspilogd</span><br /><span>execlineb         ifte          s6-fdholderd                s6-ftrig-listen1           s6-sudo                    umask</span><br /><span>exit              ifthenelse    s6-fdholder-daemon          s6-ftrig-notify            s6-sudoc                   unexport</span><br /><span>export            import        s6-fdholder-delete          s6-ftrigrd                 s6-sudod                   wait</span><br /><span>fdblock           importas      s6-fdholder-deletec         s6-ftrig-wait              s6-supervise               withstdinas</span><br /><span>fdclose           loopwhilex    s6-fdholder-getdump         s6-ioconnect               s6-svc</span><br /><span>fdmove            multidefine   s6-fdholder-getdumpc        s6-ipcclient               s6-svlisten</span><br /><span>root@rasp:/var/lib/docker/overlay2/b37847000ccdd55f5acd0ea549f16073da142458dd7e1cc1487d5ce2ea944611/diff/bin# file bash</span><br /><span>bash: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-x86_64.so.1, stripped</span><br /></pre></td></tr></table></li></ol><p><strong>惹不起，惹不起，告辞！</strong><br />至于编译，我实在不想弄，理由如下：<br />首先，有了上次编译驱动的经历之后，我是再也不想在树莓派上编译任何东西了。且不说CPU的弱鸡，光是内存不足就足够你喝一壶的。至于交叉编译？不好意思，编译之神Baymax持续掉线中。</p><h1><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#二进制安装"></a>二进制安装</h1><p>那就只有来二进制文件了。<br />嘛，这个就没啥说的了，直接参照<a href="https://docs.gitea.io/en-us/install-from-binary/" target="_blank">官方教程</a>就好了。<br />配置文件随便根据官网改改就好，这里就不贴出来。</p><h1><a href="https://blog.gaojianli.me/2018/07/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git/#最终效果"></a>最终效果</h1><p><a href="https://git.gaojianli.me/" target="_blank">Gitea</a><br />嘛，就是这样，试过了速度还行。还拥有镜像功能，可以自动追踪某一个远程仓库，以后有啥小项目就决定是你了！<br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            前言事情的起因非常简单，得益于某位校长的功劳，我的网络访问Github奇慢无比，最近甚至出现了push失败的情况，我连博客都没法好好更新了！（说的好像你更新得很多一样）嘛，正好潇在给我孜孜不倦地推荐Gitea，我就来试试在树莓派上搭建一下吧。首先我们来看官方文档：易安装您除了可
            
        </summary>
        
        <category term="树莓派"/>
        
        <category term="Web"/>
        
        <category term="服务器"/>
        
    </entry>
    
    <entry>
        <title>如何入门算法竞赛</title>
        <link href="https://byrio.org/how-to-oi/"/>
        <id>https://byrio.org/how-to-oi/</id>
        
        <author>
            <name>icebound</name>
        </author>
        
        <published>2018-07-07T09:26:26+00:00</published>
        <updated>2018-07-07T09:26:26+00:00</updated>
        
        <content type="html"><![CDATA[<p>朋友，你听说过算法竞赛吗？对对对！就那个一堆人对着电脑噼里啪啦敲的？不不不，那叫电子竞技！嗯嗯嗯，就是人比较多的，在体育场里的，做不出题在挠头的！嗯，这就是算法竞赛。</p>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/07/图片-1.png?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/07/图片-1.png?resize=652%2C268&amp;ssl=1" /></a><p>ACM-ICPC 2018 一场典型的算法竞赛。我校选手在照片拍摄地点的对面</p></div>
<p>ACM-ICPC 2018 一场典型的算法竞赛。我校选手在照片拍摄地点的对面</p>
<h3><strong>那么究竟什么是算法竞赛呢？</strong></h3>
<p>著名算法竞赛选手、教练刘汝佳曾说过，算法竞赛是一种【思维的体操】。有人说了，不就是写算法吗！有什么大不了的，我平常调库百度算法写的好着呢！平常，我们写程序，写算法，都是在一种比较放松的环境下进行的。而算法竞赛会人为制造压力，例如限制编写程序的时间，禁止选手访问网络，以及利用特殊的比赛规则（如ACM竞赛中的封榜），这都给我们套上了一层无形的枷锁，让我们只能通过冷静的思考完成算法的编写。所以，我个人认为，算法竞赛是带着镣铐的【思维体操】。</p>
<h3><strong>那算法竞赛是怎么进行的呢？</strong></h3>
<p>许多竞赛都是在OJ上进行的。OJ(online judge)是指在线评测系统。首先我们需要在特定的时间和地点编写针对特定问题的算法，写出符合要求的程序，并且进行调试。完成后，会有相应的评测程序，自动编译运行你的程序，对你的程序输入不同的测试数据，进行一番【魔鬼测试】，根据测试结果给出你不同的分数。</p>
<h3><strong>能不能透露一些比赛的细节？</strong></h3>
<p>举个例子，我曾经参与过一次比赛的出题与组织工作（HBCPC2018），比赛规则为ACM赛制。比赛的过程大概是这样的：</p>
<p><span></span></p>
<ol>
<li>比赛前一天选手报道，每三人为一队。有一次热身赛。热身赛赛题很简单，主要让大家熟悉比赛环境。</li>
<li>第二天比赛开始。选手们可以使用C/C++以及JAVA（不同比赛可用的语言不同，现在似乎Python也逐渐被算法竞赛所接受），编写12道题的程序。当你写好一道题，你可以通过题目中给的样例测试你的程序大概对不对。如果确认无误，就可以通过网页提交给评测系统。评测系统会告诉你测试结果：如答案正确(AC)，答案错误(WA)，运行时错误(RE)，超时(TLE)，输出格式错误(PE)等。</li>
<li>当你获得一次AC时，才算通过了这道题。系统会根据你的提交时间以及之前提交程序的次数计算你的罚时。通过题目多且罚时少的队伍排名靠前。比赛前4个小时，队伍排名会实时显示。最后一小时，队伍排名榜单会冻结，俗称“封榜“，给比赛带来一些刺激性。</li>
</ol>
<p>不同的比赛的规则不同，常见的赛制有ACM赛制，OI赛制，Codeforces赛制。</p>
<h3><strong>我开发能力很强，是不是可以完虐算法竞赛了？</strong></h3>
<p>开发能力和算法竞赛的能力几乎不在一棵科技树上 …… 算法竞赛主要考验的是思维，而不是考验框架的熟练使用和各种库的调用。在赛场上，对数据结构和算法的掌握程度几乎成了制胜的关键。另外，竞赛当中，为了代码的快速构建，不写注释，变量名写 a,b,c,d，乱开数组，#define int long long 等等情况经常发生。这些都与开发相去甚远。</p>
<p>当然，如果你是一名熟练的开发人员，意味着你的代码能力很强，经过一段时间的训练，有可能成为很强的竞赛选手哦！</p>
<h3><strong>那，算法竞赛都有那些呢？</strong></h3>
<h4><strong><em>中小学阶段：</em></strong></h4>
<ul>
<li>OI系列赛事。OI全称Olympiad in Informatics，信息学竞赛。在我国国内的比赛又分为NOI(National Olympiad in Informatics)和NOIP(National Olympiad in Informatics in Provinces)以及各省的省选。难度省选&gt;国赛&gt;省赛。每年中国会从NOI的金牌选手中选出国家集训队，最终派出强劲的<span>zhejiang</span>选手参加国际比赛IOI(这些比赛均是单人比赛，且有部分得分)。</li>
<li>CTSC与APIO，这两个比赛是连着的。CSTC是IOI中国国家队的选拔赛，因为集训队人太少比赛起来不好看，所以叫上全国选手陪练，难度与IOI相当。APIO是世界信息学奥林匹克亚洲赛区比赛，也是全国选手都去，最后选前6名作为中国队的成绩，难度与IOI相当。</li>
</ul>
<h4><strong><em>大学阶段：</em></strong></h4>
<ul>
<li>ACM-ICPC。这是一个由国际计算机学会举办的大型算法竞赛，也是最正规，规模最大的一个。比赛分为区域赛，区域决赛，世界总决赛，难度依次递增。比赛过程中，每个队伍可以有三个选手和一台电脑，可以互相讨论。这个比赛的一些规则使得赛事极具观赏性。</li>
<li>CCCC与CCPC。CCCC是一个单人手速赛，全靠手速和乱搞。CCPC是简单版ICPC，难度较低。</li>
<li>蓝桥杯。比较水的比赛，我们学校好像不参加。</li>
<li>BUPT校内赛。作为北邮的学生，当然要提一下我们的校赛啦！校赛在每年的春季举行，规则与ICPC一致，欢迎各位踊跃参加！</li>
</ul>
<p>除此之外，各大OJ和各种企业组织的比赛我们也可以去参加。列举几个有名的:codeforces、codechef、百度之星、UOJ等等。</p>
<h3><strong>搞算法竞赛好玩吗？我能得到啥？</strong></h3>
<p>好玩啊！刚开始学超有意思的！到后面成绩不行，只能靠退役之后出一出题，写一写《如何入门》之类的文章维持一下生活这样的（雾）。</p>
<p>说实话，学算法是一个枯燥的过程，打竞赛是一个压力很大的过程。如果你选择了这条路，可能面临假期回不了家，周六日全部报销，成绩不好整夜睡不着觉等一系列身心摧残。不过，也会得到很多别的同学得不到的东西：比如，在研究某题许久之后，一个灵光一现的思路让你成功AC的喜悦。比如，你和你的队友在奋战5小时后拿到AU，队长上台领奖时开心的微笑。比如，在你面对电脑绞尽脑汁时，场下小迷妹花痴的眼神。更多的，则是坚持于某一件事的专注，这种专注的感觉，难以形容。</p>
<p>当然，如果你的成绩很好，参加竞赛可以给你带来保研的加分。当你在国际大赛上获奖时，各大公司将会被你吸引，向你投出橄榄枝。在去年毕业的某位北邮ACM校队成员，就拿到了微软亚洲研究院的offer。当然，搞一年竞赛，你的代码能力和算法能力也会变得很强！</p>
<p>所以，想成为大佬吗？签订契约吧！</p>
<h3><strong>要想成为大佬，应该怎么入门呢？</strong></h3>
<p>首先，善用搜索引擎，当你看完这篇文章之后，你可以再去谷歌搜索如何入门，百度搜索如何入门，知乎提问如何入门。要学会自己获取信息。</p>
<p>然后，你需要几本合适的入门书。如果你C/C++还没学好(C++面向对象的思想在算法竞赛中不作为重点，可以只做了解)，推荐你去看《C++ Primer》。如果你已经大概会写C语言了，你可以去看刘汝佳的紫书《算法竞赛入门经典》。如果你感觉刘汝佳的这本紫书太容易，那么我推荐他的姊妹篇《算法竞赛入门经典(训练指南)》和黑书《算法竞赛与信息学艺术》。我不推荐看《算法导论》，这本书太过理论化，也太难了太厚了，不适合入门。</p>
<p>此外，算法竞赛作为一种比赛，练习是十分重要的。举个栗子：我因为期中考试一周没做题，紧接着就被我队友虐了。然后练了两周，某场网络赛发挥就很好。然后因为期末半个月没做题，现在已经不会写tarjan算法了。</p>
<p>只有你接触到的题目类型够多，你才可能举一反三。从入门题库开始，一点一点的去看题，选择合适的算法去解决这道题。在这里按难度推荐一些题库：</p>
<h4><strong><em>入门水平：</em></strong></h4>
<ul>
<li>Joy oj：原经典入门题库tyvj，被清北学堂收购后一蹶不振，前100题题目质量高。</li>
<li>洛谷OJ：盈利性OJ，有许多入门题。</li>
<li>CodeVS：同洛谷OJ。</li>
<li>Vijos：曾经与tyvj比肩的OJ，题目难度适中，收录了大量NOIP题目。</li>
</ul>
<h4><strong><em>基础水平：</em></strong></h4>
<ul>
<li>POJ：老牌OJ，现在已经无人维护，经常无法访问。优势是题目质量高，各种题目类型齐全。</li>
<li>HDU oj:杭电OJ，有不少经典问题，并且目前有人维护。</li>
<li>51nod：题目从简单到容易都有，贴心的分出了题目等级，可以按照等级刷题。</li>
<li>Codeforces(CF)：著名的算法竞赛平台，经常有各种比赛。在CF上你可以与世界上的顶尖选手同台竞技，题目质量较高，主要考察思维能力。</li>
<li>Uva：刘汝佳推荐的题库，建议配合紫书使用。</li>
</ul>
<h4><strong><em>进阶水平：</em></strong></h4>
<ul>
<li>BZOJ(hysbz或lydsy大视野在线测评)：老牌盈利OJ，一些难题需要购买VIP账号才可以看。题目主要是各省省选题，质量参差不齐，但是有很多好题。</li>
<li>UOJ：一群高中选手搞的OJ，题目比较有趣，收录了许多国家队集训题目。</li>
<li>Codechef：与codeforces类似，题目难度较高。</li>
</ul>
<h4><strong><em>宇宙无敌：</em></strong></h4>
<ul>
<li>Vjudge：一个利用爬虫等技术建立的OJ，本身没有评测机和题库，但是在上面可以提交几乎所有OJ的题目，相当于是一个OJ的聚合库。</li>
</ul>
<h4><strong><em>超拽炫酷无敌吊炸天：</em></strong></h4>
<ul>
<li>10.105.242.83：北邮自己的OJ，是校内比赛的主要场所，也收录了许多校内赛的题目。</li>
</ul>
<p>在刷题时，建议大家仔细思考，不要轻易看题解。如果对题解产生依赖，请多参加各种比赛，在比赛中提高自己。</p>
<p>最后，要有良好的心态。算法竞赛是一个需要投入大量时间的竞赛，不一定能够带来等价的回报。在做题时，也许一道题要WA好多好多遍，这时一定要心平气和，<strong>不要砸键盘</strong>，也不要摔门而去，深呼吸，也许就解出来了。</p>
<p>补充一点，如果参加的是ACM-ICPC，与队友的配合也是非常重要的，你可以寻找一批志同道合的小伙伴，一同做题，甚至互相出题，一起制定学习计划。这是很有趣的一件事！</p>
<h3><strong>北邮会对我学习算法竞赛提供哪些帮助？</strong></h3>
<p>在每年的春天，学校都会有归队赛、新生赛、校赛，筛选一批优秀选手进入ACM集训队。在集训队中，会有去过world final的大佬带着我们训练，每年暑假的集中训练是提升个人水平的最好机会！相比其他学校，北邮的编程气息浓厚，几乎所有人都会写代码，这也会对你的学习有帮助。</p>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/07/图片-12.png?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/07/图片-12.png?resize=147%2C179&amp;ssl=1" /></a><p><del>最后祝您，身体健康，再见</del></p></div>
<p>欢迎你成为一名算法竞赛选手！愿你在退役时，抱着各种奖杯各种奖牌，还有美丽动人的女朋友！<span>不要被水淹没</span></p>
<p><a href="https://byrio.org/how-to-oi/">如何入门算法竞赛</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            朋友，你听说过算法竞赛吗？对对对！就那个一堆人对着电脑噼里啪啦敲的？不不不，那叫电子竞技！嗯嗯嗯，就是人比较多的，在体育场里的，做不出题在挠头的！嗯，这就是算法竞赛。 ACM-ICPC 2018 一场典型的算法竞赛。我校选手在照片拍摄地点的对面 ACM-ICPC 2018 一场
            
        </summary>
        
        <category term="如何入门"/>
        
    </entry>
    
    <entry>
        <title>微软Insider DevTour小记</title>
        <link href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/"/>
        <id>https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#前言"></a>前言</h1><p>前一阵子收到了微软发给所有的insider的邀请邮件，大意说是DevTour即将巡回到北京，欢迎参加云云。弱鸡表示从来没听过这个名字，吓得我赶紧百度了一下：</p><blockquote><p>每年，我们都将最新的技术带给全球的开发者。今年，我们通过与Windows、Windows Insider项目以及我们的开发者和内部人士的合作伙伴关系，将活动扩展到更多的城市。我们将介绍人工智能，最新的桌面开发，微软365，进步网络应用，开发者办公室，混合现实，Microsoft Graph，等等。此次巡回活动是开发者与来自微软总部雷德蒙德的领导和工程师以及地区行业领先和微软开发者MVPs和RDs相互直接交流的一次绝佳机会。</p></blockquote><p>概括一下大概就是5个字：<strong>大佬见面会</strong><br />然而不幸的是这一天恰好是我考高数的日子，以前处在偏远山区的我看见这类活动只能望汤兴叹，好容易在北京，怎么能就这样鸽了呢？于是乎赶紧发邮件问了一下能否下午到场，所幸得到了肯定的答复。</p><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#到达"></a>到达</h1><p>不得不吐槽沙河校区的偏远程度超乎想象，上午高数凉了（迫真）以后即使我以最快速度向会场赶，最终在会议开始前最后一刻才成功赶到。</p><a></a><p>走进酒店，首先看见的就是指引牌。和我想象的不一样，微软并没有大张旗鼓地打印海报，仅仅是在门口放了个一人高的牌子，这与其选择如此昂贵酒店的土豪作风反而显得格格不入。<br /><img src="https://blog.gaojianli.me/guidance.jpg" /></p><p>快速完成了签到后领到了参会牌和会议集章册，后者印着会议日程，虽然是早已公布在网站上的：</p><ul><li>签到</li><li>开始签到</li><li>主题演讲</li><li>茶歇时间</li><li>如何在Windows 10上，进化您现有的应用程序</li><li>如何充分利用PWA开发Web App</li><li>午餐</li><li>基于 Azure Kubernetes Services 的DevOps 全生命周期流水线</li><li>如何使用Office 365创建高效应用程序</li><li>如何使用Microsoft Graph在所有设备上提升用户参与度</li><li>茶歇时间</li><li>边缘计算中的智能化 - 机器学习入门</li><li>构建Windows混合现实应用程序</li><li>If(dev) { Insider(); }</li><li>互动问答<br /><img src="https://blog.gaojianli.me/card.jpg" /><br />进入会场的时候，里面似乎正在进行类似一站到底的游戏，当然题目都是编程方面的，从Visual Basic到C#无所不包，（据说Basic的题目淘汰了许多年轻人）。其题目更多的是考察诸如位运算这种深层次的理解。下面是只剩两人的时候的巅峰对决，你能说出答案么？<br /><img src="https://blog.gaojianli.me/challenge.jpg" /><br />当然也不乏这种让人跑路的逗逼题目:<blockquote><p>  Which command can exit vim?<br />Head:”:wq” Tails:”rm -rf /“</p></blockquote></li></ul><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#上半场"></a>上半场</h1><p>最终夺冠的是右边的小哥，在他选择完奖品之后，讲座终于正式开始</p><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#DevOps"></a>DevOps</h2><p>这一节主要讲的是k8s和DevOps对于产品开发流程的构建。 首先主讲人Lei Xu给我们回顾了一下软件开发的架构变化:<br /><img src="https://blog.gaojianli.me/dev-art.jpg" /><br />现如今，软件的生命周期更多地向组件化，容器化发展，开发者开始更多的着眼于软件的开发，而不再去担心服务器环境的配置。Iaas的出现让开发者不用再去关心服务器的供电、网络等问题，云主机的出现则免去了操作系统和相关业务软件的配置和维护。而Docker则将软件的运行环境和系统环境实现了分离，开发环境和生产环境的差异不再是个问题。然而，即使采用了docker，容器依旧需要命令行进行管理、维护，与此同时至于k8s，先看看官方（百度）定义：</p><blockquote><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。</p></blockquote><p>k8s可以理解为一种类似腾讯云的管理平台。只不过腾讯云你开的是云主机，k8s开的是一个个容器，在这个平台上，你完全不用担心宿主机的运行状况，你的眼中有的只有一个个容器，一个个微服务。但是k8s的配置是极其复杂的，Xu在场上做了一个调查，与会的诸位中配置过k8s的只有一个人。应对这个问题，Azure提供了一个一键式平台解决方案，国内提供类似服务的好像还有阿里云。<br />至于DevOps，软工的诸位一定不会陌生，这是一种软件开发生命周期的解决方案。<br /><img src="https://blog.gaojianli.me/Devops.jpg" /><br />不过别看他说的神乎其神，微软的提供的主要是以VSTS和Azure为中心展开的业务，后者没用过不了解，但前者其实诟病甚多。主要是操作逻辑感人，喜欢把简单问题复杂化，我找个删除找了半个小时。此外Work Item的分配竟然要一个非常睿智的Query来查看，而且和宇宙第一IDE的结合也不甚完美，当然也可能是我不会用吧。毕竟人家有个岗位可是叫做<strong><span>DevOps</span></strong>工程师呢。<br />值得一提的是，可能是Azure在Edge上翻车翻多彻底绝望了吧，现场演示的计算机换成了一台运行着<strong>Chrome</strong>的<strong>Mac</strong>，有图为证（有点糊了）：<br /><img src="https://blog.gaojianli.me/mac_chrome.jpg" /><br />最后的最后，在玩滥的One more thing..之后，他介绍了一个叫做DevOps魔盒的东东，反正就是个一条龙服务，感兴趣的可以关注一下。</p><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#Teams-app开发"></a>Teams app开发</h2><p>关于这方面，由于我并不是Office 365的订阅者(2020年6月22日Update：现在是了)，因此我并不是很清楚。大意就是Office又填了一个新成员叫做Teams，应该是用于团队协作用的。这个Teams可以添加各种各种各样的web apps用于团队合作。然后这些app可以调用各种各样的数据，如下：</p><ul><li>Audio and video conferencing</li><li>Permanent chat</li><li>Online meetings and broadcasts</li><li>Shared files in SharePoint</li><li>Team notes in OneNote</li><li>Team tasks in Planner</li><li>Shared email inbox, calendar and email address</li><li>Available for web, desktop and mobile<br />这些app主要分为两类:Tabs和Bots，前者是作为一个选项卡嵌入Teams，有点类似组件，后者顾名思义是机器人。项目基于万能的html和Typescript开发，支持Visual Studio远程调试<br /><img src="https://blog.gaojianli.me/remote_debug.jpg" /><br />不过我并没有在国内看到什么人使用，也没听说哪个公司大规模购置了office 365，毕竟在你国万物可是都有替代的：<blockquote><p>版本控制？那是什么？用QQ群就够了<br />团队协作？Sharepoint?不需要，我有QQ群<br />视频会议？Skype？对不起，我还是又QQ群<br />Teams?没听过的东西，能有QQ群好用么？</p></blockquote></li></ul><p>毕竟，那句话咋说的来着？</p><blockquote>            <p><span>又不是不能用</span> </p>          </blockquote><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#Microsoft-Graph"></a>Microsoft Graph</h1><p>这个我觉得是今天下午的重中之重了，由Justin Liu给我们带来。虽然错过了上午的PWA有点可惜，不过听了这个便已经不虚此行了，你看我手都抖得不能自已了:</p><p><img src="https://blog.gaojianli.me/graph1.jpg" /><br />那么什么是MS Graph呢？Graph是微软提供的一组用于获取基于微软各项服务中产生的各种数据的api（挺绕口的），通俗地说就是你在使用微软各项服务的时侯他收集了你的隐私，然后提供了一些接口让你能够利用这个数据。我们评判一个数据提供方最主要的指标就是数据数量以及质量，那么，这个数据量究竟有多大呢，微软给了张图:<br /><img src="https://blog.gaojianli.me/(graph2.jpg" /><br />可以看到这个数据量是非常可观的，来源也非常广泛，例如Office365、Outlook、Onedrive，甚至Windows 10的Timeline。可以说，只要你使用过微软相关的云服务，你就都会有记录下来。那么究竟有那些数据呢？<br />API主要分为两类，User和Activity。前者包含的主要是用户的基本信息以及人脉信息，可以获取例如我的工作伙伴，我的照片，我的邮箱等个人信息，API以/me打头，后接简单的单词，通过GET或者POST发送请求，(2020年6月22日Update：就是Restful API)然后服务器返回JSON，如图所示：<br /><img src="https://blog.gaojianli.me/graph3.jpg" /><br />相信看到这里，有些小伙伴心里面已经有一些应用场景了，如果没有的话请再看下面这张图：<br /><img src="https://blog.gaojianli.me/graph4.jpg" /><br />是不是觉得挺眼熟？没错，前端中常见的组件化数据绑定和模板渲染！这简直是为Vue.js这种数据绑定的框架量身定制的，有这些API做个个人dashboard或者智能助理完全不是问题。<br />值得注意的是，这里官方给的Demo是追踪日历变化，在会议时长占比超过80%的时候自动提示，其关于人脉方面的API数据来源则是Office Teams，因此对于没有使用Office 365的小伙伴来说，这部分功能算是废了。不过尽管如此，剩下的API也依旧让人兴奋。<br />Microsoft Graph除了获取数据的API外，还提供了一些动作性API用于执行发送邮件等主动操作，主要通过POST访问，例如下面这个自动文档审批工作流：<br /><img src="https://blog.gaojianli.me/graph5.jpg" /><br />前面我提到了组件化和数据绑定，微软也提出了一种新型控件（暂时姑且这么叫）<a href="https://adaptivecards.io/" target="_blank">Adaptive Card</a><br /><img src="https://blog.gaojianli.me/graph6.jpg" /><br />这是一种可适应性的卡片数据交换方式，或者应该叫可适应模板。之所以被称为可适应，是因为它采用json方式传入数据，而根据应用场景的不同可以渲染成不同的样子，例如小娜消息，Skype消息，Windows Timeline等等，亦即“一份数据，万种表现”。<br />前面提到了Graph的API还有Activity这一大类，其全名是Activity &amp; Device，从名字上我们可以看出，这一类主要是偏向用户对设备的使用，而不是依赖于某个软件<br /><img src="https://blog.gaojianli.me/graph7.jpg" /><br />通过这组API我们可获取到Windows上的应用使用情况，推送Timeline消息，向特定设备推送消息等。随后，Justin展示了如何在Windows10 1803上自定义显示TImeline消息，支持对标题、显示信息甚至背景实施自定义。<br /><img src="https://blog.gaojianli.me/graph8.jpg" /></p><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#幕间"></a>幕间</h1><p>讲座到此暂歇，我也出去逛了逛喝口水，看了看一辈子也买不起的Hololens（本来是想体验的。。人太多了ORZ）<br />在此我要大喊：微软牌蛋糕真好吃！<br /><img src="https://blog.gaojianli.me/cake.jpg" /></p><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#下半场"></a>下半场</h1><p>下午3点半，讲座继续。</p><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#WindowsML"></a>WindowsML</h2><p>主讲继续是Nikola Metulev大佬，他一手打造了UWP community tookit的，他的英语是唯一一个不用传译器能听懂的，其他印度英语惹不起。<br />说实话，我一看是看见WindowsML的时候是把它看成了MR，后来又当作标记语言，直到今天我才知道这是Machine Learning的意思。<br /><img src="https://blog.gaojianli.me/ml1.jpg" /><br />说到机器学习，常规方法是通过服务器（炼丹炉）对成千上万的样本进行训练，然后得到模型进行评估，而且这种训练多半是发生在Linux上的，似乎与Windows无缘。但是，在海量样本的收集过程中，免不了会收集大量的隐私，而这对于多数用户来说是不可忽视的。因此AI在边缘计算中的重要性也在不断提高，而作为桌面上最流行的操作系统，WindowsML的存在就显得尤为必要。随后，他在Surface book 2上演示了实时的摄像头画面处理：<br /><img src="https://blog.gaojianli.me/ml2.jpg" /><br />这除了说明Surface Book 2性能很强（<s>广告嫌疑</s>）外，也说明了WindowsML具有不错的性能。然而，如果就仅仅如此的话，WindwosML也并没有什么太过出彩的地方，也难以吸引别人放弃流行的Linux平台转投Windows。<br />人们谈起机器学习，除了其烧钱的硬件外，混合高等数学、概率论、线性代数的理论知识其实更加令人头痛，大名鼎鼎的西瓜书更是手边不能离开数学教材。如此种种都说明了一个事实，大部分程序员没有独自设计神经网络的理论知识和能力。<br />而这也就是WindowsML震撼的地方,Nikola给我们当场演示了一个关于面部表情识别的demo，他向Visual Studio中拖拽了一个ONNX格式的网络模型文件，VS自动生成了相应的Input和Output函数，神经网络的使用被简化成了黑箱！输入数据，吐出数据，仅此而已。程序员可以无需关心网络实现，直接调用，而且并不局限于Python等少数语言。<br /><img src="https://blog.gaojianli.me/ml3.jpg" /><br /><img src="https://blog.gaojianli.me/ml4.jpg" /><br />那么，如何去获得ONNX文件呢？这张图给出了几种可能的方法:<br /><img src="https://blog.gaojianli.me/ml5.jpg" /><br />前两种方法姑且不提，下载现成的文件和从其他模型文件转换大家都不难想到。后两种则是直接提供了一种不用写代码就能构建神经网络的方法！<br />在他的现场演示中，用户只需要直接选择模型类别（分类器/目标识别），然后按标签上传图片就可以了，Azure甚至会自动在云端帮你进行训练（速度还不慢）。训练完成后得到的ONNX文件则可以直接使用！从炼丹炉到炼丹术，Azure都帮你做完了，用户只要等着就好了。</p><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#Windows-混合现实"></a>Windows 混合现实</h2><p>没钱，买不起，没听，下一个</p><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#If-dev-Insider"></a>If(dev) { Insider(); }</h2><p>这个环节其实更多的是在介绍Insider项目的意义，主讲是Tyler Ahn大妈。她主要举了几个依靠insider成功的例子，得出了<code>{Insider(sth);}≠{Insider=true;}</code>这一结论。Insider计划是让million的人代表billion的人，同时给开发者一个机会，一个平台去实现他们的goal。个人感觉没啥干货，就口号喊得好听:</p><blockquote><p>Make your good code into great business.</p></blockquote><h2><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#F-amp-Q"></a>F&amp;Q</h2><p>作为最后一个环节，提问，大家参与度还是非常踊跃地，看看这排队的人：<br /><img src="https://blog.gaojianli.me/faq.jpg" /><br />其实部分问题还是挺尖锐的，包括消费者买得起的Hololens何时推出？有没有开源Groove音乐等Windows内置APP的可能来给开发者提供参考？Fluent Design能用在Web和Mobile上么？关于最后一个问题，Justin让希望在Web上看见Fluent Design的举手，其结果自然是全场齐举，莫名壮观。<del>Material Design可能要有对手了。</del></p><h1><a href="https://blog.gaojianli.me/2018/06/28/%E5%BE%AE%E8%BD%AFInsider-DevTour%E5%B0%8F%E8%AE%B0/#总结"></a>总结</h1><p>第一次参加DevTour这类活动，挺新奇的的。不过感觉收获挺大，了解到了很多很多的黑科技。同时“原来有这种东西，我之前做的XXX到底有什么意义！”这种感觉也让人爱恨交织。最后的最后，如果要用两个字来形容这次活动的话，<span>好吃！</span><br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            前言前一阵子收到了微软发给所有的insider的邀请邮件，大意说是DevTour即将巡回到北京，欢迎参加云云。弱鸡表示从来没听过这个名字，吓得我赶紧百度了一下：每年，我们都将最新的技术带给全球的开发者。今年，我们通过与Windows、Windows Insider项目以及我们的
            
        </summary>
        
        <category term="讲座"/>
        
        <category term="微软"/>
        
    </entry>
    
    <entry>
        <title>Sony Z5P Dual升级系统并获取Root权限记录</title>
        <link href="https://linkthis.me/2018/06/19/the-note-of-upgrade-and-root-e6883/"/>
        <id>https://linkthis.me/2018/06/19/the-note-of-upgrade-and-root-e6883/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>Sony今天破产了吗？</p>
</blockquote>

<h3>准备工作</h3>

<p>如果手机的版本并没有升级到最新版本的话，可以通过强刷先将手机更新到最新版本。首先通过<a href="https://forum.xda-developers.com/crossdevice-dev/sony/pc-xperifirm-xperia-firmware-downloader-t2834142" target="_blank"><code>XperiFirm</code></a>下载适合自己机型的文件，一般来说，除了日本地区的ROM之外，索尼机型的ROM都支持通刷。然后使用<a href="http://www.flashtool.net/index.php" target="_blank"><code>Flashtool</code></a>解密文件并打包为<code>FTF</code>固件，在打包时可以移除<code>SIMLOCK</code>文件，以免刷机时导致机器锁死（在较新版本的Flashtool当中<code>SIMLOCK</code>已不是可选项目）。在安装<code>Flashtool Drive</code>文件夹内的驱动时，Windows8和Windows10需要<strong>事先</strong>使用<code>高级启动</code>禁用强制驱动签名。<br />
如果需要Root手机的话，<strong>必须首先</strong>在索尼官网申请<a href="https://developer.sony.com/develop/open-devices/get-started/unlock-bootloader/unlock/step1" target="_blank">解锁码</a>解除<code>BootLoader</code>，然后通过<code>fastboot</code>命令解锁。<br />
索尼的内核有保护措施，所以为了顺利Root，需要自行制作内核。同时，因为解锁之后会导致相机等的优化算法丢失，所以内核中应该包含如下内容：</p>

<ul>
  <li>Sony-ric</li>
  <li>Dm-verity</li>
  <li>Drm-fix</li>
  <li>Fully /system read&amp;write access</li>
</ul>

<p>而且索尼没有官方<code>Recovery</code>，所以需要准备对应机型的<code>Rec</code>，如果机型不对，将导致无法进入系统。Sony Z5P Dual的代号为<code>Satsuki</code>。<br /></p>

<h3>升级</h3>

<p>打开<code>Flashtool</code>，第一次打开可能需要较长时间同步机型，如果同步失败，则可以打开<code>User</code>内<code>Flashtool device</code>文件夹使用<code>git</code>命令自行同步（建议关闭自动同步）。然后点击闪电图标选择<code>Flashmode</code>，然后选择之前制作的<code>FTF</code>固件即可，注意，<strong>一定不能</strong>勾选<code>Wipe Misc TA</code>下的<code>SIMLOCK</code>，如果勾选，将导致设备变砖。手机应在开发者模式下开启USB调试模式并授权你使用的电脑，然后在关机的情况下按住音量减键然后连接USB，此时手机呼吸灯应该为绿色，然后自动开始刷机，整个过程大概需要10分钟左右。<br /></p>

<h3>Recovery &amp; Root</h3>

<p>在刷入Recovery之前，请保证手机已经解锁且开启并授权了USB调试。在关机的情况下按住音量加键然后连接USB进入<code>Fastboot mode</code>，此时呼吸灯应为蓝色。首先在命令行内用<code>Fastboot</code>命令刷入自定义内核，之后重启，然后使用命令刷入<code>Recovery</code>并重启。<br />
Root应用选择<a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445" target="_blank"><code>Magisk</code></a>，在<code>Recovery</code>中使用<code>Mount</code>挂载SD卡或者网络储存空间（如Samba），然后刷入对应的<code>ZIP</code>包即可完成Root。<br /></p>

<h3>Magisk模块</h3>

<h4>Xposed</h4>

<p>推荐使用<a href="https://forum.xda-developers.com/xposed/unofficial-systemless-xposed-t3388268" target="_blank"><code>Systemless Xposed</code></a>，可以通过<code>Magisk Manager</code>安装，而且开机速度快，但是需要注意<code>Systemless Xposed</code><strong>无法</strong>通过<code>SafetyNet</code>检查；<code>XposedInstaller</code>也应该使用<code>Systemless Xposed</code>提供的版本。</p>

<h4>NotoSansCJK</h4>

<p>通过<code>Magisk Manager</code>安装，提供全字重中日韩字体<del>因为傻逼Google只提供了Regular字重</del>，可以很好地改善字体的显示效果，不过这个模块只支持Android 7.0+。<br /></p>

<h3>Unicode字符缺失</h3>

<p>Google在Android 8.0更新了系统的Symbol字体，而一些软件使用了较新区码的字符，导致Android 7.0无法正常对应显示。<br />
Google更新的字体为<code>NotoSansSymbols-Regular-Subsetted</code>和<code>NotoSansSymbols-Regular-Subsetted2</code><del>版本号并没有变，一直是Version 1.09uh</del>，只需要自行替换位于<code>/system/fonts/</code>下的同名字体即可正常显示。操作需要在<code>Recovery</code>下进行，同时字体的权限应设置为<strong>644</strong>。<br /></p>

<blockquote>
  <p>刷机有风险，作死需谨慎。<br />
有了Magisk和Xposed就能乱整了~<del>有Recovery怎么会翻车</del>。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               Sony今天破产了吗？   准备工作  如果手机的版本并没有升级到最新版本的话，可以通过强刷先将手机更新到最新版本。首先通过XperiFirm下载适合自己机型的文件，一般来说，除了日本地区的ROM之外，索尼机型的ROM都支持通刷。然后使用Flashtool解密文件并打包为
            
        </summary>
        
        <category term="Sony"/>
        
        <category term="记录"/>
        
    </entry>
    
    <entry>
        <title>PicGo的star数破1000的心路历程</title>
        <link href="https://molunerfinn.com/note-for-picgo/"/>
        <id>https://molunerfinn.com/note-for-picgo/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>大概半年前（2017年11月28日）我在GitHub上开源了一个基于<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>的开源桌面应用<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（<a href="https://sspai.com/post/42310" target="_blank">《PicGo：基于 Electron 的图片上传工具》</a>、<a href="https://sspai.com/post/44495" target="_blank">《图床上传工具PicGo v1.5更新：支持腾讯云COSv5版本、支持GitHub图床、支持上传前重命名文件等等》</a>等等）后，6月12日，它的star数也终于突破了1000的关卡。在这过程中我也学习了不少东西。在和大家交流的过程中，我才发现原来大家都有着这些需求，才发现我一开始的实现思路并非到位等等。谨以此文记录与PicGo有关的我的心路历程。</p><blockquote><p>赶巧前不久也有一个开发者chyingp的开源项目破了1000star，也有着类似的<a href="https://juejin.im/post/5b1717a86fb9a01e3e5ce540" target="_blank">文章</a>，祝贺！</p></blockquote><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fs892cewamj21ks0emq5n.jpg" /></p><a></a><h2><a href="https://molunerfinn.com/note-for-picgo/#项目诞生"></a>项目诞生</h2><p>我以前写博客的时候，由于一开始用的是七牛的图床，所以遇到要在markdown里贴图的时候就必须登录七牛，然后手动上传图片，再找到按钮来复制链接，然后复制到markdown里。要在markdown里显示一张图片我得经过上述4个步骤。</p><p>我自己的笔记本用的是mac，所以我就接触到了一款叫做<a href="https://toolinbox.net/iPic/" target="_blank">iPic</a>的图床神器。在用它的时候我也知道了微博图床。iPic的功能和体验真的特别好。不过如果需要使用七牛等其他图床的时候，我就需要付费了。其实如果iPic支持windows的话，我可能就真的去付费了。（因为实验室的电脑是windows，所以我平时在实验室里得用windows来写东西）。仅为mac一个平台付费我有点不能接受。</p><p>于是我就在想能否我自己写一个工具来简化我的上传图片的流程呢，这个应用可以实现拖拽图片就上传，然后上传完自动复制链接到剪贴板里，我就只要粘贴到markdown里就好了。一开始想用swift写mac的应用，用C#写windows的应用。后来发现工作量不仅大，而且学习成本也很高。于是最后还是选择投入electron的怀抱。</p><p>一开始不选择electron主要是因为我的印象中electron的应用体积都挺大的（100MB以上），所以感觉体积可能有点不友好。不过后来我在用了<code>electron-vue</code>打包出来后发现体积是可以接受的范围（mac端大概50M，windows端大概38M），于是就决定用它来写了。用<code>electron-vue</code>的主要原因是我写vue比较多，想要学习成本低一些，这样开发只要学electron的部分就好了。</p><p>说干就干，在去年年底（11月下旬）我开始写这个应用。</p><h2><a href="https://molunerfinn.com/note-for-picgo/#项目发布"></a>项目发布</h2><blockquote><p>文末会给出electron-vue开发的系列经验教程</p></blockquote><p>经过20多天的间断性地开发，我在12月12号发布了1.0.0版本。由于一开始是在mac上开发的，所以1.0.0版本也只支持了macOS。一开始支持的图床也不多，只支持了微博和七牛两个图床。</p><p>1.0.0版本的截图如下：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" /></p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/34242857-d177930a-e658-11e7-9688-7405851dd5e5.gif" /></p><p>基本实现了我预期的功能，类似iPic能够通过拖拽到顶部栏图标上传。并且为了今后支持windows平台（windows平台的任务栏图标不支持拖拽事件），我就做了一个主窗口，在主窗口里也有拖拽上传的区域。因为有了主窗口，我就顺便把图床的配置也放到了主窗口里。</p><p>应用做出来了，我也想让更多的人用到。于是我在北邮人论坛、cnode、v2ex还有掘金都发了文章。不过一开始看到的人寥寥无几，发了文章也没多少人看到和使用。后来我在少数派上发了同样的文章，意外地被推荐到了首页。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fmvr6uah8rj21z20vk7wh" /></p><p>这次的契机让PicGo意外地有了些用户和star数。在跟使用者交流的过程中我也开始逐步往PicGo里加功能和修复bug。在1月10日的时候，PicGo更新v1.3.1版本支持了windows系统。</p><p>因为开始有用户了，PicGo早期确实存在着不少功能的缺失，比如<code>快捷键上传</code>，其他常用图床的缺失等等。所以那时候是PicGo迭代最快的一段时间。通过大家在issue里的反馈，我也在不断打磨PicGo。可以看到截止6月14日，已经有61个被关闭的issue了。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/5b2223c52853f.png" /></p><h2><a href="https://molunerfinn.com/note-for-picgo/#项目改进"></a>项目改进</h2><p>用户体验这个东西真的并不是开发者在开发的时候能够立马就想到的。这点在开发PicGo上我体会很深。</p><p>比如增加<code>快捷键上传</code>这个功能，我一开始觉得自定义快捷键写起来比较麻烦，干脆我定一个大家基本用不到的快捷键吧。于是我默认给了一个【command/ctrl+shift+p】的快捷键。我自己用的时候没有什么问题。结果有人给我反馈说，快捷键跟某某某软件冲突了，能否给一个快捷键自定义的功能。这是我无法回避的一个问题。于是我就开始去学习如何加入自定义快捷键。并在不久之后实现了个这个<a href="https://github.com/Molunerfinn/PicGo/commit/37a784225e90c9d115367f056957dac88ebcf816" target="_blank">功能</a>。</p><p>比如自定义链接格式的问题。我一开始给了大家4种复制链接的格式，分别是<code>markdown</code>、<code>HTML</code>、<code>URL</code>、<code>UBB</code>。本来以为这4种格式就足够大家平时使用了。后来有人提了一个<a href="https://github.com/Molunerfinn/PicGo/issues/25" target="_blank">issue</a>，问PicGo能否自定义链接格式，因为他想基于HTML增加一些属性，比如大小居中等。我觉得这个使用场景确实是有的，于是我便在后来的某个<a href="https://github.com/Molunerfinn/PicGo/commit/4010a09fe48d8109456c3c1b37695f177336f2e4" target="_blank">提交</a>里实现了这个功能。</p><p>当然并不是大家有这个需求我就一定要做。还有一些需求我觉得并不符合我对于PicGo的定位的，那么我就会给予回绝。比如<a href="https://github.com/Molunerfinn/PicGo/issues/53" target="_blank">后期能否支持上传视频文件？</a>，由于PicGo的开发初衷只针对图片，所以在流程上（图片-&gt;base64）就不允许上传视频文件。于是我拒绝了这个需求。</p><p>还有一个对我以及PicGo这个项目影响深远的<a href="https://github.com/Molunerfinn/PicGo/issues/26" target="_blank">issue</a>，ZetaoYang提出了一个想法：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/5b2228f31219a.png" /></p><p>这个建议改变了我对PicGo开发的后续想法。我思考了好久，发现确实一步步增加默认的图床支持是不长远的。一个是重复性劳动太多（图床上传除了协议和加密方式不同之外，接收文件，转成base64和最后上传成功后存到本地的流程是一样的），一个是无止尽的图床支持其实也不应该。相比之下，把PicGo做成一个Core+Plugin模式的应用会更好。其中Core的部分可以单独只做图片接收和转码，并预留一些生命周期，供上传过程中不同的需求来调用。Core的部分可以单独发布成一个npm包。Plugin可以实现接入Core的生命周期，可以实现自己的上传逻辑，可以实现图片压缩、加水印等等其他功能。而PicGo只是在Core+Plugin的基础上套了一层electron的皮方便普通用户使用，而Core和Plugin可以独立拆出方便开发者使用和开发。这个也是PicGo的2.0版本将要做的事。</p><h2><a href="https://molunerfinn.com/note-for-picgo/#总结"></a>总结</h2><p>在开发PicGo的过程中我也深刻了解到，写一个DEMO不难，给这个DEMO注入你自己的思想和灵魂是难的。PicGo从一个一开始只是我想简化上传图片流程的玩具应用，发展到现在已经是不少用户的效率工具而言，其实一路走来也并不容易。现在大家对用户体验的要求越来越高，如果只沉醉在自己的DEMO里无法自拔，只会被更好的产品所淘汰。</p><p>开发PicGo也是一件很开心的事。大家给予我的赞赏和感谢，都是给我继续开发的动力。而我也发现越来越多的文章里，都提到了PicGo。如下：</p><ul><li><a href="https://juejin.im/post/5af0021e518825671547926e" target="_blank">《老司机的神兵利器-效率工具》</a></li><li><a href="https://imwyc.com/picgo/" target="_blank">《PicGo 强大的免费图床工具》</a></li><li><a href="https://lai.yuweining.cn/archives/2035/" target="_blank">《PicGo：开源的图片管理工具》</a></li><li><a href="https://blog.csdn.net/weixin_39200308/article/details/80644336" target="_blank">《图床神器PicGo》</a></li><li><a href="https://zhuanlan.zhihu.com/p/37873730" target="_blank">《提升生活品质——个人效率工具与资讯网站推荐》</a></li><li><a href="https://sspai.com/post/44150" target="_blank">《7 款 Windows 国产软件推荐》</a></li></ul><p>我想，得到你们的认可，把它写进你们的文章，这是对我最大的肯定，这个比star数更令我感到开心。</p><p>我在开发PicGo的过程中，也写了一个系列文章<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue开发实战</a>。如果你也想学习electron或者electron-vue的开发的话，希望我的文章能够给你带来帮助。如果你之前没有听说过PicGo，那么不妨试试；如果你觉得它挺好用的，不妨点个star~</p>]]></content>
        
        <summary type="html">
            
            大概半年前（2017年11月28日）我在GitHub上开源了一个基于electron-vue的开源桌面应用PicGo。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（《PicGo：基于 Electron 的图片上传工具》、《图床上传工具Pic
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
        <category term="Nodejs"/>
        
    </entry>
    
    <entry>
        <title>小记VSCode插件amVim的改进以及插件开发</title>
        <link href="https://molunerfinn.com/vscode-extension-develop-1/"/>
        <id>https://molunerfinn.com/vscode-extension-develop-1/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>前一段时间在Mac上用VSCode的时候，发现<code>VSCodeVim</code>这个插件严重拖慢了我的开发效率。本来用<code>Vim</code>模式难道不应该是提高效率么？问题是在<code>Normal</code>模式下，光标的移动会有肉眼可见的长延时。比如我按着<code>j</code>，等我松开<code>j</code>后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下移动，松开停止。为此我查了一下相关<a href="https://github.com/VSCodeVim/Vim/issues/2021" target="_blank">issue</a>，发现跟我一样的情况的人还不少。（不过也有不少人没有这个问题，貌似跟显卡有关系？我的mac是集显的）。</p><p>卸载了<code>VSCodeVim</code>之后，光标移动的速度又恢复了正常，不过没有<code>Vim</code>模式的话非常别扭。所以我就开始看看VSCode还有没有其他<code>Vim</code>模式的插件。于是我又试了另外两个插件：<a href="https://github.com/74th/vscode-vim" target="_blank">vimStyle</a>和<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank">amVim</a>。最终我选择了后者。不仅是支持的Vim命令更多，还有就是开发者的维护一直在继续。而且很关键的一点，<code>amVim</code>的光标移动体验就是 <strong>如丝般顺滑</strong> ！</p><p>不过它有个让我很不习惯的地方：不支持<code>:</code>号调起VSCode的<code>Command Line</code>窗口，实现诸如<code>:w</code>保存，<code>:wq</code>退出等常见功能。这些功能在<code>VSCodeVim</code>里是支持的。于是我就在想有没有办法「移植」一下<code>VSCodeVim</code>的功能到<code>amVim</code>来，既能保持光标移动体验顺滑，又能用上<code>Command Line</code>的一些常用命令。所以开启了魔改模式，并在跟开发者的一系列交流后最终我提交的PR被<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank">merge</a>了。<br /><img src="https://i.loli.net/2018/06/06/5b179b533f190.png" /><br />本文记录一下我第一次对VSCode插件（修改）开发的过程。</p><a></a><h2><a href="https://molunerfinn.com/vscode-extension-develop-1/#修改插件"></a>修改插件</h2><h3><a href="https://molunerfinn.com/vscode-extension-develop-1/#开发前的准备"></a>开发前的准备</h3><p>VSCode的插件通常是用<code>TypeScript</code>来写的。如果你需要开发或者修改它，先要拥有<code>TypeScript</code>的开发环境。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>npm install -g typescript</span><br /><span><span># or</span></span><br /><span>yarn global add typescript</span><br /></pre></td></tr></table><p>通常<code>TypeScript</code>的项目都会用上<code>tslint</code>。所以你也最好全局安装它：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>npm install -g tslint</span><br /><span><span># or</span></span><br /><span>yarn global add tslint</span><br /></pre></td></tr></table><p>然后打开VSCode，安装一下<code>tslint</code>这个插件，它将通过我们上面安装在系统里的<code>tslint</code>给我们的项目提供代码检查。</p><p>修改别人的插件，可以先<code>fork</code>一份别人的代码。也为了之后方便提PR做准备。</p><p>然后就可以把插件<code>clone</code>到本地了。比如本文的<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank">amVim-for-VSCode</a>。</p><h3><a href="https://molunerfinn.com/vscode-extension-develop-1/#运行插件"></a>运行插件</h3><p>用VSCode打开这个项目，点击左侧的<code>debug</code>可以看到一个<code>launch extension</code>的配置：</p><p><img src="https://i.loli.net/2018/06/06/5b17a25905266.png" /></p><p>运行它，你会得到另外一个窗口，这个就是可以调试插件功能的窗口了：</p><p><img src="https://i.loli.net/2018/06/06/5b17a2e5d0a1b.png" /></p><h3><a href="https://molunerfinn.com/vscode-extension-develop-1/#改进插件"></a>改进插件</h3><blockquote><p>我的改进源码在这里：<a href="https://github.com/Molunerfinn/amVim-for-VSCode" target="_blank">https://github.com/Molunerfinn/amVim-for-VSCode</a> 作者合并之后做了一些修改，本文是以我的版本为主。</p></blockquote><p>为了实现<code>VSCodeVim</code>通过<code>:</code>调起VSCode的<code>inputBox</code>效果，我需要翻阅一下<code>VSCodeVim</code>的源代码。</p><p>大致效果如下：</p><p><img src="https://user-images.githubusercontent.com/12621342/40241750-61d5160c-5aee-11e8-9d21-6f96cbc4fa88.gif" /></p><p>在查看了<code>amVim</code>和<code>VSCodeVim</code>在实现命令上的部分源码后，发现二者的实现上差距还是不小的。不过相比<code>VSCodeVim</code>代码的庞大（甚至还有neoVim的支持），<code>amVim</code>在实现上就比较精巧了。</p><p>在我的PR未被merge之前，<code>amVim</code>插件提供了一个功能，按<code>:</code>打开一个<code>GoToLine</code>的<code>inputBox</code>：</p><p><img src="https://i.loli.net/2018/06/06/5b17a73b1bf15.png" /></p><p>不过只能用于输入数字并跳转到相应行数。好在查看release更新日志，追溯这个<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/192" target="_blank">commit</a>，我们可以很容易找到它是如何实现的。</p><p><img src="https://i.loli.net/2018/06/06/5b17aa66c2030.png" /></p><p>代码不多，就几行：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span>// src/Modes/Normal.ts</span></span><br /><span>{ <span>keys</span>: <span>':'</span>, <span>actions</span>: [ActionCommand.goToLine] }, <span>// 增加`:`打开GoToLine的inputBox的快捷键</span></span><br /></pre></td></tr></table><p>具体实现代码如下：<br /></p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /></pre></td><td><pre><span><span>// src/Actions/Command.ts</span></span><br /><span><span>import</span> {commands} <span>from</span> <span>'vscode'</span>;</span><br /><span></span><br /><span><span>export</span> <span><span>class</span> <span>ActionCommand</span> </span>{</span><br /><span></span><br /><span>    <span>static</span> goToLine(): Thenable&lt;boolean | <span>undefined</span>&gt; {</span><br /><span>        <span>return</span> commands.executeCommand(<span>'workbench.action.gotoLine'</span>);</span><br /><span>    }</span><br /><span></span><br /><span>}</span><br /></pre></td></tr></table><p></p><p>所以是通过<code>vscode</code>的<code>commands</code>来打开的<code>gotoLine</code>的<code>inputBox</code>窗口。</p><p>再来看看<code>VSCodeVim</code>是如何打开<code>inputBox</code>的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /></pre></td><td><pre><span><span>// src/cmd_line/commandLine.ts</span></span><br /><span><span>export</span> <span>class</span> CommandLine {</span><br /><span>  <span>// ...</span></span><br /><span>  <span>public</span> <span>static</span> <span>async</span> PromptAndRun(initialText: <span>string</span>, vimState: VimState): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>    <span>if</span> (!vscode.window.activeTextEditor) {</span><br /><span>      Logger.debug(<span>'CommandLine: No active document'</span>);</span><br /><span>      <span>return</span>;</span><br /><span>    }</span><br /><span></span><br /><span>    <span>let</span> cmd = <span>await</span> vscode.window.showInputBox(<span>this</span>.getInputBoxOptions(initialText)); <span>// 通过showInputBox打开</span></span><br /><span>    <span>if</span> (cmd &amp;&amp; cmd[<span>0</span>] === <span>':'</span> &amp;&amp; configuration.cmdLineInitialColon) {</span><br /><span>      cmd = cmd.slice(<span>1</span>);</span><br /><span>    }</span><br /><span></span><br /><span>    <span>this</span>._history.add(cmd);</span><br /><span>    <span>this</span>._history.save();</span><br /><span></span><br /><span>    <span>await</span> CommandLine.Run(cmd!, vimState);</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// ...</span></span><br /><span>  <span>private</span> <span>static</span> getInputBoxOptions(text: <span>string</span>): vscode.InputBoxOptions { <span>// inputBox的Options</span></span><br /><span>    <span>return</span> {</span><br /><span>      prompt: <span>'Vim command line'</span>,</span><br /><span>      value: configuration.cmdLineInitialColon ? <span>':'</span> + text : text,</span><br /><span>      ignoreFocusOut: <span>false</span>,</span><br /><span>      valueSelection: [</span><br /><span>        configuration.cmdLineInitialColon ? text.length + <span>1</span> : text.length,</span><br /><span>        configuration.cmdLineInitialColon ? text.length + <span>1</span> : text.length,</span><br /><span>      ],</span><br /><span>    };</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>可以看到关键的部分是通过<code>vscode.window.showInputBox</code>打开的<code>inputBox</code>。所以我也根据这个关键的入口来一步步实现我想要的功能。</p><h4><a href="https://molunerfinn.com/vscode-extension-develop-1/#功能分析"></a>功能分析</h4><p>参考<code>VSCodeVim</code>的实现，在<code>amVim</code>里可以大概分四个部分：</p><ol><li><code>src/Modes/Normal.ts</code>作为入口文件，当用户输入<code>:</code>键时触发后续功能。【已有】</li><li><code>src/Actions/CommandLine/CommandLine.ts</code>作为打开<code>inputBox</code>的入口函数，打开<code>inputBox</code>，然后负责把用户输入的内容传给下一级的<code>parser</code>，用于解析并执行相应命令。</li><li><code>src/Actions/CommandLine/Parser.ts</code>，负责接收上一级传进来的命令，然后找到命令对应的函数，并执行该函数。如果找不到相应则返回。</li><li><code>src/Actions/CommandLine/Commands/*</code>，存放各个命令的实现函数。</li></ol><p>其中<code>src/Actions/CommandLine/CommandLine.ts</code>的逻辑跟<code>VSCodeVim</code>的<code>src/cmd_line/commandLine.ts</code>非常类似。</p><h4><a href="https://molunerfinn.com/vscode-extension-develop-1/#具体实现"></a>具体实现</h4><ol><li>src/Actions/CommandLine/CommandLine.ts</li></ol><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /></pre></td><td><pre><span><span>import</span> * <span>as</span> vscode <span>from</span> <span>'vscode'</span>;</span><br /><span><span>import</span> { parser } <span>from</span> <span>'./Parser'</span>;</span><br /><span></span><br /><span><span>export</span> <span>class</span> CommandLine {</span><br /><span>  <span>public</span> <span>static</span> <span>async</span> Run(command: <span>string</span> | <span>undefined</span>): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>      <span>if</span> (!command || command.length === <span>0</span>) { <span>// 如果命令为空则直接返回</span></span><br /><span>          <span>return</span>;</span><br /><span>      }</span><br /><span>      <span>try</span> {</span><br /><span>          <span>const</span> cmd = parser(command); <span>// 将命令传给parser并返回一个可执行的函数</span></span><br /><span>          <span>if</span> (cmd) {</span><br /><span>              <span>await</span> cmd.execute(command); <span>// 调用该函数的execute方法</span></span><br /><span>          }</span><br /><span>      } <span>catch</span> (e) {</span><br /><span>          <span>console</span>.error(e);</span><br /><span>      }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>public</span> <span>static</span> <span>async</span> PromptAndRun(): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>      <span>if</span> (!vscode.window.activeTextEditor) { <span>// 如果当前没有打开的激活的文本，则命令不执行，返回空。</span></span><br /><span>          <span>return</span>;</span><br /><span>      }</span><br /><span>      <span>try</span> {</span><br /><span>          <span>let</span> cmd = <span>await</span> vscode.window.showInputBox(CommandLine.getInputBoxOptions()); <span>// 打开inputBox</span></span><br /><span>          <span>if</span> (cmd &amp;&amp; cmd[<span>0</span>] === <span>':'</span>) {</span><br /><span>              cmd = cmd.slice(<span>1</span>); <span>// 如果命令带有:则将它去掉并传给parser</span></span><br /><span>          }</span><br /><span>          <span>return</span> <span>await</span> CommandLine.Run(cmd);</span><br /><span>      } <span>catch</span> (e) {</span><br /><span>          <span>console</span>.error(e);</span><br /><span>      }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>private</span> <span>static</span> getInputBoxOptions(): vscode.InputBoxOptions { <span>// 打开的inputBox框里的文本和一些其他配置</span></span><br /><span>      <span>return</span> {</span><br /><span>          prompt: <span>'Vim command line'</span>,</span><br /><span>          value: <span>':'</span>,</span><br /><span>          ignoreFocusOut: <span>false</span>,</span><br /><span>          valueSelection: [<span>1</span>, <span>1</span>]</span><br /><span>      };</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><ol><li>src/Actions/CommandLine/Parser.ts</li></ol><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /></pre></td><td><pre><span><span>import</span> { CommandBase } <span>from</span> <span>'./Commands/Base'</span>;</span><br /><span><span>import</span> WriteCommand <span>from</span> <span>'./Commands/Write'</span>;</span><br /><span><span>import</span> WallCommand <span>from</span> <span>'./Commands/WriteAll'</span>;</span><br /><span><span>import</span> QuitCommand <span>from</span> <span>'./Commands/Quit'</span>;</span><br /><span><span>import</span> QuitAllCommand <span>from</span> <span>'./Commands/QuitAll'</span>;</span><br /><span><span>import</span> WriteQuitCommand <span>from</span> <span>'./Commands/WriteQuit'</span>;</span><br /><span><span>import</span> WriteQuitAllCommand <span>from</span> <span>'./Commands/WriteQuitAll'</span>;</span><br /><span><span>import</span> VisualSplitCommand <span>from</span> <span>'./Commands/VisualSplit'</span>;</span><br /><span><span>import</span> NewFileCommand <span>from</span> <span>'./Commands/NewFile'</span>;</span><br /><span><span>import</span> VerticalNewFileCommand <span>from</span> <span>'./Commands/VerticalNewFile'</span>;</span><br /><span><span>import</span> GoToLineCommand <span>from</span> <span>'./Commands/GoToLine'</span>;</span><br /><span></span><br /><span><span>const</span> commandParsers = { <span>// 对于命令的解析，用哈希表做映射</span></span><br /><span>    w: WriteCommand,</span><br /><span>    write: WriteCommand,</span><br /><span>    wa: WallCommand,</span><br /><span>    wall: WallCommand,</span><br /><span></span><br /><span>    q: QuitCommand,</span><br /><span>    quit: QuitCommand,</span><br /><span>    qa: QuitAllCommand,</span><br /><span>    qall: QuitAllCommand,</span><br /><span></span><br /><span>    wq: WriteQuitCommand,</span><br /><span>    x: WriteQuitCommand,</span><br /><span></span><br /><span>    wqa: WriteQuitAllCommand,</span><br /><span>    wqall: WriteQuitAllCommand,</span><br /><span>    xa: WriteQuitAllCommand,</span><br /><span>    xall: WriteQuitAllCommand,</span><br /><span></span><br /><span>    vs: VisualSplitCommand,</span><br /><span>    vsp: VisualSplitCommand,</span><br /><span></span><br /><span>    <span>new</span>: NewFileCommand,</span><br /><span>    vne: VerticalNewFileCommand,</span><br /><span>    vnew: VerticalNewFileCommand</span><br /><span>};</span><br /><span></span><br /><span><span>export</span> <span><span>function</span> <span>parser</span>(<span>input: <span>string</span></span>): <span>CommandBase</span> | <span>undefined</span> </span>{</span><br /><span>    <span>if</span> (commandParsers[input]) {</span><br /><span>        <span>return</span> commandParsers[input]; <span>// 接收inputBox里传来的命令</span></span><br /><span>    } <span>else</span> <span>if</span> (<span>Number</span>.isInteger(<span>Number</span>(input))) {</span><br /><span>        <span>return</span> GoToLineCommand;</span><br /><span>    } <span>else</span> {</span><br /><span>        <span>return</span> <span>undefined</span>;</span><br /><span>    }</span><br /><span>}</span><br /></pre></td></tr></table><ol><li>命令的实现</li></ol><p>由于命令很多，我就举三个例子。一个是<code>w</code>，一个是<code>q</code>，和一个<code>wq</code>。VSCode自己的一些功能比如关闭当前文件、保存文件等都是有自己的command的。在实现Vim模式的时候，实际上最后也是去调用VSCode自带的功能而已。</p><h5><a href="https://molunerfinn.com/vscode-extension-develop-1/#Write"></a>Write</h5><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /></pre></td><td><pre><span><span>import</span> * <span>as</span> vscode <span>from</span> <span>'vscode'</span>;</span><br /><span><span>import</span> { CommandBase } <span>from</span> <span>'./Base'</span>;</span><br /><span></span><br /><span><span>class</span> WriteCommand <span>extends</span> CommandBase {</span><br /><span>  <span>constructor</span>(<span></span>) {</span><br /><span>    <span>super</span>();</span><br /><span>  }</span><br /><span>  <span>async</span> execute(): <span>Promise</span>&lt;<span>void</span>&gt; { <span>// 暴露execute方法用于调用</span></span><br /><span>    <span>await</span> vscode.commands.executeCommand(<span>'workbench.action.files.save'</span>); <span>// 调用vscode的命令保存文件</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> <span>new</span> WriteCommand();</span><br /></pre></td></tr></table><h5><a href="https://molunerfinn.com/vscode-extension-develop-1/#Quit"></a>Quit</h5><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /></pre></td><td><pre><span><span>import</span> * <span>as</span> vscode <span>from</span> <span>'vscode'</span>;</span><br /><span><span>import</span> { CommandBase } <span>from</span> <span>'./Base'</span>;</span><br /><span></span><br /><span><span>class</span> QuitCommand <span>extends</span> CommandBase {</span><br /><span>  <span>constructor</span>(<span></span>) {</span><br /><span>    <span>super</span>();</span><br /><span>  }</span><br /><span>  <span>async</span> execute(): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>    <span>await</span> vscode.commands.executeCommand(<span>'workbench.action.closeActiveEditor'</span>); <span>// 调用vscode的命令关闭当前的文件</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> <span>new</span> QuitCommand();</span><br /></pre></td></tr></table><h5><a href="https://molunerfinn.com/vscode-extension-develop-1/#WriteQuit"></a>WriteQuit</h5><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /></pre></td><td><pre><span><span>import</span> { CommandBase } <span>from</span> <span>'./Base'</span>;</span><br /><span><span>import</span> WriteCommand <span>from</span> <span>'./Write'</span>;</span><br /><span><span>import</span> QuitCommand <span>from</span> <span>'./Quit'</span>;</span><br /><span></span><br /><span><span>class</span> WriteQuitCommand <span>extends</span> CommandBase {</span><br /><span>  <span>constructor</span>(<span></span>) {</span><br /><span>    <span>super</span>();</span><br /><span>  }</span><br /><span>  <span>async</span> execute(): <span>Promise</span>&lt;<span>void</span>&gt; {</span><br /><span>    <span>await</span> WriteCommand.execute();</span><br /><span>    <span>await</span> QuitCommand.execute();</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> <span>new</span> WriteQuitCommand();</span><br /></pre></td></tr></table><p>这一步就很有意思了，因为我们之前实现了<code>Write</code>和<code>Quit</code>的功能，所以可以在这里调用它们。看到这里你可能会有问题，虽然我知道VSCode有这些功能，但是你是怎么知道这些功能是怎么写的呢？</p><p>如果只是我这篇文章的话，我在实现Vim模式的这些命令的时候，大部分是参考了<code>VSCodeVim</code>的一些写法。它主要的命令实现在<code>src/cmd_line/commands/*</code>里。但是只这样显然还是不够的。因此我给出几个比较有用的地方供大家开发插件的时候参考：</p><ol><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensions/overview" target="_blank">Extending Visual Studio Code</a>，介绍扩展VSCode的原理和给出了一些例子。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank">Extensibility Reference</a>，介绍VSCode扩展的api文档。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank">Key Bindings for Visual Studio Code</a>，介绍VSCode的快捷键和相应的<strong>命令id</strong>。</li><li>VSCode本身的快捷键编辑面板：<br /><img src="https://i.loli.net/2018/06/13/5b20c5d23fda2.png" /></li></ol><p>说实话VSCode的文档写得不是特别好。我要实现一个功能，查找文档查了半天。其实其中很大一部分操作，你可以在上面的第3点、第4点里通过快捷键的提供的<code>Command id</code>去实现：</p><p><img src="https://i.loli.net/2018/06/13/5b20c6a5bcccd.png" /></p><p>比如你要实现一个剪切的功能，有了<code>Command id</code>，你就可以通过<code>vscode.commands.executeCommand('editor.action.clipboardCutAction')</code>来实现。因此我推荐，如果你要实现的功能有些可以用已有快捷键实现的，那么就能在这个列表里找到对应的<code>Command id</code>来手动实现了。</p><p>至于其他的一些非快捷键提供的功能，就还需要阅读第2点的api文档做出更深层次的修改了。</p><h2><a href="https://molunerfinn.com/vscode-extension-develop-1/#总结"></a>总结</h2><p>在改进完这个插件之后，我向作者提交了PR。在和作者交流后做出了一些修改，并最终被作者接受并合并。为开源项目贡献代码的感觉是真的很不错。</p>]]></content>
        
        <summary type="html">
            
            前一段时间在Mac上用VSCode的时候，发现VSCodeVim这个插件严重拖慢了我的开发效率。本来用Vim模式难道不应该是提高效率么？问题是在Normal模式下，光标的移动会有肉眼可见的长延时。比如我按着j，等我松开j后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="TypeScript"/>
        
        <category term="前端"/>
        
        <category term="Nodejs"/>
        
        <category term="VSCode"/>
        
    </entry>
    
    <entry>
        <title>写在前面</title>
        <link href="https://blog.gaojianli.me/2018/06/12/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
        <id>https://blog.gaojianli.me/2018/06/12/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
        
        <author>
            <name>高渐离</name>
        </author>
        
        <published>2021-08-20T09:12:49+00:00</published>
        <updated>2021-08-20T09:12:49+00:00</updated>
        
        <content type="html"><![CDATA[<p>思前想后，看见大家都有了，我还是开一个博客吧。<br />之前一直懒得弄的原因是担心自己没有动力去写文章。但是，怎么说呢，完事开头难，人家潇都有了我怎么能没有呢！（笑）<br />也有这么一种不服气在里面就是了。<br />那就这样吧，希望能够坚持下去。<br />では、諸君は。</p>]]></content>
        
        <summary type="html">
            
            思前想后，看见大家都有了，我还是开一个博客吧。之前一直懒得弄的原因是担心自己没有动力去写文章。但是，怎么说呢，完事开头难，人家潇都有了我怎么能没有呢！（笑）也有这么一种不服气在里面就是了。那就这样吧，希望能够坚持下去。では、諸君は。
            
        </summary>
        
    </entry>
    
    <entry>
        <title>幕後：在爭吵中成型的 SOSCON 2018 講稿和投影片</title>
        <link href="https://byrio.org/soscon-18-behind-the-scenes/"/>
        <id>https://byrio.org/soscon-18-behind-the-scenes/</id>
        
        <author>
            <name>櫻川 浅羽</name>
        </author>
        
        <published>2018-06-12T04:32:10+00:00</published>
        <updated>2018-06-12T04:32:10+00:00</updated>
        
        <content type="html"><![CDATA[<h1>BYRIO @ SOSCON 18 大事記</h1>
<p>6 月 8 日，SOSCON 18 的前夕，BYRIO 終於（在浅羽實在已經不想再改的情況下）確定了最後的講稿，並且趕製出了 Slides。</p>
<p>6 月 6 日，演講稿初步成型，向會方確認演講場地情報，開始調整 Slides。</p>
<p>6 月 3 日，浅羽交出了第一版 Slides，同時 BYRIO 開始大規模修改演講稿。</p>
<p>6 月 2 日，BYRIO 召開 Core Team 會議，安排試講 SOSCON 18。發現講稿和 Slides 都問題大。</p>
<p>所幸在大家主業都很忙的情況下，在不停地商討和爭吵中，BYRIO 的演講總算是有模有樣<del>，在 SOSCON 18 上成功地給 BYRIO 打了一個響亮的廣告</del>。SOSCON 18 舉行的兩天，因爲行程的問題，浅羽也並沒有前往現場參加。但是作爲投影片的製作者和演講稿的參與者，浅羽也想說說 SOSCON 18 的一些幕後。</p>
<p><span></span></p>
<h1>發現問題</h1>
<p>6 月 2 的 Core Team 會議當天，試講進行得很順利，然而（至少在浅羽看來）並不成功。好幾年沒有認真聽過演講的浅羽，寫了一整頁的手帳記錄發現的問題。這些問題涉及到觀點、版式、句型、用詞等等由大入微的問題，並且其他參加試講的聽衆多少都認同某些觀點。而解決方法也很簡單直接：</p>
<p><strong>改。</strong></p>

<a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/2161_001.jpg?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/2161_001.jpg?fit=1100%2C1582&amp;ssl=1" /></a>

<p>改成什麼樣？誰也不知道，只有先看看再說。散會之後，晚餐是在船歌魚水餃吃的，疲憊而缺覺的 LinkAdrifiting 和 Dimpurr 邊吃邊在<del>畫幼女</del>討論要不要吃完直接回學校改稿子。於是，LinkAdrifiting、Dimpurr 和浅羽在吃完晚餐之後，開始動爪修稿子。</p>
<h1>冷靜分析</h1>
<p>發現的問題中，有一些是屬於經驗性的和細節性的問題。LinkAdrifiting 同學是第一次演講，更是第一次準備演講稿。因此比起演講稿，稿件更像是一篇議論文——有明確的小標題、大量的括號註釋、沒有足夠的口頭化等。所以<strong>第一步就是要讓演講稿長得像演講稿</strong>。我們做了許多的努力，終於讓演講稿能夠做到口語化、平面化（而不是像這一段一樣有很多的括號們）。由於 LinkAdrifiting 本人是個遊戲迷，同時也計劃從事遊戲方面的工作，因此原稿件中有很多的梗是關於遊戲社區和公司的；因此<strong>第二步就是重新審視我們的受衆</strong>——學生開源年會的聽衆們，這些梗顯得就不是非常合適。</p>
<p>既然梗不太令人容易理解，又需要爲我們的論點提出論據，解釋我們的觀點，所以修改論據就非常必要了。</p>

<a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-11_14-08-27-1.jpg?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-11_14-08-27-1.jpg?fit=1280%2C466&amp;ssl=1" /></a>

<p>爲了舉出合適的例子，大家都絞盡腦汁，甚至從爭論例子是否具有相關性、是否適合受衆發展到了邏輯辯論的地步。</p>
<blockquote><p>@LinkAdrifting, [05.06.18 20:40]<br />
一个问题：有关多样性那里的例子<br />
假若我采用更加普适的，比如社区开发某个项目，或者其他领域受技术影响的例子<br />
将与前文说的“硬核爱好”脱节</p>
<p>@dimpurr, [05.06.18 20:45]<br />
关键是你逻辑不对，机核网这样，为什么我们也得这样？别的学校不一定存在小众兴趣的困境，说到底这个话题是你 byrio 的话题没错，但是很可能不是开源年会的话题，顶多一笔带过，你开一段讲本来就是说错了场合<br />
不是你这样改和硬核爱好脱节了<br />
而是硬核爱好和主题脱节了<br />
多样性是个格格不入的点，为啥插在新人和延续之间</p>
<p>@LinkAdrifting, [05.06.18 20:50]<br />
因为前面是“拓展”</p>
<p>@dimpurr, [05.06.18 20:50]<br />
我們爲什麼要吸收新人 这个标题错了<br />
错的很严重</p>
<p>@LinkAdrifting, [05.06.18 20:50]<br />
很遗憾，原来我这段不是zhege<br />
应该是羽chan会错意了<br />
我重申观点：我想就我所身处的现状，来以一个分享、探讨的形式去说出去<br />
而不是说：别人有强大的社团，因此他们就对此不感兴趣</p>
<p>@dimpurr, [05.06.18 20:52]<br />
为什么我们作为高校开源社区，也可以有这样的多样性呢？<br />
如果这样我会改标题<br />
「创意者社区：開源社區與精神的拓展和延續」<br />
这样就赤裸裸的 .. 就符合byrio的现状</p>
<p>@LinkAdrifting, [05.06.18 20:54]<br />
其实，在文字上都是“小问题”<br />
在逻辑上就是大问题<br />
我重申观点：我想就我所身处的现状，来以一个分享、探讨的形式去说出去</p>
<p>@dimpurr, [05.06.18 20:54]<br />
[In reply to @LinkAdrifting]<br />
锅还是你的逻辑学入门<br />
讲情怀不讲逻辑</p></blockquote>
<p>無盡地邏輯辯論，直接導致了寫 Outline、重新做 Brainstorm 的需求，於是<strong>本來應該是整理語言的第三步就變成了幾乎整個演講稿的重寫</strong>，<strong>選擇了更爲通俗的例子</strong>，對於大家可能不熟悉的例子也加入了解釋；列出了 Outline 之後，更換了一些演講順序，也<strong>調整和加入了演講論點</strong>；甚至於<strong>爲了邏輯通暢，把標題也改了</strong>。</p>

<a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-11_14-44-38.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-11_14-44-38.jpg?fit=894%2C1280&amp;ssl=1" /></a>

<p>在通篇的邏輯和觀點被大家認可後，大家因爲細節和行文又陷入了爭吵和修改。</p>
<blockquote><p>@SakuragawaAsaba, [06.06.18 15:09]<br />
[ Photo ]<br />
你提了三項，但是後文你沒有做好呼應<br />
關鍵詞分別是「探索」「吸納」「延續」而你沒有一個很重點圍繞關鍵詞展開的強調句</p>
<p>@LinkAdrifting, [06.06.18 15:10]<br />
等于内容没问题，可是需要加强调</p>
<p>@SakuragawaAsaba, [06.06.18 15:11]<br />
你就這麼理解吧，也是可以的<br />
你演講的話就不能指望靠你稿子裏的標題完成核心內容的總結和轉換<br />
你一定要有句子去做這些</p>
<p>@LinkAdrifting, [06.06.18 15:14]<br />
明白，说白了还是没有演讲经验</p>
<p>@SakuragawaAsaba, [06.06.18 15:14]<br />
你可以順便給你的畢設積累一點<br />
雖然那些老師可能自己做出來的也是提詞器</p></blockquote>
<p>經過數個晚上的爭吵，講稿也已經被改得面目全非；而乃們現在看到的那個樣子，比起它之前的任何時刻都更好。</p>

<a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/Screenshot-2018-6-11-SOSCON-2018-BYRIO-Presentation-Text.png?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/Screenshot-2018-6-11-SOSCON-2018-BYRIO-Presentation-Text.png?fit=1130%2C954&amp;ssl=1" /></a>

<h1>仔細思考</h1>
<p>那麼接下來可以做投影片了。原先，LinkAdrifting 同學是仿造機核網的風格製作的投影片，並且還在演講中埋了一個「投影片看起來很眼熟…是機核網的風格」的梗。然而經過我們的辯論，這個梗因爲受衆不合適而取消了，重做的投影片可以完全由浅羽設計風格。LinkAdrifting 是作爲 BYRIO 社羣的發言人「推銷」BYRIO 的，因此在美觀的同時，浅羽想要持續輸出 BYRIO 元素。</p>
<p>配合 BYRIO 的 Logo 顏色，浅羽想要選擇一個藍白<del>條紋胖次</del>風格作爲投影片的主調。白色自然沒什麼可說的，藍色的話…嗯，找一個 Material 色系好了。</p>

<a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/Screenshot-2018-6-11-Color-Tool-Material-Design.png?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/Screenshot-2018-6-11-Color-Tool-Material-Design.png?fit=579%2C419&amp;ssl=1" /></a>

<p>緊接着需要給背景添加同色系的輔助元素。最直接的選擇當然就是 BYRIO 的 Logo 做一個漸變化。然後選擇純白色作爲主體，這樣的配色很適合用來寫 Slogan 啊（笑）。示範截圖中作爲一個宣傳頁，可以看到最終整個頁面足有 3 個 BYRIO 的 Logo<del>，數量之多快趕上 SONY Xperia Z5 了</del>；而在其他的頁面，則是左上角的明顯 Logo 作爲社羣的版權標記，加上背景的一個裝飾性 Logo 以深化聽衆對社羣的印象。</p>
<p>對於非強調性的 Outline 頁面，則選擇了普通的灰-白-黑色系，能夠有效地保持觀衆的注意力，並且突出內容。左上的相同位置則使用藍色的 BYRIO Logo 增加藍色色系，保持色系組成的統一。</p>

<a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/1.png?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/1.png?fit=960%2C720&amp;ssl=1" /></a>
<a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/2.png?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/2.png?fit=960%2C720&amp;ssl=1" /></a>
<a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/3.png?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/3.png?fit=960%2C720&amp;ssl=1" /></a>
<a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/4.png?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/4.png?fit=960%2C720&amp;ssl=1" /></a>


<a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/5.png?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/5.png?fit=960%2C720&amp;ssl=1" /></a>
<a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/6.png?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/6.png?fit=960%2C720&amp;ssl=1" /></a>

<p>最後調整一下字號和字重，使得內容比例合適之後，風格就算確定下來了。終於交出了第一版投影片之後，大家都鬆了一口氣，開始磨合稿子和 Slides。</p>
<blockquote><p>@dimpurr, [06.06.18 11:19]<br />
改了下这个<br />
啊羽酱真天才<br />
为什么这么好看！！！<br />
羽酱万岁 永远爱羽酱！</p></blockquote>
<p>這期間，風格雖然沒有大的改變，但是內容則是經歷了簡體化又換回繁體、從自由大綱到「提詞器」再換回自由大綱等等的曲折。最後，在浅羽的堅持和 Dimpurr 的建議下，投影片總體還是保持自由大綱的形式，但添加了一定量的細節和強調內容用以輔助講演。</p>
<h1>好耶我們沒涼</h1>
<p>LinkAdrifting 演講的當天，浅羽病了一整天，所以並沒有能看到直播。不過準備了至少一週的投影片，終於也幫助 BYRIO 在衆多的學生組織中，完成了第一次亮相。</p>
<blockquote><p>@dimpurr, [10.06.18 08:35]<br />
会方自己全用的16:9<br />
我看了 USTC 和我们 BYRIO 的都是 4:3<br />
论与会者比会方上心系列</p>
<p>@dimpurr, [10.06.18 10:40]<br />
@SakuragawaAsaba 恭喜羽酱！PPT效果超赞，演讲效果目前也不错<br />
byrio 的PPT拉高了整个大会的规格</p>
<p>@FredericDT, [10.06.18 10:50]<br />
羽酱！羽酱！</p>
<p>@dimpurr, [10.06.18 12:41]<br />
@SakuragawaAsaba 话说羽酱可以准备写我们这次 soscon 的日后谈了啊</p></blockquote>
<p>最後，附上 BYRIO @ SOSCON 18 的最終投影片，博君一笑。文章首發於<a href="https://asaba.sakuragawa.moe/2018/06/幕後：在爭吵中成型的-soscon-2018-講稿和投影片/">浅羽的個人網站</a>並授權轉載，文章中所有掃描件和聊天記錄在獲得當事人同意的前提下公開。</p>
<p></p>
<p><a href="https://byrio.org/soscon-18-behind-the-scenes/">幕後：在爭吵中成型的 SOSCON 2018 講稿和投影片</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            BYRIO @ SOSCON 18 大事記 6 月 8 日，SOSCON 18 的前夕，BYRIO 終於（在浅羽實在已經不想再改的情況下）確定了最後的講稿，並且趕製出了 Slides。 6 月 6 日，演講稿初步成型，向會方確認演講場地情報，開始調整 Slides。 6 月 3
            
        </summary>
        
        <category term="活动记录"/>
        
        <category term="SOSCON"/>
        
    </entry>
    
    <entry>
        <title>如何在 Krita 中创建材质笔刷</title>
        <link href="http://blog.dimpurr.com/krita-textured-brushes/"/>
        <id>http://blog.dimpurr.com/krita-textured-brushes/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2018-06-11T16:56:07+00:00</published>
        <updated>2018-06-11T16:56:07+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>Krita 是 KDE 基金会项目下的一款专注于数码图形绘画 (Digital Art) 的跨平台开源软件。</p>
<p>在 Krita 官方讨论区 <a href="https://forum.kde.org/viewforum.php?f=274"> Krita Tutorial &amp; Resources</a> 板块和官方文档 <a href="https://docs.krita.org/en/resources_page.html#">Resources</a> 页面可以获得许多有用的材质和笔刷。本文主体内容改编翻译自 <a href="https://forum.kde.org/viewtopic.php?f=274&amp;t=140349">https://forum.kde.org/viewtopic.php?f=274&amp;t=140349</a></p>
<p>钉子的知识库： <a href="http://note.dimpurr.com/#%E8%89%BA%E6%9C%AF%E5%92%8C%E5%8A%A8%E6%BC%AB%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95">http://note.dimpurr.com/#艺术和动漫绘画学习索引 </a></p></blockquote>
<p>今天我将教你们如何创建一个酷炫的材质笔刷。如果你需要一些类似 Photoshop 的<a href="http://www.missyuan.com/thread-524629-1-1.html">双重画笔</a>一样的工具，那就是这个没错了。我想这是材质绘制的极佳方式。让我们开始吧：</p>
<p>首先创建一个基本笔刷贴图尺寸的文件（我使用 300*300px）并删除背景。</p>
<p>插入（或者手动绘制）「基础」贴图。这个贴图会决定笔刷贴图的形式、尺寸、比例并仅用于创建选区。随后右键点击该图层，在菜单中选择「选择不透明度 (Select Opaque)」。</p>
<p><span></span></p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734864-6721-sDJRPjy-600x576.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734864-6721-sDJRPjy-600x576.jpg" /></a><p>image</p></div>
<p>隐藏这个图层，并创建 5-10 个新图层。</p>
<p>选择某个材质笔刷，并在空白图层上绘画。使用随机的分散/镜像/旋转设置以增加贴图的多样性。对每个图层都这样做。你可以设置分离图层（Isolate layer）或者 Alt + 点击 切换单独绘制每个图层让这个过程舒服一点。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734863-7170-7Y53OGz.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734863-7170-7Y53OGz-600x579.jpg" /></a><p>image</p></div>
<p>现在让我们创建新的动画笔刷材质。点击 +印戳 （+Stamp） 按钮并选择 风格：动态 ，模式 ：随机 （当然你也可以是用别的）。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734864-6884-TlYsLYu.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734864-6884-TlYsLYu-600x428.jpg" /></a><p>image</p></div>
<p>这将会使用目前所有的可见图层作为笔刷的贴图。不要使用自动间隙（Auto Spacing），记得为笔刷命名。你需要反复尝试让笔刷变得正常，可以直接在画布上测试你的新笔刷。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7605-FeqWzw1.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7605-FeqWzw1-600x412.jpg" /></a><p>image</p></div>
<p>于是我们有了一个还未经设置的笔刷贴图，接下来进行一系列配置吧。对于方形笔刷贴图，我建议你使用镜像（Mirror）以增加多样性。对圆形笔刷贴图你也可以使用旋转（Rotation）。你也可以调节空隙曲线增加某种动态笔压，我以这种方式让高压力时能画出厚重的线条。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7424-5MgVPaJ.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7424-5MgVPaJ-600x476.jpg" /></a><p>image</p></div>
<p>别忘了设置你还可以使用滤镜（filters），有时候我会使用非锐化蒙版（Unsharp）、模糊（Blur）、色彩调整曲线（Color Adjustment Curves）。色彩调整曲线（Color Adjustment Curves）在透明通道（Alpha channel ）绘制的时候特别有用（当然平常也有效）。</p>
<p>后面是最终效果的一些例子。在<a href="https://forum.kde.org/viewtopic.php?f=274&amp;t=137532">我的笔刷包</a>中，我做了许多有用的基本笔刷、材质笔刷并做好了预设。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7997-IUGbYeJ.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/06/1528734864-7997-IUGbYeJ-600x259.jpg" /></a><p>image</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/krita-textured-brushes/">如何在 Krita 中创建材质笔刷</a></p>]]></content>
        
        <summary type="html">
            
            Krita 是 KDE 基金会项目下的一款专注于数码图形绘画 (Digital Art) 的跨平台开源软件。 在 Krita 官方讨论区  Krita Tutorial &amp;amp; Resources 板块和官方文档 Resources 页面可以获得许多有用的材质和笔刷。本文主
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="KDE"/>
        
        <category term="Krita"/>
        
        <category term="绘画"/>
        
    </entry>
    
    <entry>
        <title>调整Linux I/O调度器优化性能</title>
        <link href="https://linkthis.me/2018/06/12/io-scheduler-optimize-performance/"/>
        <id>https://linkthis.me/2018/06/12/io-scheduler-optimize-performance/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>Linux I/O 调度器是Linux内核中的一个组成部分，用户可以通过调整这个调度器来优化系统性能。</p>
</blockquote>

<h3>Linux I/O调度器</h3>

<p>目前主流的Linux发行版本一般提供以下三种I/O调度器，下面进行简单的介绍：</p>

<h4>CFQ</h4>

<p>CFQ全称<code>Completely Fair Scheduler</code>，中文名称完全公平调度器，它是目前多数Linux发行版默认使用的调度器，其由内核默认选择。CFQ将由进程提交的同步请求放到多个进程队列中，然后为每个队列分配时间片以访问磁盘。对于通用的服务器是最好的选择，CFQ均匀地分布对I/O带宽的访问。CFQ为每个进程和线程，单独创建一个队列来管理该进程所产生的请求，以此来保证每个进程都能被很好的分配到I/O带宽，I/O调度器每次执行一个进程的4次请求。该算法的特点是按照I/O请求的地址进行排序，而不是按照先来后到的顺序来进行响应。简单来说就是给所有同步进程分配时间片，然后才排队访问磁盘。</p>

<h4>DeadLine</h4>

<p>Deadline为截止时间调度器，是对Linus Elevator的一种改进（在2.4内核中使用的第一种I/O调度器。主要作用是为每个设备维护一个查询请求，当内核收到一个新请求时，如果能合并就合并。如果不能合并，就会尝试排序。如果既不能合并，也没有合适的位置插入，就放到请求队列的最后），可以避免有些请求太长时间不能被处理，并可以区分对待读操作和写操作。Deadline分别<strong>额外</strong>为读I/O和写I/O提供了FIFO队列。<br />
在Debian9系统下，如果使用<strong>官方</strong>提供的4.16版本内核，将会同时默认启用<code>mq-deadline</code>，其可以并行执行I/O调度，提高执行效率。</p>

<h4>NOOP</h4>

<p>NOOP全称<code>No Operation</code>，中文名称电梯式调度器，其实现了最简单的FIFO队列，所有I/O请求大致按照先来后到的顺序进行操作。NOOP实现了一个简单的FIFO队列，像电梯的工作主法一样对I/O请求进行组织。它是基于先入先出（FIFO）队列概念的Linux内核里最简单的I/O调度器。此调度程序比较适合固态硬盘。</p>

<h3>查看使用的I/O调度器调整</h3>

<p>查看系统支持的I/O调度器：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>dmesg | <span>grep</span> <span>-i</span> scheduler
<span>[</span>    1.092429] io scheduler noop registered
<span>[</span>    1.092431] io scheduler deadline registered
<span>[</span>    1.092582] io scheduler cfq registered <span>(</span>default<span>)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>结果显示，CFQ是目前使用的I/O调度器。<br />
查看某块硬盘使用的I/O调度器：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>cat</span> /sys/block/sda/queue/scheduler
noop deadline <span>[</span>cfq]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>结果显示，CFQ是此硬盘使用的I/O调度器。<br />
注意，此命令在VPS上<strong>可能</strong>无法执行。</p>

<h3>修改使用的I/O调度器</h3>

<p>修改linux的调度器十分简单，可以通过<code>shell</code>命令或者修改<code>grub</code>配置文件来达到目的。</p>

<h4>Shell</h4>

<p>此方法可以随时更改I/O调度器而无需重启计算机。</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>echo </span>deadline <span>&gt;</span> /sys/block/sda/queue/scheduler
</pre></td></tr></tbody></table></code></pre></div></div>

<p>注意，此命令在VPS上<strong>可能</strong>无法执行。</p>

<h4>GRUB</h4>

<p>此方法将永久修改默认的I/O调度器，与使用shell命令的临时修改不同，系统重启后，修改的调度器不会失效。
修改<code>/etc/default/grub</code>，在<code>GRUB_CMDLINE_LINUX_DEFAULT</code>内增加：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>elevator</span><span>=</span>deadline
</pre></td></tr></tbody></table></code></pre></div></div>

<p>保存之后执行<code>update-grub</code>命令，然后重启计算机即可。</p>

<blockquote>
  <p>用户需要根据自己的需求来选择适合自己使用环境的I/O调度器，每种调度器只有在合适的硬件上才能发挥最优的效果。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               Linux I/O 调度器是Linux内核中的一个组成部分，用户可以通过调整这个调度器来优化系统性能。   Linux I/O调度器  目前主流的Linux发行版本一般提供以下三种I/O调度器，下面进行简单的介绍：  CFQ  CFQ全称Completely Fair S
            
        </summary>
        
        <category term="Debian"/>
        
        <category term="I/O"/>
        
    </entry>
    
    <entry>
        <title>SOSCON 18 前线纪实</title>
        <link href="https://byrio.org/soscon-18-briefing/"/>
        <id>https://byrio.org/soscon-18-briefing/</id>
        
        <author>
            <name>LinkAdrifting</name>
        </author>
        
        <published>2018-06-11T07:09:15+00:00</published>
        <updated>2018-06-11T07:09:15+00:00</updated>
        
        <content type="html"><![CDATA[<p>由重庆大学 Continue 社区举办的第 0 届 SOSCON 大会就这样圆满结束了，作为中国大陆境内首个由学生自发组织举办的开源技术峰会，各路大神、社区的核心人员或分享技术成果，或分享社区经验，可谓是各显神通。这里由BYRIO前线分队为你带来前方报道。</p>
<p>由于两天议程中的内容实在不少，本文只介绍给笔者留下较深刻印象的分享内容。</p>
<p>议程：</p>
<ul>
<li>DAY 1 <a href="http://soscon.top/agenda"> http://soscon.top/agenda</a></li>
<li>DAY 2 <a href="http://soscon.top/agenda10">http://soscon.top/agenda10</a></li>
</ul>
<h2>Day 1</h2>
<p>6月9日的活动于下午开始，第一场活动是开源博览会，演讲者对本次大会做了一些简要介绍，同时也是暖场，开源博览会其实就是对一些大家比较喜闻乐见的开源项目，如 Fuchsia OS, GNOME, Wine, Requests, Django 等。</p>
<p>闪电演讲这一活动具体来说就是给一位演讲者限定 5 分钟演讲时间，内容不限。第一天的闪电演讲由于准备不足，有趣的东西不多。</p>
<p>开源辩论会则比较有意思了：辩题正是几天前刚刚发生的微软收购 GitHub 这一热点事件，正反双方的观点分别是这一事件有益/有害。正方的主要观点是：将微软视作洪水猛兽不利于开源界发展，而且引入微软的力量对各种发展也是一大助力；反方的观点则是：微软可能接受审查等等，使 GitHub 失去中立性，不利于保护我们各方面的自由。</p>
<p>稍后的运动交流会小队没有参加，而是选择游览重庆城市夜景（另有文章）。</p>
<h2>Day 2</h2>
<p>主要的活动内容都在6月10日：</p>
<p><span></span></p>
<p>上午，大会召开开幕式，这也是继 Day 1 的预热后，正式的开始，本次活动总召，来自重庆大学 Continue 社区的刘煜民，江湖人称刘贝贝，是一位胖哥哥，在自黑和玩梗之后，他介绍了他创办和运营重庆大学 Continue 社区的故事。他说，社区招人并不在乎现在的能力，而是看此人有没有热情和持续学习下去的动力；社区的活动不只是写代码，也会做其他有趣的事情；社区重视传承，建立学长每年带一年新人的制度；每周一次的分享会也会很有意思，比如：每周活动会固定放映恐怖片（喵喵喵？）。在对社区事业的态度上，他是这样认为的：运营社区最重要的因素是热爱开源事业，并且怀有将这个事情做好的决心。他的这些观点与笔者的很多想法可以说是不谋而合，也可以说是英雄所见略同了。谈及本次大会，他说到：这是第 0 届SOSCON，也是中国大陆地区联合港台姐妹社区、由学生自发组织的开源社区峰会，可谓是开创先河，我们在座的各位其实都见证了历史。</p>
<p>本次大会有一场特殊的分享会：女性专场，其实这主要是传递平权思想的一场专场——女性在技术开发中也是半边天，我们不该再纠结于社会的刻板印象。首先是来自北京邮电大学的代小岱学姐，她在程序“媛”中可谓是女中豪杰了：她曾先后在香港中文大学、微亚研等知名研究机构参与有关计算机视觉、深度学习、无人驾驶等方向的课题研究。在会上，她主要介绍、分析了目前相关研究中的工具框架，如 TensorFlow, PyTorch, Caffe 等的常用场景，并对自己在研究、成长中遇到的问题及解决方法做了分享，她曾提及自己参与的一个计算机视觉项目，有关识别路边灯杆，她遇到的问题就是，模型容易将同样竖直的高楼大厦误识别，影响模型表现；但对此的解决方案并非乱调模型，而是对数据的标记进行了进一步的处理。</p>
<p>回到主会场。</p>
<p>上午，来自中科大的两组同学分别介绍了自己由课程大作业演变过来的项目：利用 Grating Board 实现的裸眼 3D 显示；以及一个 Unikernel 镜像管理工具 CUnik <a href="http://cunik.org">cunik.org</a> ；裸眼 3D 组的同学主要介绍了项目灵感来源以及具体实施；他们强调：想要创造财富，要解决用户关心的问题，而非单纯解决技术问题；一次只使用一个新技术，否则就会陷入 nocode（没有代码只有大饼） 和 nodep(endency) （不依赖已有成果，全都要从 0 开始）的怪圈。CUnik 组的同学主要介绍了 Unikernel 这一技术与虚拟化、容器等技术的区别，同时分析了这一技术没有 Docker 那么流行的原因：学习成本高，相关生态环境不够完善。并（隆重）推出 CUnik ——一个能运行的 <del>BUG</del> Unikernel 构建、打包、管理工具。</p>
<p>中场休息过后，是一场简短的闪电演讲，一位来自台湾大学软体协会的可爱大叔表达了自己对重庆科技、人文发展速度之快的赞叹之情，他就此回忆到当年的艰苦生活；又以U盘（大陆）vs 随身碟（台湾），移动硬盘（大陆）vs 随身碟 （台湾）为例，介绍了海峡两岸的一些差异；他向会场介绍了在台大开展开源社区的经验；最后，他邀请全场参会人员与他同唱 “重庆/台湾是个好地方”，让我们倍感亲切。</p>
<p>接下来，来自中科大（<del>怎么还是他们，下一个我出场了</del>）的同学介绍了 BIOEditor ——一个好用的学术报告编辑器；团队注意到了在生物、物理等学科中，实验报告的编写往往很麻烦：电子版制图困难，手写则过于低效，已有的数字化解决方案在这一应用场景都有各自问题。他们选择用 BEL 标记语言，最终渲染 HTML 、输出 CSS 等。BIOEditor还有许多实用特性，如：自动补全、常用词提示；合作编辑 &amp; 批注、版本管理等。</p>
<p>接下来是商业自吹时间：笔者本人代表 BYRIO 社区上台演讲，题目是：为了创意者——开源社区与精神的拓展和延续。会场反响热烈，拍照不断（<del>逃</del> ，演讲稿、Slides 全文请见：<a href="https://byrio.org/soscon18">byrio.org/soscon18</a></p>
<p>之后，来自重邮的李永健同学，同时也是Linux Story的志愿者、现任重邮硬件技术与应用协会会长，介绍了 Linux Story 这一站点的发展故事；来自重庆大学的高雨彤对开源工场社区进行了一波官方安利，并分享了开源工场的组建成长历程。</p>
<p>午饭过后，来自美国伦斯勒理工大学的马渝泽分享了北美地区的开源教育开展情况，并分享了对于新人培养机制的实践经验。</p>
<p>沉寂5年的安同社区在本次大会上也重返讲台：他们讲述了自己社区的整个历史、黑历史，遇到的挫折以及其中经历的种种转变：原先，这个组织不过是三个初中生的灵感，他们在创立初期跳过很多坑：比如为了炫耀而去做事、组织有层级、成员有压力、做事低效，与外部关系紧张（Linux吧的争吵），后来他们选择闷声发大财，真正地去维护一个开放的社区，踏实地去做事、开发。</p>
<p>演讲稿全文：<a href="https://github.com/MingcongBai/soscon-2018-talk/blob/master/transcript.md">https://github.com/MingcongBai/soscon-2018-talk/blob/master/transcript.md</a></p>
<p>Slides：<a href="https://repo.aosc.io/aosc-documentation/soscon-2018/slide.pdf">https://repo.aosc.io/aosc-documentation/soscon-2018/slide.pdf</a></p>
<p>笔者认为安同社区曾经的黑历史也是很多其他组织的前车之鉴，他们现在的做法则是后来者的学习对象，我们要想明白：社区健康的发展需要我们怎么做？什么才是成熟的做法？社区根本的宗旨是什么？对于这些问题，我自己也在反思自己。</p>
<p>国内开源社区的一哥 TUNA 也进行了题为 Power TUNA 的演讲，详细介绍了社区历史、各种活动、以及大家关心的镜像站相关问题（稿件、Slides 待补充）。</p>
<p>来自台湾大学开源社的小哥姜柏任为我们带来了他的团队在台大学生会联合选举中对投票电子化做出的贡献和项目经验，投票过程中要解决的问题很多：比如一人一票、学生身份的有效性，其中为了解决性能等问题，架构进行过几次修改，同时要解决流程中一系列的痛点难题。小哥搞的事情实在很厉害！Slides详见：<a href="https://speakerdeck.com/rschiang/fantastic-vote-system-and-where-to-find-em">厉害了，我的票！</a></p>
<p>来自西安邮电大学的刘嘉辉<del>大佬</del>同学介绍了自己申请、参加著名的 Google Summer of Code 项目的经历。</p>
<p><a href="https://byrio.org/soscon-18-briefing/">SOSCON 18 前线纪实</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            由重庆大学 Continue 社区举办的第 0 届 SOSCON 大会就这样圆满结束了，作为中国大陆境内首个由学生自发组织举办的开源技术峰会，各路大神、社区的核心人员或分享技术成果，或分享社区经验，可谓是各显神通。这里由BYRIO前线分队为你带来前方报道。 由于两天议程中的内容
            
        </summary>
        
        <category term="活动记录"/>
        
        <category term="SOSCON"/>
        
    </entry>
    
    <entry>
        <title>北邮人 BYRIO 小分队从重庆 SOSCON 18 学生开源年会胜利归来</title>
        <link href="https://byrio.org/soscon-18-after/"/>
        <id>https://byrio.org/soscon-18-after/</id>
        
        <author>
            <name>dimpurr</name>
        </author>
        
        <published>2018-06-10T12:58:36+00:00</published>
        <updated>2018-06-10T12:58:36+00:00</updated>
        
        <content type="html"><![CDATA[<p>今年的 SOSCON 18 学生开源年会由重大 CONTINUE 技术社区在重庆大学成功举办，我们北邮人和 BYRIO 社区也派出小分队参与了活动。</p>
<p>活动 Day2 上午 10:30 ，在位于重大民主湖报告厅的主会场，来自我们 BYRIO 社区的 @LinkAdrifting 聂沫予同学进行了名为「为了创意者——开源社区与精神的拓展和延续」的演讲，讲稿地址位于： <a href="https://byrio.org/soscon18/">https://byrio.org/soscon18/</a> 。讲到「卡巴基佬」的出身时，台下一时洋溢着快活的空气；讲到 Eric S. Raymond 和如何提问时，引起了活动群的热烈讨论；讲到关于如何用「我是游戏设计师」的咒语打破参与开发创造的心理避障时的「单口相声」获得了好评，有人回复：</p>
<blockquote><p>这个好，只要心中有诗，即使吟不出诗，我也已经是一个诗人了<br />
即使不会弹尤克里里，我也觉得自己已经是一个吟游歌手了</p>
<p>by 0x01.me</p>
</blockquote>
<p>另一侧位于重大主教学楼 506 室，于 11:20 开始的女性专场中，我们的代小岱学姐进行了名为「Deep Learning Frameworks’ Tower of Babel」的演讲。学姐目前正在 MSRA 实习，令人敬仰令人敬仰。她介绍了深度学习框架的差异和各自生态及结合，数据科学和机器学习中的一些实践，并在观众提问时回答了获取收费数据集和模型 「调参玄学」的问题。</p>
<p>两位来自北邮的优秀讲者的活动照片如下：</p>
<p><span></span></p>
<div><a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-32.jpg?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-32.jpg?resize=1280%2C720&amp;ssl=1" /></a><p>聂沫予与 BYRIO 社区</p></div>
<div><a href="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-26.jpg?ssl=1"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-26.jpg?resize=1280%2C720&amp;ssl=1" /></a><p>北邮聂沫予「为了创意者——开源社区与精神的拓展和延续」</p></div>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_19-56-07.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_19-56-07.jpg?resize=720%2C1280&amp;ssl=1" /></a><p>聂沫予的演讲信息</p></div>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-39.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-24-39.jpg?resize=720%2C1280&amp;ssl=1" /></a><p>北邮代小岱「Deep Learning Frameworks’ Tower of Babel」</p></div>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-27-11.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-27-11.jpg?resize=1280%2C720&amp;ssl=1" /></a><p>女性专场的听众情况</p></div>
<div><a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-31-13.jpg?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-10_11-31-13.jpg?resize=720%2C1280&amp;ssl=1" /></a><p>代小岱的演讲信息</p></div>
<p>另外值得一提的是， BYRIO 小分队在入住会方提供的青旅住宿时，还遇到了来自成电、青海大学的亲切的小伙伴。为了愉快度过两天共宿时间， BYRIO 社区的 @Dimpurr 同学还在房间的门口贴了一张充满恶趣味的纸条：</p>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-08_20-24-42.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/photo_2018-06-08_20-24-42.jpg?resize=935%2C1280&amp;ssl=1" /></a><p>BYRIO 在 SOSCON 青旅的小纸条</p></div>
<div><a href="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/InkedQQ图片20180610201200_LI.jpg?ssl=1"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/InkedQQ图片20180610201200_LI.jpg?resize=5984%2C3366&amp;ssl=1" /></a><p>最后共宿的大佬们</p></div>
<p>目前，北邮人 BYRIO 小分队已经胜利抵达重庆江北机场，开始回程并即将不得不爆肝准备期末考，以弥补作死准备演讲所花费的时间。让我们感谢并祝福他们。</p>
<p>随后，全程参与了演讲稿修改、制作了直接拉高了当日活动设计水准的超·幻灯演示的 BYRIO 社区吉祥物 @SakuragawaAsaba 同学将会撰写一篇活动后日谈，敬请各位期待。</p>
<p>本次 SOSCON 年会的其他活动和演讲同样非常有趣，欢迎访问大会官网 <a href="http://soscon.top/">http://soscon.top/</a> 、活动直播地址大咖说了解。</p>
<h3>感言</h3>
<blockquote><p>重庆太酷炫太科幻太赛博朋克了！重庆的萝莉太可爱了！逛完重大和南开中学后的感想是：校园大是可以为所欲为的，在公园里修大学是可以为所欲为的。三峡博物馆和 WFC 顶楼观景台都很棒，看完博物馆的梅兰竹菊画作特展后，在洪崖洞咖啡厅就拿 Krita 在 Surface 试画了一幅竹，这很开源。</p>
<p>Dimpurr</p>
<p>两天的周末旅游真的很短暂，但我们忙里偷闲，利用一个白天、两个晚上，还是把主要景点都转了转，重庆是个很有意思的城市。不过更重要的是SOSCON18圆满成功，我的演讲效果也不错，就这样</p>
<p>LinkAdrifting</p>
</blockquote>
<h3>会议记录</h3>
<p>以下是 Dimpurr 在会议过程中的全程 OneNote 笔记，可供参考：</p>
<div><a href="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/QQ图片20180610205715.png?ssl=1"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/QQ图片20180610205715.png?resize=1694%2C10204&amp;ssl=1" /></a><p>Dimpurr 的 SOSCON 18 全程笔记</p></div>
<p><a href="https://byrio.org/soscon-18-after/">北邮人 BYRIO 小分队从重庆 SOSCON 18 学生开源年会胜利归来</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            今年的 SOSCON 18 学生开源年会由重大 CONTINUE 技术社区在重庆大学成功举办，我们北邮人和 BYRIO 社区也派出小分队参与了活动。 活动 Day2 上午 10:30 ，在位于重大民主湖报告厅的主会场，来自我们 BYRIO 社区的 @LinkAdrifting 
            
        </summary>
        
        <category term="活动记录"/>
        
        <category term="SOSCON"/>
        
    </entry>
    
    <entry>
        <title>SOSCON 18 演讲：为了创意者——开源社区与精神的拓展和延续</title>
        <link href="https://byrio.org/soscon18/"/>
        <id>https://byrio.org/soscon18/</id>
        
        <author>
            <name>LinkAdrifting</name>
        </author>
        
        <published>2018-06-10T02:50:05+00:00</published>
        <updated>2018-06-10T02:50:05+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>本文为@LinkAdrifting 在SOSCON 2018大会上的演讲稿全文，感谢 @Dimpurr Cheny ，@SakuragawaAsaba 等人在演讲筹划、改稿、PPT制作过程中的辛勤付出和无数修改建议，是 ta 们的努力使得本次演讲得以取得目前这个令人满意的效果。</p>
<p>BYRIO，为了创意者。</p></blockquote>
<h2>我的故事：身为黑客之痛</h2>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%872/"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片2.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>今天来到 SOSCON 大会的各位黑客们，大家好。可能很多人注意到了：我演讲的标题中写道：为了创意者，这是什么意思？今天的话题不如先从我个人的故事开始。</p>
<p>说来惭愧，我本人的工程开发经验可能不及在座的很多人。我的家庭并没有任何信息技术背景，我的高中学校对这方面几乎没有投入，我自己不知道要点开技术栈：于是你可以看到一个奇葩的我，有着黑客之心，认同黑客的精神与理念，却没有黑客的能力。初中时候我认识了“显卡吧”，自此走上了计算机技术的道路。在当年的百度贴吧中，我也开始了其他许多的硬核爱好，并且走出了贴吧。正如我的朋友这么形容我：“NMY 同学有着广泛的、硬核向和宅向的兴趣，喜欢谈论亚文化、御宅文化、游戏制作幕后、开源社群、硬科幻、摇滚、电子、新浪潮、合成器音乐等等的话题”。但他这段话后面跟着的另一句话，是我整个初中到高中，到大一的一个“诅咒”。他说，<em>“如此突出的个性同样使得他难以找到可以愉快讨论相关话题的小伙伴。”</em>从初中，到高中，我的同学中，能对这些文化、能对计算机技术真正爱好的，0 个。每次我和他们提起这些，他们简直都把我当怪物。</p>
<p>但我考上现在这所以技术氛围着称的大学以后，情况有所改变了吗？一开始并没有。我依旧找不到同好，找不到同类。身边容易见到的人，对于我的兴趣并不感冒，他们也不知道什么自由软件、开发者社区、或者任何在座各位热衷于的活动和组织。</p>
<p>但是这真的意味着我的学校里没有我的“ 同类 ”吗？显然不是。这完全是幸存者偏差：我通过各个琐碎的渠道，比如 QQ 群，一对一的人找人，社团里人际间的口口相传和介绍，才艰难了解到：我的同好其实是不少的！对开发各种东西感兴趣的人是不少的！</p>
<p>校园中的确是有同好的，但我找他们之前都在哪呢？我发现了一个可怕的问题：在我们北邮，学院之间不相往来，年级之间在公开层面上也没有什么往来。对于一个一般学生，我们的社交被严重局限在自己年级的这个圈子。我发现我的同好们也痛苦：他们往往是对自己的兴趣想做深入了解，并取得一些发展的。可是受上述各种制约，这种发展的成本过高；有的人则是没有意识到自己也能在其中做出贡献，他们只是被动地远观别人的创造和分享，而不敢迈出自己的第一步。</p>
<p>​我逐渐遇到了更多与我关注着相同的困难的人，并为此建设了我们自己的社区 – BYRIO ，一个综合性的创意者和开源社区。这也是为何，我今天站在这里为你们分享，我们在此过程中对于开源社区精神的探索，对于如何吸纳新人、延续社区的思考。</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%875/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片5.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>在深入探讨如何解决我们这样的痛苦和问题前，我想先讲讲“我们”——Hacker 是什么。</p>
<p><span></span></p>
<h2>我们为什么要拓展社区</h2>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%876/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片6.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>开头的时候我向大家问好，“各位黑客们”，在座的各位都是 Hacker，等等，谁是 Hacker？我的意思是说：我们怎么判断随便一个人是不是我们的一员呢？我要介绍一个人：Eric S. Raymond。他有很多博文记录了自由软件运动和黑客精神的文化与历史，主要著作有：大教堂与集市、如何成为 Hacker、Hacker 道简史、提问的智慧，这四篇是让我五体投地的神文，尤其是其中提问的智慧已经成为新人必读篇目。他在黑客道简史中做出过如下阐述：</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%878/"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片8.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>前辈黑客们做出过这么多惊天动地的工作和成果。但这些成就的达成不是靠单打独斗，而正是靠团结其他 Hacker，将每个人的才智和创造结合到一起。</p>
<p>但我们也请注意到，他接下来还说：Hacker 的思维模式、精神思想和态度并非是计算机技术意义上独有的。Hacker 的态度无外乎 5 条：</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%879/"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片9.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8710/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片10.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>世界上充满了迷人的问题等待着我们去解决——这是我们选择黑客之道的初心；没有问题应该被解决两次——不要没意义地造轮子；无趣和重复是魔鬼——我们要有趣和新意；自由是好的——不自由是坏的；态度不能替代能力——用能力说话。</p>
<p>​所以Hacker不再是单纯搞技术的了：只要创造并分享，那这个有趣的家伙ta就是个黑客啊。</p>
<p>我之前也提及到了：我不只是在计算机技术上找不到同好，而是在各方面的兴趣上都找不到同好。我不清楚在座的各位有没有这种同感，但在我的视角，这是一种常态。我们的社区正好可以把这些同道中人团结过来，对于我们，不过是举手之劳，但却对这些拥有硬核兴趣的人提供了莫大的帮助。</p>
<p>计算机领域的人的黑客基因是从 DARPANET 时代、usenet 时代这么一脉相承而来的，这就是为什么我们在实践方面是超前的、特殊的，可以看到：在其他领域，比如写作、绘画、音乐以及各种创作，虽然有人意识到黑客精神的重要性，ESR 写出这篇文章也已经 20 年了，但是就我所见，少有开源社区这一形式的组织存在（至少是校园内部）。我们作为先知先觉者有必要去接纳这些和我们持有同样精神的人，因为找不到组织的黑客是痛苦的。传播我们的思想给那些对自由、分享精神毫无概念的人也是一项重要工作。</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8712/"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片12.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>所以，社区可以“不只是技术”。而引入内容与文化多样性，社区将产生怎样的奇妙反应，又能为社区带来什么？</p>
<h2>多样性、外部性和更多的可能</h2>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8713/"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片13.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>我不太清楚各位身边是否有着强大的爱好者社团，但在我的身边，这种组织实际上并没有发挥其应有的作用，这也是上文造成我们这一类人痛苦的根源。实际上BYRIO想做的，是一个我设想中的“创意者社区”。</p>
<p>这种想法的根本来源其实是一个大家可能听说过的网站：机核网。没听说过也没关系，我来做一个简单介绍：这个网站自称“核心游戏媒体”，然而他的网站上，可谓是什么文化内容都有：电影工业、电影史、音乐制作、各国文化历史、还聊吃啥。这种无所不包为它吸引了太多有意思的内容、太多新锐创作者，还获得了无数认同这个社区的追随者。我们的社区是否也能这样海纳百川、百花齐放呢？当然可以了！我们当然也会爱各种各样的东西，我们当然可以很自然地把他们分享出来，分享给社区中的其他人。</p>
<p>这其实也是一种实属无奈的折中办法，我知道各大高校中，能够比较不错地开展活动的应该不少，那么技术社区与这些社团展开各种合作，效果也应该会比现在我们的情况好很多。我希望BYRIO社区中也能孕育出这种组织，乃至在日后独立运行。​</p>
<p>选择像我们这样直接包揽其他领域，或者和其他领域中已有的强大组织合作都是会给我们技术社区带来好处的。黑客就是画家，画家就是黑客。Hacker 是绝对热衷于创作和探索的。当我们热爱技术，热爱开源/自由软件，或者任何你正在投身于的工作的时候，其实正如上面黑客的态度里所说：我们热爱的是解决这世界上无数有趣的问题，是创作与探索。</p>
<p>但这不意味着我们要只走这条路。很多事情光靠技术是做不来的，需要其他领域更加专业的知识和人。比如搭建社区的网站系统，或者要做某个产品解决一个痛点，你会需要设计师、产品经理、提供各种各样素材的创作者。又比如我个人一直心心念念的制作独立游戏这个愿望，则需要更多不同能力的人完成从设计到实现、从可玩到好玩等等各种工作。如果你的社区、圈子里没有各种各样的人，那到时候就只能「人到用时方恨无」。</p>
<p>在自由软件界，我们常常看到的一个现象就是用户抱怨软件不好用或者界面不美观。这就意味着要借助交互设计人员的力量去改良和打磨这些软件——谁说自由软件在易用性、美观性上就该比私有软件差？我们可以通过用心的设计，去触及个人用户。比如 Firefox 浏览器，自由的输入法引擎中州韵 RIME，就连 GNOME 也在其最新版本中增加了很多实用功能，比如触摸板边缘持续拖动。我们还需要用户的不断反馈，使各种问题得到解决、提升用户体验，自由的绘图软件 Krita 在开发者和用户的共同努力下获得了体验上的飞跃，知名网络社区 Reddit 近期的前端设计大改收获不少好评，变得更加现代。这些成果都是有目共睹的。</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8717/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片17.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>因此不能局限社区的发展和定义，个人和社区都一样：前文我已经对黑客的广义定义作了强调。当我们真的想做一件事的时候，总会需要其他领域的知识和人——永远别觉得它离你十万八千里远而拒绝新知识，没有什么是孤立的。我们需要灵感、需要“外部性”，我总是强调外部性：不仅是人员的外部性、知识体系与领域的外部性，也就是已有体系没有，而只能外部吸取的东西。“新鲜血液”指的不一定是人，它还指新的想法、新的知识、新的视角。Linus 有个著名的 Linus 定理：只要有足够多眼睛注视，所有 bug 都会浮现，这有两层解读：一个是群众、社区集体的力量是强大的；第二个是，只要我们引入更多外部性，引来更多的视角和眼睛，一件事情就能向完美和完善更进一步。</p>
<h2>我们如何延续社区和精神</h2>
<p>好话说了这么多，什么：多样性能让我们变得更完美、我们能给硬核爱好者提供一个交流平台之类，可有一个问题是不可忽视的：社区延续问题。我们学生组织延续生存的最大问题就是出现人员断代，工作交接不下去，于是就荒废了，或者退化成少数大佬们的小圈子。</p>
<p>现在普遍存在这么一种论调：大环境不好，没必要接纳新人（因为他们素质都不行），更没必要传播自由思想和黑客精神。一群大佬因为各种经历关系紧密，关起门来搞事情外面谁都不知道。殊不知一个组织不培养新人、让新人接班，那结果肯定是路越走越窄，最终凉凉啊。</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8720/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片20.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>想想看我们现在组队打比赛、或者凑人做项目都是个什么模式：</p>
<ol>
<li>靠人力，到各种群里吼一嗓子招人（但 QQ 群的一大特性就是很快被刷屏，最后还是人找人找不到人，你发公告又有几个人看呢？况且公告功能做的并不好）</li>
<li>勾搭校内宣传大腿，发微博、发公众号（曝光度根本不够，公众号遍地，没几个人天天看）</li>
<li>靠自己人脉圈子（完全碰大运，而且普通人的圈子往往不宽，对非大佬人物极其不友好）</li>
</ol>
<p>看到问题所在了吗？看见一个人，碰大运正好他素质好就抓走了，而不管培养，想抱大佬变强您另谋高就，可问题是根本没有这么个组织！这是典型的只索取而不付出和回报。</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8721/"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片21.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>我还有一种另类的拔萝卜方法，就是参加各种展会靠着老北京侃爷属性（哟，您也是玩游戏/看科幻的！幸会幸会）勾搭别人，比如机核核聚变我偷来几个，QCon 活动当志愿者偷来几个同辈的志愿者，亚太科幻大会又勾搭到两个，日后再尝试寻求合作之类。但总之都不靠谱：这太松散了，简直是草台班子。</p>
<p>事实上，一个健康的社区不只有技术、经验、知识丰富的老人，还一定会有技术、经验、人脉等稍欠的新人。</p>
<p>社区想要延续，没有靠谱的新生力量是绝对不可以的：你毕业了社区给谁运营？你如何确保传火大业得以延续？社区怎么扩大影响力？乃至一些更大的话题：如何宣扬黑客的自由精神？等等等等。但现在很多团队、组织的模式根本就无法扩张、延续，他们干的事情无非是“拔萝卜”，管挖不管种。</p>
<p>他们不培养，我们培养。这是社区的责任，也是自身延续的保证。</p>
<h3>我们如何培养新人</h3>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8722/"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片22.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>新人培养的第一步就是把他们拉进我们的圈子，开始学习和工作。然而我见过太多人，当你好意邀请他的时候他总是婉拒，理由呢？无外乎就是“我是菜鸡，啥都不会，怕拖大佬后腿”，我曾经也差不多这样，这其实不是不想进步，而是没有一个”点火“的过程，他感到害怕。Don‘t Panic! 我最近在读的《游戏设计艺术》和《21天搞定电影剧本》这两本书，都是讲具体创作的，但是它们开篇的时候都提出了这么一个两难的困境，以游戏设计艺术举例：假如只有游戏设计师才能设计游戏，而只有设计游戏才能成为游戏设计师，那岂不是永远迈不出第一步？</p>
<p>我们进行一个类比就是这样：我要进行开发才是开发者，然而不是开发者的我怎么去进行开发？</p>
<p>书中给了我一个绝妙的答案，他让每个读者都念动如下咒语：我是游戏设计师。</p>
<p>什么意思？当你自我怀疑或者受到别人质疑的时候，这么做即可：</p>
<blockquote><p>你是谁？我是游戏设计师。</p>
<p>不，你不是。我<strong>是</strong>游戏设计师</p>
<p>你是哪种设计师？我是<strong>游戏</strong>设计师</p>
<p>你是说你会玩游戏？我是游戏<strong>设计师</strong></p></blockquote>
<p>新人需要一个人去把他们“踹下游泳池”：应该告诉新人，并让他们大胆承认：你是正在创造的Hacker！把他们一脚踢进技术、以及各种其他东西的汪洋大海。</p>
<p>好了，新人被调动起来了，接下来他们怎么成长呢？</p>
<p>对于新人的成长，Eric S. Raymond 曾在 如何成为黑客 一文中给出了一条路线：</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8723/"><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片23.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>仰望大神、追赶大神、与大神同行、看透大师、成为大师。没错，任何一个新人都可以通过这个路径变强；但问题在于成本，如果新人找不到组织，没头苍蝇乱撞，那入门的难度曲线会相当可怕，我们在座的都不知道踩过多少坑对不对。</p>
<p>​我们应当是开放的，包容的，只要你来我们永远欢迎，而不是重复“拔萝卜”，碰大运，发个根本无法留存的消息。也不是搞小圈子，而对于身边、学校中潜在的种子选手拒人千里。</p>
<p>​新人迫切需要这样一个社区，这样一个归属。因此社区的工作是提供一个开放的交流土壤，尤其是降低信息交流的成本，不能让新人遇到困难问题走投无路，也不能让新人像我高中那样找不到组织陷入抑郁，社区能极大改善新人的学习体验，为任何潜在的黑客提供一个平缓上升的通道，不可谓作用不大。</p>
<p>​前一段时间我参加了亚太科幻大会，其中几点来自国内外作家给新人创作者的具体建议我特别印象深刻，我认为稍作转换，就是面向开源社区新人培养具体措施的极佳建议：</p>
<ol>
<li>创作应该从短篇小作品写起而非长篇大制作（就小说来说，写短篇你能大胆尝试各种创意，写长篇你会先把自己吓到，而且得到的锻炼不多），搬到我们软件这里就是从小 gadget、小项目写起，降低学习曲线，而渐进式丰富起技术栈。</li>
<li>创作者应该有同伴压力，在写作界，这是指写作作品要拿给其他作家看，就和当年欧洲诸多作家聚群聚会一样，科研界强调一个同行评议，我们的——请允许我说：创作，也需要创作者同行去评议、改进，这是个互相进步学习的过程，对于个人进步最快。</li>
<li>创作者应该内因（兴趣）驱动，强行做你不喜欢的事情，最终会不了了之：我看到太多人被强塞着做这做那，他自己也痛苦迷惑，教育者也痛苦迷惑，其实这完全是整个学习和实践的“交互过程”缺乏设计、缺乏引导的体现。我们在座的都已经发现了兴趣，也对自己的兴趣有了很深的了解，有所深耕。而很多人还没发现兴趣，发现兴趣其实是很难的，发现兴趣并坚持下去更加需要帮助，而非单打独斗。</li>
</ol>
<p>以上所说的几点：成长路线、信心构建、共同进步、发现兴趣，每一步都是个人难以完成的，需要社区这个大家庭给新人以关怀，这是社区的责任，也是社区延续自己、“传火”的保证。</p>
<h2>BYRIO，一个异类</h2>
<p>我的演讲接近尾声，说了这么多，那我们的实践呢？话题回到我们最开始的问题：BYRIO作为一个新兴社区，我们给自己的定位是怎样的？发展路径呢？大家从我以上的演讲已经能听出一些意思了：</p>
<p>我们是个崇尚自由/开源的技术社区吗？是，也不是，因为，“不只是技术”！</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8726/"><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片26.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p>黑客精神是我们的精神核心，但更关键的是：我们将会将这种思想与精神应用到我们能探索到的所有领域，不只是技术，我们将推荐和发扬 Creative Commons 这一用于艺术/文本内容的协议，正如我们拥护 GPL 那样，因为它是符合我们“Hacker 精神”的。虽然根本上还是立足于计算机技术，但我们将团结起广义上的“创作者”，因为他们也是 Hacker，“画家就是 Hacker，Hacker 就是画家”，我们将海纳百川，这个饼画得真的很大，真的很大，但我们对此是有信心的。</p>
<p>BYRIO 虽然是新兴社区，人员也比较多样，比如我们的社区 alpha 内测群里整个北京学院路高校的人几乎都有（笑，其中不少人还是吃瓜状态，但是在我们创立之前：我们学校没有这样一个组织，能和今天参会的组织对位，我们有强大的专门方向社团，也有不那么强力，退而转为维护小圈子的社团，我们有各种各样性质的学生组织，但是，没有站在更高视角的“开源社区”，没有。</p>
<p>​所以我想借这个舞台对未来、现在、以及过去，所有期待着加入组织的，拥有一颗炽热的黑客之心的人说一句：BYRIO 让你们久等了！（Kept you waiting, huh.）</p>
<p>我的演讲到这里就结束了。日后的还需要各位同学、各个友情社区、SOSCON多多包涵、合作，感谢大家的聆听！谢谢大家！</p>
<p><a href="https://byrio.org/soscon18/%e5%b9%bb%e7%81%af%e7%89%8727/"><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/06/幻灯片27.jpg?resize=960%2C720&amp;ssl=1" /></a></p>
<p><a href="https://byrio.org/soscon18/">SOSCON 18 演讲：为了创意者——开源社区与精神的拓展和延续</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            本文为@LinkAdrifting 在SOSCON 2018大会上的演讲稿全文，感谢 @Dimpurr Cheny ，@SakuragawaAsaba 等人在演讲筹划、改稿、PPT制作过程中的辛勤付出和无数修改建议，是 ta 们的努力使得本次演讲得以取得目前这个令人满意的效果。
            
        </summary>
        
        <category term="活动记录"/>
        
        <category term="SOSCON"/>
        
    </entry>
    
    <entry>
        <title>Fail2ban使用记录</title>
        <link href="https://linkthis.me/2018/06/06/the-note-of-using-fail2ban/"/>
        <id>https://linkthis.me/2018/06/06/the-note-of-using-fail2ban/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>Fail2ban是Python语言开发监控软件，它可以监控系统的日志文件并根据检测到的任何可疑的行为自动触发不同的操作。</p>
</blockquote>

<h3>Fail2ban安装</h3>

<p>可以采用<code>apt</code>直接安装<code>Fail2ban</code>：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>apt <span>install </span>fail2ban
</pre></td></tr></tbody></table></code></pre></div></div>

<p>但是源的版本往往不够新，所以可以通过源码来安装：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>git clone https://github.com/fail2ban/fail2ban.git
<span>cd </span>fail2ban
<span>sudo </span>python setup.py <span>install</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这样会将<code>Fail2ban</code>安装到<code>Python</code>的库目录下，可执行脚本位于<code>/usr/bin</code>，配置文件位于<code>/etc/fail2ban</code>。<br />
需要注意，从源码直接安装时，并没有将<code>Fail2ban</code>自动配置为服务，在<code>Debian</code>下需要执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>cp </span>files/debian-initd /etc/init.d/fail2ban
update-rc.d fail2ban defaults
service fail2ban start
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>apt</code>安装的<code>Fail2ban</code>默认开机启动，手动安装如果需要自行设置：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>update-rc.d fail2ban <span>enable</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果需要对IPv6地址进行匹配，<code>Fail2ban</code>的版本需要大于<code>0.10</code>。<br /></p>

<h3>Fail2ban配置</h3>

<p>为了避免在升级时配置被覆盖，首先复制配置文件：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>cd</span> /etc/fail2ban
<span>cp </span>jail.conf jail.local
</pre></td></tr></tbody></table></code></pre></div></div>

<p>常用的配置参数有：</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>默认值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>filter</td>
      <td> </td>
      <td>jail检测匹配时使用的过滤器名称。过滤器每成功进行一次匹配，对应的jail内的计数器加一</td>
    </tr>
    <tr>
      <td>logpath</td>
      <td>/var/log/messages</td>
      <td>过滤器使用的日志文件的路径</td>
    </tr>
    <tr>
      <td>maxretry</td>
      <td>5</td>
      <td>IP触发操作的匹配次数（即计数器的值）</td>
    </tr>
    <tr>
      <td>findtime</td>
      <td>600 sec</td>
      <td>如果在设置的时间内未找到匹配值，则将计数器置零</td>
    </tr>
    <tr>
      <td>bantime</td>
      <td>600 sec</td>
      <td>IP被禁止的时间。负数为“永久”禁止。</td>
    </tr>
  </tbody>
</table>

<p>一般情况下的完整配置文件如下：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>[</span>DEFAULT]

ignoreip <span>=</span> 127.0.0.1/8 <span>#忽略的IP地址</span>
bantime  <span>=</span> 604800
findtime <span>=</span> 600
maxretry <span>=</span> 5

<span>[</span>sshd]

enabled <span>=</span> <span>true</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这个配置为<code>SSH</code>的配置（如果自行修改过端口，则<strong>必须</strong>指定修改后的端口），其他的配置可以参加<code>jail.conf</code>。如果需要使用，需要将<code>enabled</code>设置为<code>true</code>，并且配置<code>action</code>，指定需要匹配的端口等。<code>loglevel</code>可以设置日志级别，<code>sendmail</code>可以设置邮件提醒。<br /></p>

<h3>Fail2ban常用命令</h3>

<p>显示fail2ban的活动列表：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>fail2ban-client status
Status
|- Number of jail:	1
<span>`</span>- Jail list:	sshd
</pre></td></tr></tbody></table></code></pre></div></div>

<p>显示特定<code>jail</code>的状态：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre>fail2ban-client status sshd
Status <span>for </span>the jail: sshd
|- Filter
|  |- Currently failed:	0
|  |- Total failed:	0
|  <span>`</span>- File list:
<span>`</span>- Actions
   |- Currently banned:	0
   |- Total banned:	0
   <span>`</span>- Banned IP list:
</pre></td></tr></tbody></table></code></pre></div></div>

<p>需要注意，如果停止了<code>Fail2ban</code>服务，那么所有的IP地址都会被解锁。当你重启<code>Fail2ban</code>时，其会在<code>/var/log/auth.log</code>中查找异常的IP地址，如果这些异常地址的产生时间仍然在禁止时间内，那么<code>Fail2ban</code>将会重新禁止这些IP地址。<br /></p>

<blockquote>
  <p>更多用法咕咕当中 &amp;&amp; 一般不会有人踩的坑咕咕当中。<br />
Fial2ban<strong>只能</strong>降低风险，提高安全性。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               Fail2ban是Python语言开发监控软件，它可以监控系统的日志文件并根据检测到的任何可疑的行为自动触发不同的操作。   Fail2ban安装  可以采用apt直接安装Fail2ban：  1 apt install fail2ban   但是源的版本往往不够新，所以
            
        </summary>
        
        <category term="Fial2ban"/>
        
        <category term="Debian"/>
        
        <category term="记录"/>
        
    </entry>
    
    <entry>
        <title>如何入门绘画 (Ver. Volgo)</title>
        <link href="https://byrio.org/how-to-illustrate/"/>
        <id>https://byrio.org/how-to-illustrate/</id>
        
        <author>
            <name>Volgorabgle</name>
        </author>
        
        <published>2018-05-30T09:08:11+00:00</published>
        <updated>2018-05-30T09:08:11+00:00</updated>
        
        <content type="html"><![CDATA[<p>本文分为两部分，前部分是一些工具推荐以及学习资料。后部分介绍我 (@Volgo) 的绘画经历。还请根据喜好酌量食用。</p>
<p><strong>本文适合怎样的人看呢？</strong><br />
这个主要是面向萌新介绍绘画用的，没有考虑过认真写成教材一样的东西，所以应该是入门级别的吧，稍微有自学经验的人应该会对文中大多数观点习以为常。<br />
对于以前完全没有接触过绘画的小白，可以稍微了解下情况，然后根据提供的资料进行学习或深入了解。<br />
对于有自己在画但 get 不到学习方向的，可以看看文中的一些建议。<br />
对于可以独当一面的画师，这篇文章完全是在浪费你的时间，你完全有理由忽略掉这些东西，节省下来几分钟时间去画一张速写或许更有用处。但如果能提出意见的更好，或者能交换一发 QQ 微信， Pixiv ID 的话就再好不过了。<br />
对于看热闹的人，也可以扫一眼前部分，后部分学习资料基本可以忽略了。</p>
<h2>资源推荐</h2>
<h3>书籍</h3>
<p>真的有必要看教材吗？我一直都把漫画直接拿来当教材。</p>
<ul>
<li>《荒木飞吕彦的漫画术》</li>
<li>《快描教室漫画企划讲座》</li>
</ul>
<p>差不多够了，这两本比较经典，可以拿去了解业界作画是个怎样的体验，以及对技术有个大概了解，完全不知道业界情况的小白可以看看，不过画风比较复古，所以像了解业界那些新式作画技巧不是很需要这些。要是已经翻烂各类从入门到精通，XX漫画技法什么的可以直接跳过。都讲的差不多。具体的知识和技巧大多还需要自己实际画的时候去了解。</p>
<p>没事多翻翻知乎：</p>
<ul>
<li><a href="https://www.zhihu.com/answer/109718382">零基础如何学习数位板绘画？</a>、<a href="https://www.zhihu.com/answer/20443862">零基础如何学习数位板绘画？</a>、<a href="https://www.zhihu.com/answer/78830616">零基础如何学习数位板绘画？</a></li>
<li><a href="https://www.zhihu.com/answer/70387505">怎样自学画画？</a></li>
<li><a href="https://www.zhihu.com/answer/41122915">在缺少模特的情况下怎么如何练习速写？</a></li>
</ul>
<p>这几个答案里包含了大部分需要使用的学习资源。</p>
<p>想要指明的是，多思考多感受，原创练习比临摹更能增长技术。<br />
多花时间思考大触的画面表现，考虑自己喜欢怎样的风格想要画出怎样的画面，积累素材，思考别人为什么这么画，这么做很花时间，但是绝对比无脑临摹要好得多。</p>
<p>多逛逛B站，P站，翻翻漫画，看看各类 speed painting 作画过程什么的，了解现在的作画技巧，比你啃上十几本差不多的书去学重复性知识要好很多。<br />
关注你喜欢的作者和你喜欢的圈子，有癖好的可以学我存上十几G的图片留着备用（这个学习用素材需要和其他图片分开，一般来说是用来放能够帮助你学习绘画用的素材，有心的同学可以根据不同类型进行细分之后打包）。</p>
<p>有条件的可以多去墙外世界看看 Youtube 的 speed painting 或者 pixiv 的绘画直播，或者跟老师学一学，效率上是比一个人单打独斗好很多的。（不过前提是你得找到好老师）</p>
<h2>学习路线推荐</h2>
<p><span></span></p>
<p>学习路线之类的完全可以去参考一些有名的培训机构的教学路线，比如曼奇立德。参考 <a href="http://blog.sina.com.cn/s/blog_8c2294c70102x0mm.html">曼奇立德（国内一个比较厉害的CG培训）的招生简章</a> 。</p>
<p>以下，个人方法仅供参考：</p>
<h3>关于临摹</h3>
<p>把握好这些:</p>
<ul>
<li>临摹对象水平可以比自己高一点</li>
<li>不要临摹明显不在一个水平上的画</li>
<li>注意工具，比如你用普通水笔去临摹油画大师的作品是毫无意义的。</li>
<li>每个画师对人体的理解是不也一样的，用心体会。</li>
<li>既然是临摹，那么请提高完成度。</li>
<li>临摹不等于抄，抄的画只要时间够长，谁都能画出厉害的东西。最好的方法是在充分理解作者的画面之后进行重现（形象点就是看一边之后自己画，然后逐步使自己的画接近原作者的画）</li>
</ul>
<h3>关于素描</h3>
<p>虽然是可选学习内容，但素描的一些知识还是很有用的。</p>
<ul>
<li>对整体的把握，绘制多个物体时注意物体之间的空间位置关系</li>
<li>对构图的理解（九宫格与分割线等辅助线使用）</li>
<li>对光影的理解</li>
<li>由粗略到精细的绘画方式（在草图上不断修改以趋近最终效果，水彩，油画，板绘的厚涂都有用到）</li>
<li>光影结构: 光源，高光，灰部，明暗交界线，暗部，反光。</li>
<li>材质对光影分布的影响（比如高光在石膏上是一个面，而在玻璃材质上会分成很多点，每个点反映一个光源）</li>
<li>物体投影</li>
</ul>
<h3>关于线条</h3>
<p>主要就动画和漫画进行讨论：</p>
<ul>
<li>动画一般由多人创作，因此其线条一般都是粗细均匀的。</li>
<li>漫画的个人艺术性比较明显，线条变化较大。</li>
<li>工具上，线条质感会体现在蘸水笔笔尖和板子的压感上。</li>
<li>线条粗细变化和折点练习可以去找一些漫画的线稿去画。临摹，印画都行</li>
<li>怎样让自己的双手不再颤抖？<s>女装吧 </s>拉线吧！（拉线时尽量使线条拉得很长，保持流畅，并且让两条线之间的距离尽量靠近）</li>
<li>具体效果:</li>
</ul>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-17.jpeg?ssl=1" /></p>
<h3>关于基础（人体结构，透视，几何）</h3>
<ul>
<li>完全不懂的建议去买几本教材看，或者网上下载 PDF 版，不建议直接上手伯里曼，找几本简单易懂的打好基础，伯里曼属于高级教程，而且对新人不太友好。</li>
<li>量变引起质变，多画画吧，基础没什么捷径可走。</li>
<li>推荐分块练习，手，脚，耳朵，眼睛，躯体，四肢，分开练习之后在拼一块。</li>
<li>有条件的找模特，没条件的也别麻烦杜甫，照面全身镜自己摆姿势。上面提供的链接里有具体回答。</li>
<li>人体练习一定要全裸的。</li>
<li>AV 对你练习人体没太大帮助。</li>
</ul>
<h2>一些感想</h2>
<p>当初因为无法忍受学素描的无聊，所以没去学。如果进阶绘画的话估计还是要练一练，但是现阶段花几周时间认真画几张应该差不多了。总之，学习素描是可选选项。</p>
<p>另外，基础练习绝对比任何事情都重要，即使是成为画触的大佬们，坚持练习基础的也大有人在。</p>
<p>此外，日常速写比较重要。<br />
学习方法嘛，刚开始可以不太注重美感，把握动态即可，之后基础逐渐起来之后在开始注意美感问题，甚至可以开始画的细一些。<br />
这个过程要注意的主要就是对事物大体构形的理解与把握，人体动态的表现方式，以及透视。进阶一点的可以去关注光影变化，再高级点就可以开始感受色彩是怎么让画面质量起飞了。</p>
<p>基本功练习依照人体零件，手，脚，耳朵，眼睛，面部等等这些东西可以先分开练习，之后再组装到一起去练习。<br />
这个过程要注意的是把握各个角度下，人体会有怎样的透视，注意性别，年龄等对人体骨架的影响，以及重要的肌肉。</p>
<p>线条练习对漫画来说是很重要的，不亚于人体结构。同时也是很枯燥的，所以请做好准备。<br />
这个过程要注意线条的基本功，在什么地方要细线条，什么地方要粗线条，线条的折点，怎么去把握用笔的力度。<br />
如果是纸绘，考虑工具的选择与使用方法。但是作为入门者，你完全可以只靠一支考试用水笔，一支随处可见的铅笔，橡皮，随处可见的作业纸或A4打印用纸，<s>一只杜甫，</s>就可以开始画了。<br />
如果对这些不满足，想要像漫画家一样去画漫画，那你可能会需要：<br />
蓝色彩铅（打草稿，万一没擦净在打印时不会被打印机读到，实在不行可以铅笔代替，但勾完线稿之后要擦干净）<br />
针管笔/蘸水笔/G笔尖蘸水笔/细头毛笔笔刷（勾线，墨水没太多要求，不同笔尖触感不同，但原理类似，有条件的同学可以买来感受一下）<br />
各种尺子，各种橡皮（尺子不要太花哨的，透明最好；橡皮最好选用不易产生橡皮屑的美术专用橡皮）<br />
B3漫画专用原稿纸（漫画画面大小是A4，但原稿纸一般会大上一圈方便扫描、打印和添加备注。）<br />
透明塑料板（这个是我拿来垫手用的，防止出汗弄湿画纸）<br />
以上基本就够了。工具对你技术的影响会有但不会是致命因素，毕竟我这样的水平一根棉签沾色粉就能开始画画。</p>
<p>板绘的话，可以抽空去学习常用的绘画软件，这个不需要你刻意去钻研，完全可以在了解基本工具之后，直接操笔开画，在需要什么功能的时候再去现查就行。可以花时间去玩玩笔刷，照自己喜欢的笔刷，这类资源各种搜索引擎上多的是，不知道怎么选的可以自行知乎。<br />
软件是没有太大区别的，所以选择上，选自己喜欢的就行。<br />
要提醒的是板绘跟纸绘的差别还是很大的，板绘笔触十分光滑，除非你去买专门的贴膜贴在板子上。此外，如果是数位板而不是数位屏的话，你的眼睛跟双手是脱离的，开始需要一段时间去适应。数位板的购买请自行知乎，我用的是intuos pro 2048压感经典款。</p>
<p>个人认为速写练习没有什么必要的规定来制约你怎么画，画什么，总之就是看到什么有意思的东西，有趣的构图，能让你愣住的东西都可以画。（人肉相机 ……）</p>
<p>因为我主要画的是漫画+电脑作画，所以主要提供这方面的参考。</p>
<p>关于漫画的资料是最好找的，你平时喜欢看的漫画就可以，但是如果是想要拿来当练习对象，不要上来就找些用奇淫技巧才画的出的当临摹对象，根据自己的实际能力谨慎选择。（比如，如果我连基本人体结构都画不出来就想去画一个背景丰富，大角度透视，多人物构图的插画或漫画，肯定是因为脑子进水了）</p>
<p>但也不是说必须要去找简单的图去临摹，看个人喜好，画画还是比较自由的。在练习到一定水平的时候可以开始追求完成度了，毕竟你是在临摹不是原创，要尽量保证临摹的完成度，即使这会花很长时间（我一般会花掉6~10小时不间断作画，要是更复杂更高完成度的估计会需要花一星期断断续续的画），画的时候去感受作者的风格，对事物的理解。对人体的理解和透视的理解，你甚至可以在作者的原图上疯狂的画辅助线去理解这些东西，也可以抛开作者的设计，大胆地魔改原画，就像小时候对杜甫做的那样。</p>
<p>我自己就异常喜欢收集漫画分镜，至今手机里还保存着上千张各种漫画的截图（穷人买不起本子）。</p>
<p>素材的积累是十分有必要的，只有见的多才能扩充原创的想象力。<br />
这个不仅限于漫画，可以是任何形式的作品，摄影作品和影视作品都是很好的素材：</p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-3.png?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-15.jpeg?ssl=1" /></p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-16.jpeg?ssl=1" /></p>
<h2>就业方向</h2>
<ul>
<li>漫画家：签约漫画家（定期投稿，收入较稳定，自由度会有一定限制，但收入比较高），自由漫画家（创作自由，但大陆渠道比较窄，收入不稳定，下海风险大），兼职或全职漫画助手</li>
<li>插画家：为小说或漫画绘制插画</li>
<li>原画师：游戏原画师（最吃香的），动画原画师，动画师</li>
<li>设计师：平面设计，插画设计，动漫/游戏美术设计</li>
<li>商业画师：广告设计，商标设计，宣传画等</li>
<li>教育工作者</li>
</ul>
<h2>发展方向</h2>
<ul>
<li>美术生：就读美术专业或研究生</li>
<li>数字媒体设计</li>
<li>交互设计</li>
<li>商业设计师</li>
<li>传统职业艺术家</li>
<li>自由艺术家</li>
</ul>
<h2>面试相关</h2>
<p>在设计行业如果你能拥有优秀的艺术功底，尝尝会收到面试官的青睐，很多设计工作对艺术的要求比你想象中的要多（比如交互设计）。在动画美术，游戏美术设计，漫画 ，平面设计等领域甚至成为必不可少的技能。</p>
<h2>后言</h2>
<p>日常基础练习是必不可少的，不管你在学什么都不会变的一条定理。（如果只是想当作兴趣画画玩的话，可以忽略这个，此外如果工作日比较忙的，可以考虑练习速写，如何练习上面的链接里有说，不过尽量还是抽时间进行基础练习）</p>
<p>绘画跟考试不一样，考试即使一学期都是摸鱼过来也照样能靠一些奇淫技巧或者佛祖大人的大腿考的很好。画画是没有捷径的，按照平均，成为大触至少要5年画龄，成为商业插画师是7年以上级别的。（摆正一个错误的观点，画画靠天赋这种不负责的说法，当成饭后谈资还说的过去，但真正拿去用的时候，是很不正确的观点，绘画的天赋绝大多数表现在审美和色感上，其他的，都是后天的努力）</p>
<p>绘画中审美是最难培养的，很多培训机构都有放出他们的学生作品，但是你照样能一眼分辨出哪些是高级货，哪些只是外表妖艳。</p>
<p>虽然看似跟绘画没什么关系，但从长远考虑，你的身体健康是十分重要的，绘画对身体的损伤不亚于去当码农。与此同时，注意精神能量的重要性，这就是为什么不要去找不符合自己水平的作品去临摹，自信受打击之后的影响很不好。</p>
<p>最后，保持一颗充满好奇与求知的心。</p>
<h2>个人经历</h2>
<p>当初是为什么而开始学画画的？那种理由早就忘的一干二净了。总之依稀记得首次拿起笔的原因是因为学校实在无聊透顶，不知不觉就这样从最初打发时间用的工具，变成现在的兴趣。一晃三载，期间断断续续地画了不少东西，有过一连四十多天爆肝人体结构练习基础的体验，也有好几个月一点画画的欲望的没有的时候，总之就是自己一个人从自学画起。</p>
<p>当初没去正规报名学习的理由我记得是“基础练习太无聊，我想画有趣的东西”。于是导致我现在基础真是弱的不行。</p>
<p>脱离了那一点也不玫瑰色的高中生活之后，基于各种神奇的巧合，时隔一年又拿起画板，觉得只是自己当做兴趣随便画画什么的，感觉并不是自己想要的东西，我想要的东西应该是更加深入的东西。简单来说还是我太菜想学画画。</p>
<p>于是，在综合考虑之下，决定，与其去跟班听课，不如自己动手。于是在自画自学了断断续续的三年之后第一次认真起来对待绘画。</p>
<p>在此之前的技术嘛……上图</p>
<p>护眼+多图警告：</p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file.jpeg?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-1.jpeg?ssl=1" /></p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-2.jpeg?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-3.jpeg?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-4.jpeg?ssl=1" /></p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-5.jpeg?ssl=1" /></p>
<p><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-6.jpeg?ssl=1" /></p>
<p><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-7.jpeg?ssl=1" /></p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-8.jpeg?ssl=1" /></p>
<p>(有原创，有临摹，有魔改，还有画了一半的）</p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-9.jpeg?ssl=1" /></p>
<p>自认为画的最好的一幅。（吹爆伊藤老师!）</p>
<p><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-10.jpeg?ssl=1" /></p>
<p><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file.png?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-1.png?ssl=1" /></p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-11.jpeg?ssl=1" /></p>
<p><img src="https://i0.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-12.jpeg?ssl=1" /></p>
<p>总结来就是:</p>
<ul>
<li>虽然不是小白，但也说不上很厉害。</li>
<li>对人体结构和透视有一定了解，但也仅仅是比咸鱼稍微酸一点，并不熟练</li>
<li>有原创风格，但也不是很厉害</li>
<li>细节上的功夫很欠缺</li>
<li>线条功底上，基础薄弱的弊处凸显出来了。</li>
<li>懒得再列了。</li>
</ul>
<p>于是，在没有专业指导的情况下，自学是有难度的。虽然我到现在保持着“画不好是因为自己太懒”的观点（事实上也就是太懒）。</p>
<p>终于，报了画室。开始认真学画画。</p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-13.jpeg?ssl=1" /></p>
<p>神奇的是，这张画几乎是我用棉签画出来的。感觉有点 …… 总之自己体会吧。</p>
<p>内心懵逼。</p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-14.jpeg?ssl=1" /></p>
<p>第一次用上彩铅，感觉良好。</p>
<p>于是，作为一个沉迷二次元的绘画新人，在一堆水彩/油画大佬中瑟瑟发抖的画室修行开始了。</p>
<p>虽说从开始画画到现在有三年了，但是细数真正在认真画画估计不到一年，细数下来算上摸鱼的画，所有画也不超过500p。</p>
<p>老师: 一天二十张速写</p>
<p>我:</p>
<p><img src="https://i1.wp.com/byrio.org/wp-content/uploads/2018/05/unnamed-file-2.png?ssl=1" /></p>
<p><a href="https://byrio.org/how-to-illustrate/">如何入门绘画 (Ver. Volgo)</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            本文分为两部分，前部分是一些工具推荐以及学习资料。后部分介绍我 (@Volgo) 的绘画经历。还请根据喜好酌量食用。 本文适合怎样的人看呢？ 这个主要是面向萌新介绍绘画用的，没有考虑过认真写成教材一样的东西，所以应该是入门级别的吧，稍微有自学经验的人应该会对文中大多数观点习以为
            
        </summary>
        
        <category term="如何入门"/>
        
    </entry>
    
    <entry>
        <title>首届学生开源年会 SOSCON 将于6月在重庆大学举办，现征集北邮人组队前往</title>
        <link href="https://byrio.org/soscon-18-welcome/"/>
        <id>https://byrio.org/soscon-18-welcome/</id>
        
        <author>
            <name>dimpurr</name>
        </author>
        
        <published>2018-05-22T00:16:11+00:00</published>
        <updated>2018-05-22T00:16:11+00:00</updated>
        
        <content type="html"><![CDATA[<p>现征集北邮对开源技术感兴趣的小伙伴们组队前往 SOSCON 18 学生开源年会，<strong>会方提供住宿，路费还有一定比例报销</strong>哦。</p>
<p>另外，我们<strong>北邮将会有一场以上的演讲名额，讲者报销一半以上往返路费</strong>，有兴趣挑战一下的同学也可进群联系我们，或者通过大会官网自行报名。</p>
<ul>
<li>时间：2018年6月9日、10日</li>
<li>地点：重庆大学A区主教国际会议中心</li>
<li>活动官网：<a href="https://soscon.top/">https://soscon.top/</a></li>
</ul>
<p>感兴趣请扫码加微信群：</p>
<p><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/AB9A9CA06C976C4A5D3CBAB6B0787A0B.jpg?resize=233%2C336&amp;ssl=1" /></p>
<p>官方介绍推送如下：</p>
<h3>学生开源年会</h3>
<p>学生开源年会 ( Students Open Source Conference ) 是中国大陆首个由学生自发组织举办的开源技术峰会，峰会基于开放源代码的理念，每年举办一次，举办地点为在各个城市轮办。峰会的主旨是希望引导和鼓励学生了解、参与、贡献开源；并且在开源项目中，结识更多的朋友，同时也让长期参与开源项目和认同开源理念的同学能够有交流技术、分享经验的机会。</p>
<p>学生开源年会和台湾的 SITCON 以及香港的 SITCON HK为姊妹会议，合为两岸三地华人社区三大学生技术会议。也是中国大陆首个面向学生的开源会议，从讲者到工作人员到听众绝大部分都是学生，享受开源乐趣，参与开源贡献，关于畅想未来这件事情，我们学生更有感觉。</p>
<h3>年会展望</h3>
<p>SOSCON 2018 将于 2018年 6 月9日-10日在火热的重庆举办，来自全国各地的学生届时将齐聚一堂，想必是一场技术与思考的饕餮盛宴！</p>
<p><span></span></p>
<p>我们也希望SOSCON所聚集而成的社群会作为一个长期的舞台，活跃在各地，成为学生交流技术、开放讨论的平台，使得开源理念能够在学生群体中茁壮成长。</p>
<p>会议期间希望学生能积极交流，让学生站上舞台，展示诞生在实验室里的创想，分享蕴含在编码中的激情，畅聊属于开源理念的未来。也期待参会者能继续发挥自己的影响力，让周围更多的人为开源做贡献。</p>
<h3>峰会主旨</h3>
<p>希望引导和鼓励学生了解、参与、贡献开源；并且在开源项目中，结识更多的朋友，同时也让长期参与开源项目和认同开源理念的同学能够有交流技术、分享经验的机会。同时也欢迎到官方网站报名志愿者和演讲者。</p>
<h3>招募志愿者</h3>
<p>希望引导和鼓励学生了解、参与、贡献开源；并且在开源项目中，结识更多的朋友，同时也让长期参与开源项目和认同开源理念的同学能够有交流技术、分享经验的机会。<a href="https://soscon.top/apply">https://soscon.top/apply</a></p>
<h3>开放演讲提交</h3>
<p>所有跟开源有关的话题和议题都是被鼓励的。包括：Linux、编程语言、云计算、人工智能等等；大会采取多轨道方式同时进行，涵盖但不限于以下内容，也非常欢迎随时跟我们分享你的新鲜想法。</p>
<ul>
<li>学生自己做的开源项目分享。（譬如自己做的玩具项目、校园项目）</li>
<li>跟大学计算机、软件、网络相关的课程学习分享，譬如数据结构、操作系统等。（需与开源结合）</li>
<li>前沿领域的开源技术、开源项目分享，譬如最新的人工智能、区块链等。</li>
<li>自己参与的国际开源项目分享，譬如 Linux、GNOME、Python等等。</li>
<li>女性专场。（供女生参与及申请，与开源和计算机、软件相关的话题）</li>
<li>Workshop 工作坊，手把手带你读源代码、带你折腾代码、或者贡献开源项目。</li>
</ul>
<p>演讲者以学生为主，大会同时考虑对优秀的学生讲者进行一定的差旅补助，申请地址 <a href="https://soscon.top/apply">https://soscon.top/apply</a></p>
<h3>征求赞助商</h3>
<p>活动的举行离不开赞助商的支持，欢迎有意支持学生开源发展的公司与我们联络：<a href="mailto:soscon@openingsource.org">soscon@openingsource.org</a></p>
<h3>时间地点</h3>
<p>主办：开源工场<br />
时间：2018年6月9日、10日<br />
地点：重庆大学A区主教国际会议中心<br />
官网：<a href="https://soscon.top/">https://soscon.top</a></p>
<p>蒹葭苍苍，白露为霜；开源工场，在水一方。<br />
欢迎关注学生开源年会，与你不醉不会</p>
<p>电报群：<a href="http://t.me/soscon">http://t.me/soscon</a><br />
QQ群：202790710</p>
<p>Weibo：<a href="http://weibo.com/openingsource">http://weibo.com/openingsource</a><br />
Facebook：<a href="https://facebook.com/openingsource">https://facebook.com/openingsource</a><br />
Twitter：<a href="https://twitter.com/openingsource">https://twitter.com/openingsource</a><br />
Google +：<a href="https://google.com/+OpeningSource">https://google.com/+OpeningSource</a></p>
<div><img src="https://i2.wp.com/byrio.org/wp-content/uploads/2018/05/QQ20180522-0.jpg?resize=523%2C929&amp;ssl=1" /><p>SOSCON AD</p></div>
<p><a href="https://byrio.org/soscon-18-welcome/">首届学生开源年会 SOSCON 将于6月在重庆大学举办，现征集北邮人组队前往</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            现征集北邮对开源技术感兴趣的小伙伴们组队前往 SOSCON 18 学生开源年会，会方提供住宿，路费还有一定比例报销哦。 另外，我们北邮将会有一场以上的演讲名额，讲者报销一半以上往返路费，有兴趣挑战一下的同学也可进群联系我们，或者通过大会官网自行报名。  时间：2018年6月9日
            
        </summary>
        
        <category term="活动记录"/>
        
    </entry>
    
    <entry>
        <title>如何入门前端</title>
        <link href="https://byrio.org/how-to-frontend/"/>
        <id>https://byrio.org/how-to-frontend/</id>
        
        <author>
            <name>dimpurr</name>
        </author>
        
        <published>2018-05-21T00:11:03+00:00</published>
        <updated>2018-05-21T00:11:03+00:00</updated>
        
        <content type="html"><![CDATA[<p>通俗的来说，前端就是「写网页」。稍微严格一点说，前端指的是 Web 开发中，主要与用户所看到的界面打交道的，以 HTML 、 CSS 和 JavaScript 为技术基础的开发方向。</p>
<p>如果你对前端和 Web 开发是怎样的完全没有概念，你可以先从这几篇社区成员创作的，全面记录了整个前端开发流程的小文章感受一下：</p>
<ul>
<li><a href="https://wsq.cool/article/9.html">wsq.cool |  web 负基础入门–把手教你撸出选课系统</a></li>
<li><a href="http://blog.dimpurr.com/yiban-report-17/">校内应用个性化数据年报项目全程吐槽纪实 – 长单页面前端工程与 ECharts 图表可视化 – 钉子の次元</a></li>
</ul>
<p>在这篇文章我们不深入讲解前后端配合的方法和完整的 Web App 开发流程，请期待系列后续文章。</p>
<h2>引言</h2>
<p>在最近的几年里，前端的发展极其迅速： <a href="https://zhuanlan.zhihu.com/p/22782487">在2016 年学 JavaScript 是一种什么样的体验? – 知乎专栏</a> 这篇文章以一位从两三年前「穿越」过来的程序员，和一名 16 年的前端开发者对话的心路历程，展现了前端的技术更新换代之快 —— 写作本文的 2018 年，里面提到的技术和库，又有将近 1/3 已经被替代。</p>
<p>等等，我有没有告诉你 <strong>先不要打开上面这篇文章</strong> ……？如果你被这篇文章中复杂的技术和名词绕晕劝退了，我很抱歉 —— 其实，如果你不以前端开发为自己目标的行业，例如你是希望有自己动手实现漂亮的网页界面的基础能力的设计师，只需要很简单就能入门刚才说到的三门前端基础技术。应该说， HTML 和 CSS 可以说是最简单就能学会的「程序语言」（因为它们甚至实际上不算编程语言）， <strong>实际上几天或者几周的练习足以掌握写出静态页面所需的大部分技术</strong> 。不如说，在网络如此发达的今天，这几乎应该成为每个人必备的基础技能。</p>
<p><span></span></p>
<p>不过另一方面，如果这些名词让你感受到的不是畏惧，而是觉得深奥有趣，兴致勃勃的想要一探究竟 —— 那么恭喜你，你完全可以深入钻研前端，因为 <strong>前端可以说是目前工程开发领域中，诞生新语法、库和标准最快，应用新技术最激进冒险，技术交流最活跃的方向之一</strong> 。如果你浏览了那篇文章，可能留意到了文末一个最形象的例子： Python 3.6 已经发布如此之久，还有许多人在使用陈旧的 Python 2.6 ，而前端工程师们却就因为浏览器对 JavaScript 最新版本 ES6/ES7 兼容支持不住，不能自由的使用各种写起来舒服优雅的新特性，于是干脆搞出了 Babel 配合 Webpack 作为补丁库，把新版本语法的代码编译成旧的以便在老式浏览器运行，这样就可以愉快的玩耍还在测试阶段的新技术啦！</p>
<p>还有不得不提的是，由于使用 JavaScript 语法的 Node.js 服务器脚本语言、基于 HTML5 和 JavaScript 的 Electron 、 React Native 和 Weex 等具有开发桌面端、 Android 和 iOS 本地原生 App 的技术的流行， <strong>从前端开始入门工程开发已经成为了性价比最高的选择，因为意味着你掌握了前端开发，便不只是网页、同时还具有了编写桌面 App 和移动 App 的能力</strong> 。像 Electron 这样的技术最大的特点是「一次编译，多平台运行」，本质上是给一个功能强大的网页 （Web App） 套上了本地应用的壳子，再与浏览器内核捆绑在一起，就能用 Web 前端技术写出能在 Windows 、 macOS 和 Linux 同时运行的桌面应用。如果你使用过微软的 Visual Studio Code 编辑器，可以试试在右上角「关于」菜单打开开发者工具，你会惊奇的发现 —— 这样一个看起来功能复杂的程序，本质上居然是一个网页！</p>
<p>接下来，本文会分前端基础、前端逻辑和前端进阶三个部分讲解，如何入门前端 HTML 、 CSS 和 JavaScript 页面基础并能写出简单的页面，如何入门目前前端开发中最常用的 React Vue Angular 等逻辑库让自己具有真正的前端工程能力，如何进一步深入提高自己的前端技能点。</p>
<h2>如何入门前端基础</h2>
<p>秉承「如何入门」系列文章的宗旨，我们不浪费时间讲授领域的任何具体知识，只「授人以渔」，指出合适的资料和学习的方法。</p>
<p>你只需要清楚：<strong>入门用来编写网页所具有的内容的 HTML （超文本标记语言）、用来给网页添加字体颜色和布局排版和样式的 CSS （层叠样式表）、用来给原本静态的网页文档添加程序计算功能并操控其中元素的 JavaScript 程序语言之后，你就算入门了前端基础</strong>。</p>
<p>具体来说，学习这几门语言，你可以这样做：</p>
<ol>
<li>你可以在 <a href="http://www.w3school.com.cn">W3School</a> 或者 <a href="http://www.runoob.com/">Runoob</a> 网站上找到简明扼要又友好的这几门语言的新手在线入门教程 —— 这是公认最好的中文入门教程。</li>
<li>Mozilla 基金会 (Firefox 火狐浏览器的开发商) 的 <a href="https://developer.mozilla.org/zh-CN/">MDN</a> 网站，如果你有过学习其他程序语言的经验，里面的入门教程非常适合你；或者你在学习过程中想要查找更规范一点的参考资料，也可以在这里直接搜搜。 另外， <a href="https://bonsaiden.github.io/JavaScript-Garden/zh/">「JavaScript 秘密花园」</a> 这份文档总结了简明概要的 JavaScript 核心知识点。</li>
<li>如果你愿意阅读一些前端技术的干货文章， <a href="https://www.w3cplus.com/">W3Plus</a> 这样的前端分享专题网站可以让你进步的更快，或者去 <a href="https://segmentfault.com/frontend">SegmentFault – 前端 专栏</a> 这样的内容聚合网站、哪怕是 <a href="https://www.zhihu.com/topic/19550901">前端 – 知乎话题</a> 都可以。</li>
<li>当然，你也可以选择视频教程、慕课等你喜欢的学习方式。</li>
</ol>
<p>在学习过程中，有这样几个建议：</p>
<ol>
<li>你可以选择几个你觉得好看的网站，利用浏览器调试工具看看他们的源代码，试试自己动手写出一样的界面来，俗称「仿站」，这样会让你练习起来更高效。学到一定程度的时候，你就可以给自己写一个个人主页了 —— 这样会让你更有成就感。</li>
<li>如果你觉得已经多多少少学了一些，又懵懵懂懂不能全部记住，要知道 HTML 和 CSS 并不是一个你需要全部「背下来」的语言：你最重要的是全面的浏览这两门技术所具有的的知识点，知道他们能做什么。<strong>最重要的是，你想实现网页的某个特性的时候，能想起来 HTML 和 CSS 有某个功能特性能解决这个问题，具体怎么写的语法不必死记硬背，用时搜索就行</strong>。</li>
<li>尽管搭建网站和服务器运维并不是前端开发必须学习的内容，但是你可以试试搜索「搭建网站」「搭建个人博客」这样的关键字，自己动手搭建出一个属于自己的网站，再自己写一个好看的界面样式 —— 我个人的推荐是搭建对应的站点，然后从「WordPress 主题」或者「Hexo 主题」入手。这样的过程能极大加深你对 Web 开发和前端的意义的理解，并让自己学到的技术发挥实用功能。</li>
</ol>
<p>简单的学习 JavaScript 后，你应该就能为网页添加简单的动画，或者在网页上写小游戏了。这时候你可以试试一门名为 jQuery 的库，目前来说它并没有过时 —— 这个神奇的库帮你写好了非常多常用功能的函数，可以大大节省你编写 JS 计算、 DOM （文档对象模型，这里指文档元素）操作、 JS 动画的时间。所需的教程，前几个网站也都有。</p>
<p>在进一步深入前，如果你希望你的基础学的更扎实一些，试试看这几本书：</p>
<ul>
<li>「HTML5 秘籍」，讲了 HTML5 版本引入的多媒体播放、动画、 Canvas 画布等新特性，对 HTML 语义化的讲解非常优秀。如何在网页文档中标记有意义的信息，方便 Google 和 Baidu 这样的搜索引擎抓取，如果你在搜索结果中看到某条结果下不只有网页标题和简介，还有星级平衡、子栏目导航等内容，多半是语义化标签的功劳。</li>
<li>「CSS 权威指南」。搞定这本书，你就可以说你算是学会 CSS 了 —— 当然 CSS 的奥秘还有很多。</li>
<li>「JavaScript DOM 编程艺术」、「JavaScript 高级程序开发」和「JavaScript 权威指南」。如果你已经入门基础了，从书面应该看得出这几本书分别在哪个方面深入讲解了。一个不重要的情报，最后一本书俗称犀牛书。</li>
<li>「CSS 禅意花园」。这是 csszengarden.com 出版的官方书籍，介绍了在同一个简单的 HTML 网页中，仅仅是更换 CSS 样式表，能让界面效果变成怎样天差地别的另一个网页。这本书会让你相信 CSS 是万能的。</li>
<li>「CSS 揭秘」。可以搞定面试级别的大量实用 CSS 技巧。</li>
<li><a href="http://es6.ruanyifeng.com/">阮一峰的「ECMAScript 6 入门」</a> 。非常全面的介绍了 JavaScript 的 ES6 新特性和语法。</li>
</ul>
<h2>如何入门前端逻辑</h2>
<p>「前端逻辑」是我生造出来的词，目前似乎还没有特别公认的说法（关键词：「前端视图库」「前端视图逻辑」「前后端分离」），但是应该偏差不远。</p>
<p>光听后面的说明可能感觉「专业」的令人生畏，或者起码让人感受到和前面的前端基础好像天差地别了。其实，首先如果你不打算朝专业道路发展，只希望能在项目中完成前端工作，那么直接入手学习 React 或者 Vue 就好，其他的库都有会 create-react-app 或者 vue-cli 这样一键生成项目的「脚手架」工具帮你搞定。如果你是这样想的，直接跳到后面的 React / Vue / Angular 学习部分。</p>
<h3>前端大环境和生态</h3>
<p>这里我想指的是在最近三四年间诞生和发展的，从前端自动化和工程化库潮流（Gulp， Grunt），前端组件化模块化潮流（WebComponents， CommandJS， AMD，前面几个概念已经过时了，如今是 Webpack， Parcel）、前端异步（Promise， Fetch）和 CSS 预处理器 （SASS， LESS， Stylus） 等潮流，最后围绕 React 、 Vue 或者 Angular 等视图库和 Webpack 打包工具为核心形成的崭新的前端生态。如果你打算深入学习，其实这些技术的本质很简单，无非就是：</p>
<ol>
<li>在前端引入了服务器端语言 Node.js 的各种管理工具 （NPM， Yarn） ，并让前端取代了一部分后端和服务器功能</li>
<li>进一步抽象了 jQuery 中包装过的手动 DOM 操作，变为能自动管理数据更新和前端界面元素显示切换的视图库 （Vue， React，Angular）</li>
<li>把以前需要前端工程师用多个工具手动处理的图片压缩、雪碧图、代码压缩打包和优化等流程，合并到一个统一的管理工具中 (Gulp， Grunt， Webpack， Parcel， cssnext， postcss)</li>
<li>把比较低级的 HTML （Emmet） 和 CSS （SASS， LESS， Stylus） 语法简化，引入更强的计算和函数功能，给 JavaScript 的新标准 ECMAScript6/7 引入兼容性 （Babel），引入变量静态类型等功能 （TypeScript）</li>
<li>由于 Webpack 打包的普及，越来越多专职处理一个问题的专门库，例如负责发送网络请求的 axios 库取代了 jQuery $.ajax() ，也让 jQuery 这种大而全的库不再那么流行</li>
<li>前面所述，出现了让 Web App 打包为 Window， macOS 和 Linux 桌面应用的 Electron ，利用 React 或者 Vue 开发 Android 或者 iOS 移动 App 的 React Native 和 Weex</li>
<li>解决新出现的问题的前后端分离导致的虚拟 API mock 技术，搜索引擎优化的 SSR 服务器端技术，还有不一定只和前端相关的，工程开发所用的代码单元测试 (UnitTest) 和应用自动集成部署 (TravisCI) 技术</li>
</ol>
<p>由上，可以概括出这些变化的来源是，单纯的网页变成了复杂的程序 (Web App) ，前端工程师承担的职责越来越大、工作越来越复杂，所需的工具也越来越高级、流程越来越复杂、低级机械的工作越来越被抽象成库进行简化。</p>
<h3>React / Vue / Angular 学习</h3>
<p>这几门视图库是如今前端工程的核心，来自 Facebook 的 React 和来自 Evan You 的 Vue 基本平分秋色，应该说 React 的生态系统相对更强大一点点，而 Vue 由于是渐进性框架，对新手来说学习曲线更平缓一点点。至于 Google 主推的 Angular 如今市场相对较小，但也可一学。</p>
<p><strong>学习这类库最好的办法是阅读其官方文档提供的 新手教程 (Getting Start) ，导览 (Turtorial) ，官方文档 (Docs) 和手册 (Manual) 。虽然我们完全可以在这里列出，请你自己尝试用搜索引擎找到这几门库的官网及其官方教程文档，中文也可以，如果有条件，英文文档会更好。</strong></p>
<p>在跟着官方文档学习之后，你就可以用实现自己的项目、仿照现有站点或者应用的方式进行练习啦。在这过程中你可能还会接触到许许多多的新名词、新技术和库，那么只需要按着一样的套路：官方文档为主，民间教程为辅，加上练习实战，用到一个学一个，都不会有大的问题。遇到任何问题，合理搜索和适当翻阅文档，你就很可能在 CSDN 、 SegementFault 和 StackOverflow 找到答案，获得新的经验。</p>
<p>总而言之，在学习前端逻辑的过程中， <strong>对前端领域各种技术路线有宏观了解、阅读官方文档进行库的学习、遇到问题时用搜索引擎解决，这几种技能是最核心和无价的</strong> 。</p>
<h2>如何进阶前端</h2>
<p>HTML 游戏开发、 Canvas 、 SPA 单页面应用 …… 我们将会后续更新进一步的内容！</p>
<p><a href="https://byrio.org/how-to-frontend/">如何入门前端</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            通俗的来说，前端就是「写网页」。稍微严格一点说，前端指的是 Web 开发中，主要与用户所看到的界面打交道的，以 HTML 、 CSS 和 JavaScript 为技术基础的开发方向。 如果你对前端和 Web 开发是怎样的完全没有概念，你可以先从这几篇社区成员创作的，全面记录了整
            
        </summary>
        
        <category term="如何入门"/>
        
    </entry>
    
    <entry>
        <title>Debian使用记录</title>
        <link href="https://linkthis.me/2018/05/19/the-note-of-using-debian/"/>
        <id>https://linkthis.me/2018/05/19/the-note-of-using-debian/</id>
        
        <author>
            <name>linkthis</name>
        </author>
        
        <published>2020-03-22T07:23:24+00:00</published>
        <updated>2020-03-22T07:23:24+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote>
  <p>本记录主要对应的是<strong>桌面版</strong>Debian，而且由于系统的特性，本文所叙述之内容只能尽量保证在同一个版本之下的有效性，其它版本系统采用时请多加注意。</p>
</blockquote>

<h3>安装镜像及源选择</h3>

<p>首先安装镜像选择Debian10或以上，因为根据之前的经验，Debian8对UEFI引导支持不佳无法安装GRUB，导致系统无法启动。在选择镜像的时候，可以选择自带固件的非官方镜像，同时为了保证安装的顺利，<strong>最好</strong>不要选择Live CD镜像。<br />
Debian 10已经官方支持<code>Secure Boot</code>，且无需自行配置即可支持大部分电脑，故在安装时无需关闭BIOS的<code>Secure Boot</code>选项。<br />
因为是桌面环境，为避免需要经常编译以保持软件的版本较新，可以使用介于<code>Unstable</code>（不稳定版）和<code>Stable</code>（稳定版）之间的<code>Testing</code>（测试版）源。而如果在选择镜像时选择每周构建版（Weekly-builds）或者每日构建版（Daily-builds），则默认使用<code>Testing</code>源。如果需要使用闭源驱动，则可以在下载镜像时选择非官方版。如果使用的是<code>Stable</code>版，应首先通过<code>apt</code>更新所有已安装的包，然后修改<code>/etc/apt/source.list</code>进行切换：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre>deb http://ftp.cn.debian.org/debian/ testing main
deb-src http://ftp.cn.debian.org/debian/ testing main

deb http://ftp.cn.debian.org/debian/ testing-updates main
deb-src http://ftp.cn.debian.org/debian/ testing-updates main

deb http://security.debian.org/ testing/updates main
deb-src http://security.debian.org/ testing/updates main
</pre></td></tr></tbody></table></code></pre></div></div>

<p>需要注意的是，在某些情况下，Debian可能<strong>没有</strong>在安装结束时<strong>自动</strong>注释排在第一位的CD源，所以在提示需要<code>cdrom</code>时应自行注释对应内容。之后执行如下命令即可：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>sudo </span>apt update
<span>sudo </span>apt upgrade
<span>sudo </span>apt full-upgrade
</pre></td></tr></tbody></table></code></pre></div></div>

<p>之后需要重启计算机，即可完成更新。<br />
如果使用<code>Stable</code>版则建议启用<code>Backports</code>和<code>Stable-Proposed-Updates</code>源以便获取较新的软件：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>deb http://deb.debian.org/debian buster-backports main

deb http://deb.debian.org/debian/ stable-proposed-updates main
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>Stable-Proposed-Updates</code>在更新时的优先级与<code>Stable</code>相同，而如果要使用<code>Backports</code>，则在使用<code>apt</code>时应添加<code>-t</code>参数。<br />
如果安装的是64位系统，默认不开启32位软件的支持，如有需求应执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>dpkg <span>--add-architecture</span> i386
</pre></td></tr></tbody></table></code></pre></div></div>

<h4>Mini.iso安装</h4>

<p>如果想要实现更好的定制化安装，可以使用位于<code>debian/dists/unstable/main/installer-*/current/images/netboot/mini.iso</code>的<code>mini.iso</code>，然后使用高级命令中的<code>专业安装</code>模式，此时可以选择任意三个版本进行安装。<br />
如果选择<code>unstable</code>版本，则安装时可以选择只安装有需要的驱动，并且在安装时即可选择是否启用<code>deb-src</code>。<br />
在安装桌面环境时，推荐跳过，然后在初始安装完成后直接安装<code>gnome-core</code>，然后根据需要安装其它<code>Gnome</code>组件。</p>

<h3>为普通用户添加sudo权限</h3>

<p>如果在安装过程配置了<code>root</code>用户，那么Debian将<strong>不会</strong>自动安装<code>sudo</code>，所以应该首先执行如下操作：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>su root
apt <span>install sudo</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后为在安装时配置的用户添加<code>sudo</code>权限：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>visudo
linkthis <span>ALL</span><span>=(</span>ALL<span>)</span> ALL <span>##在root ALL=(ALL) ALL下方添加</span>
linkthis <span>ALL</span><span>=</span>NOPASSWD:ALL <span>##执行sudo时不需要密码</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>当然也可以直接修改<code>/etc/sudoers</code>文件（如果提示为只读文件，执行<code>chmod +w</code>赋予写权限），或执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>su root
adduser linkthis <span>sudo</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3>启动报错忽略</h3>

<p>在开机时，为防止系统熵过低导致无法在登陆界面进行输入，建议安装<code>Haveged</code>：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>apt <span>install </span>haveged
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在启动时由于部分硬件缺少驱动会导致报错，虽然并不影响系统的正常启动和运行，但是可以选择进行屏蔽，例如<code>TPM</code>；通过<code>dmesg</code>查看的报错内容通常为：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>[</span>    7.167566] tpm_crb MSFT0101:00: <span>[</span>Firmware Bug]: ACPI region does not cover the entire <span>command</span>/response buffer. <span>[</span>mem 0xfed40000-0xfed4087f flags 0x200] vs fed40080f80
<span>[</span>    7.168666] tpm_crb MSFT0101:00: <span>[</span>Firmware Bug]: ACPI region does not cover the entire <span>command</span>/response buffer. <span>[</span>mem 0xfed40000-0xfed4087f flags 0x200] vs fed40080f80
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果不需要使用<code>TPM</code>，应首先在<code>/etc/modprobe.d/</code>内创建一个文件（如<code>tpm-blacklist.conf</code>），然后执行命令获取需屏蔽模块名称：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>lsmod | <span>grep </span>tpm
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后根据列出的模块名称在之前创建的文件内写入如下内容：</p>

<pre><code>blacklist tpm_tis
blacklist tpm_tis_core
blacklist tpm
</code></pre>

<p>最后执行<code>sudo update-initramfs -u</code>完成文件更新。<br /></p>

<h3>修改时区</h3>

<p>Debian可直接执行如下命令修改时间：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>dpkg-reconfigure tzdata
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在完成选择以后系统时间会立即发生改变。<br />
由于Windows和Linux读取时间的方法不一样，所以需要修改RTC时间的时区，命令如下：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>timedatectl set-local-rtc 0 <span>##默认以UTC时区读取RTC时间，而Windows需修改注册表</span>
timedatectl set-local-rtc 1 <span>##以本地时区读取RTC时间，可能会导致麻烦</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>为了保证系统时间的准确，启用NTP网络时间自动同步：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>timedatectl set-ntp <span>true</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>之后可以执行<code>timedatectl  status</code>查看配置状态。<br /></p>

<h3>系统添加中文支持和输入法</h3>

<p>为了避免查非英文字体均为乱码，执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>sudo </span>apt <span>install </span>locales
<span>sudo </span>dpkg-reconfigure locales
</pre></td></tr></tbody></table></code></pre></div></div>

<p>之后<strong>仅</strong>选择<code>zh_CN.UTF-8 UTF-8</code>即可，因为多选择其它<code>CN</code>选项<strong>可能</strong>会造成问题。<br />
为改善字体显示效果安装以下字体：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>apt <span>install </span>fonts-noto-cjk fonts-noto-cjk-extra fonts-hanazono <span>##添加全字重NOTO字体并补全Unicode字符</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后打开控制面板，选择<code>Region &amp; Language</code>，在<code>Language</code>中选择<code>汉语</code>。重新登陆系统，会询问是否将home目录下文件夹的语言也变更为中文，个人建议<code>保留旧的名称</code>。<br />
Gnome默认集成了<code>iBus</code>，其它桌面环境需要执行以下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>apt <span>install </span>ibus ibus-libpinyin <span>##由于ibus-pinyin暂时没有维护，使用ibus-libpinyin替代</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后执行<code>im-config</code>将<code>ibus</code>设为系统默认的输入法框架。之后重启系统，然后在<code>Region &amp; Language</code>中的<code>Input Sources</code>内启用安装的输入法，或者使用<code>ibus-rime</code>等作为输入法。<br /></p>

<h3>安装闭源固件</h3>

<p>由于开源显卡驱动效率太低，替换为Nvidia的闭源驱动，首先对源进行修改：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre>deb http://ftp.jp.debian.org/debian/ testing main contrib non-free
<span>#deb-src http://ftp.jp.debian.org/debian/ stretch main</span>

deb http://security.debian.org/debian-security testing/updates main contrib non-free
<span>#deb-src http://security.debian.org/debian-security stretch/updates main</span>

deb http://ftp.jp.debian.org/debian/ testing-updates main contrib non-free
<span>#deb-src http://ftp.jp.debian.org/debian/ stretch-updates main</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>即在源中增加<code>contrib</code>和<code>non-free</code>，也可以在<code>Software Updates</code>的图形界面内全部勾选完成启用。<br />
然后执行如下命令：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>sudo </span>apt update
<span>sudo </span>apt <span>install </span>nvidia-driver nvidia-xconfig nvidia-smi
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用<code>apt</code>安装时会默认屏蔽开源驱动<code>Nouveau</code>。<br />
在安装即将结束时，<strong>可能</strong>出现<code>firmware</code>警告，这时需要根据缺少的包名安装对应的<code>firmware</code>，如果警告中路径<strong>不含</strong><code>nvidia</code>，则忽略此警告也是可行的。<br />
在安装完成之后，执行如下命令以生成新的<code>/etc/X11/xorg.conf</code>配置文件：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre>nvidia-xconfig
</pre></td></tr></tbody></table></code></pre></div></div>

<p>此配置文件不用修改，但如果发生进入不了图形界面的问题，则应该查看<code>/etc/modrpobe.d</code>下名称中带有<code>blacklist</code>的文件，保证屏蔽命令<strong>存在且只在出现在一个文件内</strong>。如果仍然无法解决问题，可修改或者删除此文件。<br />
由于在BIOS之中<strong>屏蔽</strong>了集成的Intel核显，导致无法通过修改配置文件或者增加<code>GRUB</code>参数达到调节屏幕亮度的目的，需安装额外的软件：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>apt <span>install </span>xbacklight
</pre></td></tr></tbody></table></code></pre></div></div>

<p>之后即可调节屏幕亮度：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre>xbacklight <span>-set</span> 25 <span>##把屏幕亮度调节为25％</span>
xbacklight <span>-inc</span> 5 <span>##增加亮度5％</span>
xbacklight <span>-dec</span> 5 <span>##减少亮度5％</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>如果使用的是<code>LXDE</code>，则可以使用<code>lxrandr</code>。<br />
同时需要注意，因为Debian遵循开源理念，默认<strong>不安装</strong>与CPU厂家对应的微码，如有需求应自行安装<del>不安装就是联发科</del>：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>apt <span>install </span>intel-microcode
</pre></td></tr></tbody></table></code></pre></div></div>

<p>上述所有操作完成之后应重启系统使更改生效。<br /></p>

<h3>更换终端</h3>

<p>Gnome为了切换至Wayland，进行了大量的变更工作<del>进行了坚持不懈的自宫</del>，为了提升使用体验，不使用默认提供的<code>Gnome-terminal</code>，选择使用<code>Tilix</code>：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>sudo </span>apt <span>install </span>tilix
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code>Tilix</code>使用了<code>VTE</code>，但因为各个发行版本的不同，可能导致位于<code>/etc/profile.d/vte.sh</code>的脚本无法正常执行而缺少某些功能，所以需要在<code>.bashrc</code>内添加以下代码：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>if</span> <span>[</span> <span>$TILIX_ID</span> <span>]</span> <span>||</span> <span>[</span> <span>$VTE_VERSION</span> <span>]</span><span>;</span> <span>then
        </span><span>source</span> /etc/profile.d/vte.sh
<span>fi</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>而在Debian上，符号链接可能缺失，需要手动创建：</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>ln</span> <span>-s</span> /etc/profile.d/vte-2.91.sh /etc/profile.d/vte.sh
</pre></td></tr></tbody></table></code></pre></div></div>

<p>当然也可以直接选中配置文件内<code>Command</code>选项下的<code>Run command as a login shell</code>。<br /></p>

<blockquote>
  <p>本文的目的只是对Debian使用过程中的一些配置行汇总，所以可能不会适用于所有人。如果发生了什么错误，我也没有什么办法，如果你有更好的解决方案也请在下面留言。<br />
持续更新。<br />
本文采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.en" target="_blank">CC BY-NC-ND 4.0</a>许可协议进行许可，转载请注明出处。<br /></p>
</blockquote>

<p>本文最后更新时间为：2020-03-22-Sunday-03:23:24 PM</p>]]></content>
        
        <summary type="html">
            
               本记录主要对应的是桌面版Debian，而且由于系统的特性，本文所叙述之内容只能尽量保证在同一个版本之下的有效性，其它版本系统采用时请多加注意。   安装镜像及源选择  首先安装镜像选择Debian10或以上，因为根据之前的经验，Debian8对UEFI引导支持不佳无法安装
            
        </summary>
        
        <category term="Debian"/>
        
        <category term="记录"/>
        
    </entry>
    
    <entry>
        <title>基于Koa2开发微信二维码扫码支付相关流程</title>
        <link href="https://molunerfinn.com/koa2-wechatpay/"/>
        <id>https://molunerfinn.com/koa2-wechatpay/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。</p><blockquote><p><strong>注</strong>： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法开发的。若无相应权限，本文不推荐阅读。</p></blockquote><a></a><h2><a href="https://molunerfinn.com/koa2-wechatpay/#两种模式"></a>两种模式</h2><p>打开微信支付的文档，我们可以看到两种支付模式：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4" target="_blank">模式一</a>和<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5" target="_blank">模式二</a>。这二者的流程图微信的文档里都给出了（不过说实话画得真的有点丑）。</p><p>文档里指出了二者的区别：</p><blockquote><p>模式一开发前，商户必须在公众平台后台设置支付回调URL。URL实现的功能：接收用户扫码后微信支付系统回调的productid和openid。</p></blockquote><blockquote><p>模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url，商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。注意：code_url有效期为2小时，过期后扫码不能再发起支付。</p></blockquote><p>模式一是我们平时在网购的时候比较常见的，会弹出一个专门的页面用于扫码支付，然后支付成功后这个页面会再次跳转回回调页面，通知你支付成功。第二种的话想对少一些，不过第二种开发起来相对简单点。<strong>本文主要介绍模式二的开发</strong>。</p><h2><a href="https://molunerfinn.com/koa2-wechatpay/#搭建Koa2的简单开发环境"></a>搭建Koa2的简单开发环境</h2><p>快速搭建Koa2的开发环境我推荐可以使用<a href="https://github.com/17koa/koa-generator" target="_blank">koa-generator</a>。脚手架能帮我们省去Koa项目一开始的一些基本中间件的书写步骤。（如果你想学习Koa最好自己搭建一个。如果你已经会Koa了就可以使用一些快速脚手架了。）</p><p>首先全局安装<code>koa-generator</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>npm install -g koa-generator</span><br /><span></span><br /><span><span>#or</span></span><br /><span></span><br /><span>yarn global add koa-generator</span><br /></pre></td></tr></table><p>然后找一个目录用来存放Koa项目，我们打算给这个项目取个名字叫做<code>koa-wechatpay</code>，然后就可以输入<code>koa2 koa-wechatpay</code>。然后脚手架会自动创建相应文件夹<code>koa-wechatpay</code>，并生成基本骨架。进入这个文件夹，安装相应的插件。输入：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>npm install</span><br /><span></span><br /><span><span>#or</span></span><br /><span></span><br /><span>yarn</span><br /></pre></td></tr></table><p>接着你可以输入<code>npm start</code> 或者 <code>yarn start</code>来运行项目（默认监听在3000端口）。</p><p>如果不出意外，你的项目跑起来了，然后我们用postman测试一下：</p><blockquote><p>这条路由是在<code>routes/index.js</code>里。</p></blockquote><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1frc14ddfn9j21iq0r2n0p.jpg" /></p><p>如果你看到了</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>{</span><br /><span>  <span>"title"</span>: <span>"koa2 json"</span></span><br /><span>}</span><br /></pre></td></tr></table><p>就说明没问题。（如果有问题，检查一下是不是端口被占用了等等。）</p><p>接下来在<code>routes</code>文件夹里我们新建一个<code>wechatpay.js</code>的文件用来书写我们的流程。</p><h2><a href="https://molunerfinn.com/koa2-wechatpay/#签名"></a>签名</h2><p>跟微信的服务器交流很关键的一环是签名必须正确，如果签名不正确，那么一切都白搭。</p><p>首先我们需要去公众号的后台获取我们所需要的如下相应的id或者key的信息。其中<code>notify_url</code>和<code>server_ip</code>是用于当我们支付成功后，微信会主动往这个url<code>post</code>支付成功的信息。</p><p>签名算法如下：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3" target="_blank">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3</a></p><p>为了签名正确，我们需要安装一下<code>md5</code>。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>npm install md5 --save</span><br /><span></span><br /><span><span>#or</span></span><br /><span></span><br /><span>yarn add md5</span><br /></pre></td></tr></table><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>const</span> md5 = <span>require</span>(<span>'md5'</span>)</span><br /><span><span>const</span> appid = <span>'xxx'</span></span><br /><span><span>const</span> mch_id = <span>'yyy'</span></span><br /><span><span>const</span> mch_api_key = <span>'zzz'</span></span><br /><span><span>const</span> notify_url = <span>'http://xxx/api/notify'</span> <span>// 服务端可访问的域名和接口</span></span><br /><span><span>const</span> server_ip = <span>'xx.xx.xx.xx'</span> <span>// 服务端的ip地址</span></span><br /><span><span>const</span> trade_type = <span>'NATIVE'</span> <span>// NATIVE对应的是二维码扫码支付</span></span><br /><span><span>let</span> body = <span>'XXX的充值支付'</span> <span>// 用于显示在支付界面的提示词</span></span><br /></pre></td></tr></table><p>然后开始写签名函数：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>const</span> signString = <span>(<span>fee, ip, nonce</span>) =&gt;</span> {</span><br /><span>  <span>let</span> tempString = <span>`appid=<span>${appid}</span>&amp;body=<span>${body}</span>&amp;mch_id=<span>${mch_id}</span>&amp;nonce_str=<span>${nonce}</span>&amp;notify_url=<span>${notify_url}</span>&amp;out_trade_no=<span>${nonce}</span>&amp;spbill_create_ip=<span>${ip}</span>&amp;total_fee=<span>${fee}</span>&amp;trade_type=<span>${trade_type}</span>&amp;key=<span>${mch_api_key}</span>`</span></span><br /><span>  <span>return</span> md5(tempString).toUpperCase()</span><br /><span>}</span><br /></pre></td></tr></table><p>其中<code>fee</code>是要充值的费用，以分为单位。比如要充值1块钱，<code>fee</code>就是100。ip是个比较随意的选项，只要符合规则的ip经过测试都是可以的，下文里我用的是<code>server_ip</code>。<code>nonce</code>就是微信要求的不重复的32位以内的字符串，通常可以使用订单号等唯一标识的字符串。</p><p>由于跟微信的服务器交流都是用xml来交流，所以现在我们要手动组装一下post请求的<code>xml</code>:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /></pre></td><td><pre><span><span>const</span> xmlBody = <span>(<span>fee, nonce_str</span>) =&gt;</span> {</span><br /><span>  <span>const</span> xml = <span>`</span></span><br /><span><span>    &lt;xml&gt;</span></span><br /><span><span>    &lt;appid&gt;<span>${appid}</span>&lt;/appid&gt;</span></span><br /><span><span>    &lt;body&gt;<span>${body}</span>&lt;/body&gt;</span></span><br /><span><span>    &lt;mch_id&gt;<span>${mch_id}</span>&lt;/mch_id&gt;</span></span><br /><span><span>    &lt;nonce_str&gt;<span>${nonce_str}</span>&lt;/nonce_str&gt;</span></span><br /><span><span>    &lt;notify_url&gt;<span>${notify_url}</span>&lt;/notify_url&gt;</span></span><br /><span><span>    &lt;out_trade_no&gt;<span>${nonce_str}</span>&lt;/out_trade_no&gt;</span></span><br /><span><span>    &lt;total_fee&gt;<span>${fee}</span>&lt;/total_fee&gt;</span></span><br /><span><span>    &lt;spbill_create_ip&gt;<span>${server_ip}</span>&lt;/spbill_create_ip&gt;</span></span><br /><span><span>    &lt;trade_type&gt;NATIVE&lt;/trade_type&gt;</span></span><br /><span><span>    &lt;sign&gt;<span>${signString(fee, server_ip, nonce_str)}</span>&lt;/sign&gt;</span></span><br /><span><span>    &lt;/xml&gt;</span></span><br /><span><span>  `</span></span><br /><span>  <span>return</span> {</span><br /><span>    xml,</span><br /><span>    out_trade_no: nonce_str</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><blockquote><p>如果你怕自己的签名的<code>xml</code>串有问题，可以提前在微信提供的<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1" target="_blank">签名校验工具</a>里先校验一遍，看看是否能通过。</p></blockquote><h2><a href="https://molunerfinn.com/koa2-wechatpay/#发送请求"></a>发送请求</h2><p>因为需要跟微信服务端发请求，所以我选择了<code>axios</code>这个在浏览器端和node端都能发起ajax请求的库。</p><p>安装过程不再赘述。继续在<code>wechatpay.js</code>写发请求的逻辑。</p><p>由于微信给我们返回的也将是一个xml格式的字符串。所以我们需要预先写好解析函数，将xml解析成js对象。为此你可以安装一个<a href="https://github.com/Leonidas-from-XIV/node-xml2js" target="_blank">xml2js</a>。安装过程跟上面的类似，不再赘述。</p><p>微信会给我们返回一个诸如下面格式的<code>xml</code>字符串：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>&lt;<span>xml</span>&gt;</span><span>&lt;<span>return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span>&lt;/<span>return_code</span>&gt;</span></span><br /><span><span>&lt;<span>return_msg</span>&gt;</span>&lt;![CDATA[OK]]&gt;<span>&lt;/<span>return_msg</span>&gt;</span></span><br /><span><span>&lt;<span>appid</span>&gt;</span>&lt;![CDATA[wx742xxxxxxxxxxxxx]]&gt;<span>&lt;/<span>appid</span>&gt;</span></span><br /><span><span>&lt;<span>mch_id</span>&gt;</span>&lt;![CDATA[14899xxxxx]]&gt;<span>&lt;/<span>mch_id</span>&gt;</span></span><br /><span><span>&lt;<span>nonce_str</span>&gt;</span>&lt;![CDATA[R69QXXXXXXXX6O]]&gt;<span>&lt;/<span>nonce_str</span>&gt;</span></span><br /><span><span>&lt;<span>sign</span>&gt;</span>&lt;![CDATA[79F0891XXXXXX189507A184XXXXXXXXX]]&gt;<span>&lt;/<span>sign</span>&gt;</span></span><br /><span><span>&lt;<span>result_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span>&lt;/<span>result_code</span>&gt;</span></span><br /><span><span>&lt;<span>prepay_id</span>&gt;</span>&lt;![CDATA[wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx]]&gt;<span>&lt;/<span>prepay_id</span>&gt;</span></span><br /><span><span>&lt;<span>trade_type</span>&gt;</span>&lt;![CDATA[NATIVE]]&gt;<span>&lt;/<span>trade_type</span>&gt;</span></span><br /><span><span>&lt;<span>code_url</span>&gt;</span>&lt;![CDATA[weixin://wxpay/xxxurl?pr=dQNakHH]]&gt;<span>&lt;/<span>code_url</span>&gt;</span></span><br /><span><span>&lt;/<span>xml</span>&gt;</span></span><br /></pre></td></tr></table><p>我们的目标是转为如下的js对象，好让我们用js来操作数据：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span>{</span><br /><span>  return_code: <span>'SUCCESS'</span>, <span>// SUCCESS 或者 FAIL</span></span><br /><span>  return_msg: <span>'OK'</span>,</span><br /><span>  appid: <span>'wx742xxxxxxxxxxxxx'</span>,</span><br /><span>  mch_id: <span>'14899xxxxx'</span>,</span><br /><span>  nonce_str: <span>'R69QXXXXXXXX6O'</span>,</span><br /><span>  sign: <span>'79F0891XXXXXX189507A184XXXXXXXXX'</span>,</span><br /><span>  result_code: <span>'SUCCESS'</span>,</span><br /><span>  prepay_id: <span>'wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>,</span><br /><span>  trade_type: <span>'NATIVE'</span>,</span><br /><span>  code_url: <span>'weixin://wxpay/xxxurl?pr=dQNakHH'</span> <span>// 用于生成支付二维码的链接</span></span><br /><span>}</span><br /></pre></td></tr></table><p>于是我们写一个函数，调用<code>xml2js</code>来解析xml：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span><span>// 将XML转为JS对象</span></span><br /><span><span>const</span> parseXML = <span>(<span>xml</span>) =&gt;</span> {</span><br /><span>  <span>return</span> <span>new</span> <span>Promise</span>(<span>(<span>res, rej</span>) =&gt;</span> {</span><br /><span>    xml2js.parseString(xml, {<span>trim</span>: <span>true</span>, <span>explicitArray</span>: <span>false</span>}, (err, json) =&gt; {</span><br /><span>      <span>if</span> (err) {</span><br /><span>        rej(err)</span><br /><span>      } <span>else</span> {</span><br /><span>        res(json.xml)</span><br /><span>      }</span><br /><span>    })</span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>上面的代码返回了一个<code>Promise</code>对象，因为<code>xml2js</code>的操作是在回调函数里返回的结果，所以为了配合Koa2的<code>async</code>、<code>await</code>，我们可以将其封装成一个<code>Promise</code>对象，将解析完的结果通过<code>resolve</code>返回回去。这样就能用<code>await</code>来取数据了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /></pre></td><td><pre><span><span>const</span> axios = <span>require</span>(<span>'axios'</span>)</span><br /><span><span>const</span> url = <span>'https://api.mch.weixin.qq.com/pay/unifiedorder'</span> <span>// 微信服务端地址</span></span><br /><span><span>const</span> pay = <span>async</span> (ctx) =&gt; {</span><br /><span>  <span>const</span> form = ctx.request.body <span>// 通过前端传来的数据</span></span><br /><span></span><br /><span>  <span>const</span> orderNo = <span>'XXXXXXXXXXXXXXXX'</span> <span>// 不重复的订单号</span></span><br /><span>  <span>const</span> fee = form.fee <span>// 通过前端传来的费用值</span></span><br /><span></span><br /><span>  <span>const</span> data = xmlBody(fee, orderNo) <span>// fee是费用，orderNo是订单号（唯一）</span></span><br /><span>  <span>const</span> res = <span>await</span> axios.post(url, {</span><br /><span>    data: data.xml</span><br /><span>  }).then(<span>async</span> res =&gt; {</span><br /><span>    <span>const</span> resJson = <span>await</span> parseXML(res.data)</span><br /><span>    <span>return</span> resJson <span>// 拿到返回的数据</span></span><br /><span>  }).catch(<span><span>err</span> =&gt;</span> {</span><br /><span>    <span>console</span>.log(err)</span><br /><span>  })</span><br /><span>  <span>if</span> (res.return_code === <span>'SUCCESS'</span>) { <span>// 如果返回的</span></span><br /><span>    <span>return</span> ctx.body = {</span><br /><span>      success: <span>true</span>,</span><br /><span>      message: <span>'请求成功'</span>,</span><br /><span>      code_url: res.code_url, <span>// code_url就是用于生成支付二维码的链接</span></span><br /><span>      order_no: orderNo <span>// 订单号</span></span><br /><span>    }</span><br /><span>  }</span><br /><span>  ctx.body = {</span><br /><span>    success: <span>false</span>,</span><br /><span>    message: <span>'请求失败'</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span>router.post(<span>'/api/pay'</span>, pay)</span><br /><span></span><br /><span><span>module</span>.exports = router</span><br /></pre></td></tr></table><p>然后我们要将这个router挂载到根目录的<code>app.js</code>里去。</p><p>找到之前默认的两个路由，一个<code>index</code>，一个<code>user</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>const</span> index = <span>require</span>(<span>'./routes/index'</span>)</span><br /><span><span>const</span> users = <span>require</span>(<span>'./routes/users'</span>)</span><br /><span><span>const</span> wechatpay = <span>require</span>(<span>'./routes/wechatpay'</span>) <span>// 加在这里</span></span><br /></pre></td></tr></table><p>然后到页面底下挂载这个路由：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span>// routes</span></span><br /><span>app.use(index.routes(), index.allowedMethods())</span><br /><span>app.use(users.routes(), users.allowedMethods())</span><br /><span>app.use(wechatpay.routes(), users.allowedMethods()) <span>// 加在这里</span></span><br /></pre></td></tr></table><p>于是你就可以通过发送<code>/api/pay</code>来请求二维码数据啦。（如果有跨域需要自己考虑解决跨域方案，可以跟Koa放在同域里，也可以开一层proxy来转发，也可以开CORS头等等）</p><p><strong>注意</strong>， 本例里是用前端来生成二维码，其实也可以通过后端生成二维码，然后再返回给前端。不过为了简易演示，本例采用前端通过获取<code>code_url</code>后，在前端生成二维码。</p><h2><a href="https://molunerfinn.com/koa2-wechatpay/#展示支付二维码"></a>展示支付二维码</h2><p>前端我用的是<code>Vue</code>，当然你可以选择你喜欢的前端框架。这里关注点在于通过拿到刚才后端传过来的<code>code_url</code>来生成二维码。</p><p>在前端，我使用的是<a href="https://github.com/xkeshi/vue-qrcode" target="_blank">@xkeshi/vue-qrcode</a>这个库来生成二维码。它调用特别简单：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>import</span> VueQrcode <span>from</span> <span>'@xkeshi/vue-qrcode'</span></span><br /><span><span>export</span> <span>default</span> {</span><br /><span>  components: {</span><br /><span>    VueQrcode</span><br /><span>  },</span><br /><span>  <span>// ...其他代码</span></span><br /><span>}</span><br /></pre></td></tr></table><p>然后就可以在前端里用<code>&lt;vue-qrcode&gt;</code>的组件来生成二维码了：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span><span>&lt;<span>vue-qrcode</span> <span>:value</span>=<span>"codeUrl"</span> <span>:options</span>=<span>"{ size: 200 }"</span>&gt;</span></span><br /></pre></td></tr></table><p>放到Dialog里就是这样的效果：</p><blockquote><p>文本是我自己添加的</p></blockquote><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/wechat-pay.png" /></p><h2><a href="https://molunerfinn.com/koa2-wechatpay/#付款成功自动刷新页面"></a>付款成功自动刷新页面</h2><p>有两种将支付成功写入数据库的办法。</p><p>一种是在打开了扫码对话框后，不停向微信服务端轮询支付结果，如果支付成功，那么就向后端发起请求，告诉后端支付成功，让后端写入数据库。</p><p>一种是后端一直开着接口，等微信主动给后端的<code>notify_url</code>发起post请求，告诉后端支付结果，让后端写入数据库。然后此时前端向后端轮询的时候应该是去数据库取轮询该订单的支付结果，如果支付成功就关闭Dialog。</p><p>第一种比较简单但是不安全：试想万一用户支付成功的同时关闭了页面，或者用户支付成功了，但是网络有问题导致前端没法往后端发支付成功的结果，那么后端就一直没办法写入支付成功的数据。</p><p>第二种虽然麻烦，但是保证了安全。所有的支付结果都必须等微信主动向后端通知，后端存完数据库后再返回给前端消息。这样哪怕用户支付成功的同时关闭了页面，下次再打开的时候，由于数据库已经写入了，所以拿到的也是支付成功的结果。</p><p>所以<code>付款成功自动刷新页面</code>这个部分我们分为两个部分来说：</p><h3><a href="https://molunerfinn.com/koa2-wechatpay/#前端部分"></a>前端部分</h3><p>Vue的data部分<br /></p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span>data: {</span><br /><span>  payStatus: <span>false</span>, <span>// 未支付成功</span></span><br /><span>  retryCount: <span>0</span>, <span>// 轮询次数，从0-200</span></span><br /><span>  orderNo: <span>'xxx'</span>, <span>// 从后端传来的order_no</span></span><br /><span>  codeUrl: <span>'xxx'</span> <span>// 从后端传来的code_url</span></span><br /><span>}</span><br /></pre></td></tr></table><p></p><p>在methods里写一个查询订单信息的方法：<br /></p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /></pre></td><td><pre><span></span><br /><span><span>// ...</span></span><br /><span></span><br /><span>handleCheckBill () {</span><br /><span>  <span>return</span> setTimeout(<span><span>()</span> =&gt;</span> {</span><br /><span>    <span>if</span> (!<span>this</span>.payStatus &amp;&amp; <span>this</span>.retryCount &lt; <span>120</span>) {</span><br /><span>      <span>this</span>.retryCount += <span>1</span></span><br /><span>      axios.post(<span>'/api/check-bill'</span>, { <span>// 向后端请求订单支付信息</span></span><br /><span>        orderNo: <span>this</span>.orderNo</span><br /><span>      })</span><br /><span>        .then(<span><span>res</span> =&gt;</span> {</span><br /><span>          <span>if</span> (res.data.success) {</span><br /><span>            <span>this</span>.payStatus = <span>true</span></span><br /><span>            location.reload() <span>// 偷懒就用reload重新刷新页面</span></span><br /><span>          } <span>else</span> {</span><br /><span>            <span>this</span>.handleCheckBill()</span><br /><span>          }</span><br /><span>        }).catch(<span><span>err</span> =&gt;</span> {</span><br /><span>          <span>console</span>.log(err)</span><br /><span>        })</span><br /><span>    } <span>else</span> {</span><br /><span>      location.reload()</span><br /><span>    }</span><br /><span>  }, <span>1000</span>)</span><br /><span>}</span><br /></pre></td></tr></table><p></p><p>在打开二维码Dialog的时候，这个方法就启用了。然后就开始轮询。我订了一个时间，200s后如果还是没有付款信息也自动刷新页面。实际上你可以自己根据项目的需要来定义这个时间。</p><h3><a href="https://molunerfinn.com/koa2-wechatpay/#后端部分"></a>后端部分</h3><p>前端到后端只有一个接口，但是后端有两个接口。一个是用来接收微信的推送，一个是用来接收前端的查询请求。</p><p>先来写最关键的微信的推送请求处理。由于我们接收微信的请求是在Koa的路由里，并且是以流的形式传输的。需要让Koa支持解析xml格式的body，所以需要安装一个<a href="https://github.com/stream-utils/raw-body" target="_blank">rawbody</a>来获取xml格式的body。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /></pre></td><td><pre><span><span>// 处理微信支付回传notify</span></span><br /><span><span>// 如果收到消息要跟微信回传是否接收到</span></span><br /><span><span>const</span> handleNotify = <span>async</span> (ctx) =&gt; {</span><br /><span>  <span>const</span> xml = <span>await</span> rawbody(ctx.req, {</span><br /><span>    length: ctx.request.length,</span><br /><span>    limit: <span>'1mb'</span>,</span><br /><span>    encoding: ctx.request.charset || <span>'utf-8'</span></span><br /><span>  })</span><br /><span></span><br /><span>  <span>const</span> res = <span>await</span> parseXML(xml) <span>// 解析xml</span></span><br /><span></span><br /><span>  <span>if</span> (res.return_code === <span>'SUCCESS'</span>) {</span><br /><span>    <span>if</span> (res.result_code === <span>'SUCCESS'</span>) { <span>// 如果都为SUCCESS代表支付成功</span></span><br /><span>      <span>// ... 这里是写入数据库的相关操作</span></span><br /><span></span><br /><span>      <span>// 开始回传微信</span></span><br /><span>      ctx.type = <span>'application/xml'</span> <span>// 指定发送的请求类型是xml</span></span><br /><span>      <span>// 回传微信，告诉已经收到</span></span><br /><span>      <span>return</span> ctx.body = <span>`&lt;xml&gt;</span></span><br /><span><span>        &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;</span></span><br /><span><span>        &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br /><span><span>      &lt;/xml&gt;</span></span><br /><span><span>      `</span></span><br /><span>    }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>// 如果支付失败，也回传微信</span></span><br /><span>  ctx.status = <span>400</span></span><br /><span>  ctx.type = <span>'application/xml'</span></span><br /><span>  ctx.body = <span>`&lt;xml&gt;</span></span><br /><span><span>    &lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;</span></span><br /><span><span>    &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br /><span><span>  &lt;/xml&gt;</span></span><br /><span><span>  `</span></span><br /><span>}</span><br /><span></span><br /><span>router.post(<span>'/api/notify'</span>, handleNotify)</span><br /></pre></td></tr></table><p>这里的坑就是Koa处理微信回传的xml。如果不知道是以<code>raw-body</code>的形式回传的，会调试半天。。</p><p>接下来这个就是比较简单的给前端回传的了。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /></pre></td><td><pre><span><span>const</span> checkBill = <span>async</span> (ctx) =&gt; {</span><br /><span>  <span>const</span> form = ctx.request.body</span><br /><span>  <span>const</span> orderNo = form.orderNo</span><br /><span>  <span>const</span> result = <span>await</span> 数据库操作</span><br /><span></span><br /><span>  <span>if</span> (result) { <span>// 如果订单支付成功</span></span><br /><span>    <span>return</span> ctx.body = {</span><br /><span>      success: <span>true</span></span><br /><span>    }</span><br /><span>  }</span><br /><span></span><br /><span>  ctx.status = <span>400</span></span><br /><span>  ctx.body = {</span><br /><span>    success: <span>false</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span>router.post(<span>'/api/check-bill'</span>, checkBill)</span><br /></pre></td></tr></table><h2><a href="https://molunerfinn.com/koa2-wechatpay/#总结"></a>总结</h2><p>至此，一整个基于Koa2的微信二维码支付流程就简单演示完了，由于不是公开的项目，所以没有实际的GitHub仓库。不过基本上关键的代码我都已经注释出来啦。我参考了不少人的实现，曾考虑过用一些比如<code>wechatpay</code>的npm库，不过最终还是自己解决了。这里面感谢很多前人的分享，也希望我这篇文章能给你一些帮助。</p><h2><a href="https://molunerfinn.com/koa2-wechatpay/#参考文章"></a>参考文章</h2><p>微信支付文章</p><p><a href="https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6" target="_blank">https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6</a></p><p><a href="https://juejin.im/post/5a8e84faf265da4e7e10c92f" target="_blank">https://juejin.im/post/5a8e84faf265da4e7e10c92f</a></p><p>返回接口</p><p><a href="http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us" target="_blank">http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us</a></p><p>XML流处理</p><p><a href="https://blog.csdn.net/yxz1025/article/details/52313221" target="_blank">https://blog.csdn.net/yxz1025/article/details/52313221</a></p><p><a href="https://juejin.im/post/5a6c558ef265da3e4b77030f" target="_blank">https://juejin.im/post/5a6c558ef265da3e4b77030f</a></p>]]></content>
        
        <summary type="html">
            
            前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。注： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="Nodejs"/>
        
        <category term="前端"/>
        
        <category term="Koa"/>
        
    </entry>
    
    <entry>
        <title>【NOTE】观察者模式VS订阅发布模式</title>
        <link href="https://molunerfinn.com/observer-vs-pubsub-pattern/"/>
        <id>https://molunerfinn.com/observer-vs-pubsub-pattern/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>最近在看了一篇<a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank">《不好意思，观察者模式跟发布订阅模式就是不一样》</a>的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论指出，一起讨论！</p><a></a><h2><a href="https://molunerfinn.com/observer-vs-pubsub-pattern/#概述"></a>概述</h2><p>有人说这两个模式其实是一个模式。我想这句话的对错对半分吧。它们有类似的地方，不过也不能说完全一致。先来一张图，这张图解释了<code>观察者模式</code>和<code>发布订阅模式</code>在流程上的一些区别：</p><p><img src="https://img.piegg.cn/observer-pubsub.png?imageslim" /></p><p>左边是观察者模式，右边是订阅发布模式。</p><p>简单阐述二者的模型：</p><p>观察者模式里，观察者（Observer）直接订阅（subscribe）主题（Subject），而当主题被激活的时候，会触发（fire）观察者里的事件。</p><p>订阅发布模式里，订阅者（Subscriber）通过监听（on）事件总线（Event Bus）里的事件，当事件总线里的事件被触发（emit）的时候，订阅者将会执行相应的操作。而这里需要注意的是，事件总线里的事件是通过发布者（Publisher）进行发布（publish）和 通知事件总线 <strong>触发</strong> 的。</p><blockquote><p>注：事件总线也有说法叫为调度中心。本质上是一样的。不过因为写Vue时候习惯用Event Bus来说了，所以本文的调度中心皆以事件总线称呼。</p></blockquote><p>所以事件总线本身不独自发布和触发事件，它会借由发布者来操作。这是跟观察者模式有着比较大的区别的地方。</p><p>当然只看这两张图和上面的解释，应该还是无法很好的理解。下面这张图能把流程讲得更清楚点。</p><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" /></p><p>这个例子可以理解为这样：左边是微信里的<code>微商-顾客</code>之间的关系。右边是<code>商家-淘宝-顾客</code>之间的关系。</p><p>观察者模式：顾客关注了微商的商品，微商会记住顾客关注的商品，一旦上新就直接 <strong>私聊</strong> 通知所有关注这个商品的顾客。这里的顾客就相当于观察者，这里的微商就相当于主题。<br />订阅发布模式：顾客通过淘宝（APP或者网站）关注了商家的商品，商家一旦上新就通过淘宝（APP或者网站）向关注了它的顾客 <strong>群发</strong> 消息。这里的顾客就是订阅者，这里的淘宝就是事件总线，这里的商家就是发布者。</p><p>所以可以看出，观察者模式的模型跟发布订阅模型里，差距就差在有没有一个中央的事件总线。如果有这个事件总线，我们就可以认为是个发布订阅模型。如果没有，那么就可以认为是个观察者模型。因为其实它们都实现了一个关键的功能：发布事件-订阅事件并触发事件。</p><p>下面用代码简单解释一下。</p><h2><a href="https://molunerfinn.com/observer-vs-pubsub-pattern/#观察者模式"></a>观察者模式</h2><blockquote><p>由于最近在学习TypeScript，所以下面的代码也会用TypeScript来书写。</p></blockquote><p>我们先写一个定义观察者和主题的文件。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /></pre></td><td><pre><span><span>// observer-pattern.ts</span></span><br /><span></span><br /><span><span>interface</span> Subjects {</span><br /><span>  [key: <span>string</span>]: <span>any</span></span><br /><span>}</span><br /><span><span>// 观察者</span></span><br /><span><span>class</span> Observer {</span><br /><span>  subject: <span>string</span></span><br /><span>  <span>constructor</span> (<span>subject: <span>string</span></span>) {</span><br /><span>    <span>this</span>.subject = subject</span><br /><span>  }</span><br /><span>  notify () {</span><br /><span>    <span>console</span>.log(<span>`This <span>${<span>this</span>.subject}</span> was fired!`</span>)</span><br /><span>    <span>this</span>.subject = <span>`Done`</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>// 主题</span></span><br /><span><span>class</span> Subject {</span><br /><span>  <span>// 根据主题的不同收集相应的订阅者</span></span><br /><span>  subjects: Subjects = {}</span><br /><span>  <span>// 订阅</span></span><br /><span>  add (subject, observer: Observer): <span>void</span> {</span><br /><span>    <span>if</span> (!<span>this</span>.subjects[subject]) {</span><br /><span>      <span>this</span>.subjects[subject] = []</span><br /><span>    }</span><br /><span>    <span>this</span>.subjects[subject].push(observer)</span><br /><span>  }</span><br /><span>  <span>// 解除订阅</span></span><br /><span>  remove (subject, observer: Observer): <span>void</span> {</span><br /><span>    <span>this</span>.subjects[subject].forEach(<span>(<span>item, index</span>) =&gt;</span> {</span><br /><span>      <span>if</span> (item === observer) {</span><br /><span>        <span>this</span>.subjects[subject].splice(index, <span>1</span>)</span><br /><span>      }</span><br /><span>    })</span><br /><span>  }</span><br /><span>  <span>// 触发事件</span></span><br /><span>  fire (subject): <span>void</span> {</span><br /><span>    <span>this</span>.subjects[subject].forEach(<span><span>item</span> =&gt;</span> item.notify())</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> {</span><br /><span>  Observer,</span><br /><span>  Subject</span><br /><span>}</span><br /></pre></td></tr></table><p>于是在调用的时候，是这样调用的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span><span>import</span> * <span>as</span> op <span>from</span> <span>'./observer-pattern'</span></span><br /><span><span>let</span> observer = <span>new</span> op.Observer(<span>'click'</span>)</span><br /><span><span>let</span> subjects = <span>new</span> op.Subject()</span><br /><span>subjects.add(<span>'click'</span>, observer)</span><br /><span>subjects.fire(<span>'click'</span>) <span>// subjects 主动通知</span></span><br /></pre></td></tr></table><p>经过上述调用，subjects触发观察者订阅的click事件，<code>observer.subject</code>的值将会变为<code>Done</code>（原先为<code>click</code>）。</p><h2><a href="https://molunerfinn.com/observer-vs-pubsub-pattern/#订阅发布模式"></a>订阅发布模式</h2><p>接下来我们来实现一些订阅发布模式。订阅发布模式最关键的地方就在于中间的<code>Event Bus</code>部分。它接管着事件总线的订阅和发布。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /></pre></td><td><pre><span><span>// pubsub.ts</span></span><br /><span></span><br /><span><span>interface</span> Subjects {</span><br /><span>  [key: <span>string</span>]: <span>any</span></span><br /><span>}</span><br /><span></span><br /><span><span>// 定义Event Bus</span></span><br /><span><span>class</span> EventBus {</span><br /><span>  subjects: Subjects = {}</span><br /><span>  on (subject, callback): <span>void</span> {</span><br /><span>    <span>/* istanbul ignore next */</span></span><br /><span>    <span>if</span> (!<span>this</span>.subjects[subject]) {</span><br /><span>      <span>this</span>.subjects[subject] = []</span><br /><span>    }</span><br /><span>    <span>this</span>.subjects[subject].push(callback)</span><br /><span>  }</span><br /><span>  off (subject, callback = <span>null</span>): <span>void</span> {</span><br /><span>    <span>if</span> (callback === <span>null</span>) {</span><br /><span>      <span>this</span>.subjects[subject] = []</span><br /><span>    } <span>else</span> {</span><br /><span>      <span>this</span>.subjects[subject].forEach(<span>(<span>item, index</span>) =&gt;</span> {</span><br /><span>        <span>/* istanbul ignore next */</span></span><br /><span>        <span>if</span> (item === callback) {</span><br /><span>          <span>this</span>.subjects[subject].splice(index, <span>1</span>)</span><br /><span>        }</span><br /><span>      })</span><br /><span>    }</span><br /><span>  }</span><br /><span>  emit (subject, data = <span>null</span>): <span>void</span> {</span><br /><span>    <span>this</span>.subjects[subject].forEach(<span><span>item</span> =&gt;</span> item(data))</span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> <span>new</span> EventBus()</span><br /></pre></td></tr></table><p>可以看出在这里的<code>EventBus</code>和观察者模式里的<code>Subject</code>几乎一致对吧。但是需要注意的是，最后一行里，我们<code>export default new EventBus()</code>，所以我们在项目里不同的地方<code>import</code>它，都会指向同一个<code>Event Bus</code>实例，这样的话就可以起到一个事件总线的作用了。它不在乎谁来监听，谁来发布。只要有人监听了，就把它放进监听队列中。只要有人发布了事件，就从相应的监听队列中触发回调。不过所有相关的事件都必须经过<code>Event Bus</code>这个实例，而不能越过它直接由发布者通知监听者。</p><blockquote><p>再次祭出这张图</p></blockquote><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" /></p><p>所以在订阅发布模型里，发布者或者订阅者的身份已经被弱化。发布者可以在任何时候发布事件，而订阅者可能只是一个回调函数。而最关键的事件总线部分，则是发布订阅模型的核心。</p><p>如果你用过Vue的<code>Event Bus</code>，相信不会陌生。接下来我们来用用我们刚才写的简单的<code>Event Bus</code>。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /></pre></td><td><pre><span><span>import</span> bus <span>from</span> <span>'./pubsub.ts'</span></span><br /><span><span>const</span> people = <span><span>function</span> (<span>val</span>) </span>{</span><br /><span>  <span>console</span>.log(<span>'我收到了新的商品通知：'</span>, val) <span>// 收到消息</span></span><br /><span>}</span><br /><span></span><br /><span>bus.on(<span>'newItem'</span>, people) <span>// 订阅newItem这个消息</span></span><br /><span></span><br /><span><span>const</span> merchant = <span><span>function</span> (<span>val</span>) </span>{ <span>// 由商户向event bus发布新商品</span></span><br /><span>  <span>const</span> item = {</span><br /><span>    item: val</span><br /><span>  }</span><br /><span>  bus.emit(<span>'newItem'</span>, item)</span><br /><span>}</span><br /><span></span><br /><span>merchant(<span>'Book'</span>) <span>// 发布</span></span><br /></pre></td></tr></table><p>所以你可以看到，这个事件总线是可以单独抽离出来的。如果要把我们这个文件丢到一个现有的项目里也是完全没问题的。</p><p>其实在写Vue组件通信的时候，你如果用到了<code>Event Bus</code>的话，也是一样的。在全局声明一个<code>new Vue()</code>做<code>Event Bus</code>总线，然后在不同的组件里只要引入了这个事件总线，就能订阅或者发布不同的消息。这个就是一个非常典型的订阅发布模型。</p><p>而如果只是Vue的父子组件通信，子组件用的是<code>this.$emit</code>来触发事件，父组件用的是<code>this.$on</code>这样的方式去订阅事件，那么你可以认为这个就是一个简单的观察者模型。因为它们之间的联系是紧密耦合的。</p><h2><a href="https://molunerfinn.com/observer-vs-pubsub-pattern/#总结"></a>总结</h2><p>不管是观察者模式也好，订阅发布模式也好，关键在于实现了在某个特定时间触发某个特定事件，从而触发监听这个特定事件的组件进行相应操作的功能。这个设计模式在很多时候非常有用。平时只是用到了它，但是没有深入去看看如何实现，这次借由这个机会把二者的关系和区别记录下来，也算是给自己加深了印象。</p><p>本文的代码你可以在我的学习仓库<a href="https://github.com/Molunerfinn/FE-Learning/tree/master/design-pattern" target="_blank">FE-Learning</a>找到。如有错误欢迎指出！</p><h2><a href="https://molunerfinn.com/observer-vs-pubsub-pattern/#参考资料"></a>参考资料</h2><p><a href="https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon" target="_blank">https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon</a></p><p><a href="http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html" target="_blank">http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html</a></p><p><a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank">https://juejin.im/post/5af05d406fb9a07a9e4d2799</a></p><p><a href="https://www.cnblogs.com/weebly/p/5279952.html" target="_blank">https://www.cnblogs.com/weebly/p/5279952.html</a></p><p><a href="https://www.jianshu.com/p/3098b1176357" target="_blank">https://www.jianshu.com/p/3098b1176357</a></p><p><a href="https://www.zhihu.com/question/23486749/answer/314072549" target="_blank">https://www.zhihu.com/question/23486749/answer/314072549</a></p>]]></content>
        
        <summary type="html">
            
            最近在看了一篇《不好意思，观察者模式跟发布订阅模式就是不一样》的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论
            
        </summary>
        
        <category term="笔记"/>
        
        <category term="note"/>
        
        <category term="Nodejs"/>
        
        <category term="JS"/>
        
    </entry>
    
    <entry>
        <title>【NOTE】进程-线程-协程 关系与区别</title>
        <link href="https://molunerfinn.com/process-thread-coroutine/"/>
        <id>https://molunerfinn.com/process-thread-coroutine/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。</p><a></a><h2><a href="https://molunerfinn.com/process-thread-coroutine/#进程"></a>进程</h2><p>一个进程好比是一个程序，它是 <strong>资源分配的最小单位</strong> 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h2><a href="https://molunerfinn.com/process-thread-coroutine/#线程"></a>线程</h2><p>如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 <strong>「微进程」</strong> 。它是 <strong>程序执行过程中的最小单元</strong> 。</p><p>一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：</p><p>拖动进度条-&gt;画面更新-&gt;声音更新。你会明显感到画面和声音和进度条不同步。</p><p>但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。</p><h2><a href="https://molunerfinn.com/process-thread-coroutine/#协程"></a>协程</h2><p>协程在线程中实现调度。你可以理解为它是 <strong>「微线程」</strong> 。它的调度不来自于CPU，而是完全来自于用户控制（可以理解为用代码控制流程）。协程的执行效率非常高，它的切换不是线程切换，没有线程切换的开销。而且只要线程越多，协程的性能优势就越明显。协程不需要多线程的锁机制，只需要判断状态即可。不过协程本身无法利用多核CPU，因为它基于线程，而线程又依赖于进程。</p><p>在JS里，常见的协程就是ES6的<code>yield Generator</code>或者ES7的<code>async await</code>。我们知道JS引擎是单线程的。所以在处理异步任务队列的时候，以往我们会陷入「回调金字塔」或者「回调地狱」。而有了协程之后我们可以在代码层面上来控制我们的程序。</p><p>比如我们有这么一个需求，等两个请求都返回之后，用它们的返回值共同做些事。（此处不用<code>Promise.all()</code>来实现，不是说不行，而是为了更好地说明主题）</p><p><strong>ES6 + co</strong> 的写法：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>const</span> axios = <span>require</span>(<span>'axios'</span>)</span><br /><span><span>const</span> co = <span>require</span>(<span>'co'</span>)</span><br /><span>co(<span><span>function</span>* (<span></span>)</span>{</span><br /><span>  <span>const</span> getData = <span>yield</span> axios.get(<span>'xxx'</span>)</span><br /><span>  <span>const</span> postData = <span>yield</span> axios.post(<span>'xxx'</span>)</span><br /><span>  <span>console</span>.log(getData, postData)</span><br /><span>})</span><br /></pre></td></tr></table><p><strong>ES7</strong> 的写法：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span>const</span> axios = <span>require</span>(<span>'axios'</span>)</span><br /><span>(<span>async</span> <span><span>function</span> (<span></span>) </span>{</span><br /><span>  <span>const</span> getData = <span>await</span> axios.get(<span>'xxx'</span>)</span><br /><span>  <span>const</span> postData = <span>await</span> axios.post(<span>'xxx'</span>)</span><br /><span>  <span>console</span>.log(getData, postData)</span><br /><span>})()</span><br /></pre></td></tr></table><p>上述用「同步」的方式写的代码实际上依然是异步执行的。不过因为了有协程，在单线程的JS里也能够让我们在代码层面上实现了任务调度。</p><h2><a href="https://molunerfinn.com/process-thread-coroutine/#总结"></a>总结</h2><p>可以说三者虽然是不同的东西，但是有着很密切的关系和类似的特性。它们的关系是从大到小，从上而下的。没有进程也就没有线程也就没有协程。总的来说，在多核处理器的情况下，多进程+多协程可以发挥最优的性能。</p><h2><a href="https://molunerfinn.com/process-thread-coroutine/#参考文献"></a>参考文献</h2><ol><li><a href="https://www.jianshu.com/p/f11724034d50" target="_blank">进程，线程，协程与并行，并发</a></li><li><a href="http://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank">进程和线程、协程的区别</a></li><li><a href="https://blog.csdn.net/blateyang/article/details/78088851" target="_blank">进程、线程和协程的比较</a></li><li><a href="http://jsonliangyoujun.iteye.com/blog/2358274" target="_blank">线程、进程与处理器</a></li></ol>]]></content>
        
        <summary type="html">
            
            在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。进程一个进程好比是一个程
            
        </summary>
        
        <category term="笔记"/>
        
        <category term="note"/>
        
        <category term="Nodejs"/>
        
    </entry>
    
    <entry>
        <title>基于Electron-vue的图床上传工具PicGo v1.5更新说明</title>
        <link href="https://molunerfinn.com/picgo-v1.5-update/"/>
        <id>https://molunerfinn.com/picgo-v1.5-update/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。</p><a></a><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持GitHub图床"></a>支持GitHub图床</h3><p>早先PicGo所支持的图床基本上都是属于国内的服务商提供的图床（如七牛、腾讯云COS等），这次更新加入了GitHub图床的支持。用GitHub做图床其实是不少写博客的朋友的做法。免费、原生支持HTTPS、GitHub仓库易于管理、和issue等功能无缝衔接都是它的优点。如果能接受GitHub在国内的访问速度不是特别快的缺点的话，用它来做你的图床是个不错的选择。来看看在PicGo里如何配置它：</p><p><strong>1. </strong>首先你得有一个GitHub账号。注册GitHub就不用我多言。</p><p><strong>2. </strong>新建一个仓库</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/create_new_repo.png" /></p><p>记下你取的仓库名。</p><p><strong>3. </strong>生成一个token用于PicGo操作你的仓库：</p><p>访问：<a href="https://github.com/settings/tokens" target="_blank">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/generate_new_token.png" /></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180508210435.png" /></p><p><strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/copy_token.png" /></p><p><strong>4. </strong>配置PicGo</p><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>Molunerfinn/test</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/setup_github.png" /></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/success.png" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持腾讯云COS-v5版本"></a>支持腾讯云COS v5版本</h3><blockquote><p>在支持腾讯云COS的路上，我可谓是费了一番心血。首先是官方提供的node-sdk对我来说基本属于瘫痪状态，只能上传具体文件而不能上传base64编码后的文件。而且居然还有v4和v5两个版本的COS，甚至两个版本的认证签名、上传url等等都<strong>完！全！不！同！</strong>。由于之前我只有v4版本的COS权限，只能开发和测试出v4版本的上传。而近来发现很多朋友用的都已经是v5版本的了，所以我提交了一个工单向腾讯云申请了v5版本的权限，没想到很快就给我派发权限了。于是就有了v5版本的面世。目前市面上能同时支持v4、v5版本COS的估计也只有PicGo了！</p></blockquote><p>如果你是v5用户，但是之前下载了PicGo却不能用的话，别担心，v1.5版本的配置跟之前的配置几乎一致，而且可以一键切换v4\v5版本。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/v5_setup.png" /></p><p><strong>1. </strong>获取你的APPID、SecretId和SecretKey</p><p>访问：<a href="https://console.cloud.tencent.com/cam/capi" target="_blank">https://console.cloud.tencent.com/cam/capi</a></p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_key_id_secret.png" /></p><p><strong>2. </strong>获取bucket名以及存储区域代号</p><p>访问：<a href="https://console.cloud.tencent.com/cos5/bucket" target="_blank">https://console.cloud.tencent.com/cos5/bucket</a></p><p>创建一个存储桶。然后找到你的存储桶名和存储区域代号：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_bucket_area.png" /></p><p>v5版本的存储桶名称格式是<code>bucket-appId</code>，类似于<code>xxxx-12312313</code>。存储区域代码和v4版本的也有所区别，v5版本的如我的是<code>ap-beijing</code>，别复制错了。</p><p><strong>3. </strong>选择v5版本并点击确定</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/choose_v5.png" /></p><p>然后记得点击<code>设为默认图床</code>，这样上传才会默认走的是腾讯云COS。</p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持编辑相册的图片信息"></a>支持编辑相册的图片信息</h3><p>有些时候可能上传的图片的url事后需要更改，比如修改http到https，比如加上一些操作后缀（例：七牛图床支持的<code>?imgslim</code>）等等。PicGo本次的更新也让你能够更方便地管理你的图片库。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_edit_info.gif" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持上传图片前重命名文件名"></a>支持上传图片前重命名文件名</h3><p>PicGo总共有三种上传模式：</p><ol><li>menubar图标拖拽上传（仅支持macOS）</li><li>主窗口拖拽或者选择图片上传</li><li>剪贴板图片（最常见的是截图）上传（支持自定义快捷键）</li></ol><p>其中前两种都是可以明确获得文件名，而第三种无法获取文件名（因为剪贴板里有些图片比如截图根本就不存在文件名），所以PicGo此前采取的规则是使用时间戳来命名剪贴板里的图片。这也导致了无法自定义文件名的问题。本次更新你可以选择开启「上传前重命名」这个选项：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/rename_before_upload.png" /></p><p>之后你在上传的时候就会弹出一个小窗口让你重命名文件。如果你不想重命名，点击确定、取消或者直接关闭这个窗口都是可以的。如果你想要重命名就在输入框里输入想要更改的名字，然后点击确定即可。另外这个特性也支持批量上传，如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_rename.gif" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持查看当前上传的图床"></a>支持查看当前上传的图床</h3><p>在主窗口的上传区，你可以直观地看到当前默认上传的图床，再也不用到处找当前的默认图床是哪个啦。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/current_picbed.png" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持显示或隐藏相应的图床"></a>支持显示或隐藏相应的图床</h3><p>很多时候你并不会使用上PicGo给你提供的全部的图床。所以为了精简显示你可以只选择你想要的图床来显示，这样侧边栏也就不会出现滚动条了。不过需要注意的是，这个仅仅是显示/隐藏而并不是剔除相应的功能。假如你隐藏了七牛云，你依然是可以通过七牛云来上传图片的。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picbed-choose.gif" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#支持开机自启动"></a>支持开机自启动</h3><p>如果你觉得每次开机要主动开启PicGo是一件麻烦事，不妨试试让它开机自启吧~</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/autoStart.png" /></p><h3><a href="https://molunerfinn.com/picgo-v1.5-update/#修复若干bugs"></a>修复若干bugs</h3><p>v1.5不光更新了上述功能，也修复了不少问题。其中一个尤为重要的是从v1.4.1开始的一个bug——macOS的menubar无法拖拽上传。该bug也在这个版本被修复。</p><h2><a href="https://molunerfinn.com/picgo-v1.5-update/#结语"></a>结语</h2><p>PicGo第一个稳定版本是在少数派上发布的，详见<a href="https://sspai.com/post/42310" target="_blank">PicGo：基于 Electron 的图片上传工具</a>。支持macOS和windows双平台，开源免费，界面美观，也得到了很多朋友的认可。本次更新也是充分聆听了大家的<a href="https://github.com/Molunerfinn/PicGo/issues/29" target="_blank">意见</a>。如果你对它有什么意见或者建议，也欢迎在<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank">issues</a>里指出。如果你喜欢它，不妨给它点个star或者请我喝杯咖啡（PicGo的GitHub<a href="https://github.com/Molunerfinn/PicGo" target="_blank">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><blockquote><p>Windows用户请下载<code>.exe</code>文件，macOS用户请下载<code>.dmg</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
        
        <summary type="html">
            
            经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具PicGo终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。支持GitHub图床早先PicGo所支持的图床基本上都是属于国内的服务商提供的图床（如七牛、腾讯
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>Electron-vue开发实战4——通过CI发布以及更新的方式</title>
        <link href="https://molunerfinn.com/electron-vue-5/"/>
        <id>https://molunerfinn.com/electron-vue-5/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/electron-vue-5/#前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2><a href="https://molunerfinn.com/electron-vue-5/#说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a></a><h2><a href="https://molunerfinn.com/electron-vue-5/#LOGO的准备"></a>LOGO的准备</h2><p>经过前面几篇文章的实战，我相信大家已经对于构建一个基本的electron应用没有太多的问题了。本文主要阐述一下如何让我们的应用通过CI系统来自动帮我们构建应用，然后发布给用户使用。以及之后如果有更新，要如何通知用户更新。</p><p>当然，在此之前，我们还需要做一件事：给你应用加上好看的LOGO。LOGO的设计和制作不在本文的设计范围内。为了我们的应用能够跨平台地使用，不同平台上应用的LOGO尺寸和格式也不尽相同。三个平台所需的图片格式如下：</p><ul><li>Linux - png</li><li>macOS - icns</li><li>Windows - ico</li></ul><p>准备一张1024*1024以下，256*256以上（长宽一致）的png图片，(推荐512 * 512）然后我们可以用一些工具来实现从png到其他两种格式。搜索png转ico或者png转icns的话有很多在线转换的网站，可以去上面在线转换。在mac上我推荐用的是<a href="http://www.img2icnsapp.com/" target="_blank">image2icon</a>这个工具。</p><p>然后我们将所得的三个图片文件，放到electron-vue项目根目录的<code>build/icons/</code>目录下。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqnr7sfuvjj20h806cglq.jpg" /></p><h2><a href="https://molunerfinn.com/electron-vue-5/#不同平台的构建配置"></a>不同平台的构建配置</h2><p>本文我们主要采用electron-vue已经配置好的基于<a href="https://github.com/electron-userland/electron-builder" target="_blank">electron-builder</a>的构建脚本来进行我们的应用构建。构建脚本会读取<code>package.json</code>里的<code>build</code>字段里的配置来进行构建。electron-vue默认的配置如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /></pre></td><td><pre><span>"build": {</span><br /><span>  "productName": "ElectronVue",</span><br /><span>  "appId": "org.simulatedgreg.electron-vue",</span><br /><span>  "dmg": {</span><br /><span>    "contents": [</span><br /><span>      {</span><br /><span>        <span>"x"</span>: <span>410</span>,</span><br /><span>        <span>"y"</span>: <span>150</span>,</span><br /><span>        <span>"type"</span>: <span>"link"</span>,</span><br /><span>        <span>"path"</span>: <span>"/Applications"</span></span><br /><span>      },</span><br /><span>      {</span><br /><span>        <span>"x"</span>: <span>130</span>,</span><br /><span>        <span>"y"</span>: <span>150</span>,</span><br /><span>        <span>"type"</span>: <span>"file"</span></span><br /><span>      }</span><br /><span>    ]</span><br /><span>  },</span><br /><span>  "directories": {</span><br /><span>    "output": "build"</span><br /><span>  },</span><br /><span>  "files": [</span><br /><span>    "dist/electron",</span><br /><span>    "node_modules/",</span><br /><span>    <span>"package.json"</span></span><br /><span>  ],</span><br /><span>  "mac": {</span><br /><span>    "icon": "build/icons/icon.icns"</span><br /><span>  },</span><br /><span>  "win": {</span><br /><span>    "icon": "build/icons/icon.ico"</span><br /><span>  },</span><br /><span>  "linux": {</span><br /><span>    "icon": "build/icons"</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><p>简单讲述一下build配置里的一些字段的含义。</p><p>首先<code>productName</code>是你的应用的名字。<code>appId</code>的作用是用于Windows平台区分应用的标识。（<strong>注意</strong>该配置必须配置，而且稍后会有使用该配置的地方。如果不配置不使用的话，构建出来的Windows平台的应用将无法发送eletron的桌面通知）<code>dmg</code>这个配置里描述了macOS平台里，打开<code>dmg</code>安装包后显示的界面里的信息。如下图：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqnrlfwfcej20u00mct9y.jpg" /></p><p>表示了有两个标识，一个是应用文件，坐标是<code>(130, 150)</code>， 一个是应用文件夹的快捷方式，坐标是<code>(410, 150)</code>。</p><p><code>directories</code>的<code>output</code>字段是你应用打包完生成的文件放置的目录。</p><p><code>files</code>指明了要打包的目录。</p><p>而<code>mac</code>，<code>win</code>，<code>linux</code>是针对三个平台的不同的配置了。可以看出默认的配置里对它们的配置都是指向了不同的icon图标（也就是上一节所说的LOGO）。</p><p>PicGo在实际开发中，针对一些情况对默认的<code>build</code>配置项做出了一些增改：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /></pre></td><td><pre><span>"build": {</span><br /><span>  "productName": "PicGo",</span><br /><span>  "appId": "com.molunerfinn.picgo",</span><br /><span>  "directories": {</span><br /><span>    "output": "build"</span><br /><span>  },</span><br /><span>  "files": [</span><br /><span>    <span>"dist/electron/**/*"</span></span><br /><span>  ],</span><br /><span>  "dmg": {</span><br /><span>    "contents": [</span><br /><span>      {</span><br /><span>        <span>"x"</span>: <span>410</span>,</span><br /><span>        <span>"y"</span>: <span>150</span>,</span><br /><span>        <span>"type"</span>: <span>"link"</span>,</span><br /><span>        <span>"path"</span>: <span>"/Applications"</span></span><br /><span>      },</span><br /><span>      {</span><br /><span>        <span>"x"</span>: <span>130</span>,</span><br /><span>        <span>"y"</span>: <span>150</span>,</span><br /><span>        <span>"type"</span>: <span>"file"</span></span><br /><span>      }</span><br /><span>    ]</span><br /><span>  },</span><br /><span>  "mac": {</span><br /><span>    "icon": "build/icons/icon.icns",</span><br /><span>    "extendInfo": {</span><br /><span>      "LSUIElement": 1</span><br /><span>    }</span><br /><span>  },</span><br /><span>  "win": {</span><br /><span>    "icon": "build/icons/icon.ico",</span><br /><span>    "target": "nsis"</span><br /><span>  },</span><br /><span>  "nsis": {</span><br /><span>    "oneClick": false,</span><br /><span>    "allowToChangeInstallationDirectory": true</span><br /><span>  },</span><br /><span>  "linux": {</span><br /><span>    "icon": "build/icons"</span><br /><span>  }</span><br /><span>},</span><br /></pre></td></tr></table><p>由于PicGo在macOS上主要是一个顶部栏应用，所以在底部docker栏我并不想拥有一个占位的图标，所以在<code>mac</code>字段里加入了：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>"extendInfo": {</span><br /><span>  "LSUIElement": 1</span><br /><span>}</span><br /></pre></td></tr></table><p>这个属性。参考相关<a href="https://github.com/electron-userland/electron-builder/issues/1456" target="_blank">issue</a>。</p><p>在Windows平台上，默认打包出来的安装包并没有办法选择安装的路径，只会默认装到C盘的用户目录。这个并不是我们想要的。我们想要的是让用户自己选择安装的路径。</p><p>所以需要修改<code>windows</code>的一些配置以及加上一个<code>nsis</code>的配置来实现：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>"win": {</span><br /><span>  "icon": "build/icons/icon.ico",</span><br /><span>  "target": "nsis"</span><br /><span>},</span><br /><span>"nsis": {</span><br /><span>  "oneClick": false,</span><br /><span>  "allowToChangeInstallationDirectory": true</span><br /><span>}</span><br /></pre></td></tr></table><p>由于目前我还没有打包过Linux平台的应用，所以Linux相关的配置暂时先不做修改。</p><h3><a href="https://molunerfinn.com/electron-vue-5/#Windows平台打包的一个小坑"></a>Windows平台打包的一个小坑</h3><p>还记得前面说到的一个配置：<code>appId</code>么，这个配置需要我们在主进程<code>index.js</code>里也要使用。否则打包后的应用将失去Windows平台的应用通知功能。这个<code>appId</code>是可以任意取的，只要保证不和其他应用重复即可。对于PicGo而言，<code>appId</code>是<code>com.molunerfinn.picgo</code>。</p><p>打开你的<code>main/index.js</code>，在Windows平台的时候加上这个<code>appId</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span><span>// ...</span></span><br /><span><span>import</span> pkg <span>from</span> <span>'../../package.json'</span></span><br /><span></span><br /><span><span>// ...</span></span><br /><span><span>// ...</span></span><br /><span></span><br /><span><span>if</span> (process.platform === <span>'win32'</span>) {</span><br /><span>  app.setAppUserModelId(pkg.build.appId)</span><br /><span>}</span><br /></pre></td></tr></table><p>这样就解决了通知的那个问题。</p><h2><a href="https://molunerfinn.com/electron-vue-5/#通过CI系统自动构建与发布"></a>通过CI系统自动构建与发布</h2><h3><a href="https://molunerfinn.com/electron-vue-5/#版本相关"></a>版本相关</h3><p>发布应用其实是一个比较繁琐的活，往往跟你的版本控制绑在一块，所以通常在项目开始的阶段就要有所布局。我说说我的做法吧，不一定很科学，不过简单易行。</p><ol><li>仓库主要两个分支，一个dev一个master。平时在dev上开发，只有在发布新版的时候merge到master上。</li><li>书写简单的更新版本的脚本，一键打tag+push到GitHub。</li><li>结合CI系统，自动构建master分支的代码，并将应用推送到GitHub仓库去。</li></ol><p>其中简单的更新版本的脚本我是在<code>package.json</code>里写了简单的<code>scripts</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>"scripts": {</span><br /><span>  "patch": "npm version patch &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 小版本</span><br /><span>  "minor": "npm version minor &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 次版本</span><br /><span>  "major": "npm version major &amp;&amp; git push origin master &amp;&amp; git push origin --tags"  // 大版本</span><br /><span>}</span><br /></pre></td></tr></table><p>里面用到了npm的一个命令，<code>npm version [options]</code>，具体可以参考version的<a href="https://docs.npmjs.com/cli/version" target="_blank">文档</a>。简单来说，它能够自动帮你升级版本，修改<code>package.json</code>里的version，并打上相应的git tag，很方便。</p><p>举个例子，一个符合语义的版本号通常由如下三个部分组成：<code>major.minor.patch</code>，比如<code>1.5.3</code>。如果我运行了<code>npm run patch</code>，那么将会将小版本更新：<code>1.5.4</code>，同时修改<code>package.json</code>里的<code>version</code>字段为<code>1.5.4</code>并自动打上一个git tag <code>1.5.4</code>，并将这个修改和tag推送到远端。</p><p>不过需要注意的是，一开始我是通过electron-vue自带的<code>npm run build</code>这个脚本让CI去执行构建，但是发现无法自动上传到GitHub的release里。所以通过查阅相关资料后，发现最简单的就是把对应的npm scripts命名为<code>release</code>。于是我把原本的<code>npm run build</code>的脚本复制了一遍，起了一个新名<code>release</code>:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>"scripts": {</span><br /><span>  <span>// ...</span></span><br /><span>  "release": "node .electron-vue/build.js &amp;&amp; electron-builder",</span><br /><span>  <span>// ...</span></span><br /><span>}</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/electron-vue-5/#CI相关"></a>CI相关</h3><p>说到这里都还没说到CI系统。什么是CI？可以参考阮一峰老师给出的解释<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank">《持续集成是什么？》</a>。我们如果每次发布应用都需要我们在本地构建，然后手动上传到GitHub（或者其他地方）去，然后让别人能下载的话，未免太累了。而且通常我们开发electron应用就是为了能够跨平台，但是要构建不同的平台的应用意味着我们要在不同的平台分别构建。这也是不能忍受的。</p><p>于是网上有一些第三方的CI系统，它们能够帮我们，在某些分支（比如master）发生了某些更新（比如更新了tag）的时候帮我们执行某些脚本（比如构建、测试）。这样就省却了我们在本地、多平台构建的烦心事，而且让一些都变得「自动化」了起来。</p><p>有了CI之后，我的electron应用的发布就变成这样的流程了：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqq9mnpumwj20rb04bt9a.jpg" /></p><p>这样，我们只需要Push代码足矣。</p><p>针对Linux或者macOS的构建，我们可以使用<a href="https://travis-ci.org/" target="_blank">Travis-CI</a>，针对Windows平台的构建，我们可以使用<a href="https://www.appveyor.com/" target="_blank">AppVeyor</a>。一个好消息是，它们对于在GitHub上的开源项目都是可以免费构建的，并且和GitHub的仓库结合地特别好，配置也比较简单，可以说的非常良心了。</p><p>在使用它们之前，我们需要给予它们一定的权限让它们能够访问我们的GitHub仓库。所以需要：</p><ol><li>用你的GitHub账号注册它们，才能获取你的仓库列表。</li><li>在GitHub上生成<a href="https://github.com/settings/tokens" target="_blank">token</a>，赋予CI系统读写你的仓库的权限。生成token的具体操作可以查看之前我写的一篇针对hexo持久化构建的<a href="https://molunerfinn.com/hexo-travisci-https/">文章</a>。</li><li>针对不同的CI平台创建不同的配置文件，好让它们知道你要它们执行什么操作。不过electron-vue很友好地为我们准备了Travis-CI的配置文件模板<code>.travis.yml</code>和AppVeyor的配置文件模板<code>appveyor.yml</code>。所以我们基本上只需要在它们的基础上小修改即可。</li></ol><h3><a href="https://molunerfinn.com/electron-vue-5/#Travis-CI"></a>Travis-CI</h3><p>注册并登录Travis-CI后，找到你要构建的仓库，然后打开，点击设置进入如下页面：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19gy1fi438l5g9sj218a0wmn1u.jpg" /></p><p>配置一下环境变量，名为<code>GH_TOKEN</code>，token的值就是上一步我们在GitHub生成的token。等会会有用。</p><p>PicGo经过修改后的<code>.travis.yml</code>如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /></pre></td><td><pre><span><span># Commented sections below can be used to run tests on the CI server</span></span><br /><span><span># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br /><span><span>osx_image:</span> <span>xcode8.3</span></span><br /><span><span>sudo:</span> <span>required</span></span><br /><span><span>dist:</span> <span>trusty</span></span><br /><span><span>language:</span> <span>c</span></span><br /><span><span>matrix:</span></span><br /><span>  <span>include:</span></span><br /><span>  <span>-</span> <span>os:</span> <span>osx</span></span><br /><span>  <span># - os: linux</span></span><br /><span>    <span>env:</span> <span>CC=clang</span> <span>CXX=clang++</span> <span>npm_config_clang=1</span></span><br /><span>    <span>compiler:</span> <span>clang</span></span><br /><span><span>cache:</span></span><br /><span>  <span>directories:</span></span><br /><span>  <span>-</span> <span>node_modules</span></span><br /><span>  <span>-</span> <span>"$HOME/.electron"</span></span><br /><span>  <span>-</span> <span>"$HOME/.cache"</span></span><br /><span><span>addons:</span></span><br /><span>  <span>apt:</span></span><br /><span>    <span>packages:</span></span><br /><span>    <span>-</span> <span>libgnome-keyring-dev</span></span><br /><span>    <span>-</span> <span>icnsutils</span></span><br /><span><span>before_install:</span></span><br /><span><span>-</span> <span>mkdir</span> <span>-p</span> <span>/tmp/git-lfs</span> <span>&amp;&amp;</span> <span>curl</span> <span>-L</span> <span>https://github.com/github/git-lfs/releases/download/v1.2.1/git-lfs-$([</span></span><br /><span>  <span>"$TRAVIS_OS_NAME"</span> <span>==</span> <span>"linux"</span> <span>]</span> <span>&amp;&amp;</span> <span>echo</span> <span>"linux"</span> <span>||</span> <span>echo</span> <span>"darwin"</span><span>)-amd64-1.2.1.tar.gz</span></span><br /><span>  <span>|</span> <span>tar</span> <span>-xz</span> <span>-C</span> <span>/tmp/git-lfs</span> <span>--strip-components</span> <span>1</span> <span>&amp;&amp;</span> <span>/tmp/git-lfs/git-lfs</span> <span>pull</span></span><br /><span><span>install:</span></span><br /><span><span>-</span> <span>nvm</span> <span>install</span> <span>8.9</span></span><br /><span><span>-</span> <span>curl</span> <span>-o-</span> <span>-L</span> <span>https://yarnpkg.com/install.sh</span> <span>|</span> <span>bash</span></span><br /><span><span>-</span> <span>source</span> <span>~/.bashrc</span></span><br /><span><span>-</span> <span>npm</span> <span>install</span> <span>-g</span> <span>xvfb-maybe</span></span><br /><span><span>-</span> <span>yarn</span></span><br /><span><span>script:</span></span><br /><span><span>-</span> <span>npm</span> <span>run</span> <span>release</span></span><br /><span><span>-</span> <span>yarn</span> <span>run</span> <span>build:docs</span></span><br /><span><span>branches:</span></span><br /><span>  <span>only:</span></span><br /><span>  <span>-</span> <span>master</span></span><br /><span><span>after_script:</span></span><br /><span>  <span>-</span> <span>cd</span> <span>docs/dist</span></span><br /><span>  <span>-</span> <span>git</span> <span>init</span></span><br /><span>  <span>-</span> <span>git</span> <span>config</span> <span>user.name</span> <span>"Molunerfinn"</span></span><br /><span>  <span>-</span> <span>git</span> <span>config</span> <span>user.email</span> <span>"marksz@teamsz.xyz"</span></span><br /><span>  <span>-</span> <span>git</span> <span>add</span> <span>.</span></span><br /><span>  <span>-</span> <span>git</span> <span>commit</span> <span>-m</span> <span>"Travis build docs"</span></span><br /><span>  <span>-</span> <span>git</span> <span>push</span>  <span>--force</span> <span>--quiet</span> <span>"https://${GH_TOKEN}@github.com/Molunerfinn/PicGo.git"</span> <span>master:gh-pages</span></span><br /></pre></td></tr></table><p>抛去很多前置依赖（比如C++编译库之类的）和构建环境（是什么系统，是什么语言），那些都是electron-vue给我们预置好的。我们需要注意的仅仅是几个部分：</p><ol><li>script</li><li>branches</li><li>after_script</li></ol><p><code>script</code>是当系统和环境和依赖都准备好之后，你要CI运行的命令。在这里我运行了两个命令，一个是<code>npm run release</code>，这个就是打包构建应用啦，并且执行了这个命令之后，<code>electron-builder</code>会自动将生成好的安装包推送到我们GitHub仓库的draft release里。另一个是构建PicGo<a href="https://molunerfinn.com/PicGo/">主页</a>的命令<code>yarn run build:docs</code>。</p><p><code>branches</code>声明了你要在哪些分支在GitHub接收到了代码更新之后就构建，这里我们自然选择的是master。</p><p><code>after_script</code>是当你执行完script里的脚本之后要做的事。可以为空。对于我而言主要在这个部分将上一步构建好的PicGo主页推送到GitHub的<code>gh-pages</code>分支。当然如果你的应用有使用说明、文档之类的网站，也可以在这里进行构建和推送。</p><p>注意到，在<code>after_script</code>命令的最后一行，有个<code>${GH_TOKEN}</code>，这个就是我们之前在Travis-CI配置里配置的环境变量<code>GH_TOKEN</code>。用环境变量的好处是不会暴露你的TOKEN，只有构建系统知道。</p><h3><a href="https://molunerfinn.com/electron-vue-5/#AppVeyor"></a>AppVeyor</h3><p>有了之前的经验，AppVeyor就更简单了。注册登录后，我们在主页添加一个PROJECT，选中你要构建的仓库。然后找到SETTING设置：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqqawmvu6sj21ji06e3z0.jpg" /></p><p>然后在左侧的<code>Genral</code>一栏的内容区中，找到构建的分支为master，以及设置我们仅在<code>tag</code>更新的时候构建：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqqazwrslxj21600emjse.jpg" /></p><blockquote><p>当然这个都是根据项目实际来的配置，我只是说PicGo的项目是这样配置的。</p></blockquote><p>然后在左侧的<code>Environment</code>区，找到环境变量配置，我们依然写入<code>GH_TOKEN</code>:</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqqb1ufhj7j21ow0gydhu.jpg" /></p><p><strong>修改完配置都别忘了拉到底部去保存！</strong></p><p>这样就算配置完了网页端的。而现在我们来看看<code>appveyor.yml</code>这个配置文件：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /></pre></td><td><pre><span><span># Commented sections below can be used to run tests on the CI server</span></span><br /><span><span># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br /><span><span>version:</span> <span>0.1</span><span>.{build}</span></span><br /><span></span><br /><span><span>branches:</span></span><br /><span>  <span>only:</span></span><br /><span>    <span>-</span> <span>master</span></span><br /><span></span><br /><span><span>image:</span> <span>Visual</span> <span>Studio</span> <span>2017</span></span><br /><span><span>platform:</span></span><br /><span>  <span>-</span> <span>x64</span></span><br /><span></span><br /><span><span>cache:</span></span><br /><span>  <span>-</span> <span>node_modules</span></span><br /><span>  <span>-</span> <span>'%APPDATA%\npm-cache'</span></span><br /><span>  <span>-</span> <span>'%USERPROFILE%\.electron'</span></span><br /><span>  <span>-</span> <span>'%USERPROFILE%\AppData\Local\Yarn\cache'</span></span><br /><span></span><br /><span><span>init:</span></span><br /><span>  <span>-</span> <span>git</span> <span>config</span> <span>--global</span> <span>core.autocrlf</span> <span>input</span></span><br /><span></span><br /><span><span>install:</span></span><br /><span>  <span>-</span> <span>ps:</span> <span>Install-Product</span> <span>node</span> <span>8</span> <span>x64</span></span><br /><span>  <span>-</span> <span>git</span> <span>reset</span> <span>--hard</span> <span>HEAD</span></span><br /><span>  <span>-</span> <span>npm</span> <span>install</span></span><br /><span>  <span>-</span> <span>node</span> <span>--version</span></span><br /><span></span><br /><span><span>build_script:</span></span><br /><span>  <span>#- yarn test</span></span><br /><span>  <span>-</span> <span>npm</span> <span>run</span> <span>release</span></span><br /><span></span><br /><span><span>test:</span> <span>off</span></span><br /></pre></td></tr></table><p>依然是只需要关注我们所关心的配置即可。一个是<code>branches</code>，一个是<code>build_script</code>。有了<code>Travis-CI</code>的<code>.travis.yml</code>的经验，我相信你也能很快理解它。</p><p>经过上述配置之后，你已经实现了一个简单的前端工程的自动化构建推送流程了。而今你只需要关注代码提交，应用的构建都将会由CI系统自动帮你完成。当然CI系统也不仅仅是拿来构建electron应用的，正如你所见的，你能想到的其他项目的构建、测试其实它都能帮你通过预定义好的脚本完成。</p><h3><a href="https://molunerfinn.com/electron-vue-5/#发布Release"></a>发布Release</h3><p>当CI构建玩应用，会将其推送到你的GitHub的release页面成为一个<code>draf</code>（草稿），你可以编辑这个草稿，加上标题和更新说明，就可以点击<code>publish</code>发布你的新版本的应用啦。</p><h2><a href="https://molunerfinn.com/electron-vue-5/#electron应用的更新"></a>electron应用的更新</h2><p>electron应用的自动更新其实社区有很好的解决方案<a href="https://github.com/electron-userland/electron-builder/tree/master/packages/electron-updater" target="_blank">electron-updater</a>。而electron-vue也在主进程的<code>main/index.js</code>里预先帮我们写好了一段注释的代码：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span>// import { autoUpdater } from 'electron-updater'</span></span><br /><span></span><br /><span><span>// autoUpdater.on('update-downloaded', () =&gt; {</span></span><br /><span><span>//   autoUpdater.quitAndInstall()</span></span><br /><span><span>// })</span></span><br /><span></span><br /><span><span>// app.on('ready', () =&gt; {</span></span><br /><span><span>//   if (process.env.NODE_ENV === 'production') {</span></span><br /><span><span>//     autoUpdater.checkForUpdates()</span></span><br /><span><span>//   }</span></span><br /><span><span>// }</span></span><br /></pre></td></tr></table><p>只要引入autoUpdater就能自动帮我们检查更新和自动下载安装更新。不过，凡事都有不过。这个方式虽然很简单，但是它需要的条件比较严格，需要你拥有证书用于应用签名。而macOS平台下的证书需要你申请开发者，一年99$的费用让我望而却步。</p><p>于是我只能退而求其次，能不能通过查询GitHub的release版本号，来比对当前版本，是否需要更新，并提醒用户呢？经过尝试，发现可行。我的实现方法如下:</p><p>我首先写了一个<code>updateChecker</code>的助手：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /></pre></td><td><pre><span><span>import</span> { dialog, shell } <span>from</span> <span>'electron'</span></span><br /><span><span>import</span> db <span>from</span> <span>'../../datastore'</span></span><br /><span><span>import</span> axios <span>from</span> <span>'axios'</span></span><br /><span><span>import</span> pkg <span>from</span> <span>'../../../package.json'</span></span><br /><span><span>const</span> version = pkg.version</span><br /><span><span>const</span> release = <span>'https://api.github.com/repos/Molunerfinn/PicGo/releases/latest'</span></span><br /><span><span>const</span> downloadUrl = <span>'https://github.com/Molunerfinn/PicGo/releases/latest'</span></span><br /><span></span><br /><span><span>const</span> checkVersion = <span>async</span> () =&gt; {</span><br /><span>  <span>let</span> showTip = db.read().get(<span>'picBed.showUpdateTip'</span>).value()</span><br /><span>  <span>if</span> (showTip === <span>undefined</span>) {</span><br /><span>    db.read().set(<span>'picBed.showUpdateTip'</span>, <span>true</span>).write()</span><br /><span>    showTip = <span>true</span></span><br /><span>  }</span><br /><span>  <span>// 自动更新的弹窗如果用户没有设置不再提醒，就可以去查询是否需要更新</span></span><br /><span>  <span>if</span> (showTip) {</span><br /><span>    <span>const</span> res = <span>await</span> axios.get(release)</span><br /><span>    <span>if</span> (res.status === <span>200</span>) {</span><br /><span>      <span>const</span> latest = res.data.name <span>// 获取版本号</span></span><br /><span>      <span>const</span> result = compareVersion2Update(version, latest) <span>// 比对版本号，如果本地版本低于远端则更新</span></span><br /><span>      <span>if</span> (result) {</span><br /><span>        dialog.showMessageBox({</span><br /><span>          type: <span>'info'</span>,</span><br /><span>          title: <span>'发现新版本'</span>,</span><br /><span>          buttons: [<span>'Yes'</span>, <span>'No'</span>],</span><br /><span>          message: <span>'发现新版本，更新了很多功能，是否去下载最新的版本？'</span>,</span><br /><span>          checkboxLabel: <span>'以后不再提醒'</span>,</span><br /><span>          checkboxChecked: <span>false</span></span><br /><span>        }, (res, checkboxChecked) =&gt; {</span><br /><span>          <span>if</span> (res === <span>0</span>) { <span>// if selected yes</span></span><br /><span>            shell.openExternal(downloadUrl)</span><br /><span>          }</span><br /><span>          db.read().set(<span>'picBed.showUpdateTip'</span>, !checkboxChecked).write()</span><br /><span>        })</span><br /><span>      }</span><br /><span>    } <span>else</span> {</span><br /><span>      <span>return</span> <span>false</span></span><br /><span>    }</span><br /><span>  } <span>else</span> {</span><br /><span>    <span>return</span> <span>false</span></span><br /><span>  }</span><br /><span>}</span><br /><span></span><br /><span><span>// if true -&gt; update else return false</span></span><br /><span><span>const</span> compareVersion2Update = <span>(<span>current, latest</span>) =&gt;</span> {</span><br /><span>  <span>const</span> currentVersion = current.split(<span>'.'</span>).map(<span><span>item</span> =&gt;</span> <span>parseInt</span>(item))</span><br /><span>  <span>const</span> latestVersion = latest.split(<span>'.'</span>).map(<span><span>item</span> =&gt;</span> <span>parseInt</span>(item))</span><br /><span>  <span>let</span> flag = <span>false</span></span><br /><span></span><br /><span>  <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; <span>3</span>; i++) {</span><br /><span>    <span>if</span> (currentVersion[i] &lt; latestVersion[i]) {</span><br /><span>      flag = <span>true</span></span><br /><span>    }</span><br /><span>  }</span><br /><span></span><br /><span>  <span>return</span> flag</span><br /><span>}</span><br /><span></span><br /><span><span>export</span> <span>default</span> checkVersion</span><br /></pre></td></tr></table><p>然后在<code>main/index.js</code>里，我在app准备启动的时候，调用这个更新助手：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>// ...</span></span><br /><span><span>import</span> uploader <span>from</span> <span>'./utils/uploader.js'</span></span><br /><span></span><br /><span>app.on(<span>'ready'</span>, () =&gt; {</span><br /><span>  <span>// ...</span></span><br /><span>  updateChecker()</span><br /><span>  <span>// ...</span></span><br /><span>})</span><br /></pre></td></tr></table><p>这样就能在启动应用的时候弹出更新提示：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fqqbm19ptvj20nc08swf7" /></p><h2><a href="https://molunerfinn.com/electron-vue-5/#总结"></a>总结</h2><p>本文简要地讲述了electron应用用上CI系统帮我们自动化构建和推送，以及在没有申请开发者，没有证书用于应用的代码签名的情况下如何告知用户进行应用更新。要做一个健壮的应用就应该考虑到应用的版本发布、版本更新和对用户的更新通知。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
        
        <summary type="html">
            
            前言前段时间，我用electron-vue开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习e
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>如何入门产品设计</title>
        <link href="https://byrio.org/how-to-product-design/"/>
        <id>https://byrio.org/how-to-product-design/</id>
        
        <author>
            <name>cengxu</name>
        </author>
        
        <published>2018-04-23T10:43:47+00:00</published>
        <updated>2018-04-23T10:43:47+00:00</updated>
        
        <content type="html"><![CDATA[<p><code>版本 201804</code></p>
<blockquote><p>Muji 不是卖产品，而是卖人生的 8000 种角色。它帮助人们拥有一个每天快乐多一点的人生。</p></blockquote>
<p>产品设计的终极目标，就是去理解人们对幸福以及满足的追求。</p>
<h2>介绍篇</h2>
<h3>产品设计是什么</h3>
<p>产品就是东西。设计是对事物进行构想创新或者改良再造，把想法和创意落地的过程。</p>
<h3>产品设计在做什么</h3>
<p>产品设计主要分为工业产品设计和互联网产品设计两大类：</p>
<ol>
<li><strong>工业产品设计（Industrial Design）：常指对实体可见产品进行设计，以工学、美学为主要基础学科。</strong>举个例子，生活中所有可见的产品，小到一只钢笔，大到一辆汽车都是经过了从草图到模型再到实体，数次迭代的周密工业设计流程而产出的成果。</li>
<li><strong>互联网产品设计：基于移动网络发展，为适应人们生活和多方面需求而顺应时代潮流产生的电子产品。</strong>包括各大门户或应用网站、手/端游、手机 App 等。比如说：王者荣耀属于互联网行业中的一款产品，而它的创意策划、前期调研、可用性评估及产品更新都是产品设计的部件（各自处于设计周期的位置可能不一样）。</li>
</ol>
<h3>辨析：产品设计、交互设计、服务设计、体验设计</h3>
<p><span></span></p>
<ol>
<li>一句话来说就是“<strong>产品基于物质，服务针对非物质，而体验看重情感，交互则是人机沟通的过程</strong>”。</li>
<li>服务设计和体验设计近几年的兴起，说明了大众已经不局限于功能的完善、需求的解决本身。从有形的产品到无形的服务，用户体验开始变成核心竞争力。User-centered（以用户为中心），Co-creative（协同创造），PSSD（产品服务系统设计）……从这些名词的侵入中也可窥见一斑。</li>
<li>产品就像根基，没有可以承载服务和体验的产品，大部分人性化设计都是空谈。星巴克卖的不是咖啡，是坐在那里有网能谈事儿的服务。但前提依旧是：星巴克，卖咖啡。</li>
<li>而交互设计往往与用户体验挂钩，为什么用户使用这个功能的时候老是点错键，老是找不到下一界面的入口？这就是交互设计的理性和科学态度，好的人机交互是完美用户体验的必要条件。</li>
</ol>
<h2>进阶篇</h2>
<h3>产品设计需要什么</h3>
<h4>产品思维</h4>
<p>用产品的思维看世界。从此之后，看灯光开关不能只看有几个，听网易云音乐不能只看评论，打绝地求生也不能只顾着吃鸡。去关注表象背后的事情，为什么四个按钮经常开错灯？为什么网易云的“我喜爱的音乐”层级藏的这么深？游戏里的各项设置是否符合人的现实行动模型并且合理？</p>
<p>只有想得够多，才能发现问题，才足够提升创想的能力（常常去对生活中的事情提问，会发现是一件极趣的事情）。</p>
<h4>用户思维</h4>
<p>站在用户角度做设计。关于 UCD ，观点并没有达到完全一致。</p>
<ol>
<li>一种观点是认为产品不是做给自己或者创造团队用的，所以需要以大众审美以及需求为核心导向。这也就体现了产品前期调研的重要性（市场背景、用户调研（辅助数据分析）、竞品分析、需求功能到信息架构的得出）。</li>
<li>而另一种看法则是，用户缺少设计的专业性，从时效以及结果来看都不是最好的选择。并且设计师要有自己的设计价值，不能被用户的需求牵着鼻子走。</li>
<li>但随着协同创造的大势发展，设计师变成了设计过程的组织者和协调者，以不同方式牵涉其中的用户（使用、实验、共同创造）都是解决方案的代理人，本质上并不存在所谓的“终端用户”。</li>
</ol>
<h4>情感思维</h4>
<p>这一点常见于艺术思维，因为艺术家靠作品中传递的情感去打动普通人。人性化、同理心、 User Experience 是互联网产品的核心关键词。如何让电子产品有温度，这一点强烈安利网易云音乐的多个案例，年终数据歌单的刷屏正是因为触及了用户的G点，人们愿意为此买单。所以好的产品设计是自带溢价运营效果的。</p>
<h2>学习建议&amp;干货</h2>
<h4>设计工具的选取和运用</h4>
<p>如果说设计区别于艺术的话，理性是很大的一个分水岭。以 IEDO 设计公司为例，许多专业的设计方法和思维都在努力使设计更科学。如何以理工科的思维做好设计，工具的学习和应用应该是我们的强项。</p>
<h4>思维复盘、展示复刻</h4>
<p>选取经典产品，从功能模块、交互设计等大的维度上去寻找它迭代的思路和原因；在设计表现上，可以从模仿开始，先学会基本技巧，再自我创造。</p>
<h4>多读书、多思考</h4>
<p>产品设计不同于平面设计、视觉设计的一点在于，它更看重你对产品的敏锐度以及痛点、需求挖掘。而这背后与市场、传播、经济的牵扯会比较多。所以用不同类型的书籍去开阔自己的思维层次是很好的一个方法。</p>
<h4>紧跟时代潮流</h4>
<p>可持续设计、人本设计、产业创新交叉某种程度上被认为是现在的设计前沿和中心。那二十年后又是什么呢？</p>
<h3>参考书目</h3>
<ol>
<li>、思维类
<ol>
<li>《设计中的设计》原研哉</li>
<li>《设计心理学》《情感化设计》唐纳德·罗曼</li>
<li>《设计方法论》柳冠中</li>
<li>《新兴实践》娄永琪、马瑾整理</li>
</ol>
</li>
<li>方法类
<ol>
<li>《设计方法与策略·代尔夫特设计指南》</li>
<li>《通用设计法则》</li>
</ol>
</li>
<li>交互类
<ol>
<li>《用户体验度量》</li>
<li>《认知与设计·理解UI设计准则》</li>
<li>《ABOUT FACE4·交互设计精髓》</li>
</ol>
</li>
</ol>
<h2>现实篇</h2>
<h3>学在北邮</h3>
<p>北邮数字媒体与设计艺术学院开设有工业设计专业，虽然名称很工业，但其实学习课程主要分为传统工业产品和信息交互两大模块。核心专业课如下：</p>
<ul>
<li>工业产品：产品结构，造型材料与工艺，设计方法与分析，</li>
<li>信息交互：可用性测试，交互设计，人机工程</li>
</ul>
<h3>研究生相关院校及专业推荐</h3>
<p>介于了解程度，暂不包含国外院校。</p>
<ol>
<li>传统工业设计类： 湖南大学、 江南大学、清华大学、浙江大学</li>
<li>信息交互设计类：
<ol>
<li><a href="http://www.tsinghua.edu.cn/publish/ad2888/2017/20170922155152162111645/20170922155152162111645_.html">清华大学美术学院·信息艺术设计（交叉学科）</a></li>
<li><a href="http://sdmda.bupt.edu.cn/?cat=21">北京邮电大学-信息与交互设计研究</a></li>
<li><a href="http://tjdi.tongji.edu.cn/about.do?ID=31">同济大学</a></li>
</ol>
</li>
</ol>
<p>21世纪的我们拥有知乎、豆瓣、得到这些知识社区真的是感谢伟大的产品设计师们！所以，去恰逢其时地各取其所，入门从此刻已经开始。</p>
<p><a href="https://byrio.org/how-to-product-design/">如何入门产品设计</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            版本 201804 Muji 不是卖产品，而是卖人生的 8000 种角色。它帮助人们拥有一个每天快乐多一点的人生。 产品设计的终极目标，就是去理解人们对幸福以及满足的追求。 介绍篇 产品设计是什么 产品就是东西。设计是对事物进行构想创新或者改良再造，把想法和创意落地的过程。 产
            
        </summary>
        
        <category term="如何入门"/>
        
    </entry>
    
    <entry>
        <title>BYRIO::helloWorld()</title>
        <link href="https://byrio.org/hello-world-alpha/"/>
        <id>https://byrio.org/hello-world-alpha/</id>
        
        <author>
            <name>dimpurr</name>
        </author>
        
        <published>2018-04-23T08:00:16+00:00</published>
        <updated>2018-04-23T08:00:16+00:00</updated>
        
        <content type="html"><![CDATA[<p>你好， BYRIOSC ，北邮学生互联网与开源社区！ BYRIOSC 社区尚处于初生阶段，需要你的支持和参与！</p>
<h3><code>__meta__</code></h3>
<p>BYRIOSC 是一个围绕互联网技术与开源文化，主题涵盖科技、开发、设计、媒体，由开发者和创意工作者组成的线上交流、线下活动的学生社区。 我们力求吸引富有热情和兴趣的开发者、创造者们加入，凝聚北邮各大学生技术组织的力量，建设成为最富有活力和创造力的学生技术社区。</p>
<h3><code>toStudents()</code></h3>
<p>欢迎来到 BYRIOSC 。在这里，你可以发现同好伙伴，交流技术话题，找到学习路线，参与项目实践和获得更多的机会。立刻： </p>
<ul>
<li>加入我们的 QQ 群 (NzUzMTExMzI2, Base64) 或者 Telegram 群 (<a href="https://t.me/byriosc"><a href="https://t.me/byriosc">https://t.me/byriosc</a></a>) 并参与讨论！ </li>
<li>在<a href="https://byrio.org/comments">留言板</a>留下你想说的话！ </li>
<li>阅读 <a href="https://byrio.org/category/how-to/">如何入门</a> 一门技术的文章，开始学习并加入对应的 <a href="https://wiki.byrio.org/books/byriosc/chapter/兴趣小组">兴趣小组</a> 。 </li>
<li>在 <a href="https://wiki.byrio.org/books/byrio/page/circle-idea">BYRCIRCLE</a> 拥有你的个人页、标记你的技能点和参与项目的意愿，认识前辈和技术同好，并在 <a href="https://wiki.byrio.org/books/byrio/page/circle-idea">BYRIDEA</a> 提出想法、组队实现或者参加竞赛。 – 在 BYRCAFE 一览最新的活动资讯和技术干货、北邮人论坛讨论和各大校内学生组织的公众号内容聚合精选（建设中）。 </li>
<li>在 <a href="https://planet.byr.moe">BYRPLANT</a> 博客圈阅读社区成员的文章，或者 <a href="https://planet.byr.moe">登记你自己的个人主页和博客</a> 以便我们收录。 </li>
<li>在 <a href="https://wiki.byrio.org">BYRWIKI</a> 了解北邮学生活动的历史、创新和创业文化以及技术类学生组织和社团，并参与其中（建设中）。 如果你有能力，并想参与我们的项目开发或者社区建设，欢迎： </li>
<li>阅读我们的 <a href="https://wiki.byrio.org/books/byriosc/chapter/项目小组">项目小组</a> 列表 ，选择你有兴趣的项目并联系负责人加入。 </li>
<li>阅读我们的 <a href="https://wiki.byrio.org/books/byriosc/page/社区宣言">社区宣言</a> 和 <a>组织结构</a> 文档，参与讨论、提供建议，或者成为社区负责人的一员。</li>
</ul>
<h3><code>toOrganizations()</code></h3>
<p>我们欢迎各类具有技术和创意性质的学生组织，加入北邮学生互联网与开源联盟成为成员组织，或者校外的技术和开源社区与我们合作。 </p>
<ul>
<li>在 BYRWIKI 拥有自己的组织介绍书，记录自己的历史、发展和产出成果。 </li>
<li>利用 BYRIOSC 联盟平台和其他组织共享人才和资源、联合举办活动。 – 利用 BYRIOSC 的学习引导基础设施培养新人，补充新鲜血液。 </li>
<li>利用 BYRIOSC 富有活力的社区招募优秀人才、利用 BYRIOSC 的媒体和信息渠道曝光和宣传。 请联系我们的社区负责人讨论具体事宜，北邮的学生技术文化发展的需要凝聚所有方向一致的力量！</li>
</ul>
<h3><code>@import how-to</code></h3>
<p>从这里开始了解你感兴趣的技术方向并深入学习，或者阅读 <a href="https://byrio.org/how-to-write-how-to/">如何撰写「如何入门」系列文章</a> 成为投稿作者！ </p>
<ul>
<li>技术、开发与互联网 </li>
<li><a href="https://byrio.org/how-to-machine-learning/">如何入门机器学习</a> </li>
<li><a href="https://byrio.org/how-to-frontend/">如何入门前端</a>– 媒体、设计与创意 </li>
<li><a href="https://byrio.org/how-to-illustrate/">如何入门绘画 </a> </li>
<li><a href="https://byrio.orghow-to-video-clip/">如何入门视频剪辑</a> </li>
<li><a href="https://byrio.org/how-to-product-design/">如何入门产品设计</a></li>
</ul>
<p><a href="https://byrio.org/hello-world-alpha/">BYRIO::helloWorld()</a> 原载于 <a href="https://byrio.org">BYRIO</a> 。</p>]]></content>
        
        <summary type="html">
            
            你好， BYRIOSC ，北邮学生互联网与开源社区！ BYRIOSC 社区尚处于初生阶段，需要你的支持和参与！ __meta__ BYRIOSC 是一个围绕互联网技术与开源文化，主题涵盖科技、开发、设计、媒体，由开发者和创意工作者组成的线上交流、线下活动的学生社区。 我们力求吸
            
        </summary>
        
        <category term="社区讨论"/>
        
    </entry>
    
    <entry>
        <title>浅谈前后端路由与前后端渲染</title>
        <link href="https://molunerfinn.com/fe-be-router-render/"/>
        <id>https://molunerfinn.com/fe-be-router-render/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<p>最近经常会遇到有人问诸如类似下面的问题：</p><ul><li>为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了<code>/</code>的页面呢</li><li>为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢</li><li>啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢</li></ul><p>这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。</p><p>老手可以绕道，去看些更有用的文章吧~</p><a></a><h2><a href="https://molunerfinn.com/fe-be-router-render/#什么是路由"></a>什么是路由</h2><p><a href="https://zhuanlan.zhihu.com/p/24814675" target="_blank">理解Web路由</a>这篇文章讲得特别好了。</p><blockquote><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p></blockquote><p>访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。</p><h2><a href="https://molunerfinn.com/fe-be-router-render/#从后端路由讲起"></a>从后端路由讲起</h2><p>在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入<code>www.baidu.com</code>到你看到网页这个过程中经历了什么」其实讲的也是这个道理。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fproibqucxj20lu03odg9.jpg" /></p><p>在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个<code>404</code>状态码。这也是我们常说的<code>404 NOT FOUND</code>的由来。</p><h3><a href="https://molunerfinn.com/fe-be-router-render/#URL与Methods"></a>URL与Methods</h3><p>如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。</p><blockquote><p>它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong> ——来自阮一峰<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank">《理解RESTful架构》</a></p></blockquote><p>虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以<code>GET</code>请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：</p><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>router.post(<span>'/user/:id'</span>, addUser)</span><br /></pre></td></tr></table><p>假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：<code>http://xxx.com/user/123</code>的话是无法访问到的，也会返回一个404。因为后端只配了一个<code>post</code>方法的路由。如果要接受这个请求，那么必须有如下的路由：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>router.get(<span>'/user/:id'</span>, getUser) <span>// 配置get路由</span></span><br /><span>router.post(<span>'/user/:id'</span>, addUser)</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/fe-be-router-render/#后端路由与服务端渲染"></a>后端路由与服务端渲染</h3><p>前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。</p><p>如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的<strong>服务端渲染</strong>。</p><p>服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。</p><p>node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。</p><p>不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。</p><p>于是，我们开始进入了前端路由的时代。</p><h2><a href="https://molunerfinn.com/fe-be-router-render/#过渡到前端路由"></a>过渡到前端路由</h2><p>前端路由——顾名思义，<strong>页面跳转的URL规则匹配</strong>由前端来控制。而前端路由主要是有两种显示方式：</p><ul><li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li><li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li></ul><p>前端路由应用最广泛的例子就是当今的SPA的web项目。不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。</p><h3><a href="https://molunerfinn.com/fe-be-router-render/#前端路由与前端渲染"></a>前端路由与前端渲染</h3><p>讲前端路由就不能不说前端渲染。我以Vue项目为例。如果你是用官方的<code>vue-cli</code>搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有<code>button</code>有<code>form</code>的样子么？我想不是的。在生产模式下，你看看构建出来的<code>index.html</code>长什么样：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /></pre></td><td><pre><span><span>&lt;!DOCTYPE <span>html</span>&gt;</span></span><br /><span><span>&lt;<span>html</span> <span>lang</span>=<span>"en"</span>&gt;</span></span><br /><span><span>&lt;<span>head</span>&gt;</span></span><br /><span>  <span>&lt;<span>meta</span> <span>charset</span>=<span>"UTF-8"</span>&gt;</span></span><br /><span>  <span>&lt;<span>title</span>&gt;</span>Vue<span>&lt;/<span>title</span>&gt;</span></span><br /><span><span>&lt;/<span>head</span>&gt;</span></span><br /><span><span>&lt;<span>body</span>&gt;</span></span><br /><span>  <span>&lt;<span>div</span> <span>id</span>=<span>"app"</span>&gt;</span><span>&lt;/<span>div</span>&gt;</span></span><br /><span>  <span>&lt;<span>script</span> <span>type</span>=<span>"text/javascript"</span> <span>src</span>=<span>"xxxx.xxx.js"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></span><br /><span>  <span>&lt;<span>script</span> <span>type</span>=<span>"text/javascript"</span> <span>src</span>=<span>"yyyy.yyy.js"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></span><br /><span>  <span>&lt;<span>script</span> <span>type</span>=<span>"text/javascript"</span> <span>src</span>=<span>"zzzz.zzz.js"</span>&gt;</span><span>&lt;/<span>script</span>&gt;</span></span><br /><span><span>&lt;/<span>body</span>&gt;</span></span><br /><span><span>&lt;/<span>html</span>&gt;</span></span><br /></pre></td></tr></table><p>通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个<code>&lt;div id="app"&gt;&lt;/div&gt;</code>这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fproyjjjlij20jg03oq3a.jpg" /></p><p>前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。</p><p>需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。</p><h4><a href="https://molunerfinn.com/fe-be-router-render/#Hash模式"></a>Hash模式</h4><p>hash模式利用的是浏览器不会对<code>#</code>号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：<code>http://localhost/#/user/1</code>和<code>http://localhost/</code>其实到服务端都是去请求<code>http://localhost</code>这个页面的内容。</p><p>而前端的router库通过捕捉<code>#</code>号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回<code>http://localhost</code>对应的html，剩下具体是哪个页面，就由前端路由去判断便可。</p><h4><a href="https://molunerfinn.com/fe-be-router-render/#History模式"></a>History模式</h4><p>不带<code>#</code>号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank">history</a>这个api。比如<code>history.pushState()</code>可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。</p><p>上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是<code>history.pushState()</code>这个api，所以跟后端没什么关系。但是<strong>一旦你从浏览器地址栏里输入一个地址，比如<code>http://localhost/user/1</code></strong>,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。</p><p>那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为<code>vue-cli</code>在开发模式下帮你启动的那个<code>express</code>开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过<code>vue-cli</code>都帮你配置好了，所以你就不用手动配置了。</p><p>那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank">配置例子</a>。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个<code>index.html</code>返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了<code>http://localhost/user/1</code>这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器<code>index.html</code>。</p><p>浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。</p><p>当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。</p><h2><a href="https://molunerfinn.com/fe-be-router-render/#前端路由与服务端渲染"></a>前端路由与服务端渲染</h2><p>虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。</p><p>当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。</p><p>关于预渲染，可以考虑使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank">prerender-spa-plugin</a>这个webapck的插件，它的3.x版本开始使用<strong>puppeteer</strong>来构建html文件了。</p><h2><a href="https://molunerfinn.com/fe-be-router-render/#前后端分离"></a>前后端分离</h2><p>得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。</p><p>前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。撒花~</p><h2><a href="https://molunerfinn.com/fe-be-router-render/#总结"></a>总结</h2><p>希望通过此文能够让你对于前后端路由和前后端渲染有所了解。在实际开发的过程中，也不应该仅仅关注于自己所在的领域，相关的领域也要有所涉猎，这样才能面对问题游刃有余。</p><blockquote><p>注：文中的图我使用OmniGraffle制作。转载请注明作者！</p></blockquote>]]></content>
        
        <summary type="html">
            
            最近经常会遇到有人问诸如类似下面的问题：为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了/的页面呢为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢这个问题是很多初
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="后端"/>
        
        <category term="笔记"/>
        
    </entry>
    
    <entry>
        <title>Electron-vue开发实战3——跨平台的一些兼容措施</title>
        <link href="https://molunerfinn.com/electron-vue-4/"/>
        <id>https://molunerfinn.com/electron-vue-4/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/electron-vue-4/#前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2><a href="https://molunerfinn.com/electron-vue-4/#说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a></a><h2><a href="https://molunerfinn.com/electron-vue-4/#跨平台的重要性"></a>跨平台的重要性</h2><p>虽然electron在大多数情况下的跨平台措施已经帮我们做得很好了。不过需要注意的是，不同平台必然存在细节上的差异。我们在书写跨平台应用的时候，如果只在自己书写平台下测试通过的话是不足以说明我们的应用是健壮的。（当然如果你只想提供给某个平台那另当别论）所以针对不同的发布平台，就需要做一些兼容性措施。</p><p>就我自己的感受而言，macOS平台支持的特性相对比较多，而这里面又很多是独有的，所以很多能在macOS上实现的功能却不一定能在windows上实现。所以对于windows用户而言，在保证整体应用的可用性的情况下，就有可能要相应地做一些妥协和牺牲。不过在windows上的一些操作习惯也可以反过来服务于macOS平台。这点我会在下面给出一个例子详细说明。</p><h2><a href="https://molunerfinn.com/electron-vue-4/#留意不同平台的独有功能"></a>留意不同平台的独有功能</h2><p>在开发electron应用的时候，很多时候我们只注意去查找api名，却容易忽视这个api能够使用的平台。在官方文档里，对于一些独占的api，大多都会有标识标出：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fpifmc1muoj21mo0ti0wa.jpg" /></p><p>不过需要注意的是一些未有平台标识的api里的配置项，也有可能是某个平台的独占：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fpifrhg1r8j21k804w0tt.jpg" /></p><p>平时开发的过程中，用到文档的地方还是需要细细留心，避免后续不必要的麻烦。</p><h2><a href="https://molunerfinn.com/electron-vue-4/#跨平台措施入门"></a>跨平台措施入门</h2><p>上面讲了这么多，该到实例的时候了。在electron应用中，通常来说<code>renderer</code>进程的东西不需要做太多的跨平台措施——毕竟不管是哪个平台，都是跑在Chrome里的页面。所以大多数情况下，这个方面的工作会放在<code>main</code>进程里。不过也有例外：</p><h3><a href="https://molunerfinn.com/electron-vue-4/#title-bar的操作区处理"></a>title-bar的操作区处理</h3><p>下面是PicGo的windows版：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fpig60gzw6j20m80ciwf1.jpg" /></p><p>下面是PicGo的macOS版：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fpig71431kj218g0p0tav.jpg" /></p><p>可以发现除了颜色有些区别之外，顶部的<code>title-bar</code>操作栏也有些区别。macOS的程序窗口习惯将窗口的缩放、关闭按钮放在窗口的左上角。而windows程序则相反，它们喜欢放在窗口的右上角。所以为了迎合用户的操作习惯，我们在开发electron程序的时候也应该注意到这一点。</p><p>当然，如果是通过普通的<code>BrowserWindow</code>创建的窗口，那么将会自动拥有常见的macOS、windows的顶部栏，以及默认的样式。</p><p>我在这里想说的是如果想要更加美观的界面，通常我们喜欢「沉浸式」的顶部栏。对于macOS而言，沉浸式的顶部栏就是将顶部栏的三个操作按钮直接「嵌入」窗口主题的左上角。而对于windows而言，只能删去顶部的三个操作按钮，自己用前端的方式来实现了。所以这个地方两个平台的差异性就出来了。</p><p>在<code>main</code>进程里创建该窗口的时候，主要代码如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /></pre></td><td><pre><span><span>const</span> createSettingWindow = <span><span>()</span> =&gt;</span> {</span><br /><span>  <span>const</span> options = {</span><br /><span>    height: <span>450</span>,</span><br /><span>    width: <span>800</span>,</span><br /><span>    show: <span>false</span>, <span>// 当window创建的时候不用打开</span></span><br /><span>    center: <span>true</span>,</span><br /><span>    fullscreenable: <span>false</span>,</span><br /><span>    resizable: <span>false</span>,</span><br /><span>    title: <span>'PicGo'</span>,</span><br /><span>    vibrancy: <span>'ultra-dark'</span>, <span>// 窗口模糊的样式</span></span><br /><span>    transparent: <span>true</span>,</span><br /><span>    titleBarStyle: <span>'hidden'</span>, <span>// title-bar的样式——隐藏顶部栏的横条，把操作按钮嵌入窗口</span></span><br /><span>    webPreferences: {</span><br /><span>      backgroundThrottling: <span>false</span></span><br /><span>    }</span><br /><span>  }</span><br /><span>  <span>if</span> (process.platform === <span>'win32'</span>) { <span>// 如果平台是win32，也即windows</span></span><br /><span>    options.show = <span>true</span> <span>// 当window创建的时候打开</span></span><br /><span>    options.frame = <span>false</span> <span>// 创建一个frameless窗口，详情：https://electronjs.org/docs/api/frameless-window</span></span><br /><span>    options.backgroundColor = <span>'#3f3c37'</span></span><br /><span>  }</span><br /><span>  settingWindow = <span>new</span> BrowserWindow(options)</span><br /><span></span><br /><span>  settingWindow.loadURL(settingWinURL)</span><br /><span></span><br /><span>  settingWindow.on(<span>'closed'</span>, () =&gt; {</span><br /><span>    settingWindow = <span>null</span></span><br /><span>  })</span><br /><span>}</span><br /></pre></td></tr></table><p>主要的工具是通过<code>process.platform</code>来判断不同的平台。当前可能的值有：</p><ul><li>‘aix’</li><li>‘darwin’</li><li>‘freebsd’</li><li>‘linux’</li><li>‘openbsd’</li><li>‘sunos’</li><li>‘win32’</li></ul><p>在这里我们基本上只需要关心<code>darwin</code>（macOS）、<code>win32</code>（windows）、<code>linux</code>（Linux）这三个平台即可。注意，由于electron的对于<code>renderer</code>进程的加持，在<code>renderer</code>进程里也能直接使用<code>process.platform</code>来判断当前的操作系统。这是一个很方便的特性。</p><p>针对windows平台，由于采用了<a href="https://electronjs.org/docs/api/frameless-window" target="_blank">frameless-window</a>，所以我们需要手动「绘制」顶部的缩放和关闭按钮，并配上相应的事件来模拟真实的按钮。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span>&lt;<span>div</span> <span>class</span>=<span>"fake-title-bar"</span>&gt;</span></span><br /><span>  PicGo - {{ version }}</span><br /><span>  <span>&lt;<span>div</span> <span>class</span>=<span>"handle-bar"</span> <span>v-if</span>=<span>"process.platform === 'win32'"</span>&gt;</span><span>&lt;!-- 如果是windows平台 --&gt;</span></span><br /><span>    <span>&lt;<span>i</span> <span>class</span>=<span>"el-icon-minus"</span> @<span>click</span>=<span>"minimizeWindow"</span>&gt;</span><span>&lt;/<span>i</span>&gt;</span></span><br /><span>    <span>&lt;<span>i</span> <span>class</span>=<span>"el-icon-close"</span> @<span>click</span>=<span>"closeWindow"</span>&gt;</span><span>&lt;/<span>i</span>&gt;</span></span><br /><span>  <span>&lt;/<span>div</span>&gt;</span></span><br /><span><span>&lt;/<span>div</span>&gt;</span></span><br /></pre></td></tr></table><p>相应的事件如下：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>minimizeWindow () {</span><br /><span>  <span>const</span> <span>window</span> = BrowserWindow.getFocusedWindow()</span><br /><span>  <span>window</span>.minimize()</span><br /><span>},</span><br /><span>closeWindow () {</span><br /><span>  <span>const</span> <span>window</span> = BrowserWindow.getFocusedWindow()</span><br /><span>  <span>window</span>.close()</span><br /><span>},</span><br /></pre></td></tr></table><p>简单来说就是调用了<code>BrowserWindow</code>的方法来获取当前激活的窗口，然后再对这个窗口进行缩小或关闭的操作。其实也不难对吧！</p><h3><a href="https://molunerfinn.com/electron-vue-4/#任务栏图标交互"></a>任务栏图标交互</h3><p>针对不同的平台，我对PicGo的任务栏图标交互也有所区别。对于macOS而言，点击顶部菜单栏的时候会弹出一个小窗口：</p><p><img src="https://blog-1251750343.cos.ap-beijing.myqcloud.com/8700af19ly1fma907llb5j20m30ed46a" /></p><p>由于macOS的顶部栏图标可以接受拖拽事件，所以就针对macOS的顶部栏制作了顶部栏图标对应的小窗口。让大部分操作不经过主窗口也能实现。而对于windows而言，没有顶部栏，取而代之的是位于底部栏的右侧的任务栏，通常点击任务栏里的图标就会把应用的主窗口调出来。所以为了迎合不同平台的操作习惯，我对于这个地方也做了相应的兼容性适配：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /></pre></td><td><pre><span>tray.on(<span>'click'</span>, () =&gt; { <span>// 不管是顶部栏的图标还是任务栏的图标都是Tray组件生成的</span></span><br /><span>  <span>if</span> (process.platform === <span>'darwin'</span>) { <span>// 如果是macOS平台</span></span><br /><span>    <span>let</span> img = clipboard.readImage()</span><br /><span>    <span>let</span> obj = []</span><br /><span>    <span>if</span> (!img.isEmpty()) {</span><br /><span>      <span>// 从剪贴板来的图片默认转为png</span></span><br /><span>      <span>const</span> imgUrl = <span>'data:image/png;base64,'</span> + Buffer.from(img.toPNG(), <span>'binary'</span>).toString(<span>'base64'</span>)</span><br /><span>      obj.push({</span><br /><span>        width: img.getSize().width,</span><br /><span>        height: img.getSize().height,</span><br /><span>        imgUrl</span><br /><span>      })</span><br /><span>    }</span><br /><span>    toggleWindow() <span>// 打开小窗口</span></span><br /><span>    setTimeout(<span><span>()</span> =&gt;</span> {</span><br /><span>      <span>window</span>.webContents.send(<span>'clipboardFiles'</span>, obj)</span><br /><span>    }, <span>0</span>)</span><br /><span>  } <span>else</span> {</span><br /><span>    <span>window</span>.hide()</span><br /><span>    <span>if</span> (settingWindow === <span>null</span>) { <span>// 如果主窗口未创建</span></span><br /><span>      createSettingWindow() <span>// 创建</span></span><br /><span>      settingWindow.show() <span>// 并打开</span></span><br /><span>    } <span>else</span> {</span><br /><span>      settingWindow.show() <span>// 如果已存在，打开</span></span><br /><span>      settingWindow.focus() <span>// 并激活</span></span><br /><span>    }</span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><h3><a href="https://molunerfinn.com/electron-vue-4/#窗口关闭与应用退出"></a>窗口关闭与应用退出</h3><p>在windows平台上，通常我们把应用的窗口都关了之后也就默认把这个应用给退出了。而如果在macOS系统上却不是这样。我们把应用的窗口关闭了，但是并非完全退出这个应用。所以为了实现这个操作习惯，我们也可以增加一个情况判断：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>app.on(<span>'window-all-closed'</span>, () =&gt; { <span>// 当窗口都被关闭了</span></span><br /><span>  <span>if</span> (process.platform !== <span>'darwin'</span>) { <span>// 如果不是macOS</span></span><br /><span>    app.quit() <span>// 应用退出</span></span><br /><span>  }</span><br /><span>})</span><br /></pre></td></tr></table><h2><a href="https://molunerfinn.com/electron-vue-4/#总结"></a>总结</h2><p>本文简要地讲述了electron应用在跨平台开发的时候的一些注意事项。可能很多人会觉得奇怪我为啥把这个章节单独拎出来讲。很多时候我们只关注于应用的开发过程，把应用的功能实现是很多情况下的「终极」目标。然而真实情况是，应用的功能实现只是「基本」目标。一个应用要给用户使用的话必然不仅要考虑到应用的功能，还必须考虑用户的使用习惯。要站在用户的角度来做应用。而不是做自嗨型的应用。所以这篇文章也希望能够帮助想要开发electron应用的你。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
        
        <summary type="html">
            
            前言前段时间，我用electron-vue开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——PicGo，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习e
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="前端"/>
        
        <category term="Vue"/>
        
        <category term="Electron"/>
        
        <category term="Electron-vue"/>
        
    </entry>
    
    <entry>
        <title>hexo-theme-melody v1.5 supports slides &amp; iframe</title>
        <link href="https://molunerfinn.com/slide-support/"/>
        <id>https://molunerfinn.com/slide-support/</id>
        
        <author>
            <name>Molunerfinn</name>
        </author>
        
        <published>2020-09-17T15:18:28+00:00</published>
        <updated>2020-09-17T15:18:28+00:00</updated>
        
        <content type="html"><![CDATA[<h2><a href="https://molunerfinn.com/slide-support/#hexo-theme-melody-v1-5"></a>hexo-theme-melody v1.5</h2><p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p><p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p><p>===</p><h2><a href="https://molunerfinn.com/slide-support/#Steps"></a>Steps</h2><h3><a href="https://molunerfinn.com/slide-support/#1-Add-a-slides-page"></a>1. Add a slides page</h3><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>hexo new page slides</span><br /><span><span>cd</span> ./<span>source</span>/slides</span><br /></pre></td></tr></table><p>===</p><h3><a href="https://molunerfinn.com/slide-support/#2-Add-the-layout-type"></a>2. Add the layout type</h3><table><tr><td><pre><span>1</span><br /></pre></td><td><pre><span>vim index.md</span><br /></pre></td></tr></table><p>Add a type called <code>slides</code>：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>title:</span> <span>slides</span></span><br /><span><span>date:</span> <span>2018</span><span>-03</span><span>-06</span> <span>20</span><span>:24:48</span></span><br /><span><span>type:</span> <span>slides</span></span><br /></pre></td></tr></table><p>===</p><h3><a href="https://molunerfinn.com/slide-support/#3-Modified-the-melody-yml"></a>3. Modified the melody.yml</h3><p>Add slides default config:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /></pre></td><td><pre><span><span>slide:</span></span><br /><span>  <span>separator:</span> <span>whatever</span> <span>you</span> <span>like</span></span><br /><span>  <span>separator_vertical:</span> <span>whatever</span> <span>you</span> <span>like</span></span><br /><span>  <span>charset:</span> <span>utf-8</span></span><br /><span>  <span>theme:</span> <span>black</span></span><br /><span>  <span>mouseWheel:</span> <span>false</span></span><br /><span>  <span>transition:</span> <span>slide</span></span><br /><span>  <span>transitionSpeed:</span> <span>default</span></span><br /><span>  <span>parallaxBackgroundImage:</span> <span>''</span></span><br /><span>  <span>parallaxBackgroundSize:</span> <span>''</span></span><br /><span>  <span>parallaxBackgroundHorizontal:</span> <span>null</span></span><br /><span>  <span>parallaxBackgroundVertical:</span> <span>null</span></span><br /></pre></td></tr></table><blockquote><p>See reveal.js <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank">config</a></p></blockquote><p>===</p><h3><a href="https://molunerfinn.com/slide-support/#4-Write-a-md-file-with-slides-layout"></a>4. Write a md file with slides layout</h3><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><p>For example:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span>title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br /><span>date: 2018-03-06 19:57:52</span><br /><span>layout: slides</span><br /><span>---</span><br /><span></span><br /><span>// balalala...</span><br /></pre></td></tr></table><p>Then you will get a post of slides type.</p><p>===</p><h2><a href="https://molunerfinn.com/slide-support/#Slides-layout-with-iframe"></a>Slides layout with iframe</h2><p>If you want to add a website whatever you like within an iframe, try this:</p><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br /><span>date: 2018-03-06 19:57:52</span><br /><span>layout: slides</span><br /><span>iframe: https://the-url-whatever-you-like</span><br /><span>---</span><br /></pre></td></tr></table><p>Then you will get a post of iframe.</p><p>===</p><h2><a href="https://molunerfinn.com/slide-support/#Configurate-single-slides-in-md"></a>Configurate single slides in md</h2><p>The slides config in <code>meldoy.yml</code> can change whole slides page.</p><p>But if you set the config in the md file, it will effect the single page.</p><p>==</p><p>For example:</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /></pre></td><td><pre><span>title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br /><span>date: 2018-03-06 19:57:52</span><br /><span>layout: slides</span><br /><span>slide:</span><br /><span>  theme: white</span><br /><span>  transition: zoom</span><br /><span>---</span><br /><span></span><br /><span>// balalala...</span><br /></pre></td></tr></table><p>===</p><h1><a href="https://molunerfinn.com/slide-support/#Enjoy"></a>Enjoy!</h1>]]></content>
        
        <summary type="html">
            
            hexo-theme-melody v1.5Supports iframe &amp;amp; slides. You can use a layout called slides to enabled the slides layout.Also you can add a ifra
            
        </summary>
        
        <category term="Web"/>
        
        <category term="开发"/>
        
        <category term="hexo"/>
        
    </entry>
    
    <entry>
        <title>校内应用个性化数据年报项目全程吐槽纪实 – 长单页面前端工程与 ECharts 图表可视化</title>
        <link href="http://blog.dimpurr.com/yiban-report-17/"/>
        <id>http://blog.dimpurr.com/yiban-report-17/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2018-02-28T12:57:59+00:00</published>
        <updated>2018-02-28T12:57:59+00:00</updated>
        
        <content type="html"><![CDATA[<p>随着校区从昌平宏福迁往西土城，一边为终于能够河北人进京城感到高兴，一边为入住人称将军冢的我校 1955 年最好的宿舍而担忧，喜忧参半的在陌生的新宿舍用 Axure 画着学院内部项目交互原型的自己，迎来了大学的第一个寒假。</p>
<p>恶补 React 和 ES6 知识、补习高数预习离散数学和入门 TensorFlow、组织和培训学院内团队的新人们入门 Web 前后端、在 VJudge 上参与面向 ACM 新生的 BUPT Winter Training 练习赛，前半个寒假就这么飞快的过去了。之后回到老家过年的我，其他时间就花在了这么一个 —— 类似网易云个人年报，展示校内自建应用的全局统计和用户个性化数据的单页面年报页面上。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/2.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/2-534x1000.png" /></a><p>校内应用个性化数据年报 设计稿/代码实现/图表效果</p></div>
<p>当时接到这个语焉不详的任务要求之后我其实是一脸懵逼的，而且这个明显重策划设计而非技术的任务，最开始居然只安排了我和另一位（虽然非常靠谱的）后端负责。于是只好抄刀硬上，自己当策划，出了一版初步设计稿就开始动工前端，然后再想办法拜托组里的设计师们修改设计图和撰写文案。后来转念一想，虽然这个估计写出来也没多少人看 (误) 的任务不是不能随便简单点糊弄过去，但是不如也干脆作为一个重新练习快要生疏的静态页面相关前端技术们的机会。最后的结果，大概就是在一个不算很复杂的移动端长页面上，塞进去了没有必要程度的自觉好玩想复习或尝试一下的技术吧。</p>
<p>这篇文章就以全程实录的方式，记述了我在接到这个校内应用个性化数据年报单页面的任务之后，从初期策划和出设计稿、组织文案撰写，再到前端工程开发、处理应用统计数据、利用 ECharts 绘制可视化图表，到最后部署上线的完整过程，以及在此期间内心满满的槽点。不得不说，一个春节在老家县城天天抱着 Surface 出来找咖啡馆干活也是没谁了，而且，这些校内应用用户数据存量稀薄的凄惨现实（导员别打我 233），实在有点让人难以正确的进行小数据可视化 ……</p>
<p>那么，也许你可以从本文窥见一个完整有趣的项目流程，或者了解我在项目过程中收获到的经验；或者你发现了其中我犯的错误或不足，也请不吝赐教。以下。</p>
<p><span></span></p>
<h2>任务开始</h2>
<p>大一上期末考完的那天下午，打开微信，就收到了 FredericDT 同学的消息：</p>
<pre>FredericDT:
考完了没！ 易班有活干！ 【滑稽】
2017年年报 撸个酷炫的 h5 presentation

Dim:
今天刚考完
这玩意儿我不太熟悉，不过能做，任务是怎么分配下来的？你要不去群里问问有没有哪个组有熟悉 h5pre 或者 impree.js 之类的人，做起来效率会更高
如果没有或者分下来是要我们组做我可以调研下相关服务，或者 impressjs 撸一个
也不难，主要要点设计成本和文案，我没经验就是了

FredericDT:
得撸出来 得能干活 ddl大年三十 我在撸接口

Dim:
所以这年报成员有谁，文案谁定，设计谁做，代码谁写，接口是啥
这个基本都是设计和文案成本，代码逻辑没啥吧

FredericDT:
明天说详细内容 你把问题问出来 我明天一一解答 成员就咱们组 “要能干活的人”</pre>
<p>于是，洗了个澡之后，我就在 Typora 上打出了问题清单：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-2.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-2-1024x567.png" /></a><p>项目规划问题清单 (Typora)</p></div>
<pre>关于易班年报H5PRE

* 个人理解：制作一个富交互动画演示单页面，优先支持手机（主要浏览渠道：微信分享，微信内置浏览器），顺便支持或者不支持桌面？
* 预期制作流程：
    * 专人负责策划。思考演示内容和主题是什么，展示易班些什么，撰写每一页的标题、介绍文案，并提供配图主题方向。本质上核心和最麻烦的工作。
    * 设计支持。修订处理演示中需要的素材图片，制作或者绘制一些需要的小装饰元素图标等。
    * 代码支持。制作实现网页网页，能够在易班渠道发布和观看。如果能找到现成的H5页面制作工具则为低端工作，若有负责交互逻辑、需要桌面端支持、需要效果很现代或者有动态程序逻辑等则会较复杂。
* 综上，问题有：
    * 该H5预期的【观看对象和目标人群】是？
    * 该H5希望展示的【具体内容】，目前以及有哪些想法？
    * 该H5的【风格和主题】是？【体现的精神风貌】是？
    * 该H5【支持移动端】还是【支持桌面端】？【发布和推广的渠道】是？
    * 有无擅长该类演示【文案策划和美术设计的人才】可以参与？【唯独程序员我们不缺】。</pre>
<p>不久后，得到了答案：</p>
<pre>* 广大学生
* 主题为“沙邮易班功能推荐”，对用户展示其活跃使用的功能（范围为全部北邮维护的应用）及频次，对其未使用功能进行推荐
* 现代科技风格，带有拜年的意味
* 都要支持。部署在易班的机子上
* 我不熟...拉不到人</pre>
<p>很快回复：</p>
<pre>Dim:
「* 有无擅长该类演示【文案策划和美术设计的人才】可以参与？ 我不熟...拉不到人」
这个我这两天想办法解决下，解决不了那就这么开工了

FredericDT:
行 没有就是你 你懂得 【滑稽】
我30号前尽量撸几个应用的接口出来</pre>
<p>几天后，回到家，我也正式开工了。干脆还是直接贴记录吧：</p>
<pre>Dim:
h5pre 那边情况如何 是不是该动工了

FredericDT:
定位是“功能推荐” 按功能把纵向的 section 码出来
我今晚给你出全部的功能点(中文描述) 我写成 google spreadsheet

Dim:
现在PRE应该是两部分吧 上来一个欢迎屏幕 下滚，然后是功能推荐 下滚，是数据可视化
然后你给我功能推荐列个点，数据可视化列个点（数据可视化你这边是还没琢磨好是吗
你可以把能导出，或者做好的数据都给我看看（直接截图或者txt/csv给我），我也试着想想

FredericDT:
数据嘛...我得看看数据库的结构

Dim:
那我现在就动工，把页面的框架搭一下，随便写点废话文案，准备做功能推荐部分咯 数据部分最后再想办法加
反正就是个复杂单页，我正好练练手，给新个人页做准备 - -
对了，咱们这个年报是大众化还是个人化 要给每个用户自己个性化数据？ 类似网易云那种

FredericDT:
个人化 对 类网易云

Dim:
我觉得不合适，咱们用户覆盖率太低，比如我肯定就没有任何数据
个人化的可以有 全部堆起来放一个section 全局的搞多一点 占面积大一点

FredericDT:
针对你这种用户 就是功能推荐 针对有数据的就是年报

Dim:
不能做一个全部用户的大数据(不大)分析吗
比如，今年，205个用户在易健身预约了14832次健身 50%的人在下午18:00~20:00时段来健身房 咕咕咕占比20%，希望大家要履行承诺哦 这种感觉 然后给个预约时段的饼图，预约人数的曲线
预约人数的曲线，可以在拐点发掘点东西，比如「2月14日情人节，健身人数较少，同学们都在做什么呢 ...?」

FredericDT:
可以做 这个可以有 这种感觉不错 我这个接口就是这么整出来的
你看到rank了吗 用sql实现的 我准备都用sql

Dim:
用户健身质量评级？
个人的实时无所谓 全局的就抓下来 做个静态分析吧 好做文案，配文字什么的 接口留着，以后每年都可以用

FredericDT:
那我回去做个dump出来 然后咱研究研究大数据跟个人怎么结合

Dim:
这样，我回去画一份临时创意设计图给你，仅供参考，无论前后端都不必要按着这个做 (只是明确下大概的方向和成品大概要什么效果
然后我这边另外去做前端的技术准备 我给需要的单页和可视化库都给熟悉一下
顺便我再找导员沟通下品牌文案那边

FredericDT:
前端你准备怎么做

Dim:
emmm，我计划是 impress.js ，响应式支持桌面和移动 图表用百度的 ECharts 有问题再 fallback 到 d3.js ...
我不确定现在水平够不够，想做激进一点，练下我的前端，给我新个人页铺路
我会把涉及数据的地方HTML写工整点 我现在还不确定JS代码的具体分布，impress.js 试用一下尤其是移动端的情况再说
jQuery 需要吗？

FredericDT:
用吧

Dim:
好 我直接开工前端仓库了 顺便画图 顺便和导员沟通

FredericDT:
我一会儿先做功能文档和数据dump对吧
下面我就用telegram了

Dim:
可以，我最近tg都在线 加油</pre>
<p>沟通后，导员的意思很明确：「希望成为针对每个用户的画像」，「尽可能导出所有应用的用户添加和使用信息，和普通的推送分别开，突出我们易班的技术性」，末了加一句「总之一定要有让人眼前一亮的感觉」。顺带介绍了组里的几位设计师支持。行吧。</p>
<h2>搭建 Webpack 前端工程</h2>
<p>要干活当然是先建一个 git repo —— <del>挖坑不填，不对，</del>获得成就感的最快方式，自然是先煞有介事的把脚手架环境搭好。既然一开始就想好了是静态的长页面而非复杂的 SPA 单页面应用，所需的任务其实更是 gulp 和 grunt 等老牌前端自动化构建工具的长项。但是既然 Webpack 正好最近在接触，各种各样的插件也同样能胜任需求，不如就尝试一下吧。</p>
<p>这事一旦有了经验也不难，先 <code>npm init</code> 然后去最近的项目的 <code>package.json</code> 复制下依赖列表并按情况做个删减，然后补上 <code>.babelrc</code> 、 <code>.eslintrc.json</code>、 <code>postcss.config.js</code> 和最重要的 <code>webpack.config.js</code> ，内容如下：</p>
<pre>const path = require('path');
const url = require('url');
const process = require('process');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const ImageminPlugin = require('imagemin-webpack-plugin').default;
const publicPath = '';

module.exports = (options = {}) =&gt; ({
    entry: './src/main.js',
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [{
            test: /\.css$/,
            use: ExtractTextPlugin.extract({
                fallback: 'style-loader',
                use: [
                    'css-loader',
                    'webpack-px-to-rem?min=3',
                    'postcss-loader'
                ]
            })
        },
        {
            test: /\.scss$/,
            use: ExtractTextPlugin.extract({
                fallback: 'style-loader',
                use: [
                    'css-loader',
                    'webpack-px-to-rem?min=3',
                    'postcss-loader',
                    'sass-loader'
                ]
            })
        },
        {
            test: /(\.jsx|\.js)$/,
            use: [
                'babel-loader',
                'eslint-loader'
            ],
            exclude: /node_modules/
        },
        {
            test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
            use: [{
                loader: 'url-loader',
                options: {
                    limit: 10000
                }
            }]
        }
        ]
    },
    plugins: [
        new CopyWebpackPlugin([{
            from: 'src/img',
            to: 'img'
        }]),
        new ImageminPlugin({
            test: /\.(jpe?g|png|gif|svg)$/i,
            // disable: process.env.NODE_ENV !== 'production',
            pngquant: {
                quality: '60-100'
            }
        }),
        new CleanWebpackPlugin(['dist']),
        new ExtractTextPlugin('bundle.css'),
        new HtmlWebpackPlugin({
            template: 'src/index.html'
        })
    ],
    devServer: {
        host: '127.0.0.1',
        port: 8012,
        proxy: {
            '/api/': {
                target: 'http://127.0.0.1:8080',
                changeOrigin: true,
                pathRewrite: {
                    '^/api': ''
                }
            }
        },
        historyApiFallback: {
            index: url.parse(options.dev ? '/static/' : publicPath).pathname
        }
    },
    devtool: options.dev ? '#eval-source-map' : '#source-map'
});</pre>
<p>当然，这份配置也是在后来的开发过程中不断修改的结果。最后打包的流程如下：</p>
<ul>
<li>对 JS ，入口 <code>main.js</code> 走 ESLint （代码格式检查）和 Babel （ECMAScript 实验特性兼容）打包到 <code>bundle.js</code></li>
<li>对 CSS ，全部使用不那么激进带花括号语法的 <code>scss</code> 格式后缀，先用 <code>webpack-px-to-rem</code> 插件直接转换 3px 以上的 px 单位到 rem 单位，再走 PostCSS 做其他处理，比如 <code>autoprefixer</code> ，最终利用 <code>extract-text-webpack-plugin</code> 导出到 <code>bundle.css</code></li>
<li>对 HTML ，直接用 <code>html-webpack-plugin</code> 导出</li>
<li>对图片，小于一定尺寸的走 <code>url-loader</code> 编码成 Base64 ，其余利用 <code>imagemin-webpack-plugin</code> 压缩后用 <code>copy-webpack-plugin</code> 拷贝到目标位置，</li>
<li>利用 <code>clean-webpack-plugin</code> 清空 dist 目录，然后重新生成</li>
</ul>
<p>还为 <code>package.json</code> 添了两条 <code>npm run</code> 命令：</p>
<div>
<ul>
<li><code>"dev": "webpack-dev-server --inline --hot --env.dev --host 0.0.0.0"</code> 运行实时调试预览和 HMR 的开发服务器的 <code>webpack-dev-server</code> 插件，把 host 设为 <code>0.0.0.0</code> 而不是 <code>127.0.0.1</code> 便可以在内网的其他设备上方便的测试，比如用手机直接访问测试微信内置浏览器打开效果</li>
<li><code>"build": "rimraf dist &amp;&amp; webpack -p --progress --hide-modules"</code> 后来这里用 <code>rimraf</code> 取代 <code>CleanWebpackPlugin</code> 以便更好的支持不同平台下的删除权限</li>
</ul>
</div>
<p>最终实际在生产时使用的库有：</p>
<ul>
<li><code>normalize.css</code> 浏览器一致重置</li>
<li><code>axios</code> 异步请求</li>
<li><code>aos</code> 跟随滚动出现和消失的动画</li>
<li><code>jarallax</code> 视差背景图</li>
<li><code>echarts</code> Baidu 开源图表库</li>
<li><code>echarts-wordcloud</code> 文字云插件</li>
<li><code>clipboard-polyfill</code> 全平台剪贴板控制</li>
</ul>
<p>项目文件结构也很简单：</p>
<pre>* src/
    * index.html
    * main.js
    * style/
        * ... .scss
* dist/
* static/</pre>
<h3>随意吐槽一下</h3>
<p>一个是折腾 Webpack 配置文件的过程中，被人大力安利了高性能零配置的 Parcel 。看了几篇文章，感觉便利程度的确是很有吸引力 —— 但是看起来缺乏的自由度应该说明了其是个专注 Node.js 系快速打包的替代品，而不打算替代复杂的前端自动化构建工作（雪碧图等更多魔法操作）吧。</p>
<p>不得不提的是，如果项目中已经用到了 ESLint ，相比每次看 VSCode 「问题」面板或者 Webpack 编译时的报错然后手动不爽，完全可以安装 VSCode 的 ESLint 插件后，去设置里开起 <code> "eslint.autoFixOnSave": true</code> ，然后感受 cmd + S 后代码自己变得整整齐齐、报错全部不见的快感吧。</p>
<p>然后又说到 CSS 预处理器。想来因为和 BootStrap 的关系，初中我最早接触的还是 LESS —— 现在我也觉得 LESS 的官方文档最好读最舒服，设计也符合直觉。时隔多年重新整理自己的技术栈，读了不少对比 CSS 预处理器的文章，才知道 LESS 因为作者的短视和低扩展性已经过气，连 BS 官方也换成了 SASS 233 因此最近的几个项目都换成了 SASS 作为主役预处理器，不过又总是有人来和我安利 Stylus ，哦，和安利 Parcel 的是同一个人，好吧 …… 虽然明知道没有什么必然区别，哪个预处理器总之用顺手就好，不过下一个项目有机会还是试试看好了。</p>
<p>其实个人对 CSS 预处理器的利用程度也不算很深，主要是嵌套 CSS 的写法的确很爽，定义变量、适当 @mixin 、一些自带计算函数和表达式这种程度的特性也很有用，偶尔还需要 @include 一下方便组织 CSS 文件。回头多读读文档，看看还能不能发挥出预处理器的更多优势吧 ……</p>
<h2>早期设计构想</h2>
<p>导员很快拉了一个群，作为设计和文案的后援。</p>
<pre>我：
总之，我们目前规划分为三大部分
「易班服务推荐」
「我的易班 2017 （个人数据分析）」
「易班校园大数据 2017 （校园数据分析）」
需要人员进行美工设计，和文案撰写
先问下你们有没有擅长网页/演示/PPT/展示/H5/平面/出版物/海报相关设计的 ... 参与到设计中来？
至于文案的话，估计是设计的留好格，再麻烦各位帮忙写
这样，我一会扔一份原型草稿上来，对自己有信心的同学认领一下视觉设计
用平面设计也就是海报的方法来做就好了

16-数媒-ZLX:
H5，平面，海报有点经验。。

17-数媒-ZJY:
举爪??文案 H5 PPT 演示会好一点……logo什么的比较无力......
</pre>
<p>想着没有设计图，一遍遍的重复说明设计目标和任务总是很麻烦，于是，虽然对自己早已生疏的设计水准不太有信心，但是还是直接操起 Sketch ，尽可能的把脑海中想象的设计画出来了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/Tablet-Portrait.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/Tablet-Portrait-279x1500.png" /></a><p>策划创意设计稿 第一版</p></div>
<pre>Dim:
先扔个图上来你们看下 ... 原谅我渣渣的视觉设计水准
不必照着这个设计，但是参考这个内容和布局组织，做一份更美化更具体的设计，并导出素材
唯一的要求是风格现代一点，我可以提供风格参考
emmm 有哪位同学觉得可以，来帮忙做视觉设计的吗

16-数媒-ZLX:
这个是最终应用于H5的吗？

Dim:
对 我负责前端代码
后期我会负责实现代码，以及加上一些简单的滚动动画，具体技术实现不用太担心，按平面的来走就好

16-数媒-ZLX:
带有拜年意味重要吗？ 我感觉拜年挺难加进来的??

导员:
对 挺好 可以加一些拜年的元素
没事 这种就在开头或者结尾加一点记一下 整体风格按照大气 科技感走
</pre>
<p>之后和后端的 FredericDT 同学沟通：</p>
<pre>Dim:
草稿画完了 我的视觉设计水准差了点 = = 但是找不到好的视觉设计师
总之这稿你看着差不多？
我前端框架都起来了 设计搞定了就能动工（现在这不算搞定，还是太难看 ...

FredericDT:
我觉得可以有
“易班服务”是导员要求加的？

Dim:
行吧，我想想设计怎么改
不是啊，就是你说的功能推荐 我不知道你想怎么推荐 就那么搞了下 不然你觉得怎么搞比较好

FredericDT:
哦这样啊 这个要结合个人数据推荐的
“个人未涉及此功能才推荐” 个人数据摆在最前头

Dim:
那顺序是，个人数据，推荐，全校数据？
我改一下也不难，推荐直接作为个人数据最后的版块</pre>
<p>那么好吧，蹭蹭蹭，改出第二版（其实只是修改了一下应用推荐的位置 ……）：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/Tablet-Portrait1.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/Tablet-Portrait1-279x1500.png" /></a><p>策划创意设计稿 第二版</p></div>
<pre>Dim:
大体原型就这样了，原谅我渣渣的视觉设计和配色水准 ...
需要做一下细化的视觉设计，这份稿子仅供参考，只是说明下大概内容会有哪些，不必限制具体发挥
按 FredericDT 要求改了一版 ... 把应用推荐作为个人数据结尾的个性化推荐</pre>
<p>初步的设计稿有了，前后端、设计外援、文案们也基本对最终的成品效果达成了共识，那么一方面等其他人的进度，一方面，前端这边也可以安心干活啦。</p>
<p>吐槽下初期设计稿的一些槽点吧。</p>
<p>因为我很明确的计划这次的项目想为自己的新个人页做设计上和技术上的铺路，所以倾斜容器 (CSS Transform Skew) 和视差滚动这些点是必须要有的。设计风格上，应该算作新个人页设计风格的衍生，所以设计前期的参考、灵感来源等等，会放到待新版本个人页写完之后的记录里一并叙述。</p>
<p>这里必须吹一把 Sketch —— 这两张简单的设计图我只花了不到一个小时就扒拉出来了，可以说 Mac 独占的 Sketch 这个优秀的原型和设计软件，是我必须一致选择 macOS 的主要理由和杀手级应用。相比全平台而且功能更强大的 Axure RP ， Sketch 在同样的时间内原型画的更快、更好看，只要稍微花点时间就能上手大部分功能，常用的形状全部绑定到一个单字母快捷键，按 O 画圆按 R 画矩形， cmd + G 和 cmd + shift + G 快速控制组合，利用 option 和 command 键组合切换穿透选择、标尺对齐，还有 Scale 等比缩放，这些看似普通、 Axure （需要一个个拖拽控件）和 Photoshop （PS 里选中你想要的图层然后自由变换，不论性能和操作速度都差不少）的确也完全能做到的功能， Sketch 却做的更爽和更行云流水。几次在讨论设计方案的过程中随手用 Sketch 糊出一个原型，据说还给数媒院的学姐留下了「画图奇快」的印象。作为一个失职已久的自称设计师，接下来有空要做的，大概是更新一下机器上的 Sketch ，然后把大把 Sketch Workflow 的强大工具都再熟悉一下吧。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/5C105226-9693-421F-B866-89419B1F8E9F.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/5C105226-9693-421F-B866-89419B1F8E9F-600x427.jpg" /></a><p>Sketch 大法好</p></div>
<p>不过画的快是快，我自觉这俩张图还是画的很瞎眼的，因为是快速原型所以很懒，因为只需要做一张不怎么需要复用组件，所以 Sketch 源文件分组什么的都很不认真，配色都是随便拉的而且我出了名的不会配色，图表图片内容也是随手截图一个占位。本来是指望有靠谱的设计师帮忙后面能 ReDesign 补上这些，虽然后面看最后还是在自己这板稿子和数媒院同学们提供的稿子的基础上，最终在写前端时暴力发挥了 ……</p>
<p>同样，作为个人页的技术储备，我调查了一番现在前端静态页面比较常用的特效及其对应的库的实现，记录在知识库 <a href="http://note.dimpurr.com/#前端实用库收集">前端实用库收集 – Dimpurr’s Knowledge Base #1</a> 。在动工前本来想找出网易云那份教科书级别营销案例的个人听歌年报参考一下的，可以的话最好能直接读下页面源码，结果却发现已经找不到对应的链接了。思考过是用劫持滚动、类似网易云那样的分页设计（准备使用的是 <a href="https://alvarotrigo.com/pagePiling">pagePiling.js</a> ，毕竟 impress.js 虽然酷炫，却更像是个前端版的 PPT 动画演示，而且太重了），还是普通的长页滚动，后来考虑到桌面端和移动端的尺寸和元素包括图表的布局适配，决定普通的滚动加上视差、滚动出现等动画即可。</p>
<p>设计稿里面用到一些图片做占位符，然而我没有本地积累图片素材的习惯 (真的需要的时候会去 <a href="http://unsplash.com/">http://unsplash.com/</a> 找免费授权的高清摄影图片，比如之前做的 BYR 日历壁纸) ，而我本地最大的图片库是看动画时的截图库 …… 这里面两张不露声色的占位符图片，有老司机看得出出处嘛 ……？一张出处应该是终物语，另一张是京吹。</p>
<p>另外你可能已经注意到的另一张占位符，是尾部的那张「谨贺新年」的新年贺图 —— 这是 <a href="https://manhua.dmzj.com/biedangounijiangle">一部我很喜欢的漫画</a> 的贺图。这部漫画不仅在 Pixiv 上免费公开连载，并且作者慷慨的授权了汉化组在动漫之家上连载汉化，还于最近在中文圈人士的协力下推出了 <a href="https://zhuanlan.zhihu.com/p/33264855">官方中文电子版</a> 。（那当然是买买买啦！）这位作者画风简练可爱，而且从东方同人漫画时期开始笔下的作品就有治愈有趣的剧情，值得安利一下。本来预想这处占位符用自制的新年贺图替换掉，但是意外的是却很受欢迎，并得到了导员的允许和作者本人的 Twitter 口头授权，因此一直保留到了最终发布的版本。（图片添加了 <a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=66567593">pixiv (c) nekotou</a> 的标识）</p>
<p>小插曲：</p>
<pre>hanyuwei:
这个结束的恭贺新年（
（钉子你知道来源么（

Henryzhao:
他申请授权了

hanyuwei:
我本意不是这个意思……

Dim:
@hanyuwei 知道来源
我还买了正版的中文版漫画第一卷电子版
还和妹妹一起看了 堂妹，没有亲妹

hanyuwei:
【捂脸】 天哪
你不怕你妹妹有什么想法……

Dim:
有什么想法 ...

hanyuwei:
【笑哭】 弄个一模一样的药

Dim:
才小六的幼女应该没这么聪明 ((

hanyuwei:
110
</pre>
<h2>前端起步</h2>
<p>不久之后，拿到了数媒院同学 ReDesign 的版本。虽然我口头说了不用太考虑前端，按以前做微信 H5 推送的思路来做就好，但是这设计稿实在有点 …… 前端不友善，不友善到几乎只能作为图片发布的程度。（虽然理论上怎样的设计稿前端切图工程师都应该有能力实现 ……）</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/yiban-redesign.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/yiban-redesign-60x1000.png" /></a><p>ReDesign</p></div>
<p>不过没关系，虽然元素布局上大概不打算照着这份设计稿做（布局上我倒不认为比我那粗浅拙劣的初期设计稿好多少 ……），但是必须要感谢数媒院小姐姐出色的帮忙完成了我最懒得做的事情（233） —— 不知道从哪里找来了许多不错的标题背景等装饰素材。作为一个懒得切图的前端，了解过我过往作品的人都知道我多么喜欢用文字排版、简单易懂的 Div 色块和 CSS 特效代替图片装饰元素 ……</p>
<p>这次就算不情愿也得化身切图大师了，拿到图层整理清楚的 ReDesign 设计稿 PSD 源文件，先调整图像大小到原来的数倍确保清晰度， Alt 右键定位元素所在图层，再配合 Alt 点击眼睛隐藏其他所有图层，图像-裁切-根据透明像素，然后 Web 格式导出 png ，其他的交给Webpack 的 imagemin 插件自动压缩。</p>
<h3>REM 布局</h3>
<p>后端的 FredericDT 同学还在勤勤恳恳的跑 SQL 倒腾数据，那么不如先把前端能做的事情做了吧，搭个大体的页面框架，剩下中间内容空白好填图表数据什么的。这一步当然是设计 scss 文件结构，把页面基础、容器、布局、响应式什么的先跑起来，把个标题弄上去，要用到的各种库也 Webpack import 进去看看能不能用。各种上库、踩坑什么的倒没啥值得说的，值得一提的可能是 rem 布局吧。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-0.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-0-600x375.jpg" /></a><p>前端早期工作区截图</p></div>
<p>其实早在 13 年也就是初二我就写过一篇 <a href="http://blog.dimpurr.com/ems-layout/">页面布局孰优孰劣：基于REM的EMs弹性布局——可用性的胜利</a> ，那时候 rem 布局还十分新鲜，几乎没有几篇国内资料，考据了不少英文资料才整理出这篇文章。现在一搜， rem 方案在移动端已经应用的十分广泛，主打的特点是「像素级实现设计稿」和「无损缩放」，各种教程也已经很多了。</p>
<p>在这次项目上，我倒是因为几年没碰前端布局技术有所生疏，犯了很大的原则性错误：一开始我设想了一个极其制杖的布局方案，就是在桌面设备使用响应式流式布局，然后切换到移动端后，再变成 rem 等比缩放；更制杖的是，我居然想靠  SASS 的 @include ，把桌面和移动端写进两完全独立的 CSS ，甚至还打算放进 @media 媒体查询里切换 …… 作为反省经验，我现在认为响应式断点布局还是一定要 Desktop First ，在桌面的基础上，移动端再做减法。至于响应式的流式布局，除非真的打算手机桌面端写成两套几乎无关的样式了，否则和 rem 固定非流式的等比缩放是很难也没必要共存的。</p>
<p>至于这次的项目我就干脆偷懒了，考虑到反正最后会看到页面的用户也就三四位数的量级外加大多会从手机打开 （我猜测主要的 User-Agent 是微信内置浏览器），所以和导员请示不是非得完美支持桌面端后，干脆一路 rem 缩放到填满屏幕，超过一定宽度之后直接露出黑边，页面实际内容缩在中间的长窄条。又嫌弃黑漆漆的背景感觉太没诚意，就弄了一套看起来有那么一点科幻酷炫的毫无意义的 CSS 滚动背景动画，似乎最后还挺受好评的就是了 ……</p>
<p>从实现上来说，我用的是 320px 为基础设计宽度（记得这是老款 iPhone 的分辨率标准，当初是觉得这世界上不存在比这更窄的手机屏幕了，后来发现这个尺寸写起来还是太碍手碍脚了，以后也许可以用个 640 之类的），然后 JavaScript 计算把 320px 拉伸到填满屏幕所需的 rem 并动态设置。一开始在 scss 里试了下手写 rem ，虽然只是 10px 的换算关系，但是还是别扭，于是去找了 <code>webpack-px-to-rem</code> 这个插件（同类插件很多，而且大多是国人做的，为什么呢？选了这个看起来 star 和 fork 比较多外加最近有维护的），之后就爽快的继续写 px 然后等自动转换啦。设计了最小转换尺寸大于 3px ，因为我习惯用 3px 做细微圆角。</p>
<p>因为我这里的设计是屏幕宽度大于一定尺寸就不再缩放占满宽度，而是居中两边留黑边，就用了一个比较简陋的 JavaScript REM  <code>&lt;html&gt;</code> 根元素 <code>font-size</code> 设置实现，原理很简单，保证屏幕宽度是 320px 的时候根元素字体大小是 10px ，其他等比：</p>
<pre>const widthMobileBreak = 640;
var cwidth = document.documentElement.clientWidth;
document.documentElement.style.fontSize = (cwidth &gt;= widthMobileBreak ? '20px' : (cwidth / 32 + 'px'));</pre>
<p>必须说 rem 布局还真是爽，虽然不同平台字体不同，对布局来说还是个不可控因素，但是大体上可以在任何宽度的屏幕上有几乎一致的观感，而且由于这次页面中出现了「倾斜容器 (css tranform skew) （ + 视差滚动背景 (jarallax.js) + 模糊变暗 (css filter blur, brightness)」这样的组合，（尤其是 skew 对容器内 margin padding 和定位的影响很大，除非嵌套多层容器（但是又受到视差滚动的 js 库的限制），不然子元素会根据倾斜的文本基线排布，然后形状被 skew 回来），这个布局还是挺难控制的，用 rem 做等比缩放也比自适应方便了不知道多少（因为在边距控制上可以放心的写 magic number ……？(逃）。</p>
<h3>BFG 删除 Git 污点提交</h3>
<p>另一个不得不提的小插曲是，在切图过程中，我手贱保存了一份 ReDesign 设计稿 @10x 的 psb 文件，文件尺寸达到数百 MB ，而且一不小心 git commit 上去了 …… 发现这个问题时，已经 push &amp; pull 了几回了，因为这个 git repo 是多地推送的，奇葩的是这么大的文件 USTCLUG 的 Gitlab 居然一下子就提交上去了，后来往 FredericDT 同学名下 Github 的 Private Repo 推送时，才因为异常的提交速度发现问题。这时候本地已经新增了很多有意义的 commit ，不想影响后面的正常 commit ，此时已经无法用常规手段抹掉这个文件了， .git 目录也大的不行。</p>
<p>按通行的搜索结果的办法跑了几遍 <code>git filter-branch</code> ，但是不知道为什么就是不行 …… 最后看到 <a href="https://www.cnblogs.com/developer-ios/p/6211903.html">如何清洗 Git Repo 代码仓库</a>  这篇文章，这个叫 <a href="https://rtyley.github.io/bfg-repo-cleaner/">bfg-repo-cleaner</a> 的 Java 小工具倒是意外的好用。一句  <code>java -jar bfg-1.13.0-2.jar --strip-blobs-bigger-than 100M</code> 就解决了我折腾半天的问题，之后 <code>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code> 更新下再 <code>git push --force</code> 强推一把就可以了。当然，其中还遇到 Gitlab 默认禁止了强推，需要到网页端 Project Setting 关闭保护的问题。另外， bfg 这个工具的输出 LOG 有一段作者的私货，你能发现下图的亮点吗？</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/6BF1FAC78B1900A970720B6BBECFBA62.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/6BF1FAC78B1900A970720B6BBECFBA62-547x1000.jpg" /></a><p>bfg-repo-cleaner</p></div>
<p>川普还真是不受待见，心疼 1s （</p>
<h3>CSS @animation 加载动画</h3>
<p>因为堆积了非常多的黑科技，当然也不得不担心一下在手机端性能下，以及在诡异的微信内置浏览器中的兼容性和效果。如前述，在 Webpack Dev Server 开起来允许内网访问后，直接用手机打开微信测试了一下。幸运的是，除了那些毫无意义的 CSS 和 JS 视差滚动动画多少不如电脑端流畅以外，并没有出现哪些让页面布局整个崩掉的问题，不管 CSS <code>clac()</code> 还是 <code>flex</code> 等都工作正常，各种特效也没问题。当然也许有一部分 postcss 的功劳，更复杂的兼容性情况也没有必要考虑，就这样了。</p>
<p>但是并不是没有问题了。一方面，头图等首屏图片素材的加载时间，让页面有一段很尴尬的显示不全的阶段；另一方面，尽管在 Chrome 显示正常，但是在微信内置浏览器中，为 REM 布局设置根元素 <code>&lt;html&gt;</code> 的 <code>font-size</code> 的 JS 需要过一段时间才会执行、而且 vh 和 vw 这俩单位的尺寸也会跳一次（？？？），导致页面布局也有一次闪动。因此，我干脆做了一个纯 CSS @animation 的加载动画，只用一个空 div （虽然挂在某个容器的 ::before 伪元素上也许可以不污染 HTML 结构，但是挂哪好像都不合适）写死时间，做了个很简单、效果也不错的全屏 loading ，底下会走一条没有实质含义进度条细线。</p>
<pre>Dim:
别的没问题 加载动画死掉了 打开来一瞬间是这样
[图片]
然后闪了一下 然后又闪 ...
chrome 就一切正常 就很尬
我发现在微信内部刷新 也没问题 就是开新窗口有问题
解决了，就是 vw vh 这俩单位 在微信页面加载完成前表现不正常 直接去掉用 % 就没问题
就是体验有点糟糕，首先微信白色背景，然后我来个黑色背景的加载动画
算了，我的load也弄成白色吧 你有取色器么 取下这个颜色
[图片]

Heymind:
#ffffff 就是白的

Dim:
好吧 感觉黑色的加载比较有质感 但是为了不闪瞎眼 那就白吧
还行 内网ip这个是 webpack dev server 还有hmr的 2333</pre>
<p>这种时候，SASS 这种 CSS 预处理器设置变量的好处就体现出来了。首先按一般合适的加载速度测算预估并写死了一个加载动画的时间，设为变量，作为 Loading 动画的持续时长、以及进入页面才开始的元素浮现的欢迎动画 Delay 延迟时长，多地使用。然后自己在开发测试过程中，本机加载资源并没有这么长的加载时间、每次等 Loading 动画也很妨碍调试，就利用 SASS 变量可以覆盖的特性写把 Loading 动画缩到极短，等开发结束部署上线的时候再注释掉。（也许结合 Webpack 和 Node.js 环境变量和 SASS Loader 参数，甚至可以自动判断生产环境，不用手动注释？不过懒得折腾了 ……）</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-1.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-1-600x375.jpg" /></a><p>CSS @animation 加载动画</p></div>
<p>一开始配合黑色的背景，写的加载动画也是黑底的。在 Chrome 中也效果不错，因为直接写进 <code>&lt;html style=""&gt;</code> 内联的黑色背景几乎会在页面加载的一开始就生效。后来发现微信内置浏览器在启动并加载页面前，无论如何都会看到不短的一段白底空页面，黑色的加载动画就显得闪烁太大，因此改为白底灰线的 Loading 动画了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG1942.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG1942-563x1000.png" /></a><p>Loading 动画最终效果</p></div>
<h2>分析数据和设计图表</h2>
<p>前端基础搞定后，就等着开始重头戏，分析数据、设计图表和文本内容了。找到后端的 FredericDT 同学：</p>
<pre>Dim:
你这边情况如何 我前端现在等着塞东西了 等我 push 一下
BUPT_Shahe_Yiban_Year2017DataPresentation/design/dist-demo-180210/
这里可以看前端的效果
当然你可以自己 npm install; npm run dev 跑测试服务器实时编译，不过 npm 一般要搞半天

FredericDT:
那俩文档撸完了那仨还没动

Dim:
应用推荐那个你想好怎么做了吗 还有前后端怎么交叉
我的想法是这样的，个人数据不保密，不需要授权
搞个固定地址，比如 report.yiban.bupt.link/17/?uid=101010101 这样就是某个人的报告地址 这样底下还可以分享链接
但是易班应用本身进来有个授权 授权只是为了拿到 uid 然后跳转到这个固定页面
然后前后端分离的话，你直接撸出一大串 json 给我，我 axios 拿到了然后填进页面
后端在 report.yiban.bupt.link/17/api/?uid=101010101 ，随便你后端怎么实现，只要能根据这个 uid 输出合理的 json 就可以
我一会读一下你出的数据，然后设计一下这个接口，如何

FredericDT:
我比较意向于带有鉴权

Dim:
那这样不就没法实现「分享自己的报告地址给别人」
我感觉这个隐私程度不高，而且别人也不容易拿到你的uid
再说如果真有人暴力想爬，就让他爬来玩好了

FredericDT:
【遮眼睛】可以啊

Dim:
你后端对我黑盒，我不管了，前端这次也不用你来塞数据了
好，我现在去根据你的数据拟下合理的 json 格式
我们的数据是分「个人」和「全局」俩个吧，个人的要动态的
全校的应该静态写死到前端页面就可以了，关键要设计点有用的图什么的出来
倒是你没有认识什么擅长数据可视化的人来做这个吗 ...

FredericDT:
全校数据主要都是cluster

Dim:
你的进度如何，datas下面哪些是已经完成的
我应该读什么？哪些是产出 .py 我不用看吧 .json .csv 全都是产出？
Go to see '/root/dumpshell.sh' 这个是啥，我不看可以吗

FredericDT:
带readme的 各个应用下的readme是说明
'/root/dumpshell.sh' 这个是我的笔记，可以不看
读json和csv 不用看py
这些数据我最后还会再整合 就是再format 不会再做处理

Dim:
我现在读下 ECharts 文档看怎么用这玩意儿

FredericDT:
我把用户数据，全局数据都做成json文件

Dim:
没问题啊 完全没问题
但是用户有那么多，你全部做成静态json文件？

FredericDT:
其实没多少... 才一千个左右
主要看cluster怎么呈现
大数据主要做得就是cluster和sum

Dim:
我估计你的 json 部分 得直接考虑好 ECharts 这个 option 的事情
这个我看我俩得合作做了
流程是这样，我按照你的数据，根据文档设计一系列的图标模板，搞个一个 demo.html 给你
然后你根据 chartsdemo.html 里面我写的 option 根据后端实际情况调整，然后后端按这个 option 格式输出
没问题吧？

FredericDT:
没问题
你先去啃文档 我去把最后两个应用啃出来 1600见</pre>
<p>做这段工作的时候，我已经春节回到了在乡下县城的老家，准备等着过年了。家里挤满的亲戚和孩子，真是嘈杂无比，但是所幸祖辈刚搬到了位于县城中央的现代化小区（虽然在这样的小区单元楼下大摆宴席和放鞭炮、在公寓单元楼之间放烟花也是一个奇景），我索性直接抱着 Surface 出来到附近商业区，四处寻找可以坐着工作的咖啡馆、奶茶店了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/AEEC2B82-31B4-484A-9283-C4BC171F2D0A.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/AEEC2B82-31B4-484A-9283-C4BC171F2D0A-1024x267.jpg" /></a><p>老家外出时的 Twitter</p></div>
<p>不得不说， Surface Pro 还真是妥妥的生产力工具。自己沉重年迈并且因为电池寿命导致续航已经不堪重负的 MacBook 15′ with Retina Mid 2014 已经几乎变成了搬不出房间的台式机，平常外出就只好靠又能当平板看个书画个草图、消遣时能画个画打个 OSU! 、要写代码时键盘手感也非常赞的 Surface Pro 了，而且， Windows 下的开发环境是 iPad Pro 绝对取代不了的。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-01.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/QQ20180227-01-600x338.jpg" /></a><p>滋润的 Surface Pro 生活</p></div>
<p>接下来要干的当然是啃 <a href="http://echarts.baidu.com">ECharts 的官方文档</a> 了 —— 花了一个下午把「特性」和「教程」下的文章通读了一遍，意外的发现功能确实强大而且十分好上手，基本只要学会 <code>option</code> 项的写法、知道什么如何查 API 配置项文档，然后对照非常丰富的官方示例按自己的需求改就好了。这里必须吹一波 ECharts 这个难得良心好用的百度开源项目，性能极佳、官方文档详细并且提供了例如 <a href="http://echarts.baidu.com/spreadsheet.html">表格数据转换工具</a> （可以方便的完成 csv 2 json ，记得在上一篇 <a href="http://blog.dimpurr.com/bigdata-gumi/">BigDataGumi 一期小记 – 浅尝爬虫数据抓取和简单可视化分析 (PySpider)</a>  文章里我不得不手写了 json2csv 的 Python 脚本吗？） 之类的实用小工具，而且可以用很少量的代码，实现扩展性和可自定义性丰富的、支持大量鼠标和触摸动态交互和自动动画的前端图表，支持 SVG 和 Canvas 两种各有优势的渲染模式。</p>
<p>在约定好的 16:00 和后端的 FredericDT 同学分头完成自己的任务后再交流进度，此时应该正式开始数据分析和图表的设计了。为了不过早的被页面具体布局和样式等不重要的问题打扰，我单开了一个 datadesign.html 并简单粗暴的 CSS / JS 全部内联，作为设计图表的草稿页面。</p>
<p>可以感受一下后端 FredericDT 同学的工作成果：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2631.jpeg"><img src="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2631-148x1500.jpeg" /></a><p>后端数据目录</p></div>
<p>当时具体的协作过程，引用我事后吐槽的记录：</p>
<pre>Dim:
FredericDT 也不容易，这些后端数据全都是他出的
xlsx 可能是他为了方便看吧，他大概是 sql 先 dump 出 csv ，然后 csv 转 json ，然后 python 洗个格式做个分析，然后还跑个 K-Means 聚类
有的全局数据直接 sql query 语句出，有的靠 python 数据工具计算
图表几乎全是我设计的，我读 FredericDT 出的数据 json / csv 和 readme 说明，然后找 echarts 可用的图表类型， surface 画设计草图，写个需要的数据格式 mock.json 给他，然后我用 mock 数据写图表，他照着要求再洗一遍数据按要求转格式，我再在最终页面 getJSON 填进真数据 ...
流程就基本是这样，设计图表这部分也就花了两天，不过那两天一天工作时间最少5h+，所以设计图表花了我最最起码10h+ ...</pre>
<p>在 Telegram 上和 FredericDT 同学一边讨论已有导出的数据，我一边在官网示例物色合适的图表类型， FredericDT 同学同步在本地用 pandas 和 matplotlib 倒腾数据和预览图表，两人一边吐槽一边尽可能在草稿页上完成最终的图表，整个流程就是这样的了。</p>
<p>怎么说我也是在之前 BigDataGumi 的数据可视化项目里做过无脑统计分析图的，还觉得自己算是有些许经验了，没想到，这次我随手挑选的第一个应用，就用现实给了我一个猝不及防的打击：这个 <code>shahe_check</code> 应用数据量比自己想象的还要小 —— 只有 3 次活动的使用记录 ……</p>
<p>但是数据小也得装成很多啊， 3 个活动，总共 300 人的签到时间戳，外加 FredericDT 同学跑出来的聚类数据，几个签到高峰点的时间戳和权值大小。怎么把只有一维（时间轴坐标）的数据呈现出来并且显得很厉害的样子？答案是暴力增加维度，把时间粒度压缩，按每 5% 时间比例统计人数，那么 300 人就变成 20*15 尺寸的折线图 …… 拿出 Surface Pen 快速的涂一个设计草稿，说明要求后，就麻烦 FredericDT 整理数据导出 json 了。</p>
<p>当时情况大概是这样的：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/shahe_check.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/shahe_check-600x400.jpg" /></a><p>shahe_check 应用 Surface 草图 （字丑求忽略 Orz）</p></div>
<pre>Dim:
我在做 shahe_check ，现在的想法是出一个签到人数随时间变化的曲线图 你看这个怎么样
[ Photo ]
反正就3个 events ，我也不知道还能怎么玩了
还有个 -1 咕咕咕，我不知道怎么展示比较好
主要是3个events太少了 怎么展示咕咕咕比例，又不突出我们只有寒酸的3场events

FredericDT:
这个可以有 我设计的score_function就是干这个用的
[In reply to Dimpurr Cheny] 不要展示这个..... 太羞耻了 推广不足

Dim:
那就过滤掉咕咕咕
感觉折线图的话数据不够 我想想能不能做成散点
每个事件大概 120 条 check 打 300 个点肯定好看，问题是我们只有一个维度，就是 score 必须暴力造多一个维度
如果按 score 合并，比如 0.2 的全部合并，作为计数，就有 y 轴了

FredericDT:
这样 我把 cluster 质心数调高 用cluster造segment
这是把三个活动都统计过后聚的签到peak 我把每个活动都跑一遍k-means 然后count label作为y x就是centers

Dim:
怎么可视化cluster 这样的话画散点？还是折线？

FredericDT:
折线
质心数大概多少合适？

Dim:
考虑手机的屏幕宽度 其实还好 7 个左右？ 现在已经是针对移动端设计了
{ eventid: 16, type: 'line', stack: '人数', data: [ ... x7 ] }
这样的搞的定不 不一定用中文，人数可以 "count" ，随便你喜欢
你最后出个数组给我，我就直接写 serires: json.data 了

FredericDT:
我先找个活动做个7个质心的

Dim:
我思考下 我觉得你画 cluster 还是数据太少了 画来画去就那几个点
要不还是尽可能把每一个 check 记录都画出来 然后 cluter 作为图上的额外标注
你这样行不行，拿两位小数做粒度
横轴 score 纵轴人数，按 0.05 为粒度，画 3 条 check 热度的曲线，标注3次事件名称和注释
然后 cluster 的话 作为竖线标记进去 我看看怎么做额外标记
markLine 有个这个
你就想办法按 0.05 为粒度计数给我成不 按 100 个人计算 期望值在 5 左右
勉勉强强啦 20 * 5 的图，毕竟只有 100 个人 ...

FredericDT:
我撸个segment函数出来 然后跑个结果

Dim:
我现在格式给你
{
    "data": [{
        "eventsId": 16,
        "name": "事件名称1",
        "description": "事件",
        "count": [
            [0.00, 3],
            [0.05, 10],
            [0.10, 3]
        ]
    }, ...
}
markline 我直接定死两条，加上颜色视觉区分，早中晚
我現在在push 效果還行
[ Photo ]

FredericDT:
pushed 可以

Dim:
这个 app 结束吧 下一个来哪个
你手头有没有什么绘图软件，或者干嘛的 你也设计几发图表吧

FredericDT:
pyplot
吃饭！ 吃完继续

Dim:
emmm，也好 我也得换个地方吃饭</pre>
<p>当时内心草泥马滚滚而过的我还忍不住发了条 Twitter 吐槽：「凄惨的现实让我难以正确的进行小数据可视化」……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/1111.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/1111-600x623.jpg" /></a><p>Telegram: 凄惨的现实让我难以正确的进行小数据可视化</p></div>
<p>好吧 …… 当然，现实也只能接受，之后其他应用无非就是如法炮制了。比如 <code>gym</code> 应用是这个画风：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/p_gym.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/p_gym-600x446.png" /></a><p>gym 应用 Surface 草图</p></div>
<p>过程大概是这个画风：</p>
<pre>Dim:
bupt_id,attend_time_1,attend_time_2,attend_time_3,gugugu_time_1,gugugu_time_2,gugugu_time_3,score_rank
bupt_id,count_of_successfully_attened_time_1,..,..,count_of_gugugued_time_1,..,..,score_generated_by_a_fomula
这个 1 2 3 是什么鬼

FredericDT:
健身的三个时段 对应18-19,19-20,20-21

Dim:
personal-gym-text
    if data.count&gt;0
    `你在过去一年里预约了 ${data.count}(3) 次健身记录，最喜欢的健身时间段是 ${data.favTime}(19:00 ~ 21:00) ，在全校的排名是 ${data.rank)(1...144)
    你获得了称号：
        1-3 北邮健身王
        4-40 身强体壮
        50-100 健康达人
        100-144 有点慵懒
设计了一段文本
扔给文案组去改写文案了

FredericDT:
这个扔用得好
【捂眼睛】
我把csv转成json？

Dim:
我们到时候 json 太多了不好吧 尽可能全部数据合并到一个 json 不然请求数太多
这个数据有啥用你觉得

FredericDT:
我有一个健身指数function
显示个 总计、履约率、健身指数、健身指数排名
健身指数是个int
我给其整体加个bias
原函数有负值
sigmoid * 1000 吧

Dim:
gym 怎么做全局分析
我感觉根本不存在全校大数据
apply_distribution.json 这个存在3个脏数据
而且太接近了，几乎就每天都是满的
这数据没啥意思 ...

FredericDT:
嗯 出个sum吧

Dim:
累计预约多少次是吧
你方不方便看一下每个时间段 就是每天 1 2 3 时段预约人数 如果有波动的话可以画个3折线

FredericDT:
每天各时段饱和

Dim:
那就没意思了 那就出一段文本？

FredericDT:
出个平均赴约率吧 还有平均预约次数 文本呈现

Dim:
全校学生过去一年里预约了 ${data.total_count}(12443) 次健身记录，平均每人预约 ${data.avaerge_count}(3) 次，并在 ${data.avaerge_attend_rate}(0.6)*10 % 的预约中准时赴约
我把文本内容移到 datadesign/readme.md 了 datadesign.html 专门用于图表

FredericDT:
gym/gym_personal_report/gym_personal_report_total.json

Dim:
ok 平均预约次数呢 有办法统计用户数量吗
要不要给个人的 gym 记录做一个 calendar 图
不过 ... 实在太少了
能不能合并下 gym, check 之类的数据 合并成「该用户使用易班服务的次数」之类的
仿 github 连击combo图 ...

FredericDT:
等等..数据有毒 我重做一个

Dim:
我弄了个 g.json 直接填真实数据进去 你搞定了就直接手写进去就好了</pre>
<p>中间还碰到一个应用，数据量小到让我们最终不得不放弃分析，此时我们的内心是崩溃的 ……</p>
<pre>Dim:
快过年了 ... 剩下俩也搞定了吗

FredericDT:
易物... ? 我都不知道怎么整 剩下俩还没写文档
易物太惨了 总计14条数据

Dim:
那还玩个毛线啊 ... 导员还说「要表现出大数据」
哈哈哈哈哈哈
给我下进度 ... 总共多少个 app / 已经搞定多少个 app
那我就等你写完文档再看呗 ... 那就是进度 3/5 呗

FredericDT:
3/5/6 文档/处理/全
易物我不打算做大数据了 太坑

Dim:
累死我了，我喘口气然后看看 borrow_room
文本信息多不多 能不能做标签云

FredericDT:
给你看一下易物

FredericDT:
swatch
计算机学院本科课本
一辆自行车
一双穿了20分钟的足球鞋
一个完好无损只用过一次的桶
中兴投影仪spro2
刚买的自行车，实心胎，仿死飞
自行车 能骑就行
大号桌斗
丽芝士纳宝帝奶酪味威化饼干
丽芝士雅嘉奶酪味玉米棒
玛丽黛佳酷黑眼线液笔
一个超级好用的3ce隔离粉底
小米6全屏贴膜

FredericDT:
? 我好方

Dim:
还有吗 数据量就这么一点？
我觉得你直接不管三七二十一 把这堆东西做成文字云
尺寸我直接 math.random 你一个数组把全部交易过的物品 (超过 20 个我觉得就够了) 给列出来

FredericDT:
就...这些
一共就这些...

Dim:
... 还有啥信息吗，价格之类的 这是以物易物还是二手平台

FredericDT:
有价格 二手平台

Dim:
1. 画一张散点图，横轴时间纵轴价格，点上标名称 2. 按价格设定大小，做个文字云
你看 1 还是 2
剧毒 少过头了一点吧 ... 除了标题，还有 desciption 吗 有 desc 的话可以从里面截词

FredericDT:
有 很不正经 全新 是高频词
看来只能这样凑合了..</pre>
<p>说到文字云，用的是 <a href="https://github.com/ecomfe/echarts-wordcloud">echarts-wordcloud</a> 这个插件。由于每一次的文字云都是动态生成，所以每一次刷新的文字云的布局和内容位置都不一样，也是十分有趣。</p>
<p>最后成功运用了两处，一次是 <code>global.borrow_shahe.wordcloud</code> 中的场地租借理由， FredericDT 同学在 Python 上跑 Jieba 分词并统计词频后，导出高频词权值对格式的 JSON 文档，生成场地使用理由的关键词云。另一次是 <code>global.askforleave.wordcloud</code> 中的请假回家理由，这个如果跑词频想必会是同质化很高的「回家」霸权，于是我干脆直接利用 <a href="https://www.jasondavies.com/wordcloud/">一个在线标签云工具</a> 不支持中文的特点，正好达到了以标点符号为分界、整句生成标签云的效果，然后拿在线生成结果的 SVG 代码扔进 VSCode 正则表达式替换，直接变成了我所需的 JSON 格式。这其中也是看到了不少充满个性的请假理由，我个人觉得「北京孩子要回家！」、「每月去看女朋友一次」这两条算是十分逗的了 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/F8BB32BBAD718B658D77B8972EE9FD53.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/F8BB32BBAD718B658D77B8972EE9FD53-600x658.jpg" /></a><p>askforleave.csv 的请假理由</p></div>
<p>其他的应用处理过程和槽点大概雷同，也就不再贴记录了。最后，折腾好的 datadesign.html 大概长这样：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/0.0.0.0_8000_datadesign_datadesign.html-1.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/0.0.0.0_8000_datadesign_datadesign.html-1-367x1500.png" /></a><p>datadesign.html</p></div>
<p>最后折腾出 ECharts 图表实际上也就这么 5 个，至于非图表而是文字数据展示的部分，则被直接写进了 <code>datadesign/README.md</code> 和文案用文档里。</p>
<h3>文案部分</h3>
<p>在 FredericDT 同学按要求折腾数据和导出 json 时，另一边我也在一方面对着文档调出符合要求的 ECharts 图表、修改 <code>option</code> 。在写代码时有点难以转换脑子再去承担文案工作，于是在最终成功合并数据、能够预览图表效果了之后，我设计了一个石墨文档，以便把出好的数据图表截图和随便写的文案实例交给文案协力同学们，拜托他们撰写引导语、详细斟酌说明文字。</p>
<p>并没有太多值得说的地方。应该可以看出来这些文案文本最后大多是用 ES6 的「模板字符串」形式，拿到 JSON 数据后异步填进了页面。另外就是在线文档协作大法好。你可以直接围观文档的副本：<a href="https://shimo.im/docs/JQIGIG7D8Nc7sx3n/">https://shimo.im/docs/JQIGIG7D8Nc7sx3n/</a> 「易班H5PRE年报提纲 公开副本」</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/5D73A018-6CB3-4B3F-96D5-F49ED93C2925.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/5D73A018-6CB3-4B3F-96D5-F49ED93C2925-600x375.jpg" /></a><p>易班H5PRE年报提纲 文案用石墨协作文档</p></div>
<p>后来文案组的同学这么吐槽：</p>
<pre>Dim:
@17-数媒-ZJY 现在基本上数据和图表都出来了
问题是，怎么把这些东西有机的塞进一个页面里
麻烦你组织下先后顺序，承接文字，每个图表的文字，之类的 ... 然后我就按照这个放进页面
样式设计我参照之前的设计图自己发挥 差不多就好了

17-数媒-ZJY:
好的我尽量
出了的都会发到之前那个网址吧
【感觉自己像在写高考语文图表题 ?</pre>
<h3>数据和图表处理阶段，其他的槽点</h3>
<p>直接贴一个我事后和别人吐槽的聊天记录吧：</p>
<pre>Dim:
行了行了，收工了，这个鬼年报搞了我好久啊
可能是我近来最大的工程

Heymind:
emmm 真·好久
【盯】 你也不偷个懒。。。

Dim:
233 其实你不觉得这玩意儿 整个微信公众号推送文章就完了么
图表也是， FredericDT 他 python mathplot 都能画，我还得 ECharts 画一遍
至于个人报告，也就那么两段，其他都是全校的 ...
至于视差/倾斜/各种高级 webpack 玩法，全都是我在瞎折腾 ...

Heymind:
我是觉得。。。。可以变得轻松。。。云端生成图表啊。。。

Dim:
2333 Echarts 主要是可以鼠标交互，比较酷炫啊，还支持触摸的，手机效果不错

Heymind:
还能交互？
还真能交互

Dim:
你居然觉得那个图表是张图？！
尤其是那个折线，沙河签到的 好玩死了，下面还能选数据范围 鼠标滚轮可以缩放

Heymind:
emmm 是的 我才发现底下的框框能拖动
2333 你不标注说明一下谁知道。。。

Dim:
对啊，可以整体拖动和两端拖动
2333 就连文字云都能 hover 呢 ... 文字云也是 ECharts

Heymind:
假大数据又一案例。。。 emmm 这数据到1k+了么
可视化没劲。。。 跑数据挖掘啊。。。

Dim:
gym 是数据量最大的 但是我们也就生成了一段话而已
至于，只有三个活动的签到系统之类的 完全是在打肿脸充胖子
那两个文字云也是，实在 TMD 没有数据可分析啊，只好从文字理由里弄出点数据
请假理由我连分词都没法分了，直接整句生成文字云
整句读起来还比较好笑，要是做个分词基本就一个词「回家」 ...
2333 而且 FredericDT 也是很有毒 他不管什么数据都要跑一个 K-Means 算 Cluster
最后用上只有 请销假那个不明不白，我都看不懂的热点图
其实想法很好 非要分析可以分析出每一个点对应的事件 比如最大那个泡泡应该是 枫叶红 啥歌赛 的 但是写文案的人表示无能为力 ...

Heymind:
2333 这个需要跑聚类？

Dim:
我是觉得大部分跑了也没啥意义，但是 FredericDT 喜欢跑，几乎每个应用都跑了 ...
【前方引用过部分，省略】

Heymind:
我猜他应该大部分时间是在解决祖传代码233
图表设计是。。。这个echarts定制性那么强？ 我以为就是填数据出图。。。

Dim:
就是根据 FredericDT 出的数据文件设计那些 echarts 图表啊
强的要死 你只要做一系列设置 其他全都自动化，自动计算动画，自动自适应
你读一下 charts.js 就知道了 setOption 就是每个图表的核心代码

Heymind:
这些应用如果全是微信小程序。。。估计全得上一个量级

Dim:
微信小程序复杂度那么高？

Heymind:
我说用户量级。。。 // 黑的好</pre>
<h2>收尾阶段</h2>
<p>贴几张工作中期截图：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2328.jpeg"><img src="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2328-600x375.jpeg" /></a><p>工作中期截图 1</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2329.jpeg"><img src="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2329-600x375.jpeg" /></a><p>工作中期截图 2</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2330.jpeg"><img src="http://img1.dimpurr.com/dimblog/2018/02/WechatIMG2330-600x375.jpeg" /></a><p>工作中期截图 3</p></div>
<p>攻克了其前端所有的新技术难关，切图导出了所需的素材图片，分析数据设计出了图表和文案，几乎最难的公关部分都已经完成了，那么剩下的只是把 datadesign.html 里的 ECharts 图表们、文案文档里的文案们，配上导出好的 JSON 数据，填进页面里并处理好细节样式了。</p>
<p>最后的前端处理，就是不断的修改样式，同时截图发到群里麻烦设计师同学和朋友们提供建议，然后继续按照建议调整细节。似乎也没有什么太多值得一提的点，就随意吐槽一波吧。</p>
<p>一个值得一提的建议来自一位做混音的朋友，一开始用 normal 字重、 bold 强调的页面看起来视觉上太过浑浊，于是她提出可以用 lighter 作为全局基础字重、对标题和数据数字采用 normal 字重做强调，效果意外的好。（毕竟现在大部分平台应该都有苹方 Light 、雅黑 Light 这样的中文细体支持了吧？）另外还记得最近有看到过 CSS <code>font-weight</code> 属性用数字替代关键字会更好的说法，但是一时没考据到出处，就没有纠结下去。</p>
<p>原本设计用于注音的 HTML <code>&lt;ruby&gt;</code> 标签（可不是编程语言的那个哦）可以方便的做出文字顶部标注的效果，被我用来在底部的署名上标注了 dimpurr 的 ID ，并加了个难以察觉的链接 233 上线后，发现 FredericDT 同学也发现了这点，并且自己加上了自己主页的链接 （</p>
<p>开发过程中经常需要生成页面的长截图，当然 Chrome Dev Tools 里内置的 Ctrl+P 命令面板的 Capture full size screenshot 命令往往是第一选择。但是这个功能的原理似乎是强制生成一个缩放比例巨大的视图，并在一屏幕里完成截图（纯属猜测），因此会导致页面中根据视图尺寸控制背景图片大小的视差滚动插件显示不正常。后来用的是 Chrome Store 里找的 FireShot 插件，用的是经典的自动滚动连续截图+拼接长图片的截图原理。</p>
<p>MacBook 充沛的性能、优先保证顺畅反应的 UI ，还有 macOS 的的多指手势、多桌面和窗口管理、「调度中心 (Mission Control)」视图、 Spotlight 等等特性，对于开发效率的帮助真是太大了。因此在 Mac 下养成了忙碌工作时窗口只开不关、后台程序也毫无节制以至于要用 Bartender 隐藏长长的 icon 列表、搜索时动不动打开数十上百个 Safari 标签页同时加载、找不到了就双指一捏显示所有标签页等等坏习惯之后，刚入手 Surface 时，甚至还真一时半会有点难以适应 Windows 憋屈原始的手势和窗口交互、不时卡顿的性能 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/48096E1D12EBC848A8B921D5A2303FDC.jpg"><img src="http://img1.dimpurr.com/dimblog/2018/02/48096E1D12EBC848A8B921D5A2303FDC-600x375.jpg" /></a><p>macOS Mission Control</p></div>
<p>（干活时一不小心窗口就会只开不关，毕竟基本不影响性能、而且不知道啥时候又会用到，而且窗口再多、需要时也能马上定位到目标窗口，等手头工作结束后再 CMD + Q 慢慢清理窗口。）</p>
<h3>最后来看一下完成的效果吧</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2018/02/yiban-report-2017-fin-r1.png"><img src="http://img1.dimpurr.com/dimblog/2018/02/yiban-report-2017-fin-r1.png" /></a><p>yiban-report-2017-fin-r1</p></div>
<p>主体内容收工后， Webpack 编译一遍并把 dist 目录交给后端的 FredericDT 同学（跑一轮 Imagemin 需要的时间还不短），把链接之类的内容从占位符替换成实际的应用地址，测试上线、在 Chrome Dev Tools 的 Network 面板观察请求数和体积，并在 WeChat 内置浏览器这个最重要的目标 User-Agent Client 上观察效果。还不错， <code>index.html, bundle.css, bundle.js</code> 几个主体文件加上数据 json 加起来不到 500K ，手动处理了几个较大素材图片之后再过一遍 Imagemin 后，完整体积从 15MB 降低到了 4MB 。应该没问题了。</p>
<p>稍微备注一点，这个页面目前只能从校内网访问，所以上线地址就不用在校外渠道和我要了。</p>
<h2>结束</h2>
<p>感谢你看完了这篇又冗长又没有重点、主要的意义在于流水账一般记录项目的整个过程和漫无目的的吐槽的文章。</p>
<p>每经过一个新的项目，都会学到很多新的知识和经验。是这种经验在我看来，要么是「去看书看官方文档啊」「去 Google 或者 StackOverflow 啊」这种程度、没有必要重复一遍的知识，要么是会被我简单粗暴塞进 <a href="http://note.dimpurr.com/">知识库</a> 的归纳整理， 总而言之，总感觉只要是自己能通过搜索引擎解决的、也就是已经被解决的问题，除非为了刻意吸引搜索流量，否则没有什么转化为博客文章的价值。久而久之，感觉博客就成了纯粹发布作品和记录生活的地方了。所以，这篇文章提供的也不是技术价值：既不是什么前端工程的最佳实践的反思，也不是什么新的设计模式，或者其他终归要看书和看文档得到的知识。这只是一个比较有代表性的小项目的全程实录流水账，应该说，更多的是记录项目过程中本身的槽点和乐趣。</p>
<p>如果你对这篇文章所涉及的领域还比较陌生，我希望这个第一视角的体验能让你感受到，一个完整的前端单页面项目是怎样被设计、策划、开发出来的，中间会涉及到哪些技术、工具和流程，以及最重要的，体会到和一群有趣的人合作做一个小作品的乐趣。当然读者的你更有可能水平在我之上，那么还烦请针对我暴露出来的不足不吝赐教。</p>
<p>这篇文章也提出了几个有意思的 TODO ，那么接下来我该做的，大概是再深入了解一下 CSS 预处理器们有用方便的特性，还有 Sketch 强大的周边 Workflow 吧。从高中毕业开始至今一个学期的前端复健似乎还算顺利， Vue 也已经了解的七七八八了，当然， React 和 Angular 的补习也不能落下。</p>
<p>感谢项目全程提供鼓励和支持的辅导员，感谢曾经参与和协助开发并提供建议、以及授权这篇文章使用与你们的私人聊天记录的 <a href="http://me.fdt.onl">FredericDT</a> 、<a href="https://github.com/heymind">Heymind</a>、ZJY、ZLX、LWJ同学和绘露群的各位，感谢授权使用插画的画师 <a href="http://twitter.com/nekotou">@nekotou</a> ，以及感谢 CCTV 或者其他更多的什么东西。</p>
<p><em>项目开发和文章撰写过程中全程循环 BGM 「DAOKO – Forever Friends」与「Sarah Brightman  – Scarborough Fair」。</em></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/yiban-report-17/">校内应用个性化数据年报项目全程吐槽纪实 – 长单页面前端工程与 ECharts 图表可视化</a></p>]]></content>
        
        <summary type="html">
            
            随着校区从昌平宏福迁往西土城，一边为终于能够河北人进京城感到高兴，一边为入住人称将军冢的我校 1955 年最好的宿舍而担忧，喜忧参半的在陌生的新宿舍用 Axure 画着学院内部项目交互原型的自己，迎来了大学的第一个寒假。 恶补 React 和 ES6 知识、补习高数预习离散数学
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="前端"/>
        
        <category term="大数据"/>
        
    </entry>
    
    <entry>
        <title>2018 新的冒险</title>
        <link href="https://binux.blog/2018/02/us/"/>
        <id>https://binux.blog/2018/02/us/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2018-02-10T06:35:03+00:00</published>
        <updated>2018-02-10T06:35:03+00:00</updated>
        
        <content type="html"><![CDATA[<p>真的又是好久没有写 blog 了。</p><p>年纪大了，记忆力下降，没有学习新东西的动力，也没精力折腾新的技术，新的领域了。每天就是看看斗鱼，打打游戏就过去了，现在的理想就是早点退休，当条咸鱼就好了。</p><p>2017 年主要给公司开发了一套基于 electron (chromium) 的页面渲染后端，可以保证抓取时和用户浏览器中看到的保持一致。同时这个服务器端的浏览器，可以通过 websocket 连接用户浏览器，双向同步页面内容变化，录下用户操作，在抓取时进行重放。这些功能我真的很想做给 pyspider，但是确实不方便。眼见着 pyspider stars 过万，而我却渐渐没有精力去维护了。我的希望是以后从现在的公司离职之后能有2-6个月全职开发 pyspider，算是这几年项目荒废的补偿吧。</p><p>公司终于把伦敦办公室关闭了，我也随着搬到了美国（湾区）。随便写一点美国的感受吧：</p><ul><li>加州税真高，比英国还高，英国人家好歹有免费医保啊</li><li>美国真的是物资极大的丰富，真的可以理解为什么很多中国人来了就想要留下来，小富即安<ul><li>地广人稀，使得超市都是 super 起步的，这样会让选择非常多，卖的量都是加大号的</li><li>充足的停车场，汽车出行不用担心不方便停车</li><li>汽车让生活半径极大扩大，湾区各种中餐半小时车程都能到达，而半小时车程也不过是正常通勤所花的时间</li><li>各种服务比起英国齐全多了，而且周六日不休</li><li>apartment 社区大都自带 365 天 7 * 24 开放恒温游泳池，健身房等设施（即使大冬天根本没有人去用，水也是恒温并更新的）</li></ul></li><li>非实时记账，很多场合真的需要使用支票，需要通过账单付费；因为是后付费，需要 SSN 查询你的信用记录。真的很不方便。</li><li>租房好贵，宽带好贵，手机卡好贵，小费好贵</li></ul><p>总体来说，英国更接近国内的政府+生活模式，而美国是只要你花钱，什么都有，不花钱，滚蛋。反正 L1 签证也就 3 年，也不能跳槽，而且就美国这个 H1B 抽奖 + 绿卡排队，比起英国来简直就是地狱模式。趁着这几年，在美国多玩一玩吧。9酱。</p>]]></content>
        
        <summary type="html">
            
            真的又是好久没有写 blog 了。年纪大了，记忆力下降，没有学习新东西的动力，也没精力折腾新的技术，新的领域了。每天就是看看斗鱼，打打游戏就过去了，现在的理想就是早点退休，当条咸鱼就好了。2017 年主要给公司开发了一套基于 electron (chromium) 的页面渲染后
            
        </summary>
        
    </entry>
    
    <entry>
        <title>如果你也要没洗澡热水了——电动花洒试用记</title>
        <link href="http://snowonion-blog.logdown.com/posts/5201435-tried-portable-shower"/>
        <id>http://snowonion-blog.logdown.com/posts/5201435-tried-portable-shower</id>
        
        <author>
            <name>SnowOnion</name>
        </author>
        
        <published>2018-01-30T13:03:09+00:00</published>
        <updated>2018-01-30T13:03:09+00:00</updated>
        
        <content type="html"><![CDATA[<p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E6%B4%97%E7%8B%97-%E7%BB%99%E5%BE%AE%E4%BF%A1%E7%BC%A9%E7%95%A5%E5%9B%BE.png" /></p>

<p>是这样的，一个多月前，宿舍楼下贴出通知，紫荆 #1~#17 2018 年 1 月 22 号 到 2 月 28 号要停淋浴热水（后通知缩短为 2018-01-25 ~ 2018-02-22）。我不想在寒风中去西区浴室洗澡。时日临近，少女推荐我用俗称「洗澡神器」的电动花洒。我就高兴地试了试。</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E4%BA%AC%E4%B8%9C1.jpg" /><p></p>

<p>这几天，我用它洗了三次。两次晚上，一次早上。</p>

<p>使用场景如下图。橡胶小碗把花洒固定座固定到墙上；小水泵使用时打开开关放在桶里，现在被拿了出来；水桶和热水瓶放在一边。</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E4%BD%BF%E7%94%A8%E4%B8%AD.JPG" /><p></p>

<p>一个热水瓶的开水，兑上室温的凉水，大约能配出一桶（21L）洗澡水。我买的这个花洒开到大的档位，一桶水能用四五分钟——比我想象的快。水流速度不如 原来的淋浴设施开到最大 大，但是冲干净洗发水还是没问题。三个热水瓶够我洗完全套的。我宿舍浴室里接凉水方便，所以用完一桶水、装下一桶水的这段时间里我可以打香皂或者干别的。各位请按需准备热水瓶和水桶……</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E5%92%8C%E9%85%8D%E5%A5%97.JPG" /><p></p>

<p>使用后请及时充电。说明书上写的是，充满电能用 60 分钟；充满需要 3 小时。我没试过它的极限。充电前把水弄干。</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E5%85%85%E7%94%B5.JPG" /><p></p>

<p>我第一次用完在宿舍楼群里发了简短的评测。有几位同学提出了共享花洒和水桶和热水瓶的模式。这个可以有！</p>

<p>2018-01-30 更新：这几天洗澡时改进了一下，配新的一桶洗澡水时，用洗衣机的进水管来兑凉水——前几次我是打开（原有的）淋浴花洒向桶里喷凉水，那样人就必须避开洗澡的区域，不好。感谢我室友去年提出合资买洗衣机！</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92-%E5%87%89%E6%B0%B4%E7%AE%A1.JPG" /><p></p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92-%E6%9C%AC%E4%BD%93%E5%B7%A5%E4%BD%9C%E5%A7%BF%E6%80%81.JPG" /><p></p>

<p>↓洗澡人视角</p>

<p></p>

<p>最后，祝你能拥有青春 激情 梦想 诗和远方。我买的是 <a href="https://item.jd.com/13311845236.html" target="_blank">https://item.jd.com/13311845236.html</a> </p>

<p>P.S. 最新的通知中，准确的停淋浴热水时段是：2018-01-25 一早停水，2018-02-22 一早供水。西区浴室在万人食堂对面，第一次去要带学生证（我不清楚是一卡通还是纸质学生证/研究生证）办洗澡卡。</p>

<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8A%B1%E6%B4%92%E4%BA%AC%E4%B8%9C2-%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9.jpg" /><p></p>]]></content>
        
        <summary type="html">
            
              是这样的，一个多月前，宿舍楼下贴出通知，紫荆 #1~#17 2018 年 1 月 22 号 到 2 月 28 号要停淋浴热水（后通知缩短为 2018-01-25 ~ 2018-02-22）。我不想在寒风中去西区浴室洗澡。时日临近，少女推荐我用俗称「洗澡神器」的电动花洒。我就
            
        </summary>
        
    </entry>
    
    <entry>
        <title>BigDataGumi 一期小记 – 浅尝爬虫数据抓取和简单可视化分析 (PySpider)</title>
        <link href="http://blog.dimpurr.com/bigdata-gumi/"/>
        <id>http://blog.dimpurr.com/bigdata-gumi/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2017-12-24T08:01:02+00:00</published>
        <updated>2017-12-24T08:01:02+00:00</updated>
        
        <content type="html"><![CDATA[<p>这学期在学校选修了一门名为「大数据分析技术导论」的公选课，课上纲领性的介绍了目前正处风口的大数据时代的特点，数据挖掘技术的操作过程和实际应用，并从统计分析基础和数据分析工具介绍两方面介绍了一些实践性质的内容。因为是导论性质的课程，课堂内容侧重介绍和应用的性质居多，而对围绕 Hadoop 和 Spark 的实际大数据技术栈，只简单按分类介绍了 MapReduce 、 NoSQL 类数据库、数据集成等常用工具的功能和使用场景，除了最后一节课以 Weka 为例示范了简单的数据集统计分析和经典机器学习模型训练，其他并没有深入讲解到实践操作部分。</p>
<p>作为课程考核的一部分，在分析论文、利用数据集进行分析实验两个选题中，我选择了后者。因为不可能有合适的平台练习分布式存储、批处理和持续集成，最后决定自己爬取一份数据，把简单数据可视化分析的流程跑通。中间踩坑的过程非常多，实际上大部分的想法都没有成功，但是尝试的过程中，对大数据领域工作流和技术栈的加深了解，应该算是达到了这个导论课本身的意义。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.001.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.001-1024x768.jpeg" /></a><p>BigDataGumi 动画评分数据可视化分析</p></div>
<p>这篇文章记录了利用 Bangumi 番组计划 (bgm.tv) 网站的动画条目和评分数据，进行数据统计分析的项目「BigDataGumi」的初步进展，包括设计网页爬虫抓取数据、利用可视化分析工具尝试获取有价值信息的实际操作部分。一些没有实现的想法和没有呈现在结果中的可能的学习方向，也会作为学习经历的一部分记录。项目的下一步想法是训练一个 tag-orinted 的机器学习模型，能够计算动画的 STAFF 构成和 TAG 标签属性对评分影响的权重，并根据 STAFF 和 TAG 数据预测新番的最终稳定评分，在撰写本文时仍在进行中。</p>
<p>尽管这个项目目前的进展不怎么大数据，不过如果你和之前的我一样从未接触过数据挖掘这个领域，从这篇文章你可以看到简单的数据爬取和可视化分析的操作流程，并且了解到数据分析部分领域的概貌。涉及到的都是非常粗浅的内容，见笑。<span></span></p>
<h3>环境准备</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.002.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.002-1024x768.jpeg" /></a><p>环境准备</p></div>
<p>在可视化分析阶段，我们主要使用在线工具，因此需要提前配置好开发环境的就是之前的数据爬取阶段。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.003.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.003-1024x768.jpeg" /></a><p>环境准备 详情</p></div>
<p>在获取数据方面，有一个知名的在线付费服务 <a href="http://import.io">import.io</a> 。如果自己动手，网页爬虫脚本的业界事实标准是 Python 的 scrapy 库，配合 python-rq 还可以实现分布式运行。当然你还可以用 BeautifulSoup 配合 request 和 urllib2 库从更底层的地方开始手写。不过，从入手效率方面考虑，这里我选择的是 <a href="https://binux.blog">binux</a> 学长的 <a href="http://www.pyspider.cn">pyspider</a> 。尽管功能相对简单不适合用于生产环境，但是其设计亲民的在线 IDE 几乎能让任何一个有 HTML 基础的人在几分钟内上手，拿到想要的数据。</p>
<p>写出简单的脚本，只需要初步的 Python 和 HTML 基础。然而，大部分有价值的信息，其数据源网站都会做反爬虫处理，后来尝试抓取拉勾网数据时我就踩到了不少这类坑。简单的反爬虫措施， 一般可以用修改 UA ，利用 node.js 平台的 PhantomJS 以及替代者 Headless Chrome 模拟浏览器，控制访问来源地址、并发数量和频率等思路解决。如果深入学习，也是个大坑。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.004.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.004-1024x768.jpeg" /></a><p>Anaconda 和 PySpider</p></div>
<p>正如其标语「The Most Popular Python Data Science Platform」， Anaconda 不仅能一键安装，比较便利的搞定一个 Python 环境，同时自带了或者能很便利的安装数据分析的许多常用工具集。接下来用到的 numpy 、 pandas 和 jupyter notebook 环境都随 Anaconda 预先安装了。</p>
<p>要注意的一个坑是，截止撰文时 PySpider 仍未完成 Python 3 的支持，需要 Python 2 环境运行。因此如果需要管理多个 Python 版本，可以考虑使用 pyenv 或者 virtualenv ，个人经验后者似乎更方便。</p>
<h3>数据爬取</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.005.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.005-1024x768.jpeg" /></a><p>数据爬取</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.006.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.006-1024x768.jpeg" /></a><p>目标数据设计</p></div>
<p>在动手编写网页爬虫脚本前，一定要预先设计好你想获得的数据，以及大概计划进行哪些类型的分析，而不是觉得数据多多益善，先抓再说，这是惨痛的教训。</p>
<p>在设计目标数据时，要注意的时尽可能的多获取格式规范的数据、尤其是量化的数值型数据，因为这一类数据可以经过较少的处理步骤而直接输出。而格式复杂的日期数据，以及文本和标签数据，都需要经过后期的结构化提取，才能让大部分的工具支持分析。</p>
<p>根据 Bangumi 番组计划的动画条目特征，最后决定将动画原文标题和译名、左侧的制作信息和 STAFF 表、用户为动画打的标签和标记人数、观看进度想看看过等标记人数、打分 Score 排名 Rank 和 1 ~ 10 每个分数段的打分人数都抓取下来。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.007.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.007-1024x768.jpeg" /></a><p>编写 PySpider 爬虫脚本并测试运行</p></div>
<p>在测试机上运行 PySpider 服务器，进入后台并新建一个爬虫任务，编写脚本。</p>
<p>建议通读 <a href="http://docs.pyspider.org/en/latest/">PySpider 的官方英文文档</a> （不建议参考年久失修的中文官网），并不复杂，参照示例代码编写就可以很快上手。其中在对网页的 HTML DOM 结构进行操作的时候， PySpider 使用的是 PyQuery ，一个类 jQuery 的 DOM 查询库，因此如果需要编写复杂的页面查询，还需要阅读 <a href="http://pythonhosted.org/pyquery/">PyQuery 的官方文档</a> 。</p>
<p>PySpider 的可视化 IDE 设计非常易用，在右边编写 Python 脚本时，你可以在左边实时浏览目标页面，并且查看抓取到的地址列表或者 JSON 数据（或者说是 Python 对象），并且手动操作单步抓取。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.008.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.008-1024x768.jpeg" /></a><p>爬虫任务和抓取结果</p></div>
<p>设置好并发数量，设置任务属性为 DEBUG 或者 RUN 并开始任务，爬取操作就会开始。在 dashboard 页会显示任务进度和抓取成功率， Active Tasks 页面会显示最近页面抓取操作的 LOG 和是否成功，在 Result 页面就可以直接以表格形式在线预览抓取结果，或者导出 JSON 或 CSV 了。</p>
<p>抓取到的一条 JSON 数据大概是这样的（不含 TAGS 标签）：</p>
<pre>{"url": "http://bgm.tv/subject/265", "updatetime": 1510571847.302935, "result": {"votes_9": "2692", "votes_8": "1362", "mark_抛弃": "66", "votes_1": "40", "votes_3": "16", "votes_2": "9", "votes_5": "68", "votes_4": "26", "votes_7": "562", "votes_6": "224", "votes": "8677", "话数": "26", "score": "9.0", "title_main": "新世紀エヴァンゲリオン", "mark_想看": "896", "mark_搁置": "298", "中文名": "新世纪福音战士", "rank": "4", "mark_在看": "339", "放送开始": "1995年10月4日", "动画制作": "GAINAX, タツノコプロ", "导演": "庵野秀明", "播放结束": "1996年3月27日", "mark_看过": "10801", "votes_10": "3678"}, "taskid": "22e5e52633f60552e28b4e49b29f5073"}</pre>
<p>CSV 是数据集最常用的格式，也是个设计十分简单的格式。然而当结果对象属性太多，或者说数据栏目过多时，在 PySpider 直接导出 CSV ，会有一部分被折叠成 JSON 。尝试了一些现有的 json 到 csv 的转换工具都不好用，因此我决定导出 JSON 之后，手动编写一个 Python 脚本对 JSON 进行处理，按自己需要的方式展开，并正好对格式有误的数据进行整理。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.009.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.009-1024x768.jpeg" /></a><p>编写 Python 脚本将 JSON 数据转换为规范格式 CSV 文件</p></div>
<p>因为 Python 对象和 JSON 的结构十分类似，利用原生 json 库进行转换也很好用，需要导出的 CSV 格式也只是按逗号 , 分割条目的纯文本，因此脚本本身并不复杂。当然，要注意把数据内容中的逗号 , 替换掉，以免冲突。</p>
<p>这里面遇到的最大的坑其实是 Python 的 Unicode 文本处理，因为数据内容中由大量 UTF-8 的中文文本，也就是 u’文本’ 形式的对象，必须在适当的时候进行 utf-8 的 encode 和 decode 操作，否则会导致乱码。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.010.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.010-1024x768.jpeg" /></a><p>利用 Numbers 观察数据密度和筛选数据列</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.011.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.011-1024x768.jpeg" /></a><p>利用 pandas 与 numpy 数学库处理数据并进行统计计算</p></div>
<p>导出了 CSV 之后，就可以清理数据并进行初步观察了。同样，使用 Excel 打开 CSV 文件可能会遇到编码问题，意外的是 Numbers 并不会。在 Numbers 里你可以肉眼直接观察明显有误的数据、数据量极少即大部分条目没有的数据项，并做简单的处理和增删操作。而在 Anaconda 中启动 jupyter notebook 并调用 pandas 和 numpy ，可以进行数据透视和一系列更强大的统计计算，例如计算每一个属性在条目中的有效内容覆盖率，计算数值数据的均值、方差、中位数、极差等数学统计信息。配合 matplotlib 绘图库，你甚至马上可以画出简单的统计图表。</p>
<p>因为 Bangumi 动画条目中的数据项可以自由添加，因此奇奇怪怪的条目非常的多，而且同样的栏目可能命名不同。因此，在这一步主要做的是删掉有效数据覆盖率低的数据栏目，以及合并同样含义的栏目数据。</p>
<p>未经处理的数据栏目类似这样：</p>
<pre>... 上映年度,上映年度:,上映年度（日本）,上色,上色担当,上色指导,上色检查,世界観監修,中国大陆上映年度,中文名,中文名:,主动画师,主标题,主演,主演:,主画师,主要动画师,主要机械设定,主要设计,主要设计工作,主要配音,主要配音演员,主题歌作曲,主题歌作曲:,主题歌作词,主题歌作词:,主题歌演出,主题歌演出:,主题歌编曲,主题歌编曲:,乐器设定,产品经理,产地,人形兵器设计,人物作画监督,人物原案,人物原案:,人物监修,人物设定,人物设定&amp;总作画监督,人物设定:,人物设定·作画监督,人物设定辅佐,人物设计,人物造型,仕上助手,企划,企划·制作,企画,企画:,企画プロデューサー 企画営業プロデューサー:,企画プロデュース,企画・制作,企画制作人,企画制作（第1 - 28話）→制作著作（第29 - 39話）,企画协力,企画担当,企画立案,作曲,作画,作画Animation,作画协力,作画协力:,作画协调,作画监修,作画监督,作画监督:,作画监督协力,作画监督补佐,作画监督补助,作画监督補佐,作画监督辅,作画监督辅佐,作画監督,作画監督補佐,作畫,作畫監督,作畫監督:,作監補,使徒(运营),先行放送,光盘发售日,全收录,全种族召唤师(制片人),全长,共同制作,其他,其他:,其他电视台,其他电视台:,军事·SF考证,军装装备设计,冲印,出品,出品人,出品公司,出品公司:,出品时间,分级,分镜,分镜:,分镜协力,分镜构图,分镜构图:,分镜构图作监:,分镜誊写,创始神,创意制作人,创意总监,创意顾问,别名,别名:,制作,制作:,制作·发行:,制作·版权,制作·音响制作,制作デスク,制作プロデューサー,制作・著作,制作主任 ...</pre>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.012.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.012-1024x768.jpeg" /></a><p>技术要点</p></div>
<h3>可视化分析</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.013.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.013-1024x768.jpeg" /></a><p>可视化分析</p></div>
<p>制作好了 CSV 格式的数据集，就可以利用各种可视化工具进行可视化分析了。</p>
<p>这方面，比较出名的在线工具有 <a href="http://visual.ly">visual.ly</a> ，<a href="http://plot.ly">plot.ly</a> ，<a href="http://tableau.com">tableau.com</a> 和 <a href="http://infogr.am">infogr.am</a> ，收费和部分免费的限制各异，对中文的支持程度也不一。开源免费工具中最好用的是 <a href="http://rawgraphs.io">RAW Graph</a> 。如果自己动手从代码开始，最流行的 <a href="https://d3js.org">D3.js</a> ， <a href="http://developers.google.com/chart/">Google Charts</a> 以及百度的 <a href="http://echarts.baidu.com">ECharts</a> 都十分不错。你甚至可以直接在本地利用 Python 绘图库，或者尝试 Processing 等可视化编程语言：</p>
<blockquote><p>当然无论是Processing还是d3.js,chart.js…或是AI，都只是工具而已，能用到什么程度，还是看使用它的人。数据可视化并不是Processing的核心，Processing可以被叫做创意编程语言，那种感觉就好像它已经从设计师跳脱到艺术家了……很多艺术家都使用processing创造自己的作品。甩个接地气的例子，日本女子组合Perfume有个国际推广的项目<a href="http://www.perfume-global.com">perfume global website</a>，她们几场看起来各种酷炫的黑科技演唱会都有Processing的一份功劳哦。</p>
<p><a href="https://www.zhihu.com/question/23416938/answer/134427120">如何将枯燥的大数据呈现为可视化的图和动画？ – 作者：美数课 – 知乎</a></p></blockquote>
<p>额外一提，因为这个契机接触到的 Processing 这门艺术创意性语言十分有意思。一方面这门类 C 语言实际上是目前很火的 Arduino 硬件平台的官方语言，在计算机导论课程上我们接触过的 Arduino IDE 实际上就是 Processing IDE ，这个组合被大量应用于交互艺术方面。另一方面，大力安利这门语言作者的书《The Nature of Code》，中译《代码本色 – 用编程模拟自然系统》，其中涉及到计算机视觉和自然模拟的内容，包括生成噪点和花纹贴图的各种噪声算法、数学分形、模拟力学、物理系统、随机游走、细胞自动机、神经网络的话题，都十分的有趣。</p>
<div><a href="http://img1.cheny.org/dptool/img/171024145258_v2-16699feaf0dd5ee329e8e66eea09b9b3_hd.png"><img src="http://img1.cheny.org/dptool/img/171024145258_v2-16699feaf0dd5ee329e8e66eea09b9b3_hd.png" /></a><p>数据可视化工具表</p></div>
<h4>结果展示</h4>
<p>后面简单展示一下利用前面抓取的 Bangumi 数据绘制出的分析图片，主要工具是 Plot.ly (免费对数据量有限制) 和 RAW Graph 。其实前述的工具我基本都尝试过一遍，但是最终生成的结果相对好看的只有这两个工具的一小部分。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.014.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.014-1024x768.jpeg" /></a><p>说明</p></div>
<p>因为 Plot.ly 的免费使用对数据量有大小限制，所以使用该工具绘制的图标数据量都只有全部条目的 1/3 量。接下来将会以 Score 、 Rank 、 Votes 简称动画的最终评分、排名、打分总人数。</p>
<h4>用户观看和评分特征分析</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.015.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.015-1024x768.jpeg" /></a><p>用户观看和评分特征分析</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.016.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.016-1024x768.jpeg" /></a><p>BigDataGumi.016</p></div>
<p>评分人数和评分方差并不成线性关系：评分人数少的作品，也可能方差小（意见一致），也可能方差大（争议大）。可以看出 Bangumi 用户评分的方差平均值在 1.8 左右，即标准差在 1.3 左右，换句话说，大部分动画的主要评分能够集中在最终评分±1分的分段。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.017.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.017-1024x768.jpeg" /></a><p>BigDataGumi.017</p></div>
<p>这是把上一页的图表，加上动画的名称标签展开的结果。我们把最终评分 Score 这个维度通过颜色表现出来，可以发现 Votes 极高，也就是用户评分次数特别多的大热作品，一般也是评分相对高的作品。</p>
<p>这里可能反映了 Bangumi 番组计划这个网站用户群体的性质：这里的热门作品和高分作品十分一致，但是这些所谓的 Bangumi 站内热门作品和 Bilibili 等用户面更广的网站中的大众热门作品，例如Fate、刀剑、小埋、民工番们、轻改名著们等并不重合。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.018.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.018-1024x768.jpeg" /></a><p>BigDataGumi.018</p></div>
<p>把作品按 Rank 由高到低从左向右排列，纵轴是方差，可以更清楚的观察到方差拔群的作品：不过大多是评分人数少的小众作品。圆点的大小代表投票人数，其实在这张图我们可以更加感受到：在热门作品中只有声之形、Angel Beats、海贼王、银魂这四部的方差高的不可思议。</p>
<p>无论作品 Rank 多少，是神作还是渣作，方差的分布模式都差不多。并不存在神作或者渣作哪一方往往争议更大的情况。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.019.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.019-1024x768.jpeg" /></a><p>BigDataGumi.019</p></div>
<p>这里是对 Bangumi 用户标记观看进度的行为分析，第一张图是统一尺寸的坐标轴，显然用户最喜欢标记的是看过，之后是想看和在看，搁置和抛弃的标记相对较少。在看数较多的几个数据，明显是当前正在上映的新番。</p>
<p>下方按比例查看，除了想看和在看受到目前新番播放进度的影响较大，我们可以看出看过、搁置、抛弃这三个属性呈现了有意思的的折线：即存在很少人能看完，大部分人都搁置的作品，甚至很少人搁置，大部分人直接抛弃的作品。</p>
<p>接下来我们可以直接比较搁置和抛弃这两个数据。</p>
<p> </p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.020.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.020-1024x768.jpeg" /></a><p>BigDataGumi.020</p></div>
<p>按搁置数排列靠前的作品：海贼王、名侦探柯南、白熊咖啡馆、花开伊吕波、银魂、妖精的尾巴、银魂’、虫师、冰菓、日常、GOSICK、回转企鹅罐、进击的巨人、来自新世界、无头骑士异闻录、未来日记、命运石之门、幸运星。</p>
<p>按抛弃数排列靠前的作品：进击的巨人、白熊咖啡馆、花开伊吕波、GOSICK、暗杀教室、樱花庄的宠物女孩、海贼王、Re：从零开始的异世界生活、来自风平浪静的明天、青之驱魔师、未来日记、境界线上的地平线、火影忍者、黑子的篮球、冰菓。</p>
<p>这些作品以京都和 PA 的日常番、一粉顶十黑的小学生番、超长民工番和电波名作为主。这里仍然颜色浅的是 Rank 高的作品，从搁置到抛弃两个角落，呈现到由浅到深的线性渐变。看来，评分低的作品可以随手抛弃，而对于评分高的公认神作，大部分用户都选择扔到搁置里，觉得自己总有一天会看完吧。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.021.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.021-1024x768.jpeg" /></a><p>BigDataGumi.021</p></div>
<p>这里对比想看和看过两个数据，可以发现想看和搁置有异曲同工之妙，区别可能是看过后搁置的作品，热度显著高于和想看而还没看的作品。原来作品的热门程度对是否有过观看行为影响较大 —— 可能这关系到作品的资源多不多，是否成为话题。</p>
<p>筛出图表右侧这些想看数独树一帜，但是其实大部分人最后都没看的作品，就可谓是个简单易懂的补番装逼目录了。</p>
<h4>动画制作公司分析</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.022.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.022-1024x768.jpeg" /></a><p>制作公司分析</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.023.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.023-1024x768.jpeg" /></a><p>BigDataGumi.023</p></div>
<p>在我们的印象中，往往对各种动画制作公司有质量高低的成见，比如京都出品必属精品，比如惨遭 A1 动画化，比如骨头社或者宅社的会玩任性 …… 但是实际按动画制作公司所有作品收到的 1~10 的评分绘制成饼图，却发现大部分公司收到的评分比例十分类似。</p>
<p>这是因为我们公认的制作精品数高的公司，往往以少数评分特别高的作品给人留下印象吗？不过，因为这张图数据只含前 1/3 的动画条目，可能对少数烂片特别多的公司有所偏颇 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.024.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.024-1024x768.jpeg" /></a><p>BigDataGumi.024</p></div>
<p>观察动画条目中集数的分布，以 1 集剧场版或 OVA ，或者单季度 12 双季度 24 长度为主，这是理所当然的结论。动画的集数长度和最终评分似乎并没有什么关联。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.025.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.025-1024x768.jpeg" /></a><p>BigDataGumi.025</p></div>
<p>左侧的动画集数、右侧的动画制作公司都按照作品数目由多到少排列。分数段越高，所含的作品就越少。</p>
<p>然而观察高分段作品右侧和制作公司关联的曲线走向，基本都直奔着最顶上走：这意味着最高分段的几部作品，都来自作品数量十分多的实力深厚的大公司，而不是只有几部作品的小作坊。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.026.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.026-1024x768.jpeg" /></a><p>BigDataGumi.026</p></div>
<p>以辐射图的形式，我们可以观察一些作品的人气或者制作数量特别突出的公司。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.027.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.027-1024x768.jpeg" /></a><p>BigDataGumi.027</p></div>
<p>一部分的动画制作公司数量显著高于人气，另一部分则是人气显著高于数量。其中的作品类型也泾渭分明。</p>
<h3>机器学习？</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.028.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.028-1024x768.jpeg" /></a><p>机器学习</p></div>
<p>之前收集到的大量 STAFF 和标签数据，因为并不是量化的数值，在可视化图表中并没有得到体现。其实在这次的项目开始之初，我就计划利用这份数据做个针对 STAFF 和 TAG 信息，对还未放送或者刚开始放送的新番，进行机器学习训练达到预测最终评分的尝试。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.029.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.029-1024x768.jpeg" /></a><p>机器学习实践初步想法</p></div>
<p>由于机器学习和神经网络这些新兴的人工智能领域，我几乎是到了大学后才第一次接触，目前还很陌生，所以截止撰文时只有粗略的想法，并没有取得实际进展。这里就不展开讲述了，等待我入门了相关知识后，再进行 BigDataGumi 项目的二期机器学习阶段吧。</p>
<p>一个有学长在参与的有意思的 Bangumi 相关项目：<a href="http://bgm.tv/group/topic/343652">基于用户评分的针对性动画推荐工具 | Bangumi</a> ，推荐系统研究的成分比较大，使用的似乎是 SVD (奇异值分解) 实现的基于项目的协同过滤推荐 (Item-based Collaborative Filtering Recommendation) 。</p>
<h3>结束</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.0302.jpeg"><img src="http://img1.dimpurr.com/dimblog/2017/12/BigDataGumi.0302-1024x768.jpeg" /></a><p>THANKS</p></div>
<p>这次项目一期虽然做的并不是很深入，不过在尝试数据爬虫抓取和可视化分析的过程中，浅尝辄止的接触到了这两个领域很多有意思的技术和工具，也增加了一些 Web 开发和 Python 的经验。应该说，算是接触和了解了数据挖掘这个大学以前闻所未闻的新兴热门领域（毕竟我是个高中信息闭塞了三年，从 2014 年穿越过来的前端开发者 233），也算达到了这门导论课的目的。相比别的同学选的各种尴尬的水课，我觉得这学期选了这门选修课还真是最明智的决定。</p>
<p>数据挖掘可以作为未来一个备选的发展方向，也因为这次的机会认识了学校数字媒体学院的一些在做数据可视化、视觉传达、交互艺术项目的学姐和导师，不得不说，计算机视觉方面我也有几分兴趣。不过目前来说，最想做的还是尝试入门机器学习和神经网络相关的知识。和计算机学院、信息通信学院的几位同学，和在做机器学习和自然语言处理相关项目的研究生学长都提过这个想法，接下来希望能向他们请教学习，把 BigDataGumi 项目二期机器学习标签预测的想法实现了。</p>
<p>项目的进度将会实时更新在知识库的项目草稿： <a href="http://note.dimpurr.com/#BigDataGumi%20草稿">http://note.dimpurr.com/#BigDataGumi%20草稿</a></p>
<p>以上。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/bigdata-gumi/">BigDataGumi 一期小记 – 浅尝爬虫数据抓取和简单可视化分析 (PySpider)</a></p>]]></content>
        
        <summary type="html">
            
            这学期在学校选修了一门名为「大数据分析技术导论」的公选课，课上纲领性的介绍了目前正处风口的大数据时代的特点，数据挖掘技术的操作过程和实际应用，并从统计分析基础和数据分析工具介绍两方面介绍了一些实践性质的内容。因为是导论性质的课程，课堂内容侧重介绍和应用的性质居多，而对围绕 Ha
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Python"/>
        
        <category term="动画"/>
        
        <category term="大数据"/>
        
    </entry>
    
    <entry>
        <title>CMake编译Opencv时遇到的bug解决方案 windres.exe: unknown option -- W ...  ； &#39;sprintf_instead_use_StringCbPrintfA_ was not declared in this scope ..</title>
        <link href="http://blog.vitechliu.com/note/qt_mingw_opencv_compiling_bugs.html"/>
        <id>http://blog.vitechliu.com/note/qt_mingw_opencv_compiling_bugs.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2017-10-21T14:07:39+00:00</published>
        <updated>2017-10-21T14:07:39+00:00</updated>
        
        <content type="html"><![CDATA[<p>执行mingw32-make后</p>
<p>28%左右遇到这种错误：<br />
... windres.exe: unknown option -- W ...</p>
<p>解决方案：<br />
在cmake中 取消勾选 ENABLE_PRECOMPILED_HEADERS</p>
<hr />
<p>32%左右遇到这种错误 ：<br />
'sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA' was not declared in this scope ...</p>
<p>解决方案：<br />
在..\opencv\sources\modules\videoio\src\cap_dshow.cpp<br />
在#include "DShow.h"这一行前加上#define NO_DSHOW_STRSAFE</p>]]></content>
        
        <summary type="html">
            
            执行mingw32-make后 28%左右遇到这种错误： ... windres.exe: unknown option -- W ... 解决方案： 在cmake中 取消勾选 ENABLE_PRECOMPILED_HEADERS  32%左右遇到这种错误 ： &#39;sprintf
            
        </summary>
        
    </entry>
    
    <entry>
        <title>使用 TiddlyWiki 打造轻便个人 Wiki 知识库</title>
        <link href="http://blog.dimpurr.com/tiddly-wiki/"/>
        <id>http://blog.dimpurr.com/tiddly-wiki/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2017-10-03T18:33:30+00:00</published>
        <updated>2017-10-03T18:33:30+00:00</updated>
        
        <content type="html"><![CDATA[<p>这篇文章将简要介绍 TiddlyWiki 的特点，并且分享一些常用的参考链接、资源、插件和常见问题的解决方案，以方便有相近需求的小伙伴们。</p>
<p>TiddlyWiki ，按官方说法是一个「非线性个人 Web 笔记本」。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全部都在一个单 html 文件内，与此同时仍然有着非常强大的功能和插件系统。在我看来，管理以文字、代码和数学公式为主的个人知识库， TiddlyWiki 可谓是最好的选择之一。</p>
<p>可以在我的知识库站点「Dimpurr’s Knowledge Base #1」：<a href="http://note.dimpurr.com/">http://note.dimpurr.com/</a> 体验一下 TiddlyWiki 的使用和效果。</p>
<p>注意，任意访客都可以体验到 TiddlyWiki 的全部功能，包括编辑和设置。不用担心，你可以随意折腾，因为你无法将更改保存到我的服务器上，只能下载到本地。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-1.jpg"><img src="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-1-1024x640.jpg" /></a><p>TiddlyWiki 效果预览</p></div>
<p><span></span></p>
<p>我想找到一个能方便快捷的打打笔记和维护个人知识库 Wiki 的方式已经很久了。</p>
<p>笔记软件，例如 EverNote 、 WizNote 、 OneNote 的确十分不错，但是也会带来客户端是否跨平台、启动速度是否好看甚至默认文字排版是否美观的问题；而且，常规的笔记软件也达不到 Wiki 级别方便的 Tag 标签系统。当然， Wiki 系统有经典的 MediaWiki 系统，还有许许多多的静态 Wiki 系统、 Wiki 知识库类客户端。然而， MediaWiki 庞大、复杂和丑陋； Wiki 客户端程序有好有坏，有设计简陋也有强大美观，但是最大的限制还是往往不跨平台；一些可以用 Github Pages 部署的，基于 Markdown 的 Wiki 系统尽管几乎能在功能上满足我的需求，但是每一次撰写新条目和部署的复杂度还是令人难以接受。</p>
<p>你可能已经看出了我口味相当的刁钻和需求相当的诡异 …… 高中时因为没有时间折腾，我搭建了一个 Ghost 博客来存放简单的读书笔记，然而随着某次 VPS 上的 SQLite 被我搞跪了之后，天国的 WIKI#0 除了遗留下来数据库里的几篇文章之外，就这样成为了历史。高中毕业的暑假来临，我决定动手寻找一款我需要的 Wiki 系统。于是，我找到了 TiddlyWiki 。</p>
<h2>TiddlyWiki 的特点</h2>
<ul>
<li><strong>程序和数据全部存储在一个单文件 html 中</strong>
<ul>
<li>这让 TiddlyWiki 既可以在你的本机运行，类似一个在浏览器中运行的绿色版单文件应用程序；又可以上传到服务器上，和网络上的所有人分享</li>
<li>同时部署极其简单，只需要一个能存放 html 的服务器，上传上去就可以使用，根本不需要 PHP、 Node.js、Python 或者其他什么语言环境，也没有任何配置步骤</li>
<li>你可以随时再把服务器上的 TiddlyWiki 保存进本地或者 U 盘，以便带进任何没有网络的环境查阅</li>
</ul>
</li>
<li><strong>作为 Wiki 系统，有 Tag 标签和条目关联等必须的基本功能，和强大的编辑器</strong>
<ul>
<li>你能用 Tag 快速整理条目</li>
<li>你能用 <code>[[条目名]]</code> 这样的语法快速链接到其他条目</li>
<li>你能用条目名作为 Tag 其他条目，达到设置子条目的效果</li>
<li>你甚至可以用 <code>&lt;&lt;list-links "[tag[ACM]sort[title]]-[tag[OJ 草稿和题解]]"&gt;&gt;</code> 这样的过滤器生成一个包含特定 Tag ，但是删除掉另一个特定 Tag 的条目列表！</li>
<li>TiddlyWiki 使用一种类似 Markdown 但是稍有差异的语法，不过很快可以习惯并且非常好用</li>
</ul>
</li>
<li><strong>方便的插件和主题系统</strong>
<ul>
<li>可以通过插件支持代码高亮、 LaTex 数学公式、标准 Markdown 语法、文章嵌入 TODO 列表、条目加密锁定 ……</li>
<li>可以安装 Material Design 风格、博客风格的样式主题 ……</li>
</ul>
</li>
<li><strong>外观和操作设计别致，使用体验好</strong>
<ul>
<li>TiddlyWiki 是一个典型的单页面 Web 应用，所以打开的时候全部内容都已经载入和缓存在了浏览器中，换而言之你不需要刷新页面，操作和访问体验非常快速和流畅</li>
<li>TiddlyWiki 在右侧是搜索和多种方式的条目索引，而左边是可以卡片式展开多个和关闭的条目，还可以为特定的条目顺序和组合生成静态链接，浏览和使用十分方便</li>
</ul>
</li>
</ul>
<h2>如何开始</h2>
<p>进入 <a href="http://tiddlywiki.com">http://tiddlywiki.com</a> 官网，阅读下面的 GettingStarted 条目。这里根据你的浏览器版本会切换的对应的教程，不过总的来说，你只需要点击 Download Empty 按钮就可以下载好一个全新的 TiddlyWiki 的 html 文件了。或者，你可以按照官方说明通过 Node.js 从 npm 安装。</p>
<p>你已经可以开始本地体验和使用了。</p>
<p>注意，你可能需要去设置页面手动安装并启用中文语言包。</p>
<p>当然，我觉得大部分人应该都有上传到服务器上，以便发送地址和在线共享的需求。一般我们会需要把默认的 tiddlywiki.html 重命名成 index.html ，这样访问就很方便了。</p>
<p>不过如果你直接上传 html 文件到服务器，你会发现，每次保存都会重新向本地下载一个编辑后的 html ，然后你需要不厌其烦的用 FTP 再进行上传和替换 …… 其实，只需要简单的配置 PHP 或者 Node.js 保存服务，就可以解决这个问题。</p>
<p>额外的： <a href="http://tiddlyspot.com">http://tiddlyspot.com</a> 提供了一个似乎是免费的在线托管 TiddlyWiki 的服务，还提供了专门用于 GTD 的一些模板； <a href="https://github.com/Jermolene/TiddlyDesktop/">TiddlyDesktop</a> 是一个 TiddlyWiki 专用的浏览器，或者说桌面客户端。</p>
<h3>PHP 保存</h3>
<p>PHP 保存非常容易配置。官方的教程在这里：<a href="http://tiddlywiki.com/#Saving%20on%20a%20PHP%20Server">http://tiddlywiki.com/#Saving%20on%20a%20PHP%20Server </a></p>
<ol>
<li>在 <a href="https://code.google.com/archive/p/bidix/downloads">https://code.google.com/archive/p/bidix/downloads</a> 下载一份 <code>TiddlyHome_*.*.*.zip</code></li>
<li>找到里面 <code>_th\lib\store.php</code> 这个文件，解压并编辑里面的 <code>$USERS = array( 'UserName1'=&gt;'Password1', etc)</code> 为你想要的用户名和密码</li>
<li>上传 store.php 到你的服务器，去 TiddlyWiki &gt; 保存 &gt; TiddlySpot 保存模块 ，设置 高级设置 &gt; 服务器网址 为这个 store.php 文件的完整地址，然后在上面填写用户名和密码</li>
<li>现在，点击保存时，已经会直接保存在服务器上了</li>
<li>注意：
<ol>
<li>你可能需要把备份文件名设置成 index.html</li>
<li>每次保存都会自动创建一份备份，你可以定期手动清理</li>
<li>建议修改备份文件夹为 backup ，这样会把备份保存在 backup/ 子目录而非 . 根目录下</li>
</ol>
</li>
</ol>
<p>因为 TiddlyWiki 并没有用户登陆界面，这个设置页面就相当于登陆页面。密码是按浏览器保存的，所以如果你想在当前浏览器退出登录，到设置页面清除密码设置就好。如果你换了一个浏览器打开 Wiki ，你将需要进入设置重新填写一次密码(相当于登陆)，才能使用在线保存。</p>
<h4>可能遇到的 store.php 错误</h4>
<p>如果你在如上配置完成后，点击保存后弹出正在保存 Wiki，此后就没有反应、并且在浏览器开发者工具中的 Network 网络面板看到 500 Internal Servel Error ，你可以尝试打开 PHP 的错误日志查看报错：</p>
<pre>vim  /usr/local/php/etc/php-fpm.conf
php_flag[display_errors] = On # 直接在网页上显示错误信息
#php_admin_value[error_log] = /usr/local/php/var/log/php_errors.log
#php_admin_flag[log_errors] = on
cat /usr/local/php/var/log/php-error.log # 或者直接在浏览器中查看报错</pre>
<p>如果遇到关于 split() 函数的问题：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/10/QQ图片20180316213404.png"><img src="http://img1.dimpurr.com/dimblog/2017/10/QQ图片20180316213404-600x340.png" /></a><p>TiddlyWiki store.php split() error</p></div>
<p>那么可能是你运行的 php 版本已经废弃这个函数，编辑 <code>store.php</code> 文件并查找替换所有的 <code>split </code>为 <code>explode</code> 即可。</p>
<h2>可能用到的资源</h2>
<p>我收集的 TiddlyWiki 相关资源，都会第一时间整理到我的知识库： <a href="http://note.dimpurr.com/#TiddlyWiki%20使用">http://note.dimpurr.com/#TiddlyWiki%20使用</a></p>
<p>比较重要的包括：</p>
<ul>
<li>第三方官网繁体中文翻译 <a href="http://tw5-zh.tiddlyspot.com/">http://tw5-zh.tiddlyspot.com</a> (感谢 Bennyli 提醒)</li>
<li>编辑器标记语法参考 <a href="http://tiddlywiki.com/#WikiText">http://tiddlywiki.com/#WikiText</a></li>
<li>TiddlyWiki Community (官方整理的社区资源列表) <a href="http://tiddlywiki.com/#Community:Community%20Plugins">http://tiddlywiki.com/#Community:Community%20Plugins</a></li>
<li>tid.li Plugins (一个个人第三方插件源) <a href="http://tid.li/tw5/plugins.html">http://tid.li/tw5/plugins.html</a></li>
<li>CommunityPlugins (更大的一个第三方插件索引) <a href="http://erwanm.github.io/tw-community-search/#CommunityPlugins">http://erwanm.github.io/tw-community-search/#CommunityPlugins</a></li>
</ul>
<h2>关于插件</h2>
<p>需要注意的是， TiddlyWiki 最新的版本 5 有重大的变化，导致针对老版本设计的插件全部失效无法安装。你可能会在网上搜索到很多老版本的插件源，以及告诉你使用新建条件、粘贴插件代码内容的方式安装，都已经无法再使用了。所以，记得确认你找到的插件支持 TW5 。</p>
<p>目前，正确的插件安装方式除了在设置页面的官方插件源在线安装，对于第三方插件源来说，一般是你拖动第三方插件源提供的链接、图标或者按钮(不一定有效)，或者其设置页面的插件名称(一定有效)，拖动到你的 Wiki 页面上，完成导入安装。</p>
<p>我这里安利下我用到的插件，更多的可以在官方插件、主题市场和上面的插件源里自己发掘。</p>
<ul>
<li>TiddlyWiki 官方插件程式库
<ul>
<li><strong>Highlight.js: syntax highlighting</strong> 代码高亮，程序员必备</li>
<li><strong>Markdown parser</strong> 添加标准 Markdown 支持，如果你希望和  md 格式的平台互相导入和导出的话；大部分情况下，如果可以我建议使用原生 TiddlyWiki 语法，因为功能更加强大和对插件支持更好</li>
<li><strong>KaTeX: mathematical typography</strong> 数学公式输入和排版</li>
</ul>
</li>
<li><strong><a href="http://mathjax-tw5.kantorsite.net">MathJax</a></strong> 相比 KaTeX 更强大的 TeX 解析器
<ul>
<li>为了兼容新版主题，你可能需要 <a href="https://gist.github.com/kpe/cc0547b318e6f8d4ddaa#gistcomment-1885438">做点微小的工作</a> 修改一行插件代码</li>
</ul>
</li>
<li><a href="http://erwanm.github.io/tw-community-search/#">TiddlyWiki Community Search </a>
<ul>
<li><strong><a href="http://grosinger.net/tw5-checklist/">tw5-checklist</a></strong> 我经常使用的，一个轻量级在文章中嵌入 checklist 的插件，适合做些学习计划等</li>
<li><strong>Encrypt-Tiddler</strong> 对单个条目启用输入密码查看</li>
</ul>
</li>
<li><a href="http://tid.li/tw5/plugins.html">tid.li Plugins</a>
<ul>
<li><strong>ToDoNow</strong> 一个强大的简直有点过头的嵌入 Todolist 插件</li>
<li><strong>EditorCounter &amp; Autosaver </strong>为编辑器添加字数统计和一定字数更改后自动保存 (原生自带了条目修改确认和删除操作时自动保存功能，去设置里开启即可)</li>
</ul>
</li>
<li><strong><a href="http://tiddlymap.org">TiddlyMap</a></strong> 一个强大的令人发指的流程图、思维导图等绘制插件</li>
</ul>
<p>至于主题也有不少，不过我对默认的主题很满意 (你可能会发现 TiddlyWiki 的默认样式巧合的和我的 <a href="http://blog.dimpurr.com/clearision/">Clearision</a> 博客主题灰色风格的设计十分相似) ，外加懒得折腾，所以就没有更换。</p>
<p>当然，尽管内容数据很难占据多少空间，安装过多不必要的插件却可能很快使 html 源文件尺寸增大，这点需要注意。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-mathjax.jpg"><img src="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-mathjax-600x375.jpg" /></a><p>使用 MathJax 插件在 TiddlyWiki 显示数学公式</p></div>
<h2>关于文本编辑</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-table.jpg"><img src="http://img1.dimpurr.com/dimblog/2017/10/tiddlywiki-table-1024x640.jpg" /></a><p>TiddlyWiki 表格排版</p></div>
<p>请务必花点时间阅读编辑器标记语法参考 <a href="http://tiddlywiki.com/#WikiText">http://tiddlywiki.com/#WikiText</a> 的内容，你会发现十分值得。这里强调几点我觉得特别有用的内容。</p>
<p>插入图片的正确姿势是 <code>[img[http://img1.cheny.org/dptool/img/170921112724_v2-0d6d1cde06a90b753193b510e5b9a5a4_r.jpg]]</code> 。文本中的 URL 会被自动识别为链接，如果你想要给一段自定义文本设置超链接，试试 <code>[ext[个人成长/学习/考试/品格/自控/时间管理 - Dimpurr 的知乎收藏|https://www.zhihu.com/collection/104053246]]</code>(ext 大部分情况下可以省略)。</p>
<p>相比 Markdown 的用缩进排版， TiddlyWiki 的无序列表 * 和有序列表 # ，以及缩进子列表不用 Tab 而是用两次列表符号比如 ** 或者 *# 刚开始可能显得有点让人迷惑。习惯就好。</p>
<p>用 TiddlyWiki 排版表格真的非常的爽！你可以自由的设置表头，表尾，表名，每个单元格对齐方式，跨格，而且语法非常简单方便，输入流畅。请阅读官方文档 <a href="http://tiddlywiki.com/#Tables%20in%20WikiText">http://tiddlywiki.com/#Tables%20in%20WikiText</a> 。</p>
<p>前面展示过自动生成条件列表，并且按 Tag 过滤的「魔法」。参考：<a href="http://tiddlywiki.com/#Transclusion%20in%20WikiText">http://tiddlywiki.com/#Transclusion%20in%20WikiText</a> ，记得阅读底部的 See also 详细说明！</p>
<p>如果你愿意折腾，你可以尝试学习 Macro 宏和 Variables 变量的用法。</p>
<p>TiddlyWiki 有时会把符合 PascalCase / UpperCamelCase 的词自动识别为条目链接。你只需要在前面加入一个波浪线 ~ 转义，比如 ~TiddlyWiki ，就会恢复为纯文本。</p>
<p>安装了 Highlight.js 插件后，你可以这样指定代码块使用的高亮语法：</p>
<pre>```bash
➜ ~ pwd
/Users/dimpurr
```</pre>
<p>在 Highlight.js 插件设置页面你可以找到支持的语法列表。注意所有 shell 命令的标识符是 bash ，而不是 sh 或者其他的什么。</p>
<h2>一些小问题</h2>
<h3>禁用搜索最小字数限制</h3>
<p>TiddlyWiki 默认的搜索框存在字符数限制，要求搜索关键词大于三个字符。对于英语环境来说这很合理，但是对于中文来说，二字词的搜索是很常见的，因此很不方便。修改这个设置只需要：</p>
<ul>
<li>添加一个标题为 <code>$:/config/Search/MinLength</code> 的新条目</li>
<li>内容为 <code>1</code></li>
</ul>
<h3>禁用自动 WikiLink</h3>
<p>TiddlyWiki 默认自动会把符合 CamelCase 的文本替换为条目链接，称为 WikiLinks 或者 WikiWords  。一般来说你可以用 ~WikiText 来转义禁止链接，但是对于长篇文章这样做实在辛苦。网上流传的基本是直接禁用 WikiLink 功能的方法，但是这样之前 ~ 反转移过的文字又会显示出 ~ 符号。</p>
<p>一个既能让之前的 ~ 不显示，同时也不会有自动链接的方法是：</p>
<ol>
<li>点击搜索框旁边的图标进入 AdvancedSearch</li>
<li>搜索 <code>$:/core/modules/parsers/wikiparser/rules/wikilink.js</code> ，或者点击 <code>$:/core</code> 再找到这个条目，点击进入编辑</li>
<li>系统会提示 <code>这是一个修改过的默认条目。删除此条目可以还原为 $:/core 插件中的默认版本。</code> 因此不用担心</li>
<li>找到最后面的 <code>return [{return [{ type: "link",</code> ，在这一行上面加上一行 <code>return [{type: "text", text: linkText}];</code> ，以便在本要返回链接的时候返回纯文本</li>
</ol>
<h3>使用树状结构组织条目内容</h3>
<p>如果你对条目的组织结构有强迫症，又不像我一样觉得内容零散到只能手动编写目录，使用自带的树状目录系统是个好选择。</p>
<pre>&lt;div class="tc-table-of-contents"&gt;
&lt;&lt;toc-selective-expandable 'Contents' sort[title]&gt;&gt;
&lt;/div&gt;</pre>
<p>通过以上代码可以创建以 Contents 条目(该条目不会显示出来)为根节点，按照标签关系嵌套的树状目录结构列表。</p>
<p>通过将这个条目命名为「目录」，并加上 <code>$:/tags/SideBar</code> 标签，就可以使这个目录显示到侧边栏。效果如下：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2017/10/TIM截图201712161811101.png"><img src="http://img1.dimpurr.com/dimblog/2017/10/TIM截图201712161811101-600x298.png" /></a><p>TiddlyWiki 树状目录</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/tiddly-wiki/">使用 TiddlyWiki 打造轻便个人 Wiki 知识库</a></p>]]></content>
        
        <summary type="html">
            
            这篇文章将简要介绍 TiddlyWiki 的特点，并且分享一些常用的参考链接、资源、插件和常见问题的解决方案，以方便有相近需求的小伙伴们。 TiddlyWiki ，按官方说法是一个「非线性个人 Web 笔记本」。相比其他笔记和 Wiki 系统，其最大的特点之一是程序本体和数据全
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="TiddlyWiki"/>
        
        <category term="前端"/>
        
        <category term="学习"/>
        
    </entry>
    
    <entry>
        <title>Matlab App Designer UIFigure中利用dojo/js/Container/缩放/改图标等技巧</title>
        <link href="http://blog.vitechliu.com/frontend/matlab_app_designer_uifigure_webview_dojo.html"/>
        <id>http://blog.vitechliu.com/frontend/matlab_app_designer_uifigure_webview_dojo.html</id>
        
        <author>
            <name>vitech</name>
        </author>
        
        <published>2017-09-20T12:40:23+00:00</published>
        <updated>2017-09-20T12:40:23+00:00</updated>
        
        <content type="html"><![CDATA[<p>本文部分内容翻译于：<a href="http://undocumentedmatlab.com/blog/customizing-uifigures-part-1">Undocumented Matlab</a></p>
<p>Matlab AppDesigner是R2016a之后推出的新界面设计工具，较GUIDE的GUI 界面更美化，组建更丰富，具有自动化编程等特性。</p>
<p>但是表面上看AppDesigner并没有暴露很多组件诸如Javaframe</p>
<p>GUIDE的figure(gcf)是基于Java的Jframe组件，而Appdesigner的app.UIFigure是基于html的webview,本质上运行了一个CEF(Chromium嵌入式框架 Chromium Embedded Framework version 3.2272 on <a href="https://www.chromium.org/developers/calendar">Chromium 41</a> in R2016a)。使用的<a href="https://dojotoolkit.org/">JS DOJO 套件</a>，可以想象Matlab与js/webapp接轨的趋势了。。</p>
<p>因此，如果像GUIDE一样或者其他教学一样视图获取</p>
<pre><code>get(app.UIFigure,'javaframe')
</code></pre>
<p>会得到一个空数组，而且是特意留下的，Matlab一直有抛弃javaframe的想法，还发布过调查，现在看来还是不敢完全抛弃。</p>
<p>不说更多，下面就揭示一些其他组件结构吧。</p>
<p><a href="http://blog.vitechliu.com/frontend/matlab_app_designer_uifigure_webview_dojo.html">[...]</a></p>]]></content>
        
        <summary type="html">
            
            本文部分内容翻译于：Undocumented Matlab Matlab AppDesigner是R2016a之后推出的新界面设计工具，较GUIDE的GUI 界面更美化，组建更丰富，具有自动化编程等特性。 但是表面上看AppDesigner并没有暴露很多组件诸如Javafram
            
        </summary>
        
    </entry>
    
    <entry>
        <title>梦里的老王、麻酱糖饼和《范德华北》</title>
        <link href="http://snowonion-blog.logdown.com/posts/1806655-dreamt-of-dr-wang-and-chinese-pancake-with-sweet-solid-sesame-paste-and-a-poem-called-van-der-waals-north-or-van-der-north-china"/>
        <id>http://snowonion-blog.logdown.com/posts/1806655-dreamt-of-dr-wang-and-chinese-pancake-with-sweet-solid-sesame-paste-and-a-poem-called-van-der-waals-north-or-van-der-north-china</id>
        
        <author>
            <name>SnowOnion</name>
        </author>
        
        <published>2018-03-09T14:09:40+00:00</published>
        <updated>2018-03-09T14:09:40+00:00</updated>
        
        <content type="html"><![CDATA[您的浏览器不支持无插件音频播放，请到 http://7tsy1b.com1.z0.glb.clouddn.com/audio/%E4%BD%9B%E7%BB%8F%E5%9B%9B%E5%B0%8F%E5%A4%A9%E9%B9%85.mp3 聆听

<p>↑建议打开背景音乐。</p>

<p>早上做了俩梦。第一个梦是这样的。我到一个博物馆参观；博物馆的展品是阿拉伯弯刀。这博物馆同时又是一个「武道馆」，比如有一个展览房间里站着一个教练和 30 个学员组成的 <code>5*6</code> 矩阵；学员们周期性地挥动圆月弯刀，动作整齐划一，应该说一模一样，就像游戏里不可对话的 NPC。然后，我进入博物馆的最里面一个房间，发现一把宝刀，就起了贼心，趁四下无人拿起刀来。顿时！警铃大作，铃声内容是古兰经 + 电吉他四小天鹅，类似文章开头的 BGM。我吓坏了，赶紧原路往外跑，一路上 NPC 们都变敌对了，拿弯刀砍我脖子和脚脖子，挨了几十刀，疼疼疼，满身是血。跑到门口，看见人民保安对我微笑点头，我像见到亲人般哭了。</p>

<p>虽然好像没醒，但是第一个梦没有继续。</p>

<p>第二个梦很长。一天傍晚，隔壁老王访问我校某食堂，好像是甲所。甲所「打菜窗口」的风格是，怎么说呢，「太空船里的酒吧吧台」。餐桌是大理石的，长条椅子也是大理石的，没有靠背。老王对麻酱糖饼赞不绝口。「时间不早了，在这儿睡觉觉嘛」，于是老王夜宿甲所宾馆 100 层。安顿下老王，我走到房间外抽颗烟，看见墙上的电幕播报晚间新闻，插播紧急消息，说我市圆月博武馆正在发生一起砍人事件，一男子满身是血逃出博武馆，直播画面（通过甲所电梯里的摄像头采集）显示该男子正在乘电梯试图上到甲所宾馆 100 层。这宾馆有 100 层，配有两部电梯。看着一部电梯不断上升的数字，我慌忙坐上另一部电梯往下走。这电梯下行速度超快，可以全程失重，脚稍稍离开电梯底部飘着；而且落地时一点儿都不不震得慌，这很魔法。落地只用了 t 时间，血男还没上到 100 层，我长出一口气。</p>

<p>甲所的 0 层大厅里，电幕在播出晚间新闻。新闻说，今天白天《欢乐中国行》西安站，有个节目是当地某监狱一在押犯唱歌，表达一种大型改过自新。结果在直播中，该在押犯突然和着旋律唱起自编的淫秽歌词，诸如「大开发的喇叭在号子里吹响 监狱的女警追赶那潮头竞风流 冰河化春水 荒漠变绿洲」。新闻给出了现场视频，视频显示现场的音响设备被迅速中断，但是穿着各事业单位文化衫的观众集族还是一阵骚动。</p>

<p>我感叹着这人不要减刑了，走出甲所大门。大门外是个视野开阔的广场，一位年轻妈妈追着三四岁的熊孩子跑。熊孩子蛇形走位，妈妈追将不上，我蹲在一旁观看。熊孩子回头冲妈妈笑，脚步还不停，结果一下子撞进了我怀里。妈妈从我怀中接过熊孩子，即兴朗诵了一首锤体诗：</p>

<div><pre>华北平原上，
我靠近了你 你远离了我
我远离了你 你靠近了我
直到一天 我离你太远了
你宣布
华北的全称是范·德华北
</pre></div>


<p></p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E8%8C%83%E5%BE%B7%E5%8D%8E%E5%8A%9B.jpg" /><p></p>

<p>P.S.（不在梦里）</p>

<ul>
<li>背阴面儿的房间で，穿袜子で睡觉，对我来说能有效防止感冒</li>
<li>甲所忒贵，但是烤鳕鱼（？）特好吃</li>
<li>西部放歌挺好听的</li>
<li>我不抽烟</li>
</ul>

<p>（BGM：《疯狂的石头》接近高潮的配乐，常称为「佛经四小天鹅」或「佛经天鹅湖」。若您是权利人，有必要时请告知我删除。）</p>

<p>^D</p>]]></content>
        
        <summary type="html">
            
            您的浏览器不支持无插件音频播放，请到 http://7tsy1b.com1.z0.glb.clouddn.com/audio/%E4%BD%9B%E7%BB%8F%E5%9B%9B%E5%B0%8F%E5%A4%A9%E9%B9%85.mp3 聆听  ↑建议打开背景音乐。  早
            
        </summary>
        
    </entry>
    
    <entry>
        <title>学术讲座通知​：深度结构建模及其在物体检测和姿态估计中的应用</title>
        <link href="http://www.pris.net.cn/archives/3731"/>
        <id>http://www.pris.net.cn/archives/3731</id>
        
        <author>
            <name>李春光 (Chun-Guang LI)</name>
        </author>
        
        <published>2017-04-06T17:09:57+00:00</published>
        <updated>2017-04-06T17:09:57+00:00</updated>
        
        <content type="html"><![CDATA[<p>题目：Modeling deep structures with application to object detection and pose estimation<br />
报告人：<a href="http://www.ee.cuhk.edu.hk/~wlouyang/" target="_blank">欧阳万里</a> 博士 香港中文大学<br />
主持人：李春光<br />
时间：2017年4月12日(星期三)16:00-17:20<br />
地点：教三811会议室</p>
<p>摘要：Deep learning attempts to learn feature representation by multiple levels of abstraction. It is found to be useful in speech recognition, face recognition, image classification, biology, physics, and material science. In this talk, a brief introduction will be given on our recent progress in using deep learning as a tool for modeling the structure in visual data for object detection and human pose estimation. We show that observation in our problem are useful in modeling the structure of deep model and help to improve the performance of deep models for our problem.</p>
<p>报告人简介:<br />
Wanli Ouyang received the PhD degree in the Department of Electronic Engineering, The Chinese University of Hong Kong, where he is now a research assistant professor. His research interests include image processing, computer vision and pattern recognition. He is the first/correspondence author of 6 papers on TPAMI and IJCV, and has published 26 papers on top tier conferences like CVPR, ICCV and NIPS. ImageNet Large Scale Visual Recognition Challenge (ILSVRC) is one of the most important grand challenges in computer vision. The team led by him ranks No. 1 in the ILSVRC 2015 and ILSVRC 2016. He receives the best reviewer award of ICCV. He has been the reviewer of many top journals and conferences such as IEEE TPAMI, TIP, IJCV, TSP, TITS, TNN, CVPR, and ICCV. He is a senior member of the IEEE.<br />
(更多信息请关注:  http://www.ee.cuhk.edu.hk/~wlouyang/ )</p>]]></content>
        
        <summary type="html">
            
            题目：Modeling deep structures with application to object detection and pose estimation 报告人：欧阳万里 博士 香港中文大学 主持人：李春光 时间：2017年4月12日(星期三)16:00-17:
            
        </summary>
        
        <category term="PRIS快讯"/>
        
    </entry>
    
    <entry>
        <title>按照选举的法</title>
        <link href="http://snowonion-blog.logdown.com/posts/1520074-in-accordance-with-the-election-law"/>
        <id>http://snowonion-blog.logdown.com/posts/1520074-in-accordance-with-the-election-law</id>
        
        <author>
            <name>SnowOnion</name>
        </author>
        
        <published>2018-05-11T12:12:01+00:00</published>
        <updated>2018-05-11T12:12:01+00:00</updated>
        
        <content type="html"><![CDATA[<p>我在知乎看到一个答案[1]讲阿罗不可能性定理（Arrow’s impossibility theorem），但是讲得不够科普，所以有人疑惑发问。我写了个评论回答他，但是被和谐叻。搜了一下阿罗不可能性定理的“科普向”文章，乱七八糟的[2][3][4]。所以把我写的评论贴过来好了，刚好这博客都要长草了。</p>

<p>资质（……）：上过唐平中先生的 Game Theory 课；唐在 2009 年给出了阿罗不可能性定理的巧妙的又一个证明[5]（上面的知乎答案就是讲的这个证明），并在 Game Theory 的一次课上详解了该 paper。</p>

<p>肯尼斯·约瑟夫·阿罗（Kenneth Joseph Arrow）于2017年2月21日去世，R.I.P.</p>

<hr />

<p>评论：</p>

<p>24 天前<br />
外行人看不太懂……怎么就……社会福利……独裁者………可以解释一下吗………</p>

<p>我：</p>

<p>Abstract: 社会福利函数指的是这样的选举制度：选票和选举结果都是候选人集合上的全序。定义一个投票人 i 是独裁者，如果无论其他投票人怎样投票，社会福利函数输出的序总和 i 写在选票上的序一样。如果一个社会福利函数可以出现独裁者，那么说这个社会福利函数是 dictatorial 的。阿罗不可能定理说，如果候选人数 &gt;=3，那么任何 unanimous 的、IIA 的社会福利函数都必然是 dictatorial 的。</p>

<p>Full text:</p>

<p>这里所说的“选举”是：n 个投票人，m 个候选人；每个投票人的选票是 m 个候选人上的一个全序（而非像选区级人大代表那样“支持一个或部分候选人”）。</p>

<p>选举，按照要选出啥结果，（至少）有两种分类：</p>

<ol>
<li><p>通过社会选择函数（social choice function）来选出<strong>一个</strong>获胜者，比如选总统； </p></li>
<li><p>通过社会福利函数（social welfare function）来决定候选人上的一个全序，比如25个政治局委员投票来给七长老排名（什么鬼）。</p></li>
</ol>

<p>一个选举机制就是一个社会福利函数 <code>W : L^n -&gt; L</code> 或一个社会选择函数 <code>C : L^n -&gt; O</code>，其中 <code>O</code> 为候选人集合，<code>L</code> 为 <code>O</code> 上的全序的集合。选举机制设计，就是设计 <code>W</code> 或 <code>C</code>，关心如何综合大家意见、把 n 个全序变成一个全序（或一个点）。</p>

<p>注意到社会福利函数的值域也是候选人上的全序。定义一个投票人 i 是社会福利函数 W 里的<strong>独裁者</strong>，如果无论其他投票人怎样投票，W 输出的序总是和 i 写在选票上的序一样。</p>

<p>如果一个社会福利函数可以出现独裁者，那么说这个社会福利函数是 dictatorial 的。一个平凡的例子是，“总是输出第 301 号投票人的序”。</p>

<p>阿罗不可能定理说，如果候选人数 &gt;=3，那么任何 unanimous 的、IIA 的社会福利函数都必然是 dictatorial 的。</p>

<p>Unanimous 和 IIA 的定义可以看<a href="http://www.cs.cmu.edu/%7Ekenshin/arrow_aij.pdf">唐平中的文章</a>[5]的 2. Arrow’s theorem 这一节的开头，就半页 :)</p>

<hr />

<p>[1] <a href="https://www.zhihu.com/question/24239308/answer/112972302" target="_blank">https://www.zhihu.com/question/24239308/answer/112972302</a><br />
[2] <a href="https://www.zhihu.com/question/20324062/answer/148764648" target="_blank">https://www.zhihu.com/question/20324062/answer/148764648</a><br />
[3] <a href="https://www.zhihu.com/question/20324062/answer/31731351" target="_blank">https://www.zhihu.com/question/20324062/answer/31731351</a><br />
[4] <a href="http://www.guokr.com/question/452481/" target="_blank">http://www.guokr.com/question/452481/</a><br />
[5] Tang P, Lin F. Computer-aided proofs of Arrow's and other impossibility theorems[J]. Artificial Intelligence, 2009, 173(11): 1041-1053. <a href="http://www.cs.cmu.edu/~kenshin/arrow_aij.pdf" target="_blank">http://www.cs.cmu.edu/~kenshin/arrow_aij.pdf</a></p>]]></content>
        
        <summary type="html">
            
            我在知乎看到一个答案[1]讲阿罗不可能性定理（Arrow’s impossibility theorem），但是讲得不够科普，所以有人疑惑发问。我写了个评论回答他，但是被和谐叻。搜了一下阿罗不可能性定理的“科普向”文章，乱七八糟的[2][3][4]。所以把我写的评论贴过来好了，
            
        </summary>
        
    </entry>
    
    <entry>
        <title>Data Highlighter</title>
        <link href="https://binux.blog/2016/12/data-highlighter/"/>
        <id>https://binux.blog/2016/12/data-highlighter/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-12-17T22:49:57+00:00</published>
        <updated>2016-12-17T22:49:57+00:00</updated>
        
        <content type="html"><![CDATA[<p>又是好久没有写 blog 了。现在确实没有上学的时候愿意折腾了，能用钱解决的问题，就不自己动手了。但是，很久不写 blog 这事呢，其实就是因为懒 _ (:3」∠) _。</p><p>这里带来的是 <a href="https://binux.blog/2014/07/how-to-extract-data-from-web/"><br />如何从 WEB 页面中提取信息</a> 一文中提到的 data highlighter。但是由于开源需要重写代码，而我并不打算使用它，这里只给出 <a href="https://demo.binux.me/data_highlighter.html" target="_blank">demo</a> 和算法思路。</p><h2><a href="https://binux.blog/2016/12/data-highlighter/#简介"></a>简介</h2><p>Data Highlighter 其实是一种生成提取规则的方式：</p><blockquote><p>Data Highlighter 的标注方式是：给一系列相似的页面，让用户标出（高亮）每个属性在页面中的位置。通过多个页面的标注信息，寻找每个属性的特征。当然了，这个特征可以是 xpath，也可以是上下文，也有可能是机器学习的特征向量。<br />Data Hightlighter 通过高亮 多个页面中相同属性 进行规则学习，省去了人为设置规则时的学习成本。实践表明，在单一页面模板下，标记2个页面就足以生成规则了。效率远大于手工设置规则。Google Data Highlighter 甚至对文字进行了切分，能在 英语 / 汉语普通话 / 粤语 xpath 相同的情况下，分别选出三种语言。是我目前见过的成熟度最高、通用性最好、最简便的数据抽取方式。</p></blockquote><p>那我们通过例子介绍一下使用方式。首先打开 <a href="https://demo.binux.me/data_highlighter.html" target="_blank">demo</a>。这里列出了5个豆瓣电影的 sample 页面，点击 go 加载页面。将鼠标放在页面中，就会发现文字被高亮了，点击拖拽鼠标选择需要提取的文字，在弹出的菜单中选择属性名。</p><p><br /></p><p>然后分别点击 <code>gen_tpl</code> 和 <code>test_all</code> 就能看到生成的模板，以及提取效果了。</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-12-04 14.44.18.png" /></p><h2><a href="https://binux.blog/2016/12/data-highlighter/#算法解析"></a>算法解析</h2><p>点击 <code>gen_tpl</code> 就可以看到生成的模板了，<code>tpl</code> 字段的 key 为抽取的变量的名字，value 描述了一个 <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank">状态机</a>。</p><p>先看一个简单的例子，以下就是对 <code>name</code> 字段的模板，它描述了一个 <code>s0 -&gt; e0</code> 的状态机。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /></pre></td><td><pre><span>{</span><br /><span>  "need_more_sample": true,</span><br /><span>  "tips": {},</span><br /><span>  "tpl": {</span><br /><span>    "name": {</span><br /><span>      "states": {</span><br /><span>        "s0": {</span><br /><span>          "tag": "start",</span><br /><span>          "transitions": [</span><br /><span>            "e0"</span><br /><span>          ],</span><br /><span>          "condition": {</span><br /><span>            "xpath": "/html/body/div/div/h1/span/textnode",</span><br /><span>            "features": {</span><br /><span>              "exclude": [],</span><br /><span>              "include": [</span><br /><span>                "ancestor::*[1][name()=\"span\" and @property='v:itemreviewed']"</span><br /><span>              ]</span><br /><span>            }</span><br /><span>          }</span><br /><span>        },</span><br /><span>        "e0": {</span><br /><span>          "tag": "end",</span><br /><span>          "transitions": [],</span><br /><span>          "condition": {</span><br /><span>            "xpath": "/html/body/div/div/h1/span/textnode",</span><br /><span>            "features": {</span><br /><span>              "exclude": [</span><br /><span>                "following::*[position()=1 and name()=\"textnode\"]"</span><br /><span>              ],</span><br /><span>              "include": [</span><br /><span>                "ancestor::*[1]/*[last()-0] = ancestor-or-self::*[1]"</span><br /><span>              ]</span><br /><span>            }</span><br /><span>          }</span><br /><span>        }</span><br /><span>      },</span><br /><span>      "entrance_state": [</span><br /><span>        "s0"</span><br /><span>      ],</span><br /><span>      "is_list": false,</span><br /><span>      "data_type": "TEXT"</span><br /><span>    }</span><br /><span>  }</span><br /><span>}</span><br /></pre></td></tr></table><blockquote><p>直接跳到 <code>tpl.name</code> 部分，它有4个字段，<code>is_list</code> 和 <code>data_type</code> 描述了字段的类型，它们在字段定义的时候就已经指定了，没什么好说的。<code>states</code> 和 <code>entrance_state</code> 为状态机的描述部分。</p><p><code>entrance_state</code> 表示状态机的入口为 <code>s0</code>。</p><p><code>states</code> 中描述了两个状态 <code>s0</code> 和 <code>e0</code>。 <code>s0.tag == start</code> 表示这是一个开始状态，即标示字段提取的开头，<code>e0.tag == end</code> 为结束状态，即字段的结尾。<code>s0.transitions == [e0]</code> 表示从 <code>s0</code> 能够转移到 <code>e0</code>，而由于 <code>e0.tag == end</code> 已经结束了，所以就没有转移状态了。<br /><br /><br />在执行时，<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#.E5.85.88.E5.BA.8F.E9.81.8D.E5.8E.86.28Pre-Order_Traversal.29" target="_blank">先序遍历</a> DOM 树，根据 <code>condition</code> 的条件进行状态转移。</p><p><code>s0.condition</code> 表示进入开始条件为：xpath <code>/html/body/div/div/h1/span/textnode</code> 并且满足 <code>ancestor::*[1][name()=\"span\" and @property='v:itemreviewed']</code>（父元素的 name 为 span，property 属性为 “v:itemreviewed”) 这个特征。  </p><p>而进入结束条件为 <code>e0.condition</code>： xpath <code>/html/body/div/div/h1/span/textnode</code> 并且满足 <code>ancestor::*[1]/*[last()-0] = ancestor-or-self::*[1]</code>（最后一个元素），并排除满足 <code>following::*[position()=1 and name()=\"textnode\"]</code>（右兄弟为 textnode，实际与 include 互斥）的元素。</p><p><strong>简单地说，这个状态机描述了 <code>属性 property='v:itemviewed' 的 span 的所有 textnode 孩子</code> 这样一条规则。</strong></p><p>而多状态的执行也是类似的，只不过它可能存在状态分支，或者在多个状态间循环。不过只要根据状态转移条件状态进行转移，再根据 <code>tag</code> 所标识的开始结束进行提取即可。</p></blockquote><p>为什么要使用状态机在后面的小结讲解，我们暂且将整个状态机理解为「描述字段提取的开头和结尾」，每个状态就描述了开头结尾的特征。先来看看状态是如何描述「字段提取的开头和结尾」的。</p><h3><a href="https://binux.blog/2016/12/data-highlighter/#状态条件的生成"></a>状态条件的生成</h3><p>算法的基本思路是<strong>寻找多个样本间相同的特征，并使得特征排除其他相似元素</strong>。</p><p>每一个元素可以根据 id, class 属性，文字内容，位置，前 n 个元素的特征，祖先元素特征生成一组特征集合。对多个样本的特征取交，对需要排除的元素取差。</p><p>例如如果每次都选择第二个「豆瓣成员常用的标签」，就会生成</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span>"features": {</span><br /><span>  "exclude": [</span><br /><span>    "preceding::*[position()=2 and name()=\"textnode\"]"</span><br /><span>  ],</span><br /><span>  "include": [</span><br /><span>    "preceding::*[position()=2 and name()=\"a\"]"</span><br /><span>  ]</span><br /><span>}</span><br /></pre></td></tr></table><p>如果每次都选择 2016 的标签，就会生成</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span>"features": {</span><br /><span>  "exclude": [],</span><br /><span>  "include": [</span><br /><span>    "ancestor::*[1][contains(., '2016')]",</span><br /><span>    "contains(., '2016')"</span><br /><span>  ]</span><br /></pre></td></tr></table><p>通过特征集合的运算，算法能够通过样本，猜测出用户选择的意图。而这样的特征集合，可以不断地添加，以满足不同页面的需要。</p><p>需要特别说明的是，特征并不需要像 demo 中使用某种特定的选择器(xpath)，由于模板执行时，可以再次为候选元素生成特征集合，对特征集合进行比较。实际上，你可以在特征集合中放入任何字符串，例如「第5元素」，「前一个字符为 answer，且值为 42」都是可以的。</p><h3><a href="https://binux.blog/2016/12/data-highlighter/#状态机"></a>状态机</h3><p>不同于往常的选取一个元素（例如 pyspider 中的选择器），data highlighter 提供了</p><ol><li>元素内文字选取</li><li>跨元素选取</li></ol><p>的功能，这使得正常的「元素选择器」不再好使，取而代之的是一种定位开始和结束的规则。描述为状态机即：<code>s0 -&gt; e0</code>。</p><p>而 data highlighter 另一种需要支持的功能为列表选取：</p><p>就不能仅仅通过 <code>s0 -&gt; e0</code> 这样开头结尾的模式进行描述了。它需要准确描述出整个列表的开头，结尾，分隔符等信息，需要通过一个类似</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>s0 -&gt; e0 -&gt; s1 -&gt; e1 -&gt; s2 -&gt; e2</span><br /><span>            |------|</span><br /></pre></td></tr></table><p>的状态机，<code>s0</code> 为整个列表的开头，<code>s1 -&gt; e1</code> 为中间循环的组，<code>e2</code> 为 整个列表的结束。</p><p>而实际中，由于某些状态可以被合并，你可能会看到类似</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span>s0 -&gt; e0 -&gt; s2 -&gt; e1</span><br /><span>       |</span><br /><span>       s1</span><br /></pre></td></tr></table><blockquote><p>e0 和 e1 被合并了，即第一个元素的结束条件和中间元素的结束没有不同</p></blockquote><p>的状态机</p><h3><a href="https://binux.blog/2016/12/data-highlighter/#状态机的生成"></a>状态机的生成</h3><p>虽然状态机看起来非常复杂，但是用程序处理起来却不难。首先为每一个样本（包括列表选取）生成一条 <code>s0 -&gt; e0 -&gt; s1 -&gt; e1 -&gt; s2 -&gt; e2 -&gt; s3 -&gt; e3 ...</code> 的长链，然后尝试合并状态，然后将多个样本的链用同一规则合并。而不能合并的状态，就做个分支转移即可。</p><p>而状态能否合并，取决于它们有没有共同特征，就是这么简单。</p><h2><a href="https://binux.blog/2016/12/data-highlighter/#总结"></a>总结</h2><p>Data Highlighter 的算法设计，实际上是对元素特征选取的一种建模。通过设计合适的数据结构，使得多样本能够反映到模板中去。</p><p>这个算法是两年前设计的，现在看起来实际上问题蛮多的，例如：</p><ul><li>无法使用组合特征，即要求元素同时满足满足多个条件</li><li>没有设计合理的泛化机制</li><li>模板不可读</li></ul><p>等，所以，我并不打算使用这个算法。</p><p>只不过，最近些年，看到很多数据提取的公司，特别是国内的数据提取平台，还在停留在非常初级的 css selector 或者 xpath 点选生成。希望这篇文章能抛砖引玉，提供一些新的思路，为数据抽取提供更易用有效的工具。</p><p>完。</p>]]></content>
        
        <summary type="html">
            
            又是好久没有写 blog 了。现在确实没有上学的时候愿意折腾了，能用钱解决的问题，就不自己动手了。但是，很久不写 blog 这事呢，其实就是因为懒 _ (:3」∠) _。这里带来的是 如何从 WEB 页面中提取信息 一文中提到的 data highlighter。但是由于开源需
            
        </summary>
        
        <category term="html"/>
        
        <category term="infomation-extraction"/>
        
        <category term="wrapper-genaration"/>
        
    </entry>
    
    <entry>
        <title>学术讲座通知​：增强现实中的计算机视觉技术探索</title>
        <link href="http://www.pris.net.cn/archives/3430"/>
        <id>http://www.pris.net.cn/archives/3430</id>
        
        <author>
            <name>李春光 (Chun-Guang LI)</name>
        </author>
        
        <published>2016-10-28T14:10:34+00:00</published>
        <updated>2016-10-28T14:10:34+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>题目</strong>：<strong>增强现实中的计算机视觉技术探索</strong><br />
<strong>报告人</strong>：<strong>凌海滨</strong> 博士（<a href="http://www.dabi.temple.edu/~hbling/" target="_blank">美国天普大学副教授</a> <a href="https://www.hiscene.com/" target="_blank">亮风台科技</a>的联合创始人&amp;首席科学家）<br />
<strong>主持人</strong>：<strong>李春光</strong><br />
<strong>时间</strong>：<strong>2016年11月16日(周三)10:00~11:20</strong><br />
<strong>地点</strong>：<strong>教三楼811学术报告厅</strong><br />
<strong>摘要</strong>：近年来，算法和硬件两方面的发展以及移动智能设备的普及从技术和市场两个方面极大得推动了增强现实的兴起和走向实用。计算机视觉作为对3D世界和3D交互理解的重要途径，在增强现实系统中起着至关重要的作用。在本报告中，我们首先回顾现代增强现实的发展及相应的技术体系，并总结增强现实中常用的计算机视觉技术。然后，我们介绍一下本课题组在相关领域的一些工作，主要包括视觉匹配（CVPR16、ECCV16）和视觉跟踪（CVPR13、CVPR14）方面的技术，同时也会讨论一些最新的探索。</p>
<p><strong>报告人简介</strong>: <strong>凌海滨</strong>博士于1997年和2000年毕业于北京大学，于2006年在美国马里兰大学(Maryland University)获博士学位，后于2006~2007年在加州大学洛杉矶分校(UCLA)做博士后。在2001年任微软亚洲研究院(MSRA)助理研究员，2007~2008年任西门子研究院研究员，从2008起任职于美国天普大学(Temple University)，现在为<a href="http://www.dabi.temple.edu/~hbling/" target="_blank">计算机系副教授</a>，并且是<a href="https://www.hiscene.com/" target="_blank">亮风台科技</a>的联合创始人并担任其首席科学家。主要研究领域为计算机视觉、增强现实、医学图像理解、和人机交互。获2003年度ACM UIST最佳学生论文奖，2014年度美国自然科学基金CAREER Award。担任期刊IEEE Trans. on Pattern Analysis and Machine Intelligence和Pattern Recognition的编委，以及CVPR 2014和CVPR 2016年的领域主席。<br />
<a href="http://www.dabi.temple.edu/~hbling/" target="_blank">更多信息请参阅</a>: http://www.dabi.temple.edu/~hbling/</p>]]></content>
        
        <summary type="html">
            
            题目：增强现实中的计算机视觉技术探索 报告人：凌海滨 博士（美国天普大学副教授 亮风台科技的联合创始人&amp;amp;首席科学家） 主持人：李春光 时间：2016年11月16日(周三)10:00~11:20 地点：教三楼811学术报告厅 摘要：近年来，算法和硬件两方面的发展以及移动智
            
        </summary>
        
        <category term="PRIS快讯"/>
        
    </entry>
    
    <entry>
        <title>“红头吃鱼猫”（頭が赤い魚を食べた猫）的五种歧义解释</title>
        <link href="http://snowonion-blog.logdown.com/posts/923176-five-ambiguous-interpretation-of-atamaga-katai-sakanawo-tabeta-neko-or-red-headed-fish-eating-cat"/>
        <id>http://snowonion-blog.logdown.com/posts/923176-five-ambiguous-interpretation-of-atamaga-katai-sakanawo-tabeta-neko-or-red-headed-fish-eating-cat</id>
        
        <author>
            <name>SnowOnion</name>
        </author>
        
        <published>2016-09-27T17:30:34+00:00</published>
        <updated>2016-09-27T17:30:34+00:00</updated>
        
        <content type="html"><![CDATA[

<p>几年前，大概是在人人网，我看到了这幅图：<br />
</p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E7%BA%A2%E5%A4%B4%E5%90%83%E9%B1%BC%E7%8C%AB-%E9%A0%AD%E3%81%8C%E8%B5%A4%E3%81%84%E9%AD%9A%E3%82%92%E9%A3%9F%E3%81%B9%E3%81%9F%E7%8C%AB.jpg" /><p></p>

<p>是对頭あたまが赤あかい魚さかなを食たべた猫ねこ（我管它叫“红头吃鱼猫”）的五种歧义解释。</p>

<p>当时还几乎不会日语，但是热爱文字游戏的我对此感到很兴奋。</p>

<p>今晚的计算语言学课，提到语法树。于是我又把这个图找出来看。</p>

<p>毕竟经历了半年多正经的日语学习——在半年中的18周，每周上两次90分钟的二外日语课；我已经能看懂这里各种解释所对应的语法现象啦。至少自己认为自己懂了。</p>

<p>原作由中村明裕 <a href="https://twitter.com/nkmr_aki">@nkmr_aki</a> 发表在<a href="https://twitter.com/nkmr_aki/status/381428185885200384">一条推文</a>中。他（她？）的 Twitter 自我介绍是 “在野の方言研究家”；这是自黑为语言学民科的意思吗？</p>

<p><a href="http://togetter.com/li/567493">这里（这类网站叫什么呢？SNS 内容聚合？）</a> 作者似乎是介绍了这句神奇的日语的创作思路。</p>

<p><a href="https://twitter.com/TokyoZooNet_PR/status/381990180023848962/photo/1">这条推文</a>尝试构造英语版本的“红头吃鱼猫”：<br />
</p><img src="http://7tsy1b.com1.z0.glb.clouddn.com/img/%E7%BA%A2%E5%A4%B4%E5%90%83%E9%B1%BC%E7%8C%AB%E8%8B%B1%E8%AF%AD%E7%89%88.jpg" /><p></p>

<p>就这些吧~</p>

]]></content>
        
        <summary type="html">
            
              几年前，大概是在人人网，我看到了这幅图：   是对頭あたまが赤あかい魚さかなを食たべた猫ねこ（我管它叫“红头吃鱼猫”）的五种歧义解释。  当时还几乎不会日语，但是热爱文字游戏的我对此感到很兴奋。  今晚的计算语言学课，提到语法树。于是我又把这个图找出来看。  毕竟经历了半年
            
        </summary>
        
    </entry>
    
    <entry>
        <title>动画「ef – a tale of memories.」：把不想忘记的思念融进心愿 ……</title>
        <link href="http://blog.dimpurr.com/anime-ef-1/"/>
        <id>http://blog.dimpurr.com/anime-ef-1/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2016-09-14T17:03:03+00:00</published>
        <updated>2016-09-14T17:03:03+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>本文原载于 Bangumi.tv <a href="http://bgm.tv/blog/273852">Dimpurr » 日志 » 「把不想忘记的思念融进心愿 ……」</a></p></blockquote>
<p>词不达意。</p>
<p>很多次看完动画都有提笔一写的冲动，最近的一次大概还是「结城友奈」。那时都选好了头图，甚至拟好了标题，却无法动笔。</p>
<p>心中的所思所想太过混杂；自己混乱的文字，能否传达出丝毫？抑或是只有彻头彻尾的反效果？我想叙说的那些事情，我真的做好的准备了么？还是徒增笑料，成为自己都不愿意回看的文字？我知道自己经常带着极强的偏好和预设去代入故事；我知道自己特别喜欢按自己的口味截取和曲解动画；我知道我的关注点很可能与很大一部分人不同。我不知道自己是否已经可以理直气壮的说出自己想说的内容，而不必担心自己笨拙的描述让人误会了内涵。</p>
<p>但是这次如果我不写，我根本无法称自己看完了一季 ef ；如果我不动笔，那么那部我眼中的 ef 便无处存在。</p>
<p>ef – a tale of memories.</p>
<p>相比别的话题作，对于 ef 一开始并没有太多预设的了解。只知道是 GalGame 游戏改；知道还算出名， Bangumi 排名和评价也算挺高。后来无意间跳跃着看了下第一集，才知道是大沼心监督，为出色的表现手法惊叹过后，并没有太弄懂故事的主题，于是决定等有时间了再补。其间依稀听说过原作 minori 的一些故事，然而也并没有留下特别深刻的印象。</p>
<p><span></span></p>
<p>最后， ef 在心目中的印象被毫无根据的排到「类似 SOLA 那样的爱情故事吧(可 SOLA 我也没看过)」「表现手法比较魔幻的故事」，在次次顺位等待着有空再说。因为第一集的印象被判定到「不太轻松，故事复杂可能看起来比较累，非放松类」的作品，直到开学初一念之下，开始用手机补起了第一季。</p>
<p>有趣的是， ef 在手机屏幕上的画面表现力，和手机、耳机 (SONY XPERIA Z1 + XBA-A3) 的音效搭配之下，反而出人意料的产生了非常棒的效果。第一集人物的依次出场，还有 ED 「I’m here」响起时的弦乐告诉我，这部作品的评价 9 星起跳了。</p>
<p>先谈谈故事以外的部分。</p>
<p>尽管是 07 年的作品，精致的作画、极高的画质、本身惊艳的人物设计和相对更抽象和唯美的背景风格，以及环境和道具设定的欧式风格，一开始就塑造了绝佳的童话般的故事风格和绝佳的画面效果。大沼心的分镜，独有特色的强烈色块对比，和新房风的诸多表现手法， OP ED 和过场中对英文字体、装饰元素的运用，可谓极其惊艳。</p>
<p>音乐方面不太懂得如何评价，不过配上好的音响或耳机，观感体验的确一流。 BGM 对氛围的营造本身很棒，但最重要的是每次的高潮部分， BGM 与分镜、音效还有对白的完美配合，让人无法不次次印象深刻。 OP ED 不能算首首神曲，但是总能配合着情节进展出现的不同的角色 ED ，还有 ED 中表现的人物形象和心理，也算令人饶有趣味。</p>
<p>总而言之，绝赞的制作班底决定了故事以外的各种硬素质， ef 的确都是当之无愧的一流水准。丰富而细致的音画表现和复杂的分镜手法，使得无论情节推动节奏如何，都能有接连不断的视觉刺激和动听音效营造出的极为充实的观看体验。</p>
<p>然后，来谈谈故事吧。剧透预警。</p>
<p>应该说 ef 第一季可以说围绕三位男主，以类似的主题展开了不同设定的三个故事。第一个和最主要的故事是莲治与「记忆锁链囚禁的少女」千寻的相遇；第二个故事是宫子对广野的乞求「请珍惜我」；第三个故事是景在京介和广野身上学会「不能总是等别人拉着自己前进」。</p>
<p>从 ep. 2 就开始不断出现的关键字「进路调查」「漫画家与学业」「社团和个性」「想要拍的画面」，已经非常明确的挑明了核心主题之一：梦想。这着实颠覆了我一开始对 ef 的预设，也让我开始期待 ef 最后能给出 10 星的水准。说正了是「樱花庄」，说偏了是「Lovelive」，在 ep.11 直言了「闪耀」这样的说法的 ef 骨子里无疑有种很典型的励志套路。很可惜，我就吃这一套。</p>
<p>至于虽然 ef 时间上更早，但是早已被「中二病」和「Another」抢去的眼罩娘设定的千寻身上，也有着不愧对名字「a tale of memories」的演绎。一方面，恰到好处的莲治视角对关系层层深入的描写、得知真相前的铺垫，在千寻的小说中埋藏的极为丰富的暗示和从一开始就埋好伏笔的拒绝，直到莲治亲眼见识到千寻「日常」的一次起床，这位 13 小时记忆的少女形象已骨肉丰满。与更近的类似设定纯爱作品「一周的朋友」全然不同， ef 用近乎夸张的手法表现的是少女无尽的寂寞和痛苦，还有对幸福的畏惧。所有的一切带来了最后一集的爆发，也让也许只是第一季暂时的 Happy End 更加弥足珍贵。</p>
<p>提到最后一集的爆发力，与之堪比的也只有宫子的这条故事线。一开始似乎特立独行满不在乎的少女，在景的威胁下很快就表露出了内心真正的焦急与不安。渴望的太深，所以太过容易的交出自己，一无所有所以赌上一切，一无所有所以无法坚强，所以轻易的被彻底的伤害、被全部击碎。那 99 条再无第二个人能听到的电话留言铺满了视野，然后带着又一次绝望如潮水般退入心底。在男主广野的选择和做法方面，也许动画的表现还是欠妥，但是最后随着电话卡的倒计时结束，广野还是来到了宫子身边；至少现在，宫子还没有迎来又一次结束，这样的结局让人长出一口气。</p>
<p>而景、京介部分的戏份相对来说就所剩无几了，他们更多的是和男主、和不断带来提示的优子一起，并没有太多的展开，但是承载了极其丰富的围绕着思念、选择和梦想的主题。</p>
<p>结尾 ep.12 ，最后的部分主角们的话显得略为突兀，但积极正面的表现出了他们对未来的乐观。而优子和夕身上的自始至终反复被提到，却从未展开的故事，为第二季的发挥埋下了伏笔，令人期待。最后，画面转为纯白，只留下了一句话：「把不想忘记的思念融进心愿中 ……」</p>
<p>关于故事中的人们。</p>
<p>广野应该是毫无疑问的第一男主，故事中着重的更多是他和景的关系、他对于漫画家的态度、他和宫子的发展。但是在他和景和宫子的关系这一方面，即使在 ep.11 经由京介挑明了「脚踏两条船」的现状，最终对于他的想法和言行，动画还是没有给出足够合理的交代。不过据此，并不能简单的将他等同为刻意玩弄女孩子的人渣吧。应该说，他的逞强、他的承担、他的选择，大多令人钦佩，也并非与景「自豪的哥哥」的身份不相称。</p>
<p>宫子的戏份并不多过千寻，但第一集 ED 的「I’m here」透露出她的故事的确是最早展开的一条线。在冷漠的家庭中长大，缺少和渴望爱的孩子 —— 在西尾、入间、几原的作品里，是不是也能找到熟悉的影子？优子一句「希望能看到和我一样的孩子得到幸福的故事」，道出了这个故事的本质。一开始了无牵挂的时候，显得那样自由和自信，在景面前一幅风轻云淡。但是不曾拥有过爱的孩子，一旦暴露出了软肋总是无法避免的惊慌失措：思念愈深，剩下的愈是只有伤口和脆弱。所幸，她绝望中的求助，最终传达到了广野这里。这的确是故事中最让人心疼的孩子之一。</p>
<p>千寻在前面也已说过不少。四年的痛苦千言难尽，几乎已经放弃全部希望、丧失对自己存在的意义之时，在小小的车站、不足 45 秒的邂逅却让她拥有了全然不同的未来。那一天内的千寻越是可爱，那 13 小时的记忆的锁链越显得残酷。写故事时她说，「如果觉得她可爱的话，她的存在就等同于没有被描绘出来」，「那个女孩的举动应该让读者感到不安」 …… 那时她也许已经开始求救，已经开始不断的拷问自己。而她从一开就决定好、最后的选择，却还是让自己陷入无止境的遗忘和悲伤，也不希望自己成为他人幸福的累赘。明明也是这个千寻，却说出了「可不能说那样的话，说不定明天会比今天更好呢？」……</p>
<p>莲治本身是个显得十分青涩的孩子，但却是始终不放弃去接近的千寻、在关键时刻毫不犹豫的真正的千寻的王子。在故事的前期，除了像普通的对女孩子倾心那样喜欢千寻，为关系变好的悄悄高兴这样男孩子的纯情举动，关于「志愿调查」的话题、看着千寻写小说时的复杂心情、第一次被千寻要求接吻时极度夸张的内心活动，是他一路看着千寻的变化之后，对自己的不安和对「未来」和「愿望」的纠结。尽管不全然类似，这部分的主题，让人不得不联想到「樱花庄」里「关于天才和凡人的故事」。</p>
<p>京介。一开始和绘美的关系变化，让他显得有一点特别。他一直作为广野的好基友，推动广野和景前进的旁观者和参与者，还有广野所选择的道路「自由与不自由的创作」的对比者，发挥着喧宾夺主但至关重要的作用。</p>
<p>景。她和广野本身的感情戏算是前期的重头戏之一，从注视着「哥哥」、希望接近广野到最后有了自己清晰的想法，她的选择和成长也让人动心。和宫子的竞争中，她也做过一些让人觉得未免残忍的举动，但是也让这个少女的思念更显真实。最后，不知道她能不能算是选择了京介？</p>
<p>火村(夕)，优子，他们的故事留下了大量令人浮想联翩的伏笔。除了没有叙述的和优子的关系，火村最让人在意的一部分，是他数年来作为千寻监护人的心情和经历；那给千寻的一巴掌，也许凝聚的是自身回忆的无尽痛苦，但是看到那样拼命的去保护回忆的千寻，他还是无法狠下心去阻止。优子本身在不同线路的故事中，扮演了在关键时刻和主角对话、给予提示的角色，不过至于她为何能够如此神出鬼没，第一季并没有给出解答。</p>
<p>如果能有空在电脑前重看一次，也许我会收集一下自己认为重要的对白整理到这里。不过在此之前，还有第二季、原作游戏在等着我吧；何况对于 ef 故事本身以外的事情，周边也好幕后也好，我还没有做过必要的了解。</p>
<p>对于后面的故事我无法保证，但就已经结束的第一季来说，可以说，在我眼中堪称完美的无以复加。在看完 ep.8 后，我把 Bangumi 全部动画的评分调低了一星，只为了 ef 能呆在按评分排序的列表的顶端。</p>
<p>无意间就写了这么长了，本想再额外对一些周边的内容多做评价，比如「I’m here」实在是神曲，千寻「空の梦」的 ED 纷飞的纸片结合故事来看实在太棒了 …… 但是至此时间已花的不少，而且也快词藻穷尽了，作罢。</p>
<p>我的评分标准写过， 10 星的标准是「近乎完美的质量；强烈影响自己；无比希望有一天能经自己笔下诞生这样的故事」。如果说第一个标准已经用我激动溢于言表的溢美之词稍作衬托了的话，后面两点却是要自己花时间来证明的。</p>
<p>可是，这又有什么不好呢？</p>
<p>如果说动画或者任何其他载体的故事不过是数十分钟的一场梦境，那剩余的日常也不过是一切和一切的铺垫，是洁白无瑕的梦的睡前准备。就算是干脆说自己为此而活着也没问题。</p>
<p>因为啊，拿起笔的时候，戴上耳机的时候。「这一刻，即是高潮」。</p>
<p>如果说乏味的日常中不可能时时保持这样的心情，那么，要学会把梦想铭刻进心底呢，因为也许自己的尝试和偶然组合起来，就可能发生奇迹，不是么？</p>
<p>「把不想忘记的思念融进心愿 ……」</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/anime-ef-1/">动画「ef – a tale of memories.」：把不想忘记的思念融进心愿 ……</a></p>]]></content>
        
        <summary type="html">
            
            本文原载于 Bangumi.tv Dimpurr » 日志 » 「把不想忘记的思念融进心愿 ……」 词不达意。 很多次看完动画都有提笔一写的冲动，最近的一次大概还是「结城友奈」。那时都选好了头图，甚至拟好了标题，却无法动笔。 心中的所思所想太过混杂；自己混乱的文字，能否传达出丝
            
        </summary>
        
        <category term="次元爱"/>
        
        <category term="ef"/>
        
        <category term="动画"/>
        
        <category term="青春"/>
        
    </entry>
    
    <entry>
        <title>euphoric field</title>
        <link href="http://blog.dimpurr.com/euphoric-field/"/>
        <id>http://blog.dimpurr.com/euphoric-field/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2016-09-10T19:11:39+00:00</published>
        <updated>2016-09-10T19:11:39+00:00</updated>
        
        <content type="html"><![CDATA[<p>大概已经过了许久，没有再动手写一篇不止是给自己看的文章了。</p>
<p>明天早上返校，所以大概没有那么多时间构思和修改。并不是真的多么在意这在别人眼中会怎样 —— 更重要的是，随着时间沉淀下来的这篇文章，在以后的自己眼中将会怎样。</p>
<p>无意间翻阅 Google Keep 中两三年前的 Notes ，发现那时候基本都是想要写的主题先记下来几天，等有了些想法之后再动笔。只是这次，我必须得这样仓促的开始，然后又仓促的结束，并回归到并不能用日复一日来形容的日常中 —— 这样的，我的高中和高三生活中了。</p>
<p><span></span></p>
<hr />
<p>能描述到什么程度为止？ —— 这是脑海中浮现的第一个问题。我还没想的足够清楚，或者说并没有准备好，用什么方式来叙述自己的高中生活。</p>
<p>笼统的说，已经过去的高中两年，其信息量和事件密度并不会亚于初中或更久以前。但是，一言以蔽之的话，我对我的高中生活的评价只能是 —— 并不满意。</p>
<p>这是不难理解的结论。应该说，高一的时候，我就已经明确的意识到了结果的走向将会怎样。只是，到了高三的现在，终于偶尔会为这早已知道的事实难受起来。</p>
<p>为什么说不难理解呢？因为见过了更好的生活方式，所以当然会为当下的状态和环境感到不满意；因为一开始就抉择好了保证什么和放弃什么，所以当然会如同预想之中一样的承受难以割舍的痛苦；因为曾经的自己在拼尽全力的去玩，而现在只能拼尽全力的 —— 让自己将来能够再尽力去玩。</p>
<p>这便是我的高中了。结果还没到来，离真正意义上的结束也还有 270 天。但是很多事情已无法改变。初中和小学的我大概没有遗憾；那对于高中，我只能说，我没有后悔，但是无法不遗憾。</p>
<hr />
<p>All work and no play makes Dimpurr a dull boy. 放到多年前也许我会抱怨两句所谓的教育体制，可现在的我只会在知乎上撰写上千字的答案，义正言辞的为高校的筛选机制辩护 —— 何尝又不是为自己的现在的不堪开脱和为自己的选择辩护？「<a href="http://zhihu.com/question/41579742/answer/91887698" target="_blank">如果说学习就是为了应用，那么如何看待高考？高考算是对知识的应用吗？ – 回答作者: Cheny Dimpurr</a>」只是，如果将不满的根源归咎于此的话，未免太过可笑。实际的问题与此全无关系。</p>
<p>初中毕业的时候，我写过一篇「<a href="http://blog.dimpurr.com/become-history/" target="_blank">初中毕业了，毕竟老了。</a>」，我用纠结的文笔慷慨激昂的陈述了一番我所刚刚理解的理所当然的事实，大概只是为了衬托出曾经的自己多么愚蠢。我想那之后我又一股脑的做了一系列的蠢事，比如随着我的高中被搁置到现在的 Rhytune ，一个歌词百科服务，比如最后和我并没有什么关系的变成了 connext 和 GTC 的 evenBits ，又一个不知所云的面基大会。放弃她们只是所有放弃的开始。</p>
<p>放弃的原因是我想造航空母舰，但是在创建 SpaceX 之前起码得先创建 SolarCity 和卖掉 Paypal 的股份。初三的我已经意识到我正在透支自己，我知道我那时短暂的爆发背后是整个小学和初中的全部技术和能力积累，我也知道从那时开始我已经走的太远，远到自己的能力已经无法胜任了，可我却还在不断的工作和输出而没有静下心来学习的时间。然而更重要的是那时的我比现在更是个完美主义者，对作品的偏执让我宁可选择次品从一开始就不要存在。</p>
<p>简单的说，我只是打算闭关修炼罢了。</p>
<p>黑海造船厂即将关闭时马卡洛夫报告说，「总之需要一个伟大的国家才能完成他（瓦良格号）」。所以虽说是放弃，不过大概很多事情并未结束，只是我还需要再那么一点时间，让自己变得能够完成他。</p>
<hr />
<p>理所当然的，一开始我不过是从各种复杂而喧闹的事情中抽身，回到曾经自己折腾捣鼓的状态里来罢了。那时我也还满怀信心，相信自己的学习和进步很快会让人大吃一惊。画风不过是小小的开始改变了一点。我在高一寒假的记录中写道：</p>
<blockquote><p>「这个寒假，必要的应付完 evenBits 。从今以后，淡出圈子，完全聚焦于提升自己的实力上面。主要点的技能栈是前端、交互设计、绘画、视频、作曲。学业上，进入年级前十。学习上，每天要进行文学阅读和英文阅读。剩下的是写作业。在两天内完成寒假作业，然后进行计划。技术上，每天要看书。专注。耐心。不用每个圈子都掺一脚，也不用点太多无关技能栈。」</p></blockquote>
<p>另一边，我开始迎接我的高中生活，带着对「冰菓」中描述的「蔷薇色」的憧憬。</p>
<p>开学典礼上我在漏雨的大礼堂中拿着本子画着夏娜；我很快熟悉了新的学校，并且学会了潜入艺术楼，趁琴房的主人离开时偷弹里面的钢琴；我发现学校后山上有比山顶的亭子更合适的适合观景的水泥墩，那里能俯瞰整个学校和四周的小区，还有三环路上的立交桥。那时候我还没拿到学校漫画社团的漂流画本，更不知道我们学校与贫弱的文化班全然不同的省内拔尖的艺术班在艺术节上将会有怎样的节目，但起码我知道辩论部的迎新赛上，我的清晰而尖锐的观众提问怎样为我在部里的前辈中迎来了绝佳的第一印象。</p>
<p>另外，我还发现当我开始认真学习后，我其实并没有那么学渣，所以旁边的一圈妹子总是很喜欢来找我问问题；我当然不会想再重蹈初中的覆辙，我不再轻视成绩，所以我花了半个学期从入学时的年纪 450 名挤进了前 100 名。我在班级中刻意的积极表现，几次课堂上对文学或者技术类问题的侃侃而谈莫不让同学们感到新奇，无意中和舍友们提到的我在网络上和技术上的一点事情，不胫而走逐渐演变成了班级中的传说。简而言之，我只是把初中时并不在意学校中的生活，而只在网络上全力表现的自己，注意力重新转移回了现实中而已。</p>
<p>网络上太好高骛远的事情暂时不打算搞了，那么身边未免就不能做些事情。那时 illumer 还远远没有迎来现在的结局，写完那篇感慨的文章不久的我当然也想试试在这个城市做个类似的社团联合会。任务的难度和 evenBits 那样扯淡的目标相比当然完全不在一个层级，我熟练的开始了各学校间联系和讨论，只是某次在和一中信息社的社长对话时，很快的和他互相自我介绍后，被他问起我在哪个学校。我如实相告之后，他这么对我说：</p>
<blockquote><p>「真遗憾你不在我们这里啊。」</p></blockquote>
<p>当然，这句话本身是对我的认可，是对不能和我共事的惋惜之情。可对于高中的我来说，这句话还有另一层意思 —— 因为不论是城市和环境的限制还是我自己的问题，我的确在一所二流中学，就是这样的现实，让我不能逃避的现实。</p>
<p>这句话并不是原因，可那之后事情的确变得有点不同。</p>
<p>高一下，作为最有希望的三辩之一，我放弃了首届三校辩论赛近乎已经钦定的出席资格，只因为我担心中午的睡眠时间被长期占用会影响到最后的分班考试。我当然记得，那一天早上学校广播放的是「秋姉妹のなく顷に」，我为那位初中就开始同班的好友写好了辩题的提纲，那天正是他生日，他穿着西装在舞台上十分耀眼，总结陈词的时候还扯到了他最喜欢的 Fate 梗，一时全场沸腾。</p>
<p>我只是静静的坐在下面摄像，并不太可惜本可以属于我的这些荣耀，只是在意要仍旧按着自己的风格，在观众提问环节留下简短的证明自己实力的发言。那时的我还不知道结果是高二我从次重点进入了学校最好的重点班而他仍在次重点，而在那以后我们的成绩逐渐成为了单调性相反的函数。</p>
<p>但那时，我对这个感觉已经不陌生。我看着和 Rhytune 同期的一些项目逐渐开花结果，我看见曾经远在我身后的朋友因为有更多的时间在技术上远远超过我，我当然还看到了，我没有任何权利去不甘心的，那些大大小小的聚会，那些膜蛤作死成为明星的举办者们，那些像我当初一样尽兴而归的与会者们。</p>
<p>按理说，我该表现出一副自己风轻云淡的样子，这样会显得自己更加高冷成熟或者至少没那么可笑；只是，有些时候，人需要偏执一点的刺激自己，才会让自己不至于忘记方向，不是么？</p>
<p>当然，关于建立地区技术社团联盟的想法，不出意外的在对这个城市和学校的失望中放弃了。再一次看到那位一中信息社的社长的名字，已经是在两年后，已经高三伊始的我去一中参加物理竞赛的时候了。门口前的喜报红的耀眼，全省理科前十，那个人的名字赫然在列，后面跟着一个括号，分数已屏蔽。最后，我还是不知道到底做了什么分数能够被屏蔽。</p>
<p>只是我意识到我错过了什么，还有我现在必须放弃什么和保证做到什么，才能让以后不再错过。是的，我想走的更远。</p>
<hr />
<p>如果说我曾经拥有过我自认为合格的高中生活，那就是我的高一上。初三下到高一上，大概就是我目前为止短暂的人生经历中，我最痛苦也最幸福的一段时期，我最喜欢的生活状态之一了。</p>
<p>可是，就像借口一样，我的完美主义和偏执症又犯了；大概是初三下的那些经历让我变得太过自信，或者是那时自己所见到的一些东西实在太过动人，这个乏味而平庸的学校很快的让我感到厌倦；比起在无知的同学中博取优越感，我开始为更多事情的连番遇挫感到束手束脚，我开始无比渴望起更好的同学、更好的学校、更好的城市；暂时失去网络这个舞台的我，急需一个更适合的、现实中的舞台。只不过，它不在这里。</p>
<p>我想和更有趣的人一起生活一起前进，我希望被菊苣打击，我宁可做凤尾也不想做鸡头。高一下的我很快变得全然不同，当时我并没有意识到，我在同学们中的印象开始被加多了一个标签「高冷」。大概是那时我太过集中于思考自己的事情 —— 我当然有很多事情要思考。</p>
<p>我后来评价道，我自认为自己有两段比较中二的时期，一段大概在小学二三年级，另一段就是高一下了。考虑下我的年龄，大部分人这个岁数本来就在读初二也说不定罢了。但是实际的情况是，那时的我不过是被抛向了一系列，我从来从来就没有遇到过的问题罢了。后来我在暑假的记录中写：</p>
<blockquote><p>「高一一学年以来，上半阶段的自己在由于 evenBits 的各项事务和学习成绩落后的极大压力下达成了极其可观的进步。然而在自己水平提高后，来到了一个比上不足比下有余的现实瓶颈，压力减小，动力却没有增大。具体的原因分析如下：</p>
<ol>
<li>学习进步之后潜意识里感到自满，危机感降低，技术上放弃 evenBits ，最终使得压力消失</li>
<li>学习和技术上，都已经领先了大部分不用功的人和身边的人，然而与用功的人差距仍大以至于缺乏与之竞争的动力</li>
<li>自己本身的拖延症、完美主义、没有长远眼光和坚持能力的缺陷</li>
</ol>
<p>这个缺乏动力的问题是目前高中生涯最大的阻碍，也是今后大学和独立都需要面对的问题。这个问题同样已经导致了高一下学期后半部分长达一个月的低潮期，在严重影响自我成长的情况下，终于换来了理智和情感上对自己目标的肯定。因此，在接下来的两年中，必须保证不再出现这种情况。」</p></blockquote>
<p>这段时间实际发生的事情更加复杂，除了学习还在慢慢磨蹭进二三十名的水准之外，平常过的可谓是更加的「浪」，例如说终于有一次无法避免的把画画到了黑板上。我也不知道同学们一个周末回来后，发现整个黑板被在大块粉笔铺设的背景上画了一只动漫画风的少女之后，心情到底是怎样的。之后偶尔节假日逢自己留校学习，总要无聊的来这么一张；一开始是谁画的还是秘密，后来终于发展成了和基友在体育课上公开画了。</p>
<p>然而直接和这段时间挂钩的关键词是「哲学」，不带男性符号的普遍意义上的那个哲学。概括地说，我仓促的离开了那个初中开始自己就不断寻找而终于逐渐发现的世界，所以我前所未有的不得不第一次面临未来的迷茫和方向的抉择；更何况，本来就到了差不多该建立世界观的时候了。</p>
<p>我开始追问生活的意义，只不过我用的是自己熟悉的方式 —— 网络上的资料和哲学的科普著作或部分经典原作。我开始不断的自己思考和询问他人，逐渐了解自己究竟更重视什么，然后审问自己到底想要什么，想选择怎样的现在和未来。</p>
<p>我做了很多中二的事情，包括但不限于在周末的晚上带着耳机躺在学校的操场中央，听着初三放学每天回家路上听的歌，仰望被建筑物围成弧形的天空想自己的未来；包括但不限于成为学校天台的常客，包括但不限于在没有任何人察觉的情况下在教室中流泪一天，包括但不限于尝试在虚拟的故事中寻求真实感。最后，还顺便为自己始终无人理解而痛苦。</p>
<p>这是很显然的；这种属于每一个人自己的事情又怎么会有他人能够理解？不写个百万字又怎么可能陈述的清楚而不只是看起来十分可笑？所以我开始动笔尝试写小说，但这不是关键。</p>
<p>在我今后有机会更详细的叙说个中含意之前，现在我只能说，我绝不认为这些事情全无意义。我自认为，没有高一下那半年可笑而纠结的行为，也不会有如今对自己有着清晰的认识和冷静的自信，有着不容置疑的方向和目标的自己。</p>
<p>很可惜的是，本来那段经历，就自己在哲学上了解到一些有意义的学术内容，本来我打算整理撰写成一篇类似之前写过的量子计算机那样的以「自由意志」为主题的文章，但在搜集好了相关资料和列了些提纲后就没有下文了。那段时间还接触了很多心理学的内容，这两个学科的兴趣我想我也会一直保持下去。</p>
<p>不过，前面也提到，初三下那种自己抓住一切机会输出的做法的空虚感让我感到不安 —— 自己的确看起来好像很厉害，但是自己全部也只有这么一点厉害了。有一种说法说，真正有学识的人应该像一座冰山，展露出来的是一小部分，而水面下的内涵才是绝大部分。至少，我想高中两年平静的积累后的自己，应该会相比之前那样空洞硬撑的自己来说，更实在的有趣一点了吧。并不是没有高中沉寂而大学再度一鸣惊人的菊苣的前例，有时也以此聊以自慰。</p>
<p>我在接下来的记录中写：</p>
<blockquote><p>「因为上个学期已经思考过太多次了，所以答案可以呼之欲出：这并不是什么高尚或者唯一正确的生活方式，更没资格去歧视那些看起来懒懒散散的人，但是只需要这句话就够了。</p>
<p>「因为尝试过以后，就会上瘾，再也无法忘记这种感觉了」。</p>
<p>因为懒懒散散的度过一天后，会发现这样的日子并没有价值，会发现失去了时间感后什么事情都变得不再有趣，只是用娱乐消磨时间，等待着被外力推向下一个不可抗的改变。这时候心里会泛起空虚感，会想起高一初那段拼命的日子。</p>
<p>是啊，那段时间虽然是自己最辛苦的日子，但是哪里又是最痛苦的日子呢 —— 那是自己至今为止最幸福的日子啊。</p>
<ul>
<li>Q: 我的目标是？</li>
<li>A: 和有趣的人做有趣的事。只是自己做有趣的事太过孤单，所以要到好的环境，和菊苣在一起，有趣的事情也会更有趣。</li>
<li>Q: 在身边的人都没那么高的要求的情况下，为什么不降低对自己的要求，顺其自然？</li>
<li>A: 因为我本就不是为他们而活的，我永远不可能也无法接受变成他们心目中的样子，我必须坚持我的路走下去。而且我已经试过顺其自然了，其实根本不开心。</li>
<li>Q: 为什么不能不改变世界，就改变自己，放弃这些无聊的坚持呢？</li>
<li>A: 因为如果放弃了，那我就没有存在的意义了。对我来说我无论如何都要贯彻这些只属于我的信念，因为这样的话，一定也会有只有我才能做到的事情，只有我才能创造的价值。</li>
</ul>
<p>简而言之，我已经不会再怀疑我自己想要的究竟是什么。如果有时候在困难和挫折面前无法回想起当初的心情，那不过是方法上的问题，因为已经怀疑了够多次数，无需再去怀疑自己的目标究竟是否值得。」</p></blockquote>
<p>让一个从来只知道思考怎么玩的孩子，学会努力和对自己负责。那时，我不得不开始尝试这么做。</p>
<hr />
<p>马上迎来了高二上。我如愿进入了重点班，新的班级刚开始有点沉闷，大家都只是埋头学习；这种学霸氛围的压力让我也不得不紧张起来，平常收起了自己作死的一面，开始踏踏实实的学习了一段时间。出于迷一般的运气，我被分到了全班乃至全年级最好的宿舍，那时候我们拿成绩开玩笑，赌谁考到了宿舍前三要请吃饭；可我没想到，就在紧接着的月考里，我们宿舍除了雷打不动的年级第一和第二，其他的人却大失水准，而我则意外的进入了前十。请吃饭是当然的，随之而来的，就是这个几乎唯一主题是课内学习和考试的高二上。</p>
<p>值得一提的故事相对来说并不多。留下记忆的当属社团那难得让我略微有点青春的现实感的招新活动，还有校运会上实习老师为增进我们班级感情做的各种活动，其他的，除了各种绞尽脑汁压榨自己的时间，提高学习效率之外，大概就是利用自己的年龄优势，跑上跑下为报名来年的(少年班)高考做准备吧。新的班级明显变得有趣得多，能融入学霸们的圈子还是十分有趣，运气更好的是，分到的小组里的另外几个男生都是学霸和宅。</p>
<p>相比高一时和身边的现充同学们几乎无话可说，高二终于能不时的和同桌聊聊 Hifi 交换试听耳机和播放器，或者拿着「基础有机化学」和「普林斯顿微积分读本」各种讨论。印象最深的是一天下午，我问起圆周运动向心加速度的公式怎么求证，三个人于是就开始一路从班里聊回宿舍，动用了几何证明、坐标系和取极限等各种能想到的手段，最后勉强弄出了和标准证明思路近似的不严谨的证明。</p>
<p>终于在一次学校元旦晚会的晚上，无聊的思考着的我惊奇的发现从洛伦兹力出发能推导出电磁场的一系列定则和公式，激动的不能自已的我在晚自习结束后走上了讲台，宣扬了一番自己的成果。后来发现自己的推导还真是对的，不过只是个早已存在的考试用处不大顶多当促进理解的奇淫技巧罢了。</p>
<p>然而开始并不是重点，后来我一时兴起创造的这种晚修结束前的小课堂的模式居然成了风俗，在时常和我讨论的那两位同学同时也是学习委员的组织下，坚持了好一阵子。无非是同学们自行报名上来，然后讲点各学科的基础知识、有趣的解法或者未学的选修的黑科技。我无比的确信高一时我的牺牲没有错 —— 在这个班里，总算看起来不那么的让人讨厌。</p>
<p>高二的寒假前也就是新年，我写下了一篇标题为「2016 – 凛と伸び咲く.」的记录。单独成篇发布看起来更加奇怪，所以干脆就大段选摘在此吧。限于篇幅，一些具体的规划和方法就省去了。</p>
<blockquote><p>「又是一年元旦。</p>
<p>记忆中，两年前、一年前的元旦，都是在网络上一片热闹的度过。前年在YY语音里互道新年的声音仿佛就在耳边，半年后我却告别了百度贴吧；去年群里的景象虽然没留下太多的印象但也十分愉快，可半年之后我却已经停下了所有的项目和网站，在网络上变得悄无声息了。而今年的零点十分，我在洗澡，家人已经睡了，QQ 和 Twitter 寂静无声。</p>
<p>如果说，以寒假为标志的中二症晚期开始、对 evenBits 的挥别加处理后事是高一下学期的主旋律，那么以一个失败而不可或缺、平静而充满震荡的暑假分隔而来的，就是高二下学期以难以置信的速度完成的心理稳定和学霸 Level Up 了。今年各种事情的密度很高，并且通过博客、 Log 、邮件和 IM 留下了相当丰富的记录。可是记忆中，一如既往的，高二开学前的事情都恍若隔世。</p>
<p>「掐着秒表做梦」，这是个不太恰当但是可窥见一斑的描述。前半年的中二期现在自然是印象已淡，至于后半年，则是从反复无常到平实稳定，从热血中二到平和冷淡的过程。遗留下来的紧张感有气无力的支配着不算迷茫却总有点难再说出拼命的内心，不再是间断爆发而是如影随身的淡淡无力不时拉扯着蹒跚前行的脚步。总而言之，说差大概会愤懑不平，说好又会心有愧疚，却总觉得也不能冠以一个不上不下的称呼。「有很努力了」，「没有当初拼命了」，「本来应该做得更好」，「时间不允许不做的更好了」。大概就是这样的感觉。</p>
<p>因为情感和回忆太过混杂，文字也显得矫揉粉饰。大概旧的一年不得不得就这样盖棺定论，那么，新的一年呢？</p>
<p>新的一年里，我会迎来 3 月份的 [英语口语测试] 和 [生物竞赛] ， 6 月份的 [学测] 和 [中科大少年班高考] 。每一项都是唯一的机会，每一项都由不得马虎。不如说，我已经对自己的无力足够宽容，放弃到只剩下这几件必须做好的事情了。</p>
<p>新的一年里，我要面对的问题，却仍然很多。</p>
<p>……</p>
<p>「凛然独自开放」，经过了一个堪称中二可笑的，也只有自己知其中心酸的暑假，我终于能够对自己这么说道。我亲手抉择了我要坚持怎样的自己，也真的没有再怀疑。</p>
<p>努力最可怕的事情就是，越努力越清楚知道自己的极限在哪里。虽然现在不能妄言已经尽力，却也知道不可能一个决心一个拼命就能让自己超神无敌了。看着明显与目标相去甚远的现状，却除了在心急如焚的同时踏实逐个慢慢面对之外别无它法。</p>
<p>…… 要考上，要认真考，要考上。</p>
<p>从很早开始就已经没有再质疑过或者动摇过了，哪怕偶尔会担心在落榜之后回看会多么可笑，但是却不打算考虑放弃。</p>
<p>那么，就来面对问题吧。</p>
<p>……</p>
<p>已经没有任何余地了，我必须以自己最好的、以及比最好还更好的姿态去迎接这些至关重要的挑战，即使清晰的知道这一切不是终点，而是无数痛苦的浴火重生的起点。</p>
<p>所以，这一年，我告诉自己，凛と伸び咲く。凛然独自开放，我为这句话赋予了更多的含义。</p>
<p>**凛然** 独自开放，是不在意他人的眼光。因为你身后已经没有任何人了，你要面对的、负责的只有自己。不要在意周围平庸的人的看法， **离开他们，飞向更高更远的地方** 。坚持自己所持的信念，保持一份哪怕是幼稚可笑的、对前方美好的热切向往。</p>
<p>凛然 **独自** 开放，是对自己的完全负责。如果失落难受，那就痛快的哭，如果哭不出来，就滚回去学习。不要乞求别人的理解和安慰，不要含沙射影的寻求心理平衡，因为你早就知道，最终将一无所获。 **到能理解你的人身边，用努力和成绩证明自己** 。绝不能再放弃思考放纵自己，因为除了你自己，没有人把你拉出这无底深渊。</p>
<p>凛然独自 **开放** ，是尽情的展示美丽。不要害羞含蓄，哪怕张扬会带来更多的挫折失败。新的一年，要变得更加可爱，更加温柔，更加接近想成为的自己。想成为 Haruhi ，就去找外星人、未来人、异世界人、超能力者。做出了选择，就去拼命创造奇迹。</p>
<p>……</p>
<p>一周前留宿学校时，和同学谈起大学的目标和志向时，对方出人意外的说了句直入我心坎的话：平日里锋芒毕露的人，可能不一定有很长远的志向；但凡真正想装个大逼的，往往反而知道隐忍。这话虽然说得没有情怀，却是事实所在。</p>
<p>高中对我来说，是第一次学会收起自己的羽毛，隐忍而积蓄力量的时候。也许我的高中，更多的与只身一人的挣扎和痛苦为伴，相比小学的收尽眼前风光，初中的无意之间错过，是真正眼睁睁亲手放开了无数的诱人的机会。不论是网络上还是高中生活，我都只能看着他人博得掌声与喝彩，而自己只能步伐蹒跚，咬咬牙继续前行在自己的路上。但我相信，这一切不是我为自己无能找的借口，最后的最后，自己会抵达旁人所无法涉及的地方。</p>
<p>世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。</p>
<p>伝えてこの想い 风よ星よ，信じて待っていることを。」</p></blockquote>
<p>啊，写的蛮中二的。不过我喜欢。</p>
<hr />
<p>对高二下，我的评价一般是「简直 bullshit」。用个形容词，就是糟心。寒假时的计划里我这样写：</p>
<blockquote><p>「一言以蔽之，死到临头了。 …… 适应性测试基本确定没法考，一模无法准备，二模基本是唯一机会。接下来的半个月内生物竞赛和听力是头等要务，做好睁眼见闭眼见梦里见的准备。自己作的死，含着泪也要做完。」</p></blockquote>
<p>相比显得相对平淡的高二上，这学期则是一点都不安稳。因为学校和地区软硬件条件最后放弃了强省弱市的 NOIP 的我，选择了最后在好歹是弱省弱市的生物竞赛尝试一下。另外，当时并没有预料到生物竞赛市内能领先出线的我没为此计划太多的时间，所以一开始的主题当然就是并不是很有信心，但是不管怎么说也得全力以赴的挑战一次的高二高考。</p>
<p>除了学习以外值得一提的事情应该还有些许，不过马上能想起来的不过是久违的捡起了代码和设计，和同桌给班里写了个基于 Django with Python 的带随机点名、语音提示、加减分、历史记录和人品计算等功能的课堂助手。个中有趣的事情也不少，但也不得不承认朋友的增多和对高中生活的适应，让学习略微松懈了一点。</p>
<p>学期初的我面临的问题众多，加上上学期一路高走的排名遭到了挫折，使得我开始为焦虑困扰。不得不说，当时读到的几本书对改善我的完美主义和降低焦虑、心里控制有了极大的帮助。但是我终于在连番的失败和压力中，一时间失去了对自己状态的把握，我在后来的记录中写道：</p>
<blockquote><p>「事实上，本学期的主要问题在于开局不利。以探索和混沌为主题的寒假结束后，带着期末不顺和迷茫的心情我来到了新的一学期。以往，我都会在学期伊始，马上提高要求，争取尽快领先；虽然最后总是失败，但是无论如何是给接下来抓住机会，创造决定性突破奠定了基础。但是这学期初几周，我的精力竟然先是在迷茫，随后决定「提高幸福感」上；当然不可否认这个进步的意义，然后随后我又开始了文化和技术方面的「重拾感觉」，这些事情加起来，我可以说本没有约束的学期初期就被消耗掉了。</p>
<p>……</p>
<p>寒假是对追求、动力和自控的探索，在学期初解决了焦虑和幸福感低下的问题后，在面对接踵而至的考试过程中树立了一个完善可靠的自控系统。在情况显得愈来愈好的时候，却被生物竞赛忽然打断，其中收获颇丰，但对其他事情不管不问的做法，也大大延误了课内的任务和计划。 …… 虽然总体上收获还是更多，但是这种初中继承下来的「单线程、对其他事情不管不顾」的做法，已经愈发显得成就和不完善，多半是不应该有下一次了。」</p></blockquote>
<p>大意是，我在备考生物竞赛的时候，仍旧采用的是和初三那时「<a href="http://blog.dimpurr.com/no-impossible/" target="_blank">Nothing is Impossible.</a>」中写过的、类似于临时抱佛脚的仓促而极端的方式。准确一点的说，这也是过去的我常使用的方式：不计成本、不计客观情况、抛下所有的其他必要和不必要的事情只关注一件事的不合理的冲刺方式。这只是一方面；另一方面，也正因为我在自己的关心的目标，学业抑或技术上受挫了，我终于有机会，尽管不合时宜的发现这一点：我对于自己感兴趣的事情以外的太多事情，换句话说关于生活，关注的实在太少了。</p>
<p>所以这学期，在这种小地方当然很难找到同类的伙伴，我可以说是一定程度无视了学校的授课进度而焦头烂额的独自投入到了竞赛和高考中，也终于有了一定合理而有条不紊的、科学的学习和规划能力。除此之外最大的变化，就是我开始重视起了自己从未重视过的东西，生活、健康、人际关系、家庭、亲情，如此等等。在此之前，我尽管在自己的世界里很耀眼，但是在实际的生活中大概并不是一个那么讨人喜欢和积极的孩子；而这个学期，一定程度的以成绩为代价，我想自己离自己心目中的成熟稍微接近了一点。今后还会有更多的机会，在此就不过多的描述了。</p>
<p>具体的故事限于篇幅和时间这次不便再讲，简单地说，我只能疲于应付一个又一个挑战，最后的结果也不算奇怪的并不成功，相比之下过程和经验的意义还显得更大一些。备考生物竞赛前，和学校申请不参加期中考，停课一周每天骑车去图书馆自习室的记忆还十分鲜明，在省实参加考试时，见到来自各地的学霸们、了解到自己求而不得的全然不同的高中生活的感觉自然难以言表。然而我也不讳言，这次的结果最终只有毫无意义的名次，甚至还比不上纯属运气的物理竞赛全国奖的价值。</p>
<p>另一边的高考，更是在模考只有二A的情况下应付完竞赛就仓促上阵，在两个月提分近 100 的情况下，结果除了给学校贡献多了一名重本人数之外，仍旧距离有意义的分数线千里之遥。关于高考前后的逸事也不少，不过经历过的人才知道在广东高考和高二政史地学测三天连考有多痛苦。高考第一天的前夜借同学的宿舍，然而陌生的床位上蚊帐根本关不住，于是那个又热又有三四只蚊子陪伴的夜晚我愣是直到四点半才睡着，第二天就那么硬生生的上了考场。还好刻意调整了几天睡眠的自己状态并不会太差，和真正的高三学生并不太一样、以及自己这学期各种折腾练出来的心理素质也还算过关，除了高考发挥正常，学测也没有差错的保住了全 A ，不必担心给高三留下什么心理负担了。</p>
<p>到最后，如果你可以否认现实和结果的话，只为自己的所谓努力自我感动和陶醉当然是很简单的。可是竞争是冷酷的，没有人会同情你，无论你多努力，还是根本没有努力；无论你过去有多不堪，到今天这一步已经多么不容易。所有争辩全无意义，失败就是失败，仅此而已。</p>
<p>回看当时的记录，五味杂陈。</p>
<blockquote><p>「对这 100 天的自己，我的态度是：</p>
<p>无所谓，我就是想试着逼一下自己。想再一次认真的试一下，自己能做到多好。想离那些自己所喜爱的身影更近一点，想能够和他们一样。想尝试用一件事情把自己的每一天填满是一种怎样的感受，想试试一心一意、专注于目标的感觉。</p>
<p>就是达不到所谓的「目标」，我也有办法活下去。但是我享受为「目标」所困扰的过程。仅此而已。</p>
<p>好事是，自己摒弃多余的关注点和活动之后，能够让自己更加全心全意的面对自己生活的核心问题：学习，和心态问题。焦虑、拖延、完美主义、缺乏安全感，这些困扰自己已久的问题；如何与自己、与事情相处；然后，如何计划，如何利用时间，如何学习。一步步的来，会好的。</p>
<p>……</p>
<p>我如何选择我的生活？</p>
<p>我选择面对每一个现在。学会把未来摆在不远不近的位置。学会思考如何更好的度过每一个今天。学会不闹情绪，听从自己的话。踏踏实实的做好应当做的事情，然后给自己留出时间，面对自己和真正的问题。这是接下来的 100 天，还有一生中，将要切实去做的。</p>
<p>我希望到哪里去？——这固然很重要，但是更重要的是，曾经我希望现在的我身处何方，现在的我希望我现在正在做着什么？</p>
<p>我想，我希望这 100 天里，我变得更加成熟。能冷静的思考，不再为孤独而恐慌，与自己相处，学会听从自己的话语。然后，不再逃避、自暴自弃，而是踏实认真的去面对一直以来困扰自己的问题，面对自身的责任和负担。与此同时，同样最重要的，就是面对高考这项挑战，用这 100 天的表现，证明自己的可能性。</p>
<p>一定可以做到的。因为一直以来，现在仍旧在努力着。</p>
<p>再答应自己一件事：一定不要停下和自己的对话。世界仍旧有趣，不要沉浸在容易醉人的忧郁。在完成任务之前，不要让自己失控。……在那之后。」</p></blockquote>
<p>竞赛前的记录中，我写：</p>
<blockquote><p>「我曾经憧憬过很多的剧本。有所谓蔷薇色的高中生活，有所谓学霸的奋斗历程，有很多动画中故事中描写的、他人转述的经验和经历。我曾经不止一次站在其中一个剧本的起始，我也很清楚，究竟有多少次的机会我已经亲手放过。</p>
<p>现在，我再一次站在了，拥有一切可能性的剧本的起始。这一次，我能像故事里的主人公一样，精彩的书写下动人的过程、炫目的结局么？</p>
<p>……</p>
<p>我希望通过这次的机会能提醒自己，怎样对自己负责，怎样关注重要的事情不在意他人无谓的看法，怎样抓住机会，怎样亲自书写自己憧憬的剧本；同时解决困扰自己两年之久的假期和自习问题，解决许多潜伏已久的家庭关系和心理认识问题，与之前一直无法面对的感情「和解」，继而用全新的在家学习效率迎接最后一个逆袭的暑假，用全新的自控体系面对下一阶段的学习。」</p></blockquote>
<p>想想并不难理解，绝决的抛弃现在、在似乎快要看不到希望的时候也不放弃、咬牙坚持到最后，这并不可能是没有任何困难就可以做到的事。非要说的话，高二下的我仅仅是对于从高一下开始的长途跋涉略微有些失去了信心，所以方向也显得不够坚定。只是所有的挑战仍旧如约而至，我无法逃避。</p>
<p>我想，故事最后的走向不算糟糕，当初计划的要达成的其他事情我大多还是做到了吧。除了最重要的，结果本身。</p>
<hr />
<p>高二下，我因为独自准备竞赛和高考，在校内的排名一路下跌。一切都结束后的一调，我终于能够静下心来好好备考一次，也成功的从近 70 多名回到 10 名左右。在很久之前我就已经稍微想到过竞赛和高考结束后的规划，那时我写：</p>
<blockquote><p>「大概到时候学习上的战略，就是先重建经过高二下修饰的高二上系统，再在以可能的最高状态基础上另寻他变吧。」</p></blockquote>
<p>失败归失败，但是对于高二上一定程度感受到了成绩提升瓶颈的我，应该说在高二下的这段经历还是很有价值的。首先迎来暑假的我，无非就是在补课、规划高三和一趟上海之旅中度过了短暂的不到一个月的假期。</p>
<p>这次的旅行相比小时候的普通观光，应该说是一次目的很明确的出行：我没有去任何文化和娱乐景点，我直奔这里的大学和图书馆，我游览了陆家嘴和各种文化场所，了解这里的中学、大街小巷和日常生活。相比初三时参与活动和参观学校、科技公司为主的那趟北京面基之旅，这次除了被 Thiece 君拿去凑数听了个小的技术交流活动之外，没什么和技术搭边的事情，毕竟高中两年消失在社交网络的我已经没有太多可以联系的朋友了；我更关注的也许是外文书店的 Animate 和人民广场站的 MisterDonuts ，小忍最喜欢吃的甜甜圈。</p>
<p>我要为自己的大学和未来的生活选择城市。</p>
<p>留下了 3000 张照片和对一个地方、一种生活方式的深刻印象，以及带回一袋本子和一袋「本子」的战利品之后，我并没有过多的再逗留下去。很快就是新的学期，就是现在。</p>
<p>在高二下的记录里，我还曾经写：</p>
<blockquote><p>「问题并没有那么复杂 —— 前进是痛苦的，然而我只是开始畏惧这份痛苦。</p>
<p>我用「听话」描述了我上学期期末和这学期初的状态 —— 认真享受老师的确可以称之为精彩的课堂，认真完成作业，认真和优秀的同学们讨论。每一天都很充实，都很棒，除了我在完成任务，表现的完美无缺之外，同时放弃了对自己究竟学到了多少认真负责之外。</p>
<p>从寒假开始我就在试着调整心态。不管是「克服」了完美主义还是在每个早上调整心情，是用习惯取代了不合理而过分的自我要求还是更多「直面」或者「逃避」焦虑的小技巧，我成功了 —— 让我的日子变得很好过，变得无可指责。</p>
<p>我对外用的口径是，正是因为这样，我才学的还不如之前虽然可能不听课、不按要求做作业，但是自己在认真对自己负责，认真做了自己的选择和付出的时候。可是我心底里知道，我究竟害怕的是怎么回事。</p>
<p>我很害怕，害怕自己体验到快乐，然后一旦觉得快乐，就会觉得这样就够了，就会开始懒惰，开始驻足停步，闭上眼睛不再望向下一个地方。学名叫舒适区，这是冠冕堂皇的说法。</p>
<p>冠冕堂皇的说法，不那么好听的版本就是不逼就会懒。但是我知道我真正害怕的其实是，相比之下，我的状态可以称之为是「适应」了。</p>
<p>是啊，找到了最适合现在的生活方式，和其他人一样，享受学习，享受生活，享受好今天；然后，以最「适合」现在的生活方式，走向最「适合」现在的终点，然后奔向下一个既定的地方。如同链式反应一样 —— 我曾经用「一眼就能望到终点」来描述 —— 如同命运一般，默默前行。</p>
<p>企鹅罐里说，「我讨厌『命运』这个词。出生、相遇、离别，成功和失败，人生的幸运与不幸，如果这些都是由命运事先决定好了的话，那我们又是为何而生呢？」</p>
<p>我曾经用过这样的话来描述环境的影响相比个人的决心是微不足道的：「如果你是年级前十，你需要在意这所学校的本科率是怎样的么？只有优秀率对你才有意义了。」在那天下午的对话中，我并没有那么明确的意识到现在的问题的本质，可那天我的全部话题和回应，已经潜意识中说出了我究竟在担心什么。</p>
<p>嗯，把问题描述的简明扼要一点吧。</p>
<p>我怕自己不再贪心了。」</p></blockquote>
<p>当我开始以我是年级第几来定义自己的时候，当我开始斤斤计较身边的同学何以在排名上高过自己的时候，我就只是这个学校小池塘的一个还算可以的学生，我就不再是那个拥有更广阔的世界，拥有无限可能性的自己了。这就是我高二下所一直处于的，也是暑假的我期望能够结束的状态。</p>
<p>当然我还是做到了。我开始不断的提醒自己调整心态注视远方。我重振旗鼓再度踏上了为自己梦想的大学和城市努力的路程，这次是真正的高考。这学期初我终于解决了许多积存已久了听课和作业的问题，月考是之前还未达到过的年级第四，这是个好的开始。</p>
<p>我和自己说，「一手好牌，可别打坏了呢」。</p>
<p>前几天没忍住在草稿纸上摸鱼了起来，却意外的发现自己的伯里曼人体没白练，总算能画出可以萌到自己的画了 ……。小说尽管没有哪篇最终成文的，练习短篇倒是有一堆，对自己的文风也是相当满意。还没到可以晒出来的程度呢。想想距离自己能画出本子估计还要好一段时间，不过说不定可以开始构思第一部漫画的剧情脚本和人设了吧？高中以来，相比初中单纯的专注于代码和设计，在历史、经济学、社会科学方面的阅读也不少。不过前端算是被彻底搁置了，不过有了更好的基础，大学再捡起来也为时不晚吧？嘛，现在最重要的总归是学习呢。</p>
<p>我写：</p>
<blockquote><p>「我想回到那个世界。</p>
<p>不是以后，就是现在。现在就可以，证明自己有实力做到。</p>
<p>因为啊，至少在这漫长而曲折的，混合了探索和迷茫的已经走过的道路中，有一件事我还是明白了的。</p>
<p>没有时间永远不会是问题，因为在因为觉得没有时间而紧张兮兮后，你仍旧很可能在大把大把的浪费时间。更重要的是，没有时间是如此幸福的一件事，因为当自己觉得时间不够时，时间才真真正正的在自己的手中。」</p></blockquote>
<hr />
<p>终于迎来了结尾。</p>
<p>困意已经十分浓重，虽然深夜写这样的文章也不是一次两次，但是高中并不那么适合这样做。本来我大概想用更多的篇幅来描绘下现在的自己，或者谈谈和对未来的想法，但是至此我大概只能以远远超出预想的万字长文的过往经历代替它们，然后尽快草草结束。</p>
<p>很快就会有机会再详叙的，不是吗？不过半年多而已了。</p>
<p>高中生活我留在公开的站点上的记录不多，博客更是基本放置 Play ，唯一有变化的，也许只有每逢画画时大概会更新一下的 <a href="https://twitter.com/myccyycy" target="_blank">Twitter</a> ，还有坚持不懈的标记动画的 <a href="http://bgm.tv/user/myccyycy" target="_blank">Bangumi.tv</a> 。各种群聊自然也是没有时间看了，要联系我的话，也许只能直接 QQ 私信吧。</p>
<p>不多谈各种领域的书籍，只提下高中在个人成长方面我认为对自己有一定影响的书，按我接触到的时间顺序依次是「暗时间」「习惯的力量」「心理控制方法」「专业投机原理」。同样很重要的就是动画了，高中之前看过的有「冰菓」「龙与虎」「樱花庄的宠物女孩」「CLANNAD」「Angel Beats!」，高中按时间顺序依次「吹响吧！上低音号」「回转企鹅罐」「结城友奈是勇者」「ef – a tale of memories.」，和并没有动画的「Narcissu」。我计划做一个单独的页面，收藏我喜爱的动画、书籍、设备 Setup 等等并加以评论，届时再写写详细的感想吧。</p>
<p>高中以来，能谈起学习方法、关于未来和动力的迷茫等话题的人并不是完全没有，但总归很不尽兴；在自己感兴趣的领域中，离开了网络，现实中更是难以找到对互联网和设计、 ACG 作品和业界、哲学历史社科文学和科学科普有与自己一样的趣味的人了。当然，我也并不指望很快就能找到这样的同好；因为高中生活和环境的限制，无法放开手脚的利用互联网或者各种方式去寻找，也许我需要耐心等待大学生活的到来。</p>
<p>尽管很多事情已经改变，后来也又发生了许多，但高一时留下的话语并没有失效。那时我写：</p>
<blockquote><p>「希望能和善于思考、敢于创新、不墨守成规的优秀的人在一起，做有创造力、能让世界变得更有趣的事情。具体的实现方式是，在好的大学和创业、工作单位中，与杰出的人一起做改变世界的产品，在业余进行同人创作。</p>
<p>希望自己成为有独特见解和能力、能依照自己的原则率真待人处世的人，在感兴趣的领域小有名气，作品能为读者、用户带来乐趣或感动，能通过自己的才能给祖国和世界带来些改变。</p>
<p>除去学习，希望高中阶段能改正自己主要的性格缺陷，以一个较为完善的人格进入大学。希望自己能在空余时间尽可能的积攒一些专业知识，以供大学有足够的时间时做好准备。」</p></blockquote>
<p>时间并不剩下很多了。按照日程和规划，月考结束后接下来紧接着就是二调。距离阶段性的目标分数还有距离，目前的情况并不太乐观。明天就要返校，很快得重新投入到新的挑战中去。</p>
<p>但是，还是可以有信心的，不是么？</p>
<blockquote><p>ひとりでもゆくよ例え辛くても<br />
きみと見た夢は必ず持ってくよ<br />
例え辛くても寂しさに泣いても<br />
心の奧には 溫もりを感じるよ<br />
—— 「Girls Dead Monster – 一番の寶物」</p></blockquote>
<p><em>全文 1W6 字符，BGM「Yun*chi – Your song*」单曲循环，写作环境 Byword with OS X 。</em></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/euphoric-field/">euphoric field</a></p>]]></content>
        
        <summary type="html">
            
            大概已经过了许久，没有再动手写一篇不止是给自己看的文章了。 明天早上返校，所以大概没有那么多时间构思和修改。并不是真的多么在意这在别人眼中会怎样 —— 更重要的是，随着时间沉淀下来的这篇文章，在以后的自己眼中将会怎样。 无意间翻阅 Google Keep 中两三年前的 Note
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="回忆"/>
        
        <category term="成长"/>
        
        <category term="日常"/>
        
        <category term="青春"/>
        
        <category term="高中"/>
        
    </entry>
    
    <entry>
        <title>bilibili 新番承包付费意愿调查</title>
        <link href="https://binux.blog/2016/05/bilibili-pay-user-analysis/"/>
        <id>https://binux.blog/2016/05/bilibili-pay-user-analysis/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:22:05+00:00</published>
        <updated>2016-05-17T22:22:05+00:00</updated>
        
        <content type="html"><![CDATA[<p>2014年10月1日 bilibili 正版新番承包上线，我就对 bilibili 这种自愿付费的方式感到好奇。而且经常听到「正版体验不佳」，「正版动画比起盗版，有何优势呢」的言论，那么中国用户在不插广告，不优先播放，不强制的情况下，到底愿意为「爱」付多少钱呢？</p><blockquote><p><strong>为什么 bilibili?</strong></p><p>bilibili 早期，新番都是用户上传的，可以说是典型的「盗版网站」。那么这个拥有大量用户的「盗版网站」体验应该说不差吧。</p><p>随着 bilibili 开始购买版权，现在新番实际上是正版盗版共存的模式，而 bilibili 不插前置广告（当然现在有「约不约」了），不强制付费；从体验上看，特别相对其他国内视频网站，应该是最接近「盗版」的了。</p></blockquote><h1><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#付费人数"></a>付费人数</h1><p>bilibili 新番承包人数可以非常方便的从番剧的介绍页面上获知：</p><p><img src="https://binux.blog/assets/image/Screenshot_2016-05-15_13_41_24.png" /></p><p>但是由于动画的类型不同，热度不同，独播非独播用户（路人）成分不同，直接比较数字没有什么意义。需要首先找到一个基准来讨论播放和付费数之间的关系。</p><p>我抓取了新番承包上线以来新开播的 142 部新番（<a href="http://demo.pyspider.org/results?project=bgm_bilibili" target="_blank">http://demo.pyspider.org/results?project=bgm_bilibili</a>），去除话数小于10的 OAD，OVA 等，剩下 136 部。将总播放，追番人数，弹幕总数画为散点图：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 15.29.25.png" /></p><p>由图可知，弹幕总数和总播放数相关性比追番人数相关性更大（参照 <a href="https://en.wikipedia.org/wiki/Coefficient_of_determination" target="_blank">R^2</a>）。独家和非独家新番在弹幕参与度上相差不大，但是非独家的追番率比独家新番少了一半。难道非独家新番用户大多是非 bilibili 注册用户吗？这说不通啊，明明应该是反过来，非会员不得不到 bilibili 上看才对啊。。</p><h3><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#付费比例"></a>付费比例</h3><p>在开始写这一节的时候，我本想应该挺简单的，承包人数要么和播放数正相关，要么和活跃（弹幕数）相关，要么就和追番人数相关。但是经过了3个小时，当我尝试了：</p><ul><li>总播放数</li><li>平均每集播放数</li><li>弹幕数</li><li>收藏（追番）人数</li><li>时间</li><li>是否独家新番</li></ul><p>画了20+张图之后发现，问题并没有这么简单。很难有一个什么方法能够预测出用户的付费意愿，有很多叫好不叫座，或者叫座不叫好，导致付费比例非常分散：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 17.55.25.png" /></p><blockquote><p>图中左边是独播新番，右边为非独播</p></blockquote><p>这里面会发现一些有趣的地方：在独播和非独播中，都有一个承包比例非常高的点，分别是《电器街的漫画店》和《Fate/stay night [Unlimited Blade Works] 第一季》，他们都是2014年10月番，正好是新番承包刚上线时的作品，可能用户对承包模式的尝鲜，或者前期宣传上的增益。</p><p>将特异点排除之后，发现不管是否独播，他们的付费比例差别不大，但是非独播的方差大得多：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 18.00.02.png" /></p><p>平均上来说，<strong>bilibili 的付费比例约为播放数的万分之 1.447，收藏人数的千分之5.373</strong>。但是这只能是整体估计，具体到单个番剧就没有意义了。</p><h3><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#用户到底为了什么付费？"></a>用户到底为了什么付费？</h3><p>那么，具体到每一部番剧，用户到底因为什么因素愿意付费呢？</p><p>当我将付费比例前10与付费比例后10的放在一起比较，试图找出答案的时候，我真的失败了：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 21.11.35.png" /></p><p>在前10中有在我看来「这什么鬼」的，在后10中也有追过的，完全搞不懂拥有更高收费比例的番剧是为什么。当然，通过加入声优，导演，制作，类型 tag 等因素，或许可能找到原因，但这样少的数据，又很容易陷入过拟合的境地（如果有兴趣，可以<a href="http://demo.pyspider.org/results?project=bgm_bilibili" target="_blank">下载数据</a>分析看看）。</p><h1><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#付费金额"></a>付费金额</h1><h3><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#人均承包金额"></a>人均承包金额</h3><p>虽然在 bilibili 页面中有承包商排名，但是并不知道付费的金额，仅在你承包的时候，给出你当前的排名。为了了解承包商们在这样没有强制金额的「捐献」中愿意付多少钱，我从1元开始承包，然后查看我当前的排名来获得各个区段的人数：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 21.16.24.png" /></p><p>为了消除连载中，独播，类型等影响，这里选择了连载中，非独播的的 <a href="http://bangumi.bilibili.com/anime/3461" target="_blank">Re:Zero</a> 和已完结，独播，稍微腐女向的 <a href="http://bangumi.bilibili.com/anime/2725" target="_blank">K RETURN</a>。</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 18.32.14.png" /></p><p>从图中可以看出：</p><ul><li>主要用户的付费金额在 5-13（不要吐槽为什么是13，手抖了！）</li><li>不同类型的番剧，承包金额的分布几乎是完全一样的</li><li>TOP 付费用户的付费金额比较高，Re:Zero 我付到 500 元，依然有 3 个比我高的（于是我放弃了）</li><li>同样付出 150 元，在 Re:Zero 中能排到 19，而在 K 中只能排到 37，还不论 K 的付费人数实际少于 Re:Zero（腐女还是有钱人多啊）</li></ul><p>那么，假如我们不考虑前 3 位的土豪，<strong>人均承包金额约为 13.08 元</strong>。因为我们并不知道土豪能为我们拉升多少身价，那，即使我们现在假设排名前三的土豪均承包五千块，人均承包金额也不过18元。为了简化，我们取20块好了。因为选取了两部因素差异蛮大的动画，得知不同因素对承包金额的分布影响不大，这个人均承包金额是可以套用到不同番剧上的。</p><h3><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#承包收入"></a>承包收入</h3><p>那我们算一下，bilibili 通过新番承包，到底能赚多少钱呢？因为承包人数是公开的，乘以估计的人均20块的话，bilibili 承包收入收入排行：</p><p><img src="https://binux.blog/assets/image/Screenshot 2016-05-15 18.55.03.png" /></p><p>根据网上的传言，每集非独播新番版权价格大约是5万，独播更贵。那么好，我们统统算1万一集吧（对，就是这么任性）！那么也就 《Fate/stay night [Unlimited Blade Works] 第一季》 和 《电器街的漫画店》 实现了盈利。记得我们前面说过的付费比例异常吗？对，就是这两部「盈利」了的番剧。</p><p>从整体来看，bilibili 通过承包总收入为 288.7 万，平均每部番剧的承包收入是 21388 元，不打折的话，一集都买不起啊！</p><h1><a href="https://binux.blog/2016/05/bilibili-pay-user-analysis/#我想说什么"></a>我想说什么</h1><p>经常有人会用「正版体验不佳」作为盗版的理由，<strong>说得好像正版体验一样了就会付费了似的</strong>。bilibili 同时有提供正版和盗版内容，正版有比盗版体验差吗？难道正版看得人就少了吗？好，就算确实看正版的人少了，我们不看绝对值，那这寒酸的千分之5.373的付费比例是怎么回事？什么「正版体验不佳」啊，「要付钱当然体验不佳」啦。</p><p>另外一个常见的理由是「学生党，没有钱」，人均 20 块太贵出不起。请回过头看看追番人数，要是每个人出<strong>一块钱</strong>，那也要比现在这千分之5.373，人均20块的总收入高啊！<strong>一块钱</strong>都出不起吗？这可是<strong>一季</strong>动画，而不是一集让你出一块钱啊！看动画都是因为爱，而这份爱，连一块钱都不值吗？</p><p><img src="https://binux.blog/assets/image/ai.jpg" /></p><p>bilibili 不想通过广告那样半强制地收回那么一点点版权费，然而看起来这「爱」并不畅销。<strong>所以，我弱弱地提议，各位有爱的小伙伴，在看完一季动画后（是的，不喜欢可以不承包），从微信红包（是的，不用银行卡）中拿出那么一块钱（是的，最低承包不是5块，是可以改的），承包一下你喜欢的动画吧。</strong>。希望在「劣币驱逐良币」之前，良币不会先自己饿死吧。</p>]]></content>
        
        <summary type="html">
            
            2014年10月1日 bilibili 正版新番承包上线，我就对 bilibili 这种自愿付费的方式感到好奇。而且经常听到「正版体验不佳」，「正版动画比起盗版，有何优势呢」的言论，那么中国用户在不插广告，不优先播放，不强制的情况下，到底愿意为「爱」付多少钱呢？为什么 bili
            
        </summary>
        
        <category term="bilibili"/>
        
        <category term="ACG"/>
        
    </entry>
    
    <entry>
        <title>demo.pyspider.org 部署经验</title>
        <link href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/"/>
        <id>https://binux.blog/2016/05/deployment-of-demopyspiderorg/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>经常有人会问 <a href="https://github.com/binux/pyspider" target="_blank">pyspider</a> 怎么进行分布式部署，这里以 <a href="http://demo.pyspider.org/" target="_blank">demo.pyspider.org</a> 的实际部署经验做一个例子。</p><p>因为 <a href="https://github.com/binux/pyspider" target="_blank">pyspider</a> 支持分布式部署，为了验证也好，为了省钱多蹭 CPU 也好, <a href="http://demo.pyspider.org/" target="_blank">demo.pyspider.org</a> 通过 docker 部署在同一机房的 3 台 VPS 上，VPS 间有内网传输（实际通过 <a href="http://www.tinc-vpn.org/" target="_blank">tinc</a>）。</p><p>使用 docker 的原因是实际上 pyspider 能够运行任何 python 脚本，至少需要 docker 环境逃逸。</p><h1><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#数据库-amp-消息队列"></a>数据库 &amp; 消息队列</h1><p>demo.pyspider.org 的<strong>数据库为 <a href="http://www.postgresql.org/" target="_blank">PostgreSQL</a></strong>，理由是测试目的，磁盘占用和性能的折中。<strong>消息队列为 <a href="http://redis.io/" target="_blank">Redis</a></strong>，因为部署简单。</p><p>它们也是跑在 docker 中的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span>docker run --name postgres -v /data/postgres/:/var/lib/postgresql/data <span>-d</span> -p <span>$LOCAL_IP</span>:5432:5432 <span>-e</span> POSTGRES_PASSWORD=<span>""</span> postgres</span><br /><span>docker run --name redis <span>-d</span> -p  <span>$LOCAL_IP</span>:6379:6379 redis</span><br /></pre></td></tr></table><p>由于前面说过，机器间有内网，通过绑定内网 IP，没有做鉴权（反正 demo 会泄露）。</p><h1><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#scheduler"></a>scheduler</h1><p>由于 scheduler 只能运行一个，并且需要进行大量的数据库操作，它与上面的数据库和消息队列部署在一台单独的机器上。</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span>docker run --name scheduler <span>-d</span> -p <span>$LOCAL_IP</span>:23333:23333 --restart=always binux/pyspider \</span><br /><span> --taskdb <span>"sqlalchemy+postgresql+taskdb://binux@10.21.0.7/taskdb"</span> \</span><br /><span> --resultdb <span>"sqlalchemy+postgresql+resultdb://binux@10.21.0.7/resultdb"</span> \</span><br /><span> --projectdb <span>"sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb"</span> \</span><br /><span> --message-queue <span>"redis://10.21.0.7:6379/1"</span> \</span><br /><span> scheduler --inqueue-limit 5000 --delete-time 43200</span><br /></pre></td></tr></table><h1><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#其他组件"></a>其他组件</h1><p>所有其他的组件（fetcher, processor, result_worker）在剩余的两台 VPS 上以相同的配置启动。他们都是通过 docker-compose 管理的</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /><span>21</span><br /><span>22</span><br /><span>23</span><br /><span>24</span><br /><span>25</span><br /><span>26</span><br /><span>27</span><br /><span>28</span><br /><span>29</span><br /><span>30</span><br /><span>31</span><br /><span>32</span><br /><span>33</span><br /><span>34</span><br /><span>35</span><br /><span>36</span><br /><span>37</span><br /><span>38</span><br /><span>39</span><br /><span>40</span><br /><span>41</span><br /><span>42</span><br /><span>43</span><br /><span>44</span><br /><span>45</span><br /><span>46</span><br /><span>47</span><br /><span>48</span><br /><span>49</span><br /><span>50</span><br /><span>51</span><br /><span>52</span><br /><span>53</span><br /><span>54</span><br /><span>55</span><br /><span>56</span><br /><span>57</span><br /><span>58</span><br /><span>59</span><br /><span>60</span><br /><span>61</span><br /><span>62</span><br /><span>63</span><br /><span>64</span><br /><span>65</span><br /><span>66</span><br /><span>67</span><br /><span>68</span><br /><span>69</span><br /><span>70</span><br /><span>71</span><br /><span>72</span><br /><span>73</span><br /></pre></td><td><pre><span><span>phantomjs:</span></span><br /><span><span>  image:</span> <span>'binux/pyspider:latest'</span></span><br /><span><span>  command:</span> phantomjs</span><br /><span><span>  cpu_shares:</span> <span>512</span></span><br /><span><span>  environment:</span></span><br /><span><span>    -</span> <span>'EXCLUDE_PORTS=5000,23333,24444'</span></span><br /><span><span>  expose:</span></span><br /><span><span>    -</span> <span>'25555'</span></span><br /><span><span>  mem_limit:</span> <span>512</span>m</span><br /><span><span>  restart:</span> always</span><br /><span><span>phantomjs-lb:</span></span><br /><span><span>  image:</span> <span>'dockercloud/haproxy:latest'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> phantomjs</span><br /><span><span>  restart:</span> always</span><br /><span>  </span><br /><span><span>fetcher:</span></span><br /><span><span>  image:</span> <span>'binux/pyspider:latest'</span></span><br /><span><span>  command:</span> <span>'--message-queue "redis://10.21.0.7:6379/1" --phantomjs-proxy "phantomjs:80" fetcher --xmlrpc'</span></span><br /><span><span>  cpu_shares:</span> <span>512</span></span><br /><span><span>  environment:</span></span><br /><span><span>    -</span> <span>'EXCLUDE_PORTS=5000,25555,23333'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> <span>'phantomjs-lb:phantomjs'</span></span><br /><span><span>  mem_limit:</span> <span>128</span>m</span><br /><span><span>  restart:</span> always</span><br /><span><span>fetcher-lb:</span></span><br /><span><span>  image:</span> <span>'dockercloud/haproxy:latest'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> fetcher</span><br /><span><span>  restart:</span> always</span><br /><span>  </span><br /><span><span>processor:</span></span><br /><span><span>  image:</span> <span>'binux/pyspider:latest'</span></span><br /><span><span>  command:</span> <span>'--projectdb "sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb" --message-queue "redis://10.21.0.7:6379/1" processor'</span></span><br /><span><span>  cpu_shares:</span> <span>512</span></span><br /><span><span>  mem_limit:</span> <span>256</span>m</span><br /><span><span>  restart:</span> always</span><br /><span>  </span><br /><span><span>result-worker:</span></span><br /><span><span>  image:</span> <span>'binux/pyspider:latest'</span></span><br /><span><span>  command:</span> <span>'--taskdb "sqlalchemy+postgresql+taskdb://binux@10.21.0.7/taskdb"  --projectdb "sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb" --resultdb "sqlalchemy+postgresql+resultdb://binux@10.21.0.7/resultdb" --message-queue "redis://10.21.0.7:6379/1" result_worker'</span></span><br /><span><span>  cpu_shares:</span> <span>512</span></span><br /><span><span>  mem_limit:</span> <span>256</span>m</span><br /><span><span>  restart:</span> always</span><br /><span>  </span><br /><span><span>webui:</span></span><br /><span><span>  image:</span> <span>'binux/pyspider:latest'</span></span><br /><span><span>  command:</span> <span>'--taskdb "sqlalchemy+postgresql+taskdb://binux@10.21.0.7/taskdb"  --projectdb "sqlalchemy+postgresql+projectdb://binux@10.21.0.7/projectdb" --resultdb "sqlalchemy+postgresql+resultdb://binux@10.21.0.7/resultdb" --message-queue "redis://10.21.0.7:6379/1" webui --max-rate 0.2 --max-burst 3 --scheduler-rpc "http://o4.i.binux.me:23333/" --fetcher-rpc "http://fetcher/"'</span></span><br /><span></span><br /><span><span>  cpu_shares:</span> <span>512</span></span><br /><span><span>  environment:</span></span><br /><span><span>    -</span> <span>'EXCLUDE_PORTS=24444,25555,23333'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> <span>'fetcher-lb:fetcher'</span></span><br /><span><span>  mem_limit:</span> <span>256</span>m</span><br /><span><span>  restart:</span> always</span><br /><span><span>webui-lb:</span></span><br /><span><span>  image:</span> <span>'dockercloud/haproxy:latest'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> webui</span><br /><span><span>  restart:</span> always</span><br /><span>  </span><br /><span><span>nginx:</span></span><br /><span><span>  image:</span> <span>'nginx'</span></span><br /><span><span>  links:</span></span><br /><span><span>    -</span> <span>'webui-lb:HAPROXY'</span></span><br /><span><span>  ports:</span></span><br /><span><span>    -</span> <span>'0.0.0.0:80:80'</span></span><br /><span><span>  volumes:</span></span><br /><span><span>    -</span> /home/binux/nfs/profile/nginx/nginx.conf:/etc/nginx/nginx.conf</span><br /><span><span>    -</span> /home/binux/nfs/profile/nginx/conf.d/:/etc/nginx/conf.d/</span><br /><span><span>  restart:</span> always</span><br /></pre></td></tr></table><p>然后通过 <code>docker-compose scale phantomjs=2 processor=2 webui=4</code> 指定启动两个 phantomjs 进程，两个 processor 进程，4个 webui 进程。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#phantomjs"></a>phantomjs</h4><p>由于 phantomjs 有内存泄露问题，限制下内存就好了。<code>EXCLUDE_PORTS</code> 是为了下面的 haproxy 能够正确的均衡负载正确端口。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#phantomjs-lb"></a>phantomjs-lb</h4><p>通过 <a href="https://hub.docker.com/r/dockercloud/haproxy/" target="_blank">haproxy</a> 自动负载均衡，只要将服务链接上去，就会将请求分发到不定多个 phantomjs 实例上，同时只暴露一个对外服务端口。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#fetcher"></a>fetcher</h4><p>链接 <code>phantomjs-lb:phantomjs</code>，注意这里的 <code>--phantomjs-proxy "phantomjs:80"</code></p><p>由于 fetcher 是异步 http 请求，如果没有发生堵塞，单个 fetcher 一般就足够了。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#fetcher-lb"></a>fetcher-lb</h4><p>同 phantomjs-lb</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#processor"></a>processor</h4><p>processor 为最消耗 CPU 的组件，建议根据 CPU 的数量部署 +1/2 个。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#result-worker"></a>result-worker</h4><p>默认的 result-worker 只是在写数据库，除非发生堵塞，或者你重载了 result_worker，一个就够。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#webui"></a>webui</h4><p>首先，webui 为了安全性，限制了最大抓取速率 <code>--max-rate 0.2 --max-burst 3</code>。</p><p>然后通过实际的 fetcher 进行抓取 <code>--fetcher-rpc "http://fetcher/"</code> 而不是 webui 自己发起请求，最大程度模拟环境（IP，库版本），因为以前遇到过调试的时候没问题，跑起来失败，然后在调试器复现又没法复现的问题。fetcher-rpc 可以不用，这样的会 webui 会自己直接发起请求。</p><p>因为 demo.pyspider.org 主要就是提供通过页面来尝试 pyspider, 这里的负载较大，而且实现上是同步的，任何脚本执行，抓取都是堵塞了，多一些 webui 会比较好。</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#webui-lb"></a>webui-lb</h4><p>同 phantpmjs-lb</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#nginx"></a>nginx</h4><p>这里做了一些前端缓存</p><h4><a href="https://binux.blog/2016/05/deployment-of-demopyspiderorg/#其他"></a>其他</h4><p>因为懒得管，每小时我会重启除了 scheduler 以外的其他组件（反正会重试）。</p>]]></content>
        
        <summary type="html">
            
            经常有人会问 pyspider 怎么进行分布式部署，这里以 demo.pyspider.org 的实际部署经验做一个例子。因为 pyspider 支持分布式部署，为了验证也好，为了省钱多蹭 CPU 也好, demo.pyspider.org 通过 docker 部署在同一机房的
            
        </summary>
        
        <category term="pyspider"/>
        
        <category term="deployment"/>
        
    </entry>
    
    <entry>
        <title>年轻好啊</title>
        <link href="http://snowonion-blog.logdown.com/posts/731048-viva-young"/>
        <id>http://snowonion-blog.logdown.com/posts/731048-viva-young</id>
        
        <author>
            <name>SnowOnion</name>
        </author>
        
        <published>2016-05-28T17:11:24+00:00</published>
        <updated>2016-05-28T17:11:24+00:00</updated>
        
        <content type="html"><![CDATA[<p>年轻好啊</p>

<p>敏捷</p>

<p>每个人都该年轻</p>

]]></content>
        
        <summary type="html">
            
            年轻好啊  敏捷  每个人都该年轻  
            
        </summary>
        
    </entry>
    
    <entry>
        <title>Django 学习手记 三 数据操作的常用方法</title>
        <link href="http://blog.dimpurr.com/django-note-3/"/>
        <id>http://blog.dimpurr.com/django-note-3/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2016-02-04T15:45:15+00:00</published>
        <updated>2016-02-04T15:45:15+00:00</updated>
        
        <content type="html"><![CDATA[<p>上一篇中，我们已经建立了基本的 Model 数据模型，并且熟悉了关于数据结构的存取、更新操作。本篇中主要介绍了对 Model 数据进行操作的常用方法，包含有许多示例 <a href="https://docs.djangoproject.com/en/1.9/intro/tutorial02/#playing-with-the-api" target="_blank">参见</a> ，亲自操作一下就很容易明白。</p>
<p>为了方便，我们可以通过 Python 在终端提供的交互式 Shell 来尝试和熟悉各种数据接口类的 API 。</p>
<pre>python manage.py shell</pre>
<p>使用这个命令会启动 Python 的交互式 Shell ，并且预先加载好 Django 所需的环境和变量。</p>
<h3>示例：创建和修改新对象</h3>
<p>涉及到的新方法：</p>
<ul>
<li><code>all()</code> 列出所有对象</li>
<li><code>save()</code> 将该对象存入数据库</li>
</ul>
<p><span></span></p>
<pre>from polls.models import Question, Choice # 导入要操作的 Model
Question.objects.all()

from django.utils import timezone
q = Question(question_text="What's new?", pub_date=timezone.now()) # 创建一个新的 Question 对象
q.save() # 保存后才会被写入数据库

q.id # 输出属性
q.question_text
q.pub_date
q.question_text = "What's up?" # 修改属性
q.save()
Question.objects.all()</pre>
<h3>示例：为 Model 编写自定义方法</h3>
<p>因为 <code>Question.objects.all()</code> 的输出 <code>[&lt;Question: Question object&gt;]</code> 是一个没有任何意义的对象标识，我们可以为 Question 类型增一个 <code>__str__</code> 方法。同时可以了解一下如何添加自定义方法。修改之前的 <code>polls/models.py</code> ，在里面加入：</p>
<pre>import datetime
from django.utils import timezone
# …

class Author(models.Model):
# …
def __str__(self):
return self.name

class Question(models.Model):
# ...
def __str__(self):
return self.question_text
def was_published_recently(self): # 判断该 Question 是否为 1 天内添加的自定义方法
return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1)

class Choice(models.Model):
# ...
def __str__(self):
return self.choice_text</pre>
<p>现在再回到交互式 Shell ，测试刚才新增的方法的效果。在 <code>models.py</code> 中对方法的修改并不需要重新迁移生成，就可以马上生效：</p>
<pre>from polls.models import Question, Choice
Question.objects.all() # 此时的输出已经带有描述文字</pre>
<p>当然，如果改动了 <code>models.py</code> 中的数据结构，记得要重新 makemigrations 和 migrate 。</p>
<h3>关联对象常用方法参考</h3>
<p>这些方法常用在含有 ForeignKey 或 ManyToManyField 类的关联对象中。</p>
<ul>
<li><code>add(obj1, obj2, ...)</code> 添加新的关联</li>
<li><code>remove(obj1, obj2, ...)</code> 删除关联</li>
<li><code>clear()</code> 删除所有关联</li>
<li><code>set([obj1, obj2, …])</code> 直接用新的对象组覆盖已有的关联</li>
<li><code>count()</code> 计数子对象数</li>
<li><code>delete()</code> 删除对象</li>
<li><code>create()</code> 新建关联对象并直接引用到数据库（不需要再手动保存）</li>
</ul>
<h3>示例：数据的添加</h3>
<pre>a1 = Author(name="dim”,email="dim@example.com")
a2 = Author(name="ikaros",email="ikaros@example.com")
a1.save()
a2.save()
q.authors.add(a1,a2) # 给 ManyToManyField 添加多个指向
q.authors.all()

q.authors.count()
q.authors.all()[1].delete()
q.authors.all()

q.choice_set.create(choice_text='Not much', votes=0) # 在 Question 下新建一个 Choice
q.choice_set.create(choice_text='The sky', votes=0)
q.choice_set.all()

c = q.choice_set.create(choice_text='Just hacking again', votes=0)
c.question # 从 q.choice_set 新创建的 Choice 已经自动指向了父级 q</pre>
<h3>其他 Model 类型方法参考</h3>
<p>以下是前文未提到的一些对 Model 对象实例进行操作的方法。<a href="https://docs.djangoproject.com/en/1.9/ref/models/instances/" target="_blank">参见</a></p>
<ul>
<li><code>refresh_from_db()</code> 将缓存中该对象的值更新为与数据库相同</li>
<li><code>clean_fields(exclude=None)</code> 验证 Field 有效性</li>
<li><code>clean()</code> 应当由你自行定义，提供验证 Field 是否有效和自动修复（填入数据）的功能</li>
<li><code>full_clean()</code> 调用 clean_fields() 和 clean() 方法（如果有）</li>
<li><code>validate_unique()</code> 类似 clean_fields() ，用于检测重复</li>
<li><code>save(force_insert=True, force_update=True)</code> 启用强制插入或更新</li>
</ul>
<h3>数据的取出、复制和筛选</h3>
<p>针对每个 Models ，都提供了一个称为 objects 的对象管理器 (Manager)。利用 objects 的各种方法，可以方便的进行数据的管理工作。关于筛选对象的条件语句称为 QuerySet 。</p>
<p>涉及到的新方法：</p>
<ul>
<li><code>objects.get()</code> 获取单个对象</li>
<li><code>objects.filter()</code> 获取多个对象</li>
<li><code>exclude()</code> 排除符合条件的对象</li>
<li><code>F()</code> 在条件语句中引用其他属性的值</li>
<li><code>Q()</code> 合并复杂查询</li>
<li><code>update()</code> 批量修改</li>
</ul>
<p>为了方便，再增加一组测试数据，然后尝试示例：</p>
<pre>q2 = Question(question_text=“Try another?”, pub_date=timezone.now())
q2.save()

Question.objects.get(id=1) # 根据 id 获取对象，也可以用其他 Field 的值搜索
q3 = Question.objects.get(pk=1) # 根据主键 (Primary Key) 获取对象，在这里就是 id</pre>
<p>将一个对象副本的唯一标识 (pk, id 等) 删除，再重新存入，此时会自动分配 pk 或 id ，即实现了对象的复制。</p>
<pre>q3.pk = None
q3.save()
q3.pk # 可以看出 id 已经更新</pre>
<p>get() 只能取得一个对象，无匹配或者不止一个匹配时都会报错，而 filter() 可以取得多个匹配。</p>
<pre>from django.utils import timezone
current_year = timezone.now().year
Question.objects.get(pub_date__year=current_year) Question.objects.filter(pub_date__year=current_year)

qlist = Question.objects.filter(question_text__startswith='What')
from datetime import timedelta
qlist2 = qlist.exclude(pub_date__gte=datetime.date.today() + timedelta(days=3))</pre>
<p>对 ManyToManyField 类 Field 指向的对象集，同样可以应用 get() 和 filter() 。举例来说，要获取关联了该 Question 对象的全部 Choice 对象，只需要加上一个 _set 后缀：</p>
<pre>q.choice_set.filter(choice_text__startswith='Just hacking')</pre>
<p>至于 F() 和 Q() ，使用时需要额外引用其所在的模块。</p>
<pre>from django.db.models import F
Author.objects.filter(email__startswith=F('name'))

from django.db.models import Q
Question.objects.filter(Q(question_text__startswith='What'),Q(pub_date__lt=date(2011, 11, 11)) | Q(pub_date__gte=date(2012, 3, 4)))

Author.objects.all().update(email="admin@example.com")
Author.objects.all().update(email=F('name'))</pre>
<h3>QuerySet 条件语句参考</h3>
<p>这里是在括号中使用的一些常用条件语句后缀，在这些条件语句中，利用双下划线区分层级来描述最终的指向，比如连接 Model 和 Field 的名称，最后再加上双下划线以及条件后缀。具体可以参考上方的示例。</p>
<ul>
<li><code>__excat</code> 精确等于，如果是字符则大小写也要相同</li>
<li><code>__contains</code> 内容包含</li>
<li><code>__startswith, __endswith</code> 开始于，结尾于</li>
<li><code>__iexact, __istartswith, __endswith</code> 不精确等于， 不开始于，不结尾于</li>
<li><code>__gt, __gte, __lt, __lte</code> 大于，大于等于，小于，小于等于</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/django-note-3/">Django 学习手记 三 数据操作的常用方法</a></p>]]></content>
        
        <summary type="html">
            
            上一篇中，我们已经建立了基本的 Model 数据模型，并且熟悉了关于数据结构的存取、更新操作。本篇中主要介绍了对 Model 数据进行操作的常用方法，包含有许多示例 参见 ，亲自操作一下就很容易明白。 为了方便，我们可以通过 Python 在终端提供的交互式 Shell 来尝试
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Django"/>
        
        <category term="Django 学习手记"/>
        
        <category term="MVC"/>
        
        <category term="Python"/>
        
        <category term="SQL"/>
        
        <category term="Web"/>
        
        <category term="编程"/>
        
    </entry>
    
    <entry>
        <title>足兆叉虫的2015</title>
        <link href="https://binux.blog/2015/12/uk2/"/>
        <id>https://binux.blog/2015/12/uk2/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>我是从来不记日子的，这导致我也不知道有些事情是2015年发生的，还是2014年发生的，亦或只是我的臆想。即便如此，2015年也是变化的一年。</p><p>跳槽，工资没涨…… 到这里居然和2013年是一样的，但是当我在2015写下这篇日志的时候，国内已经2016。</p><p>说来惭愧，这一年除了一月写了几篇教程之后，不但 blog 落下了，开源也没有做多少。看着 pyspider 的 star 数蹭蹭涨到 5813，但是并没有太多精力去更新。希望在 2016 年能有时间把 slime 模式的坑填了吧。</p><p>其他的项目也就在年末的时候又重新玩了一把 WebRTC，基于的 <a href="https://webtorrent.io" target="_blank">WebTorrent</a> 经过一年的开发，已经成熟了很多，feross 在 javascript 上从 tracker 到 BT 协议都实现了一遍，比起我那时山寨的好了非常多，虽然 hybrid 模式还有很多问题。。。对了 2015 年参与过 technical review 的 <a href="https://www.packtpub.com/web-development/learning-webrtc" target="_blank">Learning WebRTC</a> 也出版了，算是一次挺有趣的经历吧。</p><p>8月到英国之后，就是各种适应，加上新公司的蜜月期，一门心思放在了公司的项目上。在新公司才算是第一次接触到了机器学习，给我带来了很多新的思路，有种能成的感觉吧。</p><p>希望2016年能更有趣吧。</p><h2><a href="https://binux.blog/2015/12/uk2/#英国（二）"></a>英国（二）</h2><p>然后说一些「关于英国生活」类似的东西吧，想到什么写什么</p><h3><a href="https://binux.blog/2015/12/uk2/#衣食住行"></a>衣食住行</h3><ul><li>夏天不热，这个冬天不冷</li><li>冬天是雨季，几乎一半时间在下雨，但是从来没有在上下班的时候下</li><li>英国不负「难吃国」之名，只要是英文店名的地方，那真是难吃 + 贵</li><li>中午的饭点是1-2点，晚餐饭点是8-9点</li><li>一个很大问题是，看菜单很多时候不知道是什么东西，查字典也没用</li><li>一盒 200g 的毛豆都要卖20-30RMB，而且还被他们视为高贵的健康食品</li><li>有很多中国人开的中餐馆和日式便当，这是唯一能吃的东西（除了 KFC）</li><li>超市的肉类品种和部位很不同，炒出来很老，我用了3个月才想出来怎么吃</li><li>鸡翅鸡腿比鸡胸便宜，只要10RMB/斤</li><li>肉比蔬菜便宜</li><li>住非常贵，北京的7-8倍</li><li>行非常贵，北京的5-10倍</li><li>伦敦很小，和北京比起来</li></ul><h3><a href="https://binux.blog/2015/12/uk2/#公司"></a>公司</h3><ul><li>公司现在有40+个人，但是有15种国籍，22+种语言</li><li>有4个华裔同事，但是任意两者之间只能用英语交流（除英语外会的语言分别是普通话，粤语，日语，马来语，德语）</li><li>没有印度人</li><li>一年25天年假，8天法定假日，没有年终奖</li><li>不加班的主要原因是没有晚餐，肚子饿</li><li>公司以外听不懂别人说什么 =_=</li></ul>]]></content>
        
        <summary type="html">
            
            我是从来不记日子的，这导致我也不知道有些事情是2015年发生的，还是2014年发生的，亦或只是我的臆想。即便如此，2015年也是变化的一年。跳槽，工资没涨…… 到这里居然和2013年是一样的，但是当我在2015写下这篇日志的时候，国内已经2016。说来惭愧，这一年除了一月写了几
            
        </summary>
        
    </entry>
    
    <entry>
        <title>学术讲座通知​：城市计算与大数据</title>
        <link href="http://www.pris.net.cn/archives/2881"/>
        <id>http://www.pris.net.cn/archives/2881</id>
        
        <author>
            <name>马 占宇</name>
        </author>
        
        <published>2015-11-05T18:03:44+00:00</published>
        <updated>2015-11-05T18:03:44+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>讲座题目：城市计算与大数据</strong></p>
<p><strong>主讲人：郑宇博士（微软亚洲研究院主管研究员）</strong></p>
<p><strong>主持人：马占宇副教授</strong></p>
<p><strong>时间：2015</strong><strong>年11</strong><strong>月11</strong><strong>日(</strong><strong>周三)14:30~16</strong><strong>：00</strong></p>
<p><strong>地点：教三楼811</strong><strong>学术报告厅</strong></p>
<p><strong>摘要：</strong>城市计算是计算机科学以城市为背景，跟城市规划、交通、能源、环境、社会学和经济等学科融合的新兴领域。城市计算通过不断获取、整合和分析城市中不同领域的大数据来解决城市所面临的挑战。本报告将概述城市计算的定义、框架和主要研究问题，以典型应用为案例着重介绍大数据中跨域数据的融合和协同计算技术。具体案例包括基于大数据的细粒度空气质量分析和预测、城市油耗和汽车尾气排放评估，以及城市住房价值分级和评估等。相关技术发表在KDD等顶尖国际会议和期刊上，并在实际系统中部署应用。更多细节请看http://research.microsoft.com/en-us/projects/urbancomputing/default.aspx。</p>
<p> </p>
<p> </p>
<p> </p>
<p><strong>校学术委员会</strong></p>
<p>信通院</p>
<p>2015年11月4日</p>]]></content>
        
        <summary type="html">
            
            讲座题目：城市计算与大数据 主讲人：郑宇博士（微软亚洲研究院主管研究员） 主持人：马占宇副教授 时间：2015年11月11日(周三)14:30~16：00 地点：教三楼811学术报告厅 摘要：城市计算是计算机科学以城市为背景，跟城市规划、交通、能源、环境、社会学和经济等学科融合
            
        </summary>
        
        <category term="PRIS快讯"/>
        
        <category term="学术快讯"/>
        
    </entry>
    
    <entry>
        <title>学术报告: Complete Dictionary Recovery over the Sphere</title>
        <link href="http://www.pris.net.cn/archives/2826"/>
        <id>http://www.pris.net.cn/archives/2826</id>
        
        <author>
            <name>李春光 (Chun-Guang LI)</name>
        </author>
        
        <published>2015-08-30T14:25:52+00:00</published>
        <updated>2015-08-30T14:25:52+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>报告题目</strong>： <strong>Complete Dictionary Recovery over the Sphere</strong><br />
<strong>报告人</strong>：Dr.<a href="http://sunju.org/"><strong>Ju Sun</strong></a>, Electrical Engineering, Columbia University<br />
<strong>主持人</strong>: 北邮模式识别实验室 李春光<br />
<strong>时间</strong>：2015年9月2日 15:00-16:30<br />
<strong>地点</strong>：教三810会议室</p>
<p>报告摘要：We consider the problem of recovering a complete (i.e., square and invertible) matrix $A_0$, from $Y \in R^{n\times p} with $Y = A_0X_0$, provided $X_0$ is sufficiently sparse. This recovery problem is central to the theoretical understanding of dictionary learning, which seeks a sparse representation for a collection of input signals, and finds numerous applications in modern signal processing and machine learning. We give the first efficient algorithm that provably recovers $A_0$ when $X_0$ has $O (n)$ nonzeros per column, under suitable probability model for $X_0$. In contrast, prior results based on efficient algorithms provide recovery guarantees when $X_0$ has only $O (pn)$ nonzeros per column. Our algorithmic pipeline centers around solving a certain nonconvex optimization problem with a spherical constraint, and hence is naturally phrased in the language of manifold optimization. To show this apparently hard problem is tractable, we first provide a geometric characterization of the high-dimensional objective landscape, which shows that with high probability there are no “spurious” local minima. This particular geometric structure allows us to design a Riemannian trust region algorithm over the sphere that provably converges to one local minimizer with an arbitrary initialization, despite the presence of saddle points. The geometric approach we develop here may also shed light on other problems arising from nonconvex recovery of structured signals.</p>
<p>报告人简介：Ju Sun is now a five year PhD candidate (Advisor: Prof. John Wright) in the Department of Electrical Engineering, Columbia University in the City of New York. He works at the intersection of computer vision, machine learning, numerical optimization, signal/image processing, information theory, and compressive sensing, focusing on modeling, harnessing, and computing with structures in massive data, with provable guarantees and practical algorithms. His paper “Complete Dictionary Recovery over the Sphere” has recently received the best student paper award from SPARS 2015, which was held in Cambridge University.</p>
<p><a href="http://www.columbia.edu/~js4038/">详细信息请参阅</a><br />
http://www.columbia.edu/~js4038/<br />
http://sunju.org/</p>
<p>欢迎各位老师和同学积极参加!</p>]]></content>
        
        <summary type="html">
            
            报告题目： Complete Dictionary Recovery over the Sphere 报告人：Dr.Ju Sun, Electrical Engineering, Columbia University 主持人: 北邮模式识别实验室 李春光 时间：2015年9月
            
        </summary>
        
        <category term="PRIS快讯"/>
        
    </entry>
    
    <entry>
        <title>英国</title>
        <link href="https://binux.blog/2015/07/uk/"/>
        <id>https://binux.blog/2015/07/uk/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>半年没有更新 blog 了，<del>其实我在憋(wan)个(W)大(O)招(W)</del>。一年半以前，我说过<a href="http://blog.binux.me/2013/12/2013/" target="_blank">「想学日语，想出国」</a>，虽然这一年半也是没有干劲地随随便便过的，但是至少出国了。</p><p>目的地英国，工作，8月初。</p><p>要说经历，其实简单到爆。</p><ol><li>投简历（依旧是只投一家）</li><li>视频面试（用我8年没用过的蹩脚英语）</li><li>考雅思（而且只要4分，我只做了套剑9就去了）</li><li>对方办 <a href="https://www.gov.uk/tier-2-general/eligibility" target="_blank">certificates of sponsorship</a>（虽然每月有名额限制，按照打分排，但是以往的数据，只要满足条件，名额都够。）</li><li>办签证（不像旅游签证，不用行程单，不用资产证明，有 COS 就 ok）</li><li>买机票</li><li>over</li></ol><p>工资没涨，物价大涨，难吃，加上烂英语，瞬间感觉生活甚是艰辛。。。不过， there is always a way，就当作一次挑战吧。</p><p>就酱</p>]]></content>
        
        <summary type="html">
            
            半年没有更新 blog 了，其实我在憋(wan)个(W)大(O)招(W)。一年半以前，我说过「想学日语，想出国」，虽然这一年半也是没有干劲地随随便便过的，但是至少出国了。目的地英国，工作，8月初。要说经历，其实简单到爆。投简历（依旧是只投一家）视频面试（用我8年没用过的蹩脚英语
            
        </summary>
        
    </entry>
    
    <entry>
        <title>图像识别技术其智能应用</title>
        <link href="http://www.pris.net.cn/archives/2774"/>
        <id>http://www.pris.net.cn/archives/2774</id>
        
        <author>
            <name>马 占宇</name>
        </author>
        
        <published>2015-06-23T12:55:06+00:00</published>
        <updated>2015-06-23T12:55:06+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>主讲人：</strong><strong><a href="http://www.jdl.ac.cn/user/sqjiang/">蒋树强</a>，中科院计算所研究员，博士生导师</strong></p>
<p><strong>时间：</strong><strong>2015</strong><strong>年</strong><strong>7</strong><strong>月</strong><strong>1</strong><strong>日（周三）下午</strong><strong>14:00-16:00</strong></p>
<p><strong>地点：教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>主持人：<a href="www.pris.net.cn/introduction/teacher/zhanyu">马占宇</a>  副教授 北邮模式识别实验室</strong></p>
<p><strong>内容摘要：</strong></p>
<p>自动图像识别是计算机视觉和多媒体领域的重要研究目标之一，具有广阔的应用前景。由于受到一义多图、一图多物、一物多态、异物相似等多重因素的影响，图像识别技术仍存在许多悬而未决的问题，距实际应用仍有很大差距；如何面向具体应用建立图像的高效表示和分类方法、实现图像的准确识别是一项值得研究的课题。本报告将从纯视觉信息的图像识别和基于上下文信息的图像识别两个角度进行技术介绍，包括实例级物体识别、场景识别、基于地理上下文的图像识别和基于RGB-D的手持物体识别，这些技术可以分别应用在手机图像识别和面向机器人的视觉交互等。报告最后对应用前景进行展望并进行技术演示。</p>
<p><strong>主讲人简介：</strong></p>
<p>蒋树强，中科院计算所研究员，博士生导师，IEEE Senior Member，研究方向为图像/视频等多媒体信息的分析、理解与检索技术，共在国内外刊物和会议上发表论文100多篇，获授权专利10项，部分技术被应用于多个实际系统中，获得2008年度北京市科技新星计划支持，2012年度中国科学院卢嘉锡青年人才奖，2012年度中国计算机学会科学技术奖（排名第二），2013年度中国科学院青年科学家国际合作奖，获2013年度国家自然科学基金优秀青年科学基金支持。</p>]]></content>
        
        <summary type="html">
            
            主讲人：蒋树强，中科院计算所研究员，博士生导师 时间：2015年7月1日（周三）下午14:00-16:00 地点：教三楼811会议室 主持人：马占宇  副教授 北邮模式识别实验室 内容摘要： 自动图像识别是计算机视觉和多媒体领域的重要研究目标之一，具有广阔的应用前景。由于受到一
            
        </summary>
        
        <category term="PRIS快讯"/>
        
        <category term="学术快讯"/>
        
    </entry>
    
    <entry>
        <title>学术讲座通知：Deep models for face processing with “big” or “small” data</title>
        <link href="http://www.pris.net.cn/archives/2759"/>
        <id>http://www.pris.net.cn/archives/2759</id>
        
        <author>
            <name>马 占宇</name>
        </author>
        
        <published>2015-06-09T09:12:22+00:00</published>
        <updated>2015-06-09T09:12:22+00:00</updated>
        
        <content type="html"><![CDATA[<p><strong>主讲人：</strong><strong><a href="http://www.jdl.ac.cn/user/sgshan/">山世光</a>，中国科学院计算技术研究所研究员，中科院智能信息处理重点实验室常务副主任</strong></p>
<p><strong>时间：</strong><strong>2015</strong><strong>年</strong><strong>6</strong><strong>月</strong><strong>18</strong><strong>日（周四）上午</strong><strong>9:00-11:00</strong></p>
<p><strong>地点：教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>主持人：<a href="www.pris.net.cn/introduction/teacher/zhanyu">马占宇</a>  副教授 北邮模式识别实验室</strong></p>
<p><strong>内容摘要：</strong></p>
<p>Deep learning models, especially CNN, has been successfully applied to face recognition, especially under the evaluation protocol of Labeled Faces in the Wild (LFW), when big face data is available. In this talk, except showing some recent results of CNN feature for video-based face processing (our FG’15 paper), I will also show that alternative deep models such as Auto-Encoder can also benefit face recognition impressively, especially for face alignment (our ECCV14 paper) and pose normalization (our CVPR14 paper) purpose. Both works might imply in case of “small” data, elaborate deep models can also work well for many computer vision tasks.</p>
<p><strong>主讲人简介：</strong></p>
<p>山世光，中国科学院计算技术研究所研究员、博士生导师，中科院智能信息处理重点实验室常务副主任。主要从事图像处理与理解、计算机视觉、模式识别、智能人机交互界面等相关研究工作。已在国际/国内期刊、国际会议上发表/录用学术论文200余篇，其中CCF A类国际会议和期刊论文40余篇。论文曾获CCF A类国际会议CVPR2008大会颁发的Best Student Poster Award Runner-up奖。所发表论文被国内外同行引用6800余次（Google Scholar），领导课题组完成的人脸识别系统多次获得国内外人脸识别竞赛第一名。应邀担任CCF-A类国际刊物IEEE Trans. on Image Processing以及Neurocomputing ，EURASIP Journal of Image and Video Processing, Frontier of Computer Science, 《计算机研究与发展》等期刊的编委(Associate Editor)，应邀担任过ICCV2011, ICPR2012, ACCV2012, FG2013, ICASSP2014和ICPR2014等相关领域重要国际会议的Area Chair（领域主席）。所完成的人脸识别研究成果2005年度国家科技进步二等奖（第3完成人）。他是2012年度国家自然科学基金委员会首届“优青”获得者。</p>
<p><span><em><strong>该讲座为北京邮电大学60周年校庆系列讲座之一。</strong></em></span></p>]]></content>
        
        <summary type="html">
            
            主讲人：山世光，中国科学院计算技术研究所研究员，中科院智能信息处理重点实验室常务副主任 时间：2015年6月18日（周四）上午9:00-11:00 地点：教三楼811会议室 主持人：马占宇  副教授 北邮模式识别实验室 内容摘要： Deep learning models, e
            
        </summary>
        
        <category term="PRIS快讯"/>
        
        <category term="学术快讯"/>
        
    </entry>
    
    <entry>
        <title>HTML Head Generator – 纯 CSS 实现的头部元标签代码生成器</title>
        <link href="http://blog.dimpurr.com/head-generator/"/>
        <id>http://blog.dimpurr.com/head-generator/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-05-30T12:09:23+00:00</published>
        <updated>2015-05-30T12:09:23+00:00</updated>
        
        <content type="html"><![CDATA[<p>前段时间突发奇想，捣鼓出了这个纯 CSS 选择器实现的在线 HTML &lt;head&gt; Meta 标签生成器，以解决每次要写 HTML 头都得去找个之前的文档复制，还得琢磨半天需要哪些的麻烦。没有到用一行 JavaScript ，基本原理是 CSS 3 的 + 紧邻选择器和 ~ 同级后继选择器。前端攻城狮们可以用短链接 <a href="http://find.moe/headgen" target="_blank">http://find.moe/headgen</a> 快速访问，也可以拖到收藏夹备用。</p>
<p>感谢 <a href="http://dring.cc/" target="_blank">电灵</a> 酱对最终样式的建议。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/05/headgen.png"><img src="http://img1.dimpurr.com/dimblog/2015/05/headgen-600x363.png" /></a><p>Dimpurr’s Head Tag Generator</p></div>
<p>写的时候感觉槽点一大堆，过了一周什么都忘了 …… 简单说明一下实现的要点吧。如果有更好的实现思路或觉得有可以改进的地方敬请指教，不过，前提是无 JavaScript 。</p>
<p><span></span></p>
<p>首先是要在无 JavaScript 的情况下，实现左侧的多选和单选按钮效果。尝试了几种隐藏复选框的方案之后，最后实现的原理是这样的：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/05/2015-05-30-下午7.49.51.png"><img src="http://img1.dimpurr.com/dimblog/2015/05/2015-05-30-下午7.49.51-600x202.png" /></a><p>Checkbox + Span</p></div>
<p>修改 <code>&lt;input type="checkbox" /&gt;</code> 和 <code>&lt;input type="radio" /&gt;</code> 的尺寸和边距，使之和后继 Span 模拟的按钮完全重合，并设置透明度 <code>opcatiy: 0</code> 。当复选框或多选框选中之后，使用伪类控制 Span 的样式变化：<code>.check:checked + span { ... }</code></p>
<p>同样，在代码生成部分，预先存储好生成器可能用到的代码并设置 <code>display: none</code> 。最后为每组标签的选择框和对应代码设置相同样式，然后设置当选中时显示： <code>.xxx:checked ~ .code .xxx { display: block; }</code></p>
<p>当然，这就会需要一长串不同的类名，可能会导致极其难以维护的 HTML 代码。一般可以用 LESS 之类的解决方案，不过我最后是把数据部分抽出写了个蹩脚的 Python 脚本来生成文档结构。</p>
<p>另外，我尽可能的收集了大部分常用的 Head 标签，如果鼠标悬浮在按钮上还可以看到我三脚猫英文的注释。有什么要补充的话可以回复我，或者去我的 Github Repo 里找源码。</p>
<h3>参考来源</h3>
<ul>
<li><a href="http://fex.baidu.com/blog/2014/10/html-head-tags/" target="_blank">HTML head 头标签 – FEX</a></li>
<li><a href="https://github.com/yisibl/blog/issues/1" target="_blank">常用的 HTML 头部标签 · Issue #1 · yisibl/blog</a></li>
<li><a href="http://code.lancepollard.com/complete-list-of-html-meta-tags/" target="_blank">Complete List of HTML Meta Tags | Lance Pollard</a></li>
<li><a href="http://iblogc.com/2015/05/06/UC和QQ浏览器私有META/" target="_blank">UC&amp;QQ浏览器私有META | Korvin’s blog</a></li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/head-generator/">HTML Head Generator – 纯 CSS 实现的头部元标签代码生成器</a></p>]]></content>
        
        <summary type="html">
            
            前段时间突发奇想，捣鼓出了这个纯 CSS 选择器实现的在线 HTML &amp;lt;head&amp;gt; Meta 标签生成器，以解决每次要写 HTML 头都得去找个之前的文档复制，还得琢磨半天需要哪些的麻烦。没有到用一行 JavaScript ，基本原理是 CSS 3 的 + 紧邻选择
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS3"/>
        
        <category term="HTML"/>
        
        <category term="Python"/>
        
        <category term="代码"/>
        
        <category term="前端"/>
        
    </entry>
    
    <entry>
        <title>Slackview – 多级响应式 WordPress 主题</title>
        <link href="http://blog.dimpurr.com/slackview/"/>
        <id>http://blog.dimpurr.com/slackview/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-05-30T10:46:21+00:00</published>
        <updated>2015-05-30T10:46:21+00:00</updated>
        
        <content type="html"><![CDATA[<p>Slackview 是一个黑色扁平大气风格、 HTML5 多级响应式三栏布局的 WordPress 主题。她是 <a href="http://blog.dimpurr.com/clearision/" target="_blank">Clearision</a> 的姐妹主题，也将是我的第二款长期自用主题。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/05/screenshot.png"><img src="http://img1.dimpurr.com/dimblog/2015/05/screenshot-600x417.png" /></a><p>Slackview</p></div>
<p><span></span></p>
<h3>功能特点</h3>
<ul>
<li>宽屏、平板、移动三级响应式布局</li>
<li>站点头图和文章特色图片支持</li>
</ul>
<h3>获取主题</h3>
<ul>
<li>演示 <a href="http://work.dimpurr.com/demo/wp/slackview/" target="_blank">Slackview Demo Site</a></li>
<li>下载 <a href="https://github.com/dimpurr/Slackview/releases/" target="_blank">Github Release</a></li>
</ul>
<h3>使用说明</h3>
<ul>
<li>记得将 <code>img/background.png</code> 替换为你的站点头图</li>
<li>侧边栏的最后一个 Widget 将会自动应用 Sticky 滚动粘连效果</li>
<li>支持多级导航菜单</li>
<li>正文中 <code>&lt;pre&gt;</code> 为多行代码， <code>&lt;code&gt;</code> 为行内代码</li>
<li>没有后台设置，功能扩展请用插件解决</li>
<li>评论区居中的设计将保留，不满意请自行修改</li>
</ul>
<h3>截图预览</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2015/05/article.png"><img src="http://img1.dimpurr.com/dimblog/2015/05/article-600x337.png" /></a><p>Slackview Article</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2015/05/mobile.png"><img src="http://img1.dimpurr.com/dimblog/2015/05/mobile-600x881.png" /></a><p>Slackview Mobile</p></div>
<p> </p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/slackview/">Slackview – 多级响应式 WordPress 主题</a></p>]]></content>
        
        <summary type="html">
            
            Slackview 是一个黑色扁平大气风格、 HTML5 多级响应式三栏布局的 WordPress 主题。她是 Clearision 的姐妹主题，也将是我的第二款长期自用主题。 Slackview  功能特点  宽屏、平板、移动三级响应式布局 站点头图和文章特色图片支持  获取
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Clearision"/>
        
        <category term="Slackview"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>Django 学习手记 二 建立模型层</title>
        <link href="http://blog.dimpurr.com/django-note-2/"/>
        <id>http://blog.dimpurr.com/django-note-2/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-04-11T16:56:56+00:00</published>
        <updated>2015-04-11T16:56:56+00:00</updated>
        
        <content type="html"><![CDATA[<p>这篇文章记录了如何创建 Django 项目的一个子应用并编写 models.py 。如有错误，请不吝赐教。</p>
<p>Django 框架同样遵循 MVC 开发模式。在 Django 中，我们定义 Model 数据模型并自动同步生成数据库和后台，由 Template 和 Views 处理界面并转交 URLconf 控制器。</p>
<p>因为 MVC 中 C (Controller) 的部分主要交给框架进行，我们也将 Django 称为 MTV (Model, Template, Views) 模式。 <a href="http://djangobook.py3k.cn/2.0/chapter05/#cn19" target="_blank">参见</a></p>
<p>一个 Django 项目有两种层级，称为 project 项目 和 app 应用。一般来说，一个 project 就是一个完整的站点，比如一个大型论坛或者门户站点。而一个 app 就是一个有完整功能、可复用的应用，比如一个私信组件，一个投票组件或者一个讨论版。</p>
<p>一个 project 即使没有 app 也能独立运行，但是一个独立的 app 可以在不同的 project 中复用。另外，如果你要使用 Django 的模型功能即数据库层，模型必须存放在 app 中。</p>
<h3>创建应用并建立模型</h3>
<p>执行 <code>./manage.py startapp polls</code> 命令，来创建一个名为 polls 的 app 。同样， Django 会自动在项目根目录下创建一个名为 polls 的目录和一系列文件。我们会以 Django 官方教程为例，先编写一个投票应用。</p>
<p>在这个应用中，我们需要 Quesntion 问题和 Choice 选项两个类，并且添加一系列的属性。</p>
<p>首先，我们编辑 <code>polls/models.py</code> ，这个文件就是你的模型：</p>
<p><span></span></p>
<pre>from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
    authors = models.ManyToManyField(Author)

        # class Meta:
        # date = ["pub_date"]
        # text_filed_name = “question”

class Choice(models.Model):
    question = models.ForeignKey(Question)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)</pre>
<p>代码很容易理解。为 <code>question_text</code> 这样的属性名提供一个易读的名字会方便接下来的开发。</p>
<p>对于一个类，提供一个名为 Meta 的内嵌类，可以存放一些「不是 Field」的 Field ，比如排序信息，数据库名。<a href="https://docs.djangoproject.com/en/1.8/ref/models/options/" target="_blank">详见</a></p>
<h3>应用更改</h3>
<p>编辑完成后，我们修改 project 根目录的 <code>settings.py</code> ，找到 INSTALLED_APPS ，在已安装应用列表的底部加上我们自己的新 app <code>'polls'</code> 。这里也列出了其他的自带 app ，如果用不着，可以注释掉。</p>
<p>运行 <code>./manage.py makemigrations polls</code> 以生成更改。这个命令同时会生成类似 <code>polls/migrations/0001_initial.py</code> 的脚本文件，它们是人类可读的，但是一般你不需要太过在意。使用 <code>./manage.py sqlmigrate polls 0001</code> 命令可以查看生成的数据库命令。</p>
<p>最后使用 <code>./manage.py migrate</code> 迁移命令，应用更改到数据库。</p>
<p>下篇文章将会介绍如何使用 <code>./manage.py shell</code> 测试当前的数据模型、以及关于元素间互相绑定和关联的详情。<a href="https://docs.djangoproject.com/en/1.8/topics/db/models/#relationships" target="_blank">元素绑定详见</a></p>
<h3>Field 类型参考</h3>
<p>下面是一些常用的 Field 类型和部分特有的参数。</p>
<ul>
<li><code>ForeignKey(Class_Name, limit_choices_to={‘key_name’: value}, on_delete=models.SET_NULL)</code>
<ul>
<li>绑定一个其他类的元素(类名、可以是 ‘self’, 对于目标的属性的限制条件，关联目标被删除时的操作)</li>
<li>一般会生成一个下拉列表</li>
</ul>
</li>
<li><code>ManyToManyField</code> # 多对多关联，用法同上</li>
<li><code>OneToOneField</code> # 单对单关联，用法同上</li>
<li><code>CharField(max_length = 100)</code> # 字符</li>
<li><code>TextField(max_length = 100)</code> # 字符</li>
<li></li>
<li><code>SlugField</code> # 为 CMS 预留的别名栏，用法同上</li>
<li><code>DateField(auto_now/auto_now_add)</code></li>
<li>
<ul>
<li>日期 (自动设为最后编辑日期/自动设为首次创建日期)</li>
</ul>
</li>
<li><code>TimeField</code> # 时间</li>
<li><code>DateTimeField</code> # 日期和时间，参数同上</li>
<li><code>IntegerField</code> # 实数</li>
<li><code>BigIntegerField</code> # 大实数</li>
<li><code>FloatField</code> # 浮点数</li>
<li><code>BooleanField</code> # True or False 单选</li>
<li><code>EmailField</code> # 邮件</li>
<li><code>IPAddressField</code> # IP 地址</li>
<li><code>GenericIPAddressField(protocol=ipv4, unpack_ipv4=False)</code>
<ul>
<li>自动获得 IP 地址(协议限制，解包去掉 ::ffff: 前缀)</li>
</ul>
</li>
<li><code>URLField</code> # URL 地址</li>
<li><code>FileField(upload_to = ‘photos/%Y/%m/%d’ )</code>
<ul>
<li>文件(相对于 MEDIA_ROOT 设置的媒体路径的子目录，支持解析日期)</li>
<li><a href="https://docs.djangoproject.com/en/1.8/topics/files/" target="_blank">文件系统参见</a></li>
<li><a href="https://docs.djangoproject.com/en/1.8/ref/models/fields/#filefield-and-fieldfile" target="_blank">文件 Field 的调用方法参见</a></li>
</ul>
</li>
<li><code>ImageField</code>
<ul>
<li>图片，参数同上，可以通过 height_field 和 width_field 熟悉拿到宽高</li>
</ul>
</li>
<li><code>FilePathField(path="/home/images", match=“*.png”, recursive=True, allow_files = True, allow_folders = False)</code>
<ul>
<li>文件路径(起始路径，正则匹配，包含子目录，允许选择文件，允许选择目录)</li>
</ul>
</li>
</ul>
<h3>Field 参数参考</h3>
<p>以下是一些其他常用的通用参数。</p>
<ul>
<li><code>blank = true</code> # 该属性可为空</li>
<li><code>null = Ture</code> # 该属性可为 null</li>
<li><code>choices = a_list_or_a_tuple</code> # 该属性从一个列表中选择，值的具体写法见列表结束</li>
<li><code>default = 'A default value'</code> # 设置默认值</li>
<li>validators = [validate_even] # 设置数据有效性验证器 <a href="https://docs.djangoproject.com/en/1.8/ref/validators/" target="_blank">详见</a></li>
</ul>
<p>使用如下形式的，最终的每个元素是 (‘option value’, ‘option name’) 形式的元组的多层嵌套元组，可以定义一个任意层级的可选列表。最终将会在 HTML 中生成多个 select 下拉列表的形式。第一项是 None 的元组会被作为默认选项。<a href="https://docs.djangoproject.com/en/1.8/ref/models/fields/#choices">详见</a></p>
<pre>MEDIA_CHOICES = (
    ( None, 'Unknown' ),
    ( 'Audio', ( ('vinyl', 'Vinyl'), ('cd', 'CD'), ) ),
    ( 'Video', ( ('vhs', 'VHS Tape'), ('dvd', 'DVD'), ) ),
)</pre>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/django-note-2/">Django 学习手记 二 建立模型层</a></p>]]></content>
        
        <summary type="html">
            
            这篇文章记录了如何创建 Django 项目的一个子应用并编写 models.py 。如有错误，请不吝赐教。 Django 框架同样遵循 MVC 开发模式。在 Django 中，我们定义 Model 数据模型并自动同步生成数据库和后台，由 Template 和 Views 处理界
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Django"/>
        
        <category term="Django 学习手记"/>
        
        <category term="MVC"/>
        
        <category term="Python"/>
        
        <category term="Web"/>
        
        <category term="编程"/>
        
    </entry>
    
    <entry>
        <title>Django 学习手记 一 安装和配置</title>
        <link href="http://blog.dimpurr.com/django-note-1/"/>
        <id>http://blog.dimpurr.com/django-note-1/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-04-11T14:35:55+00:00</published>
        <updated>2015-04-11T14:35:55+00:00</updated>
        
        <content type="html"><![CDATA[<p>Django 是一款知名的 Python Web 框架，最初为 CMS 设计，现在已经发展成为了一个能快速根据抽象数据模型生成和维护数据库、后台、和模版系统，同时自带用户系统、地址重写等大量实用功能的大型框架。</p>
<p>本文为个人在 Django 学习中的一些心得体会，主要是官方教程和参考文档的一些整理和归纳，并非完全依照原教程翻译而来，因此如有错误，请不吝赐教。</p>
<p>由于本文力求语言精简、参考方便，因此很多较为基础的内容，并没有特别详细的进行解释。不过在容易混淆的部分，大部分都提供了有对应的详细解释说明的「参见」链接，应当注意。</p>
<h3>参考资料</h3>
<ul>
<li>官方文档 <a href="https://docs.djangoproject.com/en/" target="_blank">https://docs.djangoproject.com/en/</a></li>
<li>The Django Book (Chinese) <a href="http://djangobook.py3k.cn/2.0/" target="_blank">http://djangobook.py3k.cn/2.0/</a></li>
</ul>
<h3>安装 Django</h3>
<p>首先，安装 Python 的包管理器 <a href="http://pip.pypa.io" target="_blank">pip</a> 。首先尝试使用 Python 自带的 easy_install 模块安装：</p>
<p><span></span></p>
<pre>easy_install pip</pre>
<p>如果成功就没问题了。如果无法使用 easy_install ，使用以下方式安装：</p>
<pre>wget https://bootstrap.pypa.io/get-pip.py
sudo python get-pip.py</pre>
<p>完成之后，编辑配置文件，如果没有可以新建一个，换用豆瓣源加速下载： <code>~/.pip/pip.conf</code></p>
<pre>[global]
index-url = http://pypi.douban.com/simple/</pre>
<p>现在可以使用 PiP 安装 Django 了。安装成功后，查看 Django 版本号。</p>
<pre>sudo pip install django
python -c "import django; print(django.get_version())"</pre>
<h3>开始项目</h3>
<p>在打算存放项目文件的位置使用一下命令， testsite 是站点的名字。随后， Django 会自动创建一个同名文件夹和一些必要文件。出于权限控制合安全考虑，不建议存放在类似 <code>/var/www</code> 的网站目录下，实际上， Django 项目可以运行在任何位置。</p>
<pre>django-admin.py startproject testsite</pre>
<p>编辑文件夹内的 <code>settings.py</code> ，修改语言和时区设置。</p>
<pre>LANGUAGE_CODE = 'zh-cn'
TIME_ZONE = 'Asia/Shanghai'</pre>
<p>然后进行数据库设置。</p>
<p>默认的设置是 Python 自带的 SQLite3 ，简单易用、单文件存储，你可以修改 <code>'NAME': os.path.join(BASE_DIR, 'db.sqlite3')</code> 后面的 db.sqlite3 为自己想要的相对项目根目录的路径和数据库文件名。下面是一份其他数据库的示例。</p>
<pre>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': ‘数据库名’,
        'USER': ‘数据库用户’,
        'PASSWORD': ‘数据库密码’,
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}</pre>
<p>如果想使用其他的数据库，可以尝试把 <code>'ENGINE'</code> 的值改为以下 Django 自带支持的数据库包。如果打算使用的数据库不包含在下列列表中，可以尝试直接填写该数据 Python 包的全名。<a href="https://docs.djangoproject.com/en/1.7/ref/settings/#std:setting-DATABASE-ENGINE" target="_blank">详见</a></p>
<ul>
<li><code>django.db.backends.postgresql_psycopg2</code></li>
<li><code>django.db.backends.mysql</code></li>
<li><code>django.db.backends.sqlite3</code></li>
<li><code>django.db.backends.oracle</code></li>
</ul>
<p>如果你使用的是 SQLite3 以外的数据库，运行 <code>./manage.py shell</code> 进入 Django 环境的测试用交互式 Shell ，使用以下命令进行测试连接。如果没有报错信息说明链接成功。</p>
<pre>&gt;&gt;&gt; from django.db import connection
&gt;&gt;&gt; cursor = connection.cursor()</pre>
<p>配置完成后，执行 <code>./manage.py migrate</code> ，首次创建项目数据库。我们姑且将这个命令称为「迁移」。在较老版本的教程中这一步会执行 syncdb ，实际上 migrate 这个命令原本来自一个叫 <a href="http://south.aeracode.org/" target="_blank">South</a> 的插件，在 Django 1.7 以上<a href="https://docs.djangoproject.com/en/1.8/releases/1.7/#schema-migrations" target="_blank">变为自带</a>，拥有比 syncdb 更高级的数据库同步和版本控制特性。</p>
<p>创建完成后，执行 <code>./manage.py runserver 127.0.0.1:8888</code> ，最后的地址和端口可以自行修改或省略，就可以成功运行 Django 的测试服务器了。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/django-note-1/">Django 学习手记 一 安装和配置</a></p>]]></content>
        
        <summary type="html">
            
            Django 是一款知名的 Python Web 框架，最初为 CMS 设计，现在已经发展成为了一个能快速根据抽象数据模型生成和维护数据库、后台、和模版系统，同时自带用户系统、地址重写等大量实用功能的大型框架。 本文为个人在 Django 学习中的一些心得体会，主要是官方教程和
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Django"/>
        
        <category term="Django 学习手记"/>
        
        <category term="Python"/>
        
        <category term="Web"/>
        
        <category term="数据库"/>
        
        <category term="编程"/>
        
    </entry>
    
    <entry>
        <title>书柜大整理 (Lゝω·)~☆ Kira</title>
        <link href="http://blog.dimpurr.com/bookcase-clean/"/>
        <id>http://blog.dimpurr.com/bookcase-clean/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-03-06T15:53:33+00:00</published>
        <updated>2015-03-06T15:53:33+00:00</updated>
        
        <content type="html"><![CDATA[<p>为了制定新学期的阅读计划，看着乱七八糟的书柜实在不爽，于是折腾了一整个晚上把自己的书柜整理好了 …… 相应为自己的两个书架做了份布局对照表。于是留档。</p>
<h3>房间内主役小书柜</h3>
<p>就在钉子房间书桌旁边触手可及的书柜。存放常用的书，不过也有不少书带到学校了，比如看了十来遍的「量子力学史话」缺席此合照。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/03/QQ20150306-1.png"><img src="http://img1.dimpurr.com/dimblog/2015/03/QQ20150306-1-600x400.png" /></a><p>钉子房间内的小书架の对照表</p></div>
<p><span></span></p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/03/DSC_0656.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/03/DSC_0656-563x1000.jpg" /></a><p>房间内主役小书柜</p></div>
<h3>书房藏书用大书柜</h3>
<p>钉子家书房的书柜有整面墙大小，于是钉子果断霸占了靠左的两列。除了轻小说基本上存放的都是小学初中看的，和其他现在不常看的书。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/03/QQ20150306-2.png"><img src="http://img1.dimpurr.com/dimblog/2015/03/QQ20150306-2-600x291.png" /></a><p>钉子书房的两列书柜の对照表</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2015/03/DSC_0658.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/03/DSC_0658-563x1000.jpg" /></a><p>书房藏书柜</p></div>
<p>以上。怎么感觉还是小学时的自己（相对同龄人的阅读面来说）比较菊苣 ……</p>
<p>新的学期开始了，大概忙起来博客也会再次变得安静吧 ……。另外也许有人发现，咱把博客背景换了，记得这个画面是小圆中沙耶香失去灵核的片段，当时被构图震惊果断截的图。嘛，也祝愿我在接下来更多生死未卜的高中征途中好运吧。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/bookcase-clean/">书柜大整理 (Lゝω·)~☆ Kira</a></p>]]></content>
        
        <summary type="html">
            
            为了制定新学期的阅读计划，看着乱七八糟的书柜实在不爽，于是折腾了一整个晚上把自己的书柜整理好了 …… 相应为自己的两个书架做了份布局对照表。于是留档。 房间内主役小书柜 就在钉子房间书桌旁边触手可及的书柜。存放常用的书，不过也有不少书带到学校了，比如看了十来遍的「量子力学史话」
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="书"/>
        
        <category term="学习"/>
        
        <category term="小说"/>
        
        <category term="文学"/>
        
        <category term="考试"/>
        
        <category term="阅读"/>
        
    </entry>
    
    <entry>
        <title>量子计算机有什么实际的应用意义？</title>
        <link href="http://blog.dimpurr.com/quantum-means/"/>
        <id>http://blog.dimpurr.com/quantum-means/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-02-18T01:44:26+00:00</published>
        <updated>2015-02-18T01:44:26+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>此回答由本人原载于知乎</p></blockquote>
<p>鄙人见识浅薄，还请诸位大神指正。</p>
<p>量子有一种很神奇的特性，也就是量子的叠加态。一个粒子，在我们观测之前，它处于又左旋又右旋的状态。但是我们观测以后，我们只能得到要么左旋，要么右旋的结果。换句话说，在观测的一瞬间，它「塌缩」了。</p>
<p>对于量子处于叠加态的证明，可以搜索一下托马斯·杨的「双缝干涉实验」中，观测手段影响光的波粒二象性的表现，以及「延迟决定实验」中，在一切结束后再对过程进行决定的实验。可以说，量子论打破了经典物理学中的决定论和定域性，实际上，不存在一个确定的「历史」，而取决于我们观察的方式。同时，不同的观测方式甚至可以导致不同的历史。</p>
<p>把它放到量子计算机上，这意味着几个好处。</p>
<p><span></span></p>
<p>第一，是指数级增长的计算能力。经典计算机中，一个经典比特只能存储一位信息，要么是 1 ，要么是 0 。但是在量子计算机中，这个比特可能是 0 ，也可以是 1 ，关键是它们同时参与了计算，而只在你观测时，才会塌缩成一个完全确定的解答。假如是 10 经典比特，那么相当于 10 位数据参与运算。而 10 量子比特，就是 2^10 ，也就是 1024 位数据参与了运算，这是多么巨大的差距。</p>
<p>第二，假设现在你的手放在键盘上，准备进行 Google 搜索。不可思议的地方在于，甚至在你想好要搜什么之前，量子计算机就可以完成计算！乍看起来这样非常不合常理，但是实际上，在你打字时，后台就可以开始进行计算。这个计算可能是各种搜索关键字的叠加态，而在你打好字按下回车时，这个叠加态一瞬间塌缩为你要的关键字，你的搜索早已运算完毕了。</p>
<p>第三，我们现在计算机的主要热量，来源于我们对存储器的不断读写和重置。假设我们的存储器内有 0 和 1 组成的杂乱无章的数据，现在我们全部清零。这一刻，我们的存储器显然变得更加「有序」，即无序程度「熵」的降低，而根据热力学定律，这些熵就以热量的形式散发出去。因为微观粒子的幺正性，量子的运算是一种完全可逆计算，信息不会丢失而得到重用，几乎不会有热量的散失。</p>
<p>所以说，届时在一块手表上实现超越一切经典计算机的算力，并且超低功耗和热量，的确不是不可能的。我们可以期待通用量子计算机普及的时候，人类文明会迎来多大的飞跃。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/quantum-means/">量子计算机有什么实际的应用意义？</a></p>]]></content>
        
        <summary type="html">
            
            此回答由本人原载于知乎 鄙人见识浅薄，还请诸位大神指正。 量子有一种很神奇的特性，也就是量子的叠加态。一个粒子，在我们观测之前，它处于又左旋又右旋的状态。但是我们观测以后，我们只能得到要么左旋，要么右旋的结果。换句话说，在观测的一瞬间，它「塌缩」了。 对于量子处于叠加态的证明，
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="物理"/>
        
        <category term="知乎"/>
        
        <category term="量子"/>
        
        <category term="量子计算机"/>
        
    </entry>
    
    <entry>
        <title>如何用圈外人士能理解的文字解释「量子退火」？</title>
        <link href="http://blog.dimpurr.com/quantum-annealing/"/>
        <id>http://blog.dimpurr.com/quantum-annealing/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-02-18T01:39:07+00:00</published>
        <updated>2015-02-18T01:39:07+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>此回答由本人原载于知乎</p></blockquote>
<p>不邀自来，见识浅薄，还请诸位大神指正。</p>
<p>量子退火法，是一种基于量子特性的量子计算机算法，脱胎于经典计算机上的模拟退火算法。实际上，模拟退火算法的步骤和思路，与金属的退火确实有着异曲同工的妙处。</p>
<blockquote><p>将金属加温到某个高于再结晶温度的一点并维持此温度一段时间，再将其缓慢冷却。<br />
—— <a href="http://zh.wikipedia.org/wiki/%E9%80%80%E7%81%AB" target="_blank">退火<i></i></a> – Wikipedia</p></blockquote>
<p>关于通用量子计算机的原理和特性，可以参见我的另一个回答：<a href="http://blog.dimpurr.com/quantum-means/" target="_blank">量子计算机有什么实际的应用意义？ – Cheny Dimpurr 的回答</a></p>
<p>作为量子退火机应用较多的一种特性，再补充一种神秘的「量子隧道效应」。这种效应一般来说，指的是微观粒子有一定纪律穿过穿过不可能穿越的壁障，出现在壁障的另一端的情况。因为一个微观量子并不存在一个精确的位置，而是以一定概率分布在一片区域，化学上的电子云概念就是这样的。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/02/d55d83bb687b4d982f0287f2974ea76e_b.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/02/d55d83bb687b4d982f0287f2974ea76e_b.jpg" /></a><p>量子隧道效应</p></div>
<p>假设容器的边缘有一个粒子，蓝色的深浅标出了它的德布罗意波，即它可能出现的位置的可能性大小。可以注意到，在很小的几率下，这个粒子会出现在容器的对面。不是漏出，也不是穿过，而是瞬移！但是这也不是瞬移，因为对于电子来说，它本来就有可能出现在那里，只是在你观测的时候，本来存在于一定范围的电子忽然给出了一个正好的容器外的位置。</p>
<p>首先，我们先来看看我们都熟悉的一种贪心算法，爬山算法。</p>
<p>爬山算法指的是以以一个任意值为起始点，计算临近的解，然后不断判断这个解和符合条件的差距，选择选择更适合的方向继续计算，直到达到一个任意方向都是更劣解的位置。</p>
<p><span></span></p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/02/b3c44a2f3adaf1b87a54906de4d85be4_b.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/02/b3c44a2f3adaf1b87a54906de4d85be4_b-600x325.jpg" /></a><p>解的示例图像</p></div>
<p>来看看这幅图。假设蓝线的位置就是正解的位置。</p>
<p>首先，一个登山者（计算机）从 <b>FE</b> 段的任意一处出发。对他来说，向下走无疑是更接近正解的。只不过，当他走到了山谷，也就是 <b>E</b> 点时，他会发现：此时无论他往哪边走，都会距离谷底更远！</p>
<p>我们的爬山者被困在山谷底，或者说「势阱」了。</p>
<p>至于模拟退火法，引入了一个随机的扰动，也就是温度 <i>T</i><i> 。</i></p>
<p>我们可以这样来概括它的步骤：</p>
<ol>
<li>在值域内，按照随机扰动 <i>Δ</i> ，产生一个一定范围距离的新解</li>
<li>判断新解和正解的距离，与当前解与新解的距离进行比较</li>
<li>如果可以接受，那么在当前 <i>T </i>的范围内，有一定可能性改用新解</li>
<li>当确定正解在某个区间以内时，缩小范围继续应用模拟退火算法</li>
</ol>
<p>实际上，就模拟退火算法的具体实现来说这个概括不是很准确。不过这样一来，就可以看出它和爬山算法的最大区别：我们的登山者一次被困在山谷 <b>E</b> 时，他可以选择瞬移到 DC 段的某处，并且惊喜的发现这里更接近正解！在对「整座山」通过统计学方法「退火」时，他就会发现最接近正解的区间<b>BCD</b> ，从而集中精力在 <b>C</b> 处寻找精确解了。</p>
<p>退火法还有很多有趣的性质，比如初温 <i>T </i>越高，得到正解的概率也越高，因为此时计算机会更勇敢的选择新解，相当于退火的更彻底。相应的，要达到对「整座山」锁定目标需要的耗时就越长。这个问题，量子退火中就可以得到改善。</p>
<p>那么，这次我们的登山者不同寻常，是一位量子登山者。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/02/e7501a8947c1198bf4944280f095ccaa_b.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/02/e7501a8947c1198bf4944280f095ccaa_b-600x317.jpg" /></a><p>量子登山者</p></div>
<p>看到这幅图也许已经有人明白了：此时这个登山者不仅处在 <b>DE </b>段上的某一点，其实他「同时」存在于这四周的一大块区域！在它的可能性范围所能触及的区域，他发现了 <b>CD </b>段上有着更低的一点。利用量子隧道，我们的登山者逃出了山谷！</p>
<p>还不仅仅如此。我们还记得在模拟退火法的第一步上，我们提到了我们会从图像（山脉）的某处开始搜索。但是，因为量子的叠加性质，我们的量子计算元件可以同时处在图中的很多个位置！这样以来，搜索的效率可以以（2 的）指数性增长！</p>
<p>这样优秀（当然，适合处理的问题有所局限）的算法，让我们来看看这个庞然大物， D-Wave Two 是怎么实现的。</p>
<p>首先，在合适的环境下，制备好一系列量子比特。 D-Wave Two 拥有 128 个量子比特。</p>
<p>接着，为这些量子设置好三维的伊辛模型，也就是设置好他们的初始位置和自旋状态。这个初始模型就决定了接下来的计算，可以说就是编好的程序。</p>
<p>随后，减弱量子间的相互作用，通过向超导电路通入特殊电流，向设置好的模型施加一个横磁场。这种情况下，量子就进入了自旋的叠加状态，相当于同时具有 0 和 1 状态的比特。</p>
<p>最终，我们进行「退火」。我们慢慢撤去横磁场，增强相互作用，量子们稳定下来，我们得出了最终解。</p>
<p>就像别的答案中提到的，量子退火机就是让大自然自己去进行计算，我们等着看结果：最终稳定下来的量子，一定是在这个三维伊辛模型中，相互间能量很小的状态。意即只要模型设置得当，我们就有非常大的机率落到最低的「山谷」当中。</p>
<p>因为算法本身基于统计学而非遍历的性质，我们可以理解，即使量子退火算法在模拟退火算法的基础上提高了算力，还是有只得出近似解的情况存在。因此， D-Wave Two 据说会针对每次计算任务重复 4000 次，选择其中的最优解得出解答。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/02/b0063796af646363f4d2c4748ee7faed_b.jpg"><img src="http://img1.dimpurr.com/dimblog/2015/02/b0063796af646363f4d2c4748ee7faed_b-600x528.jpg" /></a><p>D-Wave Two</p></div>
<p>最终，和大家预想的不一样， Dwave Two 确实「只是」一台量子退火机。在吭哧吭哧工作时，还得全程由液氮保护运行在 0.02 K，也就是 -273.13 ℃ 下。不过，相比经典计算机，量子退火机还是在特定领域达到了上万甚至上亿倍的算力提升。我们可以期待，一个真正的通用量子计算机，将会给科技行业乃至人类智慧带来极大的革命。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/quantum-annealing/">如何用圈外人士能理解的文字解释「量子退火」？</a></p>]]></content>
        
        <summary type="html">
            
            此回答由本人原载于知乎 不邀自来，见识浅薄，还请诸位大神指正。 量子退火法，是一种基于量子特性的量子计算机算法，脱胎于经典计算机上的模拟退火算法。实际上，模拟退火算法的步骤和思路，与金属的退火确实有着异曲同工的妙处。 将金属加温到某个高于再结晶温度的一点并维持此温度一段时间，再
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="D-Wave"/>
        
        <category term="物理"/>
        
        <category term="知乎"/>
        
        <category term="算法"/>
        
        <category term="退火"/>
        
        <category term="量子"/>
        
        <category term="量子计算机"/>
        
        <category term="量子退火"/>
        
    </entry>
    
    <entry>
        <title>pyspider 爬虫教程（三）：使用 PhantomJS 渲染带 JS 的页面</title>
        <link href="https://binux.blog/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/"/>
        <id>https://binux.blog/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>英文原文：<a href="http://docs.pyspider.org/en/latest/tutorial/Render-with-PhantomJS/" target="_blank">http://docs.pyspider.org/en/latest/tutorial/Render-with-PhantomJS/</a></p><p>在上两篇教程中，我们学习了怎么从 HTML 中提取信息，也学习了怎么处理一些请求复杂的页面。但是有一些页面，它实在太复杂了，无论是分析 API 请求的地址，还是渲染时进行了加密，让直接抓取请求非常麻烦。这时候就是 <a href="http://phantomjs.org/" target="_blank">PhantomJS</a> 大显身手的时候了。</p><p>在使用 <a href="http://phantomjs.org/" target="_blank">PhantomJS</a> 之前，你需要安装它（<a href="http://phantomjs.org/download.html" target="_blank">安装文档</a>）。当你安装了之后，在运行 <code>all</code> 模式的 pyspider 时就会自动启用了。当然，你也可以在 <a href="http://demo.pyspider.org/" target="_blank">demo.pyspider.org</a> 上尝试。</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/#使用-PhantomJS"></a>使用 PhantomJS</h2><p>当 pyspider 连上 PhantomJS 代理后，你就能通过在 <code>self.crawl</code> 中添加 <code>fetch_type='js'</code> 的参数，开启使用 PhantomJS 抓取。例如，在教程二中，我们尝试抓取的 <a href="http://movie.douban.com/explore" target="_blank">http://movie.douban.com/explore</a> 就可以通过 PhantomJS 直接抓取：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /></pre></td><td><pre><span><span><span>class</span> <span>Handler</span><span>(BaseHandler)</span>:</span></span><br /><span>    <span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>        self.crawl(<span>'http://movie.douban.com/explore'</span>,</span><br /><span>                   fetch_type=<span>'js'</span>, callback=self.phantomjs_parser)</span><br /><span>    </span><br /><span>    <span><span>def</span> <span>phantomjs_parser</span><span>(self, response)</span>:</span></span><br /><span>        <span>return</span> [{</span><br /><span>            <span>"title"</span>: <span>""</span>.join(</span><br /><span>                s <span>for</span> s <span>in</span> x(<span>'p'</span>).contents() <span>if</span> isinstance(s, basestring)</span><br /><span>            ).strip(),</span><br /><span>            <span>"rate"</span>: x(<span>'p strong'</span>).text(),</span><br /><span>            <span>"url"</span>: x.attr.href,</span><br /><span>        } <span>for</span> x <span>in</span> response.doc(<span>'a.item'</span>).items()]</span><br /></pre></td></tr></table><blockquote><ul><li>我在这里使用了一些 PyQuery 的 API，你可以在 <a href="https://pythonhosted.org/pyquery/api.html" target="_blank">PyQuery complete API</a> 获得完整的 API 手册。</li></ul></blockquote><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-3-render-with-phantomjs/#在页面上执行自定义脚本"></a>在页面上执行自定义脚本</h2><p>你会发现，在上面我们使用 <a href="http://phantomjs.org/" target="_blank">PhantomJS</a> 抓取的豆瓣热门电影只有 20 条。当你点击『加载更多』时，能获得更多的热门电影。为了获得更多的电影，我们可以使用 <code>self.crawl</code> 的 <code>js_script</code> 参数，在页面上执行一段脚本，点击加载更多：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>    self.crawl(<span>'http://movie.douban.com/explore#more'</span>,</span><br /><span>               fetch_type=<span>'js'</span>, js_script=<span>"""</span></span><br /><span><span>               function() {</span></span><br /><span><span>                 setTimeout("$('.more').click()", 1000);</span></span><br /><span><span>               }"""</span>, callback=self.phantomjs_parser)</span><br /></pre></td></tr></table><blockquote><ul><li>这个脚本默认在页面加载结束后执行，你可以通过 <code>js_run_at</code> <a href="http://docs.pyspider.org/en/latest//apis/self.crawl/#enable-javascript-fetcher-need-support-by-fetcher" target="_blank">参数</a> 修改这个行为</li><li>由于是 AJAX 异步加载的，在页面加载完成时，第一页的电影可能还没有加载完，所以我们用 <code>setTimeout</code> 延迟 1 秒执行。</li><li>你可以间隔一定时间，多次点击，这样可以加载更多页。</li><li>由于相同 URL （实际是相同 taskid） 的任务会被去重，所以这里为 URL 加了一个 <code>#more</code></li></ul></blockquote><p>上面两个例子，都可以在 <a href="http://demo.pyspider.org/debug/tutorial_douban_explore" target="_blank">http://demo.pyspider.org/debug/tutorial_douban_explore</a> 中找到。</p>]]></content>
        
        <summary type="html">
            
            英文原文：http://docs.pyspider.org/en/latest/tutorial/Render-with-PhantomJS/在上两篇教程中，我们学习了怎么从 HTML 中提取信息，也学习了怎么处理一些请求复杂的页面。但是有一些页面，它实在太复杂了，无论是分析 
            
        </summary>
        
        <category term="python"/>
        
        <category term="pyspider"/>
        
    </entry>
    
    <entry>
        <title>pyspider 爬虫教程（二）：AJAX 和 HTTP</title>
        <link href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/"/>
        <id>https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>在上一篇教程中，我们使用 <code>self.crawl</code> API 抓取豆瓣电影的 HTML 内容，并使用 CSS 选择器解析了一些内容。不过，现在的网站通过使用 <a href="http://www.w3school.com.cn/ajax/ajax_intro.asp" target="_blank">AJAX</a> 等技术，在你与服务器交互的同时，不用重新加载整个页面。但是，这些交互手段，让抓取变得稍微难了一些：你会发现，这些网页在抓回来后，和浏览器中的并不相同。你需要的信息并不在返回 HTML 代码中。</p><p>在这一篇教程中，我们会讨论这些技术 和 抓取他们的方法。（英文版：<a href="http://docs.pyspider.org/en/latest/tutorial/AJAX-and-more-HTTP/" target="_blank">AJAX-and-more-HTTP</a>）</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#AJAX"></a>AJAX</h2><p><a href="http://www.w3school.com.cn/ajax/ajax_intro.asp" target="_blank">AJAX</a> 是 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）的缩写。AJAX 通过使用原有的 web 标准组件，实现了在不重新加载整个页面的情况下，与服务器进行数据交互。例如在新浪微博中，你可以展开一条微博的评论，而不需要重新加载，或者打开一个新的页面。但是这些内容并不是一开始就在页面中的（这样页面就太大了），而是在你点击的时候被加载进来的。这就导致了你抓取这个页面的时候，并不能获得这些评论信息（因为你没有『展开』）。</p><p><a href="http://www.w3school.com.cn/ajax/ajax_intro.asp" target="_blank">AJAX</a> 的一种常见用法是使用 <a href="http://www.w3school.com.cn/ajax/ajax_intro.asp" target="_blank">AJAX</a> 加载 <a href="http://www.w3school.com.cn/json/" target="_blank">JSON</a> 数据，然后在浏览器端渲染。如果能直接抓取到 <a href="http://www.w3school.com.cn/json/" target="_blank">JSON</a> 数据，会比 HTML 更容易解析。</p><p>当一个网站使用了 AJAX 的时候，除了用 pyspider 抓取到的页面和浏览器看到的不同以外。你在浏览器中打开这样的页面，或者点击『展开』的时候，常常会看到『加载中』或者类似的图标/动画。例如，当你尝试抓取：<a href="http://movie.douban.com/explore" target="_blank">http://movie.douban.com/explore</a></p><p><img src="https://binux.blog/assets/image/douban_explore.png" /></p><p>你会发现电影是『载入中…』</p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#找到真实的请求"></a>找到真实的请求</h3><p>由于 AJAX 实际上也是通过 HTTP 传输数据的，所以我们可以通过 <a href="https://developer.chrome.com/devtools" target="_blank">Chrome Developer Tools</a> 找到真实的请求，直接发起真实请求的抓取就可以获得数据了。</p><ol><li>打开一个新窗口</li><li>按 <code>Ctrl</code>+<code>Shift</code>+<code>I</code> (在 Mac 上请按 <code>Cmd</code>+<code>Opt</code>+<code>I</code>) 打开开发者工具。</li><li>切换到网络（ Netwotk 面板）</li><li>在窗口中打开 <a href="http://movie.douban.com/explore" target="_blank">http://movie.douban.com/explore</a></li></ol><p>在页面加载的过程中，你会在面板中看到所有的资源请求。</p><p><img src="https://binux.blog/assets/image/douban_explore_network_panel.png" /></p><p>AJAX 一般是通过 <a href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_create.asp" target="_blank">XMLHttpRequest</a> 对象接口发送请求的，XMLHttpRequest 一般被缩写为 XHR。点击网络面板上漏斗形的过滤按钮，过滤出 XHR 请求。挨个查看每个请求，通过访问路径和预览，找到包含信息的请求：<a href="http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0" target="_blank">http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0</a></p><p><img src="https://binux.blog/assets/image/douban_explore_xhr_preview.png" /></p><p>在豆瓣这个例子中，XHR 请求并不多，可以挨个查看来确认。但在 XHR 请求较多的时候，可能需要结合触发动作的时间，请求的路径等信息帮助在大量的请求中找到包含信息的关键请求。这需要抓取或者前端的相关经验。所以，有一个我一直在提的观点，学习抓取的最好方法是：学会写网站。</p><p>现在可以在新窗口中打开 <a href="http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0" target="_blank">http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0</a>，你会看到包含电影数据的 <a href="http://www.w3school.com.cn/json/" target="_blank">JSON</a> 原始数据。推荐安装 <a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc" target="_blank">JSONView</a>（<a href="http://jsonview.com/" target="_blank">Firfox版</a>）插件，这样可以看到更好看的 JSON 格式，展开折叠列等功能。然后，我们根据 <a href="http://www.w3school.com.cn/json/" target="_blank">JSON</a> 数据，编写一个提取电影名和评分的脚本：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span><span><span>class</span> <span>Handler</span><span>(BaseHandler)</span>:</span></span><br /><span>    <span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>        self.crawl(<span>'http://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0'</span>,</span><br /><span>                   callback=self.json_parser)</span><br /><span></span><br /><span>    <span><span>def</span> <span>json_parser</span><span>(self, response)</span>:</span></span><br /><span>        <span>return</span> [{</span><br /><span>            <span>"title"</span>: x[<span>'title'</span>],</span><br /><span>            <span>"rate"</span>: x[<span>'rate'</span>],</span><br /><span>            <span>"url"</span>: x[<span>'url'</span>]</span><br /><span>        } <span>for</span> x <span>in</span> response.json[<span>'subjects'</span>]]</span><br /></pre></td></tr></table><blockquote><ul><li>你可以使用 <code>response.json</code> 将结果转为一个 python 的 <code>dict</code> 对象</li></ul></blockquote><p>你可以在 <a href="http://demo.pyspider.org/debug/tutorial_douban_explore" target="_blank">http://demo.pyspider.org/debug/tutorial_douban_explore</a> 获得完整的代码，并进行调试。脚本中还有一个使用 <a href="http://phantomjs.org/" target="_blank">PhantomJS</a> 渲染的提取版本，将会在下一篇教程中介绍。</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#HTTP"></a>HTTP</h2><p><a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank">HTTP</a> 是用来传输网页内容的协议。在前面的教程中，我们已经通过 <code>self.crawl</code> 接口提交了 URL 进行了抓取。这些抓取就是通过 HTTP 协议传输的。</p><p>在抓取过程中，你可能会遇到类似 <code>403 Forbidden</code>，或者需要登录的情况，这时候你就需要正确的 HTTP 参数进行抓取了。</p><p>一个典型的 HTTP 请求包如下，这个请求是发往 <a href="http://example.com/" target="_blank">http://example.com/</a> 的：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /></pre></td><td><pre><span>GET / HTTP/1.1</span><br /><span>Host: example.com</span><br /><span>Connection: keep-alive</span><br /><span>Cache-Control: max-age=0</span><br /><span>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br /><span>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.45 Safari/537.36</span><br /><span>Referer: http://en.wikipedia.org/wiki/Example.com</span><br /><span>Accept-Encoding: gzip, deflate, sdch</span><br /><span>Accept-Language: zh-CN,zh;q=0.8</span><br /><span>If-None-Match: <span>"359670651"</span></span><br /><span>If-Modified-Since: Fri, 09 Aug 2013 23:54:35 GMT</span><br /></pre></td></tr></table><blockquote><ul><li>请求的第一行包含 <code>method</code>, <code>path</code> 和 HTTP 协议的版本信息</li><li>余下的行被称为 header，是以 <code>key: value</code> 的形式呈现的</li><li>如果是 POST 请求，在请求结尾可能还会有 <code>body</code> 内容</li></ul></blockquote><p>你可以通过前面用过的 <a href="https://developer.chrome.com/devtools" target="_blank">Chrome Developer Tools</a> 工具查看到这些信息：</p><p><img src="https://binux.blog/assets/image/request-headers.png" /></p><p>在大多数时候，使用正确的 <code>method</code>, <code>path</code>, <code>headers</code> 和 <code>body</code> 总是能抓取到你需要的信息的。</p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#HTTP-Method"></a>HTTP Method</h3><p><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank">HTTP Method</a> 告诉服务器对 URL 资源期望进行的操作。例如在打开一个 URL 的时候使用的是 GET 方式，而在提交数据的时候一般使用 POST。</p><p>TODO： need example here</p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#HTTP-Headers"></a>HTTP Headers</h3><p>HTTP Headers 是请求所带的一个参数列表，你可以在 <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank">这里</a> 找到完整的常用 Headers 列表。一些常用的需要注意的有：</p><h4><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#User-Agent"></a>User-Agent</h4><p>UA 是标识你使用的浏览器，或抓取程序的一段字符串。pyspider 使用的默认 UA 是 <code>pyspider/VERSION (+http://pyspider.org/)</code>。网站常用这个字符串来区分用户的操作系统和浏览器，以及判断对方是否是爬虫。所以在抓取的时候，常常会对 UA 进行伪装。</p><p>在 pyspider 中，你可以通过 <code>self.crawl(URL, headers={'User-Agent': 'pyspider'})</code>，或者是 <code>crawl_config = {'headers': {'User-Agent': 'xxxx'}}</code> 来指定脚本级别的 UA。详细请查看 <a href="http://docs.pyspider.org/en/latest/apis/self.crawl/#fetch" target="_blank">API 文档</a>。</p><h4><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#Referer"></a>Referer</h4><p>Referer 用于告诉服务器，你访问的上一个网页是什么。常常被用于防盗链，在抓取图片的时候可能会用到。</p><h4><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#X-Requested-With"></a>X-Requested-With</h4><p>当使用 XHR 发送 AJAX 请求时会带上的 Header，常被用于判断是不是 AJAX 请求。例如在 <a href="http://bbs.byr.cn/" target="_blank">北邮人论坛</a> 中，你需要：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /></pre></td><td><pre><span><span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>    self.crawl(<span>'http://bbs.byr.cn/board/Python'</span>,</span><br /><span>               headers={<span>'X-Requested-With'</span>: <span>'XMLHttpRequest'</span>},</span><br /><span>               callback=self.index_page)</span><br /></pre></td></tr></table><p>带有 <code>headers={'X-Requested-With': 'XMLHttpRequest'}</code> 才能抓取到内容。</p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-2-ajax-and-more-http/#HTTP-Cookie"></a>HTTP Cookie</h3><p>虽然 <code>Cookie</code> 只是 HTTP Header 中的一个，但是因为非常重要，但是拿出来说一下。<code>Cookie</code> 被 HTTP 请求用来区分、追踪用户的身份，当你在一个网站登录的时候，就是通过写入 <code>Cookie</code> 字段来记录登录状态的。</p><p>当遇到需要登录的网站，你需要通过设置 Cookie 参数，来请求需要登录的内容。Cookie 可以通过开发者工具的请求面板，或者是资源面板中获得。在 pyspider 中，你也可以使用 <code>response.cookies</code> 获得返回的 cookie，并使用 <code>self.crawl(URL, cookie={'key': 'value'})</code> 来设置请求的 Cookie 参数。</p>]]></content>
        
        <summary type="html">
            
            在上一篇教程中，我们使用 self.crawl API 抓取豆瓣电影的 HTML 内容，并使用 CSS 选择器解析了一些内容。不过，现在的网站通过使用 AJAX 等技术，在你与服务器交互的同时，不用重新加载整个页面。但是，这些交互手段，让抓取变得稍微难了一些：你会发现，这些网页
            
        </summary>
        
        <category term="pyspider"/>
        
        <category term="scrape"/>
        
        <category term="crawl"/>
        
        <category term="AJAX"/>
        
        <category term="HTTP"/>
        
    </entry>
    
    <entry>
        <title>pyspider 爬虫教程（一）：HTML 和 CSS 选择器</title>
        <link href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/"/>
        <id>https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>虽然以前写过 <a href="http://blog.binux.me/2013/09/howto-crawl-web/" target="_blank">如何抓取WEB页面</a> 和 <a href="http://blog.binux.me/2014/07/how-to-extract-data-from-web/" target="_blank">如何从 WEB 页面中提取信息</a>。但是感觉还是需要一篇 step by step 的教程，不然没有一个总体的认识。不过，没想到这个教程居然会变成一篇<a href="http://docs.pyspider.org/en/latest/tutorial/HTML-and-CSS-Selector/" target="_blank">译文</a>，在这个爬虫教程系列文章中，会以实际的例子，由浅入深讨论爬取（抓取和解析）的一些关键问题。</p><p>在 教程一 中，我们将要爬取的网站是豆瓣电影：<a href="http://movie.douban.com/" target="_blank">http://movie.douban.com/</a></p><p>你可以在: <a href="http://demo.pyspider.org/debug/tutorial_douban_movie" target="_blank">http://demo.pyspider.org/debug/tutorial_douban_movie</a> 获得完整的代码，和进行测试。</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#开始之前"></a>开始之前</h2><p>由于教程是基于 pyspider 的，你可以安装一个 pyspider（<a href="http://docs.pyspider.org/en/latest/Quickstart/" target="_blank">Quickstart</a>，也可以直接使用 pyspider 的 demo 环境： <a href="http://demo.pyspider.org/" target="_blank">http://demo.pyspider.org/</a>。</p><p>你还应该至少对万维网是什么有一个简单的认识：</p><ul><li><a href="http://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank">万维网</a>是一个由许多互相链接的超文本页面（以下简称网页）组成的系统。</li><li>网页使用网址（<a href="http://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank">URL</a>）定位，并链接彼此</li><li>网页使用 <a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank">HTTP</a> 协议传输</li><li>网页使用 <a href="http://zh.wikipedia.org/wiki/HTML" target="_blank">HTML</a> 描述外观和语义</li></ul><p>所以，爬网页实际上就是：</p><ol><li>找到包含我们需要的信息的网址（URL）列表</li><li>通过 HTTP 协议把页面下载回来</li><li>从页面的 HTML 中解析出需要的信息</li><li>找到更多这个的 URL，回到 2 继续</li></ol><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#选取一个开始网址"></a>选取一个开始网址</h2><p>既然我们要爬所有的电影，首先我们需要抓一个电影列表，一个好的列表应该：</p><ul><li>包含足够多的电影的 URL</li><li>通过翻页，可以遍历到所有的电影</li><li>一个按照更新时间排序的列表，可以更快抓到最新更新的电影</li></ul><p>我们在 <a href="http://movie.douban.com/" target="_blank">http://movie.douban.com/</a> 扫了一遍，发现并没有一个列表能包含所有电影，只能退而求其次，通过抓取分类下的所有的标签列表页，来遍历所有的电影： <a href="http://movie.douban.com/tag/" target="_blank">http://movie.douban.com/tag/</a> </p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#创建一个项目"></a>创建一个项目</h3><p>在 pyspider 的 dashboard 的右下角，点击 “Create” 按钮</p><p><img src="https://binux.blog/assets/image/creating_project.png" /></p><p>替换 <code>on_start</code> 函数的 <code>self.crawl</code> 的 URL：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /></pre></td><td><pre><span><span>@every(minutes=24 * 60)</span></span><br /><span><span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>    self.crawl(<span>'http://movie.douban.com/tag/'</span>, callback=self.index_page)</span><br /></pre></td></tr></table><blockquote><ul><li><code>self.crawl</code> 告诉 pyspider 抓取指定页面，然后使用 <code>callback</code> 函数对结果进行解析。</li><li><a href="(http://docs.pyspider.org/en/latest/apis/@every/"><code>@every</code></a>) 修饰器，表示 <code>on_start</code> 每天会执行一次，这样就能抓到最新的电影了。</li></ul></blockquote><p>点击绿色的 <code>run</code> 执行，你会看到 <code>follows</code> 上面有一个红色的 1，切换到 <code>follows</code> 面板，点击绿色的播放按钮：</p><p><img src="https://binux.blog/assets/image/run_one_step.png" /></p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#Tag-列表页"></a>Tag 列表页</h2><p>在 <a href="http://movie.douban.com/tag/" target="_blank">tag 列表页</a> 中，我们需要提取出所有的 电影列表页 的 URL。你可能已经发现了，sample handler 已经提取了非常多大的 URL，所有，一种可行的提取列表页 URL 的方法就是用正则从中过滤出来：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /></pre></td><td><pre><span><span>import</span> re</span><br /><span>...</span><br /><span></span><br /><span><span>    @config(age=10 * 24 * 60 * 60)</span></span><br /><span>    <span><span>def</span> <span>index_page</span><span>(self, response)</span>:</span></span><br /><span>        <span>for</span> each <span>in</span> response.doc(<span>'a[href^="http"]'</span>).items():</span><br /><span>            <span>if</span> re.match(<span>"http://movie.douban.com/tag/\w+"</span>, each.attr.href, re.U):</span><br /><span>                self.crawl(each.attr.href, callback=self.list_page)</span><br /></pre></td></tr></table><blockquote><ul><li>由于 电影列表页和 tag列表页长的并不一样，在这里新建了一个 <code>callback</code> 为 <code>self.list_page</code></li><li><code>@config(age=10 * 24 * 60 * 60)</code> 在这表示我们认为 10 天内页面有效，不会再次进行更新抓取</li></ul></blockquote><p>由于 pyspider 是纯 Python 环境，你可以使用 Python 强大的内置库，或者你熟悉的第三方库对页面进行解析。不过更推荐使用 CSS选择器。</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#电影列表页"></a>电影列表页</h2><p>再次点击 <code>run</code> 让我们进入一个电影列表页(<code>list_page</code>)。在这个页面中我们需要提取：</p><ul><li>电影的链接，例如，<a href="http://movie.douban.com/subject/1292052/" target="_blank">http://movie.douban.com/subject/1292052/</a></li><li>下一页的链接，用来翻页</li></ul><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#CSS选择器"></a>CSS选择器</h3><p>CSS选择器，顾名思义，是 <a href="http://www.w3school.com.cn/css/css_intro.asp" target="_blank">CSS</a> 用来定位需要设置样式的元素 所使用的表达式。既然前端程序员都使用 CSS选择器 为页面上的不同元素设置样式，我们也可以通过它定位需要的元素。你可以在 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank">CSS 选择器参考手册</a> 这里学习更多的 CSS选择器 语法。</p><p>在 pyspider 中，内置了 <code>response.doc</code> 的 <a href="https://pythonhosted.org/pyquery/" target="_blank">PyQuery</a> 对象，让你可以使用类似 jQuery 的语法操作 DOM 元素。你可以在 <a href="https://pythonhosted.org/pyquery/" target="_blank">PyQuery</a> 的页面上找到完整的文档。</p><h3><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#CSS-Selector-Helper"></a>CSS Selector Helper</h3><p>在 pyspider 中，还内置了一个 <code>CSS Selector Helper</code>，当你点击页面上的元素的时候，可以帮你生成它的 CSS选择器 表达式。你可以点击 <code>Enable CSS selector helper</code> 按钮，然后切换到 <code>web</code> 页面：</p><p><img src="https://binux.blog/assets/image/css_selector_helper.png" /></p><p>开启后，鼠标放在元素上，会被黄色高亮，点击后，所有拥有相同 CSS选择器 表达式的元素会被高亮。表达式会被插入到 python 代码当前光标位置。创建下面的代码，将光标停留在单引号中间：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /></pre></td><td><pre><span><span><span>def</span> <span>list_page</span><span>(self, response)</span>:</span></span><br /><span>    <span>for</span> each <span>in</span> response.doc(<span>''</span>).items():</span><br /></pre></td></tr></table><p>点击一个电影的链接，CSS选择器 表达式将会插入到你的代码中，如此重复，插入翻页的链接：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /></pre></td><td><pre><span><span><span>def</span> <span>list_page</span><span>(self, response)</span>:</span></span><br /><span>    <span>for</span> each <span>in</span> response.doc(<span>'HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV&gt;TABLE TR.item&gt;TD&gt;DIV.pl2&gt;A'</span>).items():</span><br /><span>        self.crawl(each.attr.href, callback=self.detail_page)</span><br /><span>    <span># 翻页</span></span><br /><span>    <span>for</span> each <span>in</span> response.doc(<span>'HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV.paginator&gt;A'</span>).items():</span><br /><span>        self.crawl(each.attr.href, callback=self.list_page)</span><br /></pre></td></tr></table><blockquote><ul><li>翻页是一个到自己的 <code>callback</code> 回调</li></ul></blockquote><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#电影详情页"></a>电影详情页</h2><p>再次点击 <code>run</code>，follow 到详情页。使用 <code>css selector helper</code> 分别添加电影标题，打分和导演：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /></pre></td><td><pre><span><span><span>def</span> <span>detail_page</span><span>(self, response)</span>:</span></span><br /><span>    <span>return</span> {</span><br /><span>        <span>"url"</span>: response.url,</span><br /><span>        <span>"title"</span>: response.doc(<span>'HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;H1&gt;SPAN'</span>).text(),</span><br /><span>        <span>"rating"</span>: response.doc(<span>'HTML&gt;BODY&gt;DIV#wrapper&gt;DIV#content&gt;DIV.grid-16-8.clearfix&gt;DIV.article&gt;DIV.indent.clearfix&gt;DIV.subjectwrap.clearfix&gt;DIV#interest_sectl&gt;DIV.rating_wrap.clearbox&gt;P.rating_self.clearfix&gt;STRONG.ll.rating_num'</span>).text(),</span><br /><span>        <span>"导演"</span>: [x.text() <span>for</span> x <span>in</span> response.doc(<span>'a[rel="v:directedBy"]'</span>).items()],</span><br /><span>    }</span><br /></pre></td></tr></table><p>注意，你会发现 <code>css selector helper</code> 并不是总是能提取到合适的 CSS选择器 表达式。你可以在 <a href="https://developer.chrome.com/devtools" target="_blank">Chrome Dev Tools</a> 的帮助下，写一个合适的表达式：</p><p><img src="https://binux.blog/assets/image/chrome_dev_tools.png" /></p><p>右键点击需要提取的元素，点击审查元素。你并不需要像自动生成的表达式那样写出所有的祖先节点，只要写出那些能区分你不需要的元素的关键节点的属性就可以了。不过这需要抓取和网页前端的经验。所以，学习抓取的最好方法就是学会这个页面/网站是怎么写的。</p><p>你也可以在 Chrome Dev Tools 的 Javascript Console 中，使用 <code>$$(a[rel="v:directedBy"])</code> 测试 CSS Selector。</p><h2><a href="https://binux.blog/2015/01/pyspider-tutorial-level-1-html-and-css-selector/#开始抓取"></a>开始抓取</h2><ol><li>使用 <code>run</code> 单步调试你的代码，对于用一个 <code>callback</code> 最好使用多个页面类型进行测试。<strong>然后保存。</strong></li><li>回到 Dashboard，找到你的项目</li><li>将 <code>status</code> 修改为 <code>DEBUG</code> 或 <code>RUNNING</code></li><li>按 <code>run</code> 按钮</li></ol><p><img src="https://binux.blog/assets/image/pyspider_index_page.png" /></p>]]></content>
        
        <summary type="html">
            
            虽然以前写过 如何抓取WEB页面 和 如何从 WEB 页面中提取信息。但是感觉还是需要一篇 step by step 的教程，不然没有一个总体的认识。不过，没想到这个教程居然会变成一篇译文，在这个爬虫教程系列文章中，会以实际的例子，由浅入深讨论爬取（抓取和解析）的一些关键问题。
            
        </summary>
        
        <category term="css selector"/>
        
        <category term="pyspider"/>
        
        <category term="scrape"/>
        
        <category term="crawl"/>
        
    </entry>
    
    <entry>
        <title>Tuneiz – 清新文字向单栏 Ghost 主题</title>
        <link href="http://blog.dimpurr.com/tuneiz/"/>
        <id>http://blog.dimpurr.com/tuneiz/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2015-01-02T04:27:24+00:00</published>
        <updated>2015-01-02T04:27:24+00:00</updated>
        
        <content type="html"><![CDATA[<p>这是一个简洁清新、注重阅读体验的轻量级 <a href="https://ghost.org/" target="_blank">Ghost</a> 主题。自用主题，庆祝 <a href="http://blog.dimpurr.com/clearision/" target="_blank">Clearision</a> 用户数破千特别释出 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/01/2014-08-26-下午7.28.20.png"><img src="http://img1.dimpurr.com/dimblog/2015/01/2014-08-26-下午7.28.20-600x335.png" /></a><p>Tuneiz</p></div>
<p><span></span></p>
<div><a href="http://img1.dimpurr.com/dimblog/2015/01/2014-08-26-下午7.33.19.png"><img src="http://img1.dimpurr.com/dimblog/2015/01/2014-08-26-下午7.33.19-600x335.png" /></a><p>Tuneiz 正文</p></div>
<h3>功能特点</h3>
<ul>
<li>自适应宽屏和响应式移动版</li>
<li>Ghost 原生 Logo 和 Cover 支持</li>
<li>全屏首页和作者页头图</li>
<li>HTML5 语义标签和 CSS3 特效，兼容到 IE9 及以上</li>
</ul>
<h3>主题演示</h3>
<ul>
<li><a href="http://work.dimpurr.com/demo/ghost/tuneiz/" target="_blank">Tuneiz 静态演示</a></li>
</ul>
<h3>获取主题</h3>
<ul>
<li><a href="https://github.com/dimpurr/Tuneiz/releases/tag/1.0.1" target="_blank">Github</a></li>
<li><a href="http://pan.baidu.com/s/1dDxnCrv" target="_blank">百度网盘</a></li>
</ul>
<h3>使用说明</h3>
<ul>
<li>将 <code>tuneiz</code> 文件夹复制到 <code>content/themes/</code> 目录下即可使用</li>
<li>可在 <code>assets/css/style.css:46</code> 的 <code>height: 100vh;</code> 修改头图占竖屏百分比</li>
<li>可以编辑 <code>partials/nav.hbs</code> 来编辑导航</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/tuneiz/">Tuneiz – 清新文字向单栏 Ghost 主题</a></p>]]></content>
        
        <summary type="html">
            
            这是一个简洁清新、注重阅读体验的轻量级 Ghost 主题。自用主题，庆祝 Clearision 用户数破千特别释出 …… Tuneiz  Tuneiz 正文 功能特点  自适应宽屏和响应式移动版 Ghost 原生 Logo 和 Cover 支持 全屏首页和作者页头图 HTML5
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Ghost"/>
        
        <category term="Tuneiz"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>迁移 Python 3</title>
        <link href="https://binux.blog/2014/12/porting-to-python-3/"/>
        <id>https://binux.blog/2014/12/porting-to-python-3/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>使用 Python 3 的呼声一直很高，Python 3 解决了很多 2 中的坑，比如 unicode，在向他们解释为什么 <code>print str</code> 乱码，<code>fp.write(str)</code> 时报错，在什么时候需要 <code>encode</code>，更容易了。</p><p>但是由于一开始接触的就是 Python 2，熟悉的包都是 Python 2（我也不确定他们是否支持 Python 3）。公司机器上的 Python 2.7 就算是“最新”版本。于是一直没有升级。不过有一种说法，切换到 Python 3 的最好时机就是现在。-为了庆祝 star 过 3000-，由于见到两次要求支持 Python 3，用一个周末为 pyspider 加入了 Python 3 支持（怎么样，不难吧）。</p><p>主要参考：</p><ul><li><a href="https://docs.python.org/3/howto/pyporting.html" target="_blank">Porting Python 2 Code to Python 3</a></li><li><a href="http://python-future.org/compatible_idioms.html" target="_blank">Cheat Sheet: Writing Python 2-3 compatible code</a></li><li><a href="https://pythonhosted.org/six/" target="_blank">Six: Python 2 and 3 Compatibility Library</a></li></ul><h2><a href="https://binux.blog/2014/12/porting-to-python-3/#开始之前"></a>开始之前</h2><p>其实 <a href="https://docs.python.org/3/howto/pyporting.html" target="_blank">Porting Python 2 Code to Python 3</a> 这篇文章是一个非常好的索引，能让你对将要进行的工作有一个整体的把握，同时能提供细节的链接，能让你立即开始工作。而且这一节内容就来自此文的 <a href="https://docs.python.org/3/howto/pyporting.html#the-short-explanation" target="_blank">The Short Explanation</a> 一节。因为总结得很好，所以就不重复造轮子了。</p><p>首先，低版本的 Python 2 与 Python 3 之间的鸿沟太大了，特别是 Python 2.5(含) 以前的版本。要同时兼容他们的代价太大。而 Python 2.6 和 Python 2.7 已经带有部分 Python 3 的特性，这让迁移的代价大大降低了。同时，不建议支持 Python 3.3 以下的 3 字头版本，由于 Python 3 实际上已经 release 6 年了，这些 Python 3.x 版本也比较老了，很多特性还没有，或者包不支持。所以建议跳过他们。</p><p>其次，一定要有测试，保证测试足够的代码覆盖。Python 2 到 Python 3 从包改名到语法都有变化，几乎所有的代码都需要有修改。足够的代码覆盖，才能在这样大规模修改中，保证所有功能可用。而 pyspider 正是因为有 86% 的代码覆盖，我能这么快地完成代码迁移。</p><p>读一读 Python 2 和 Python 3 有什么不同。这个可以看看 <a href="https://docs.python.org/3/whatsnew/index.html" target="_blank">What’s New in Python</a>，特别是 <a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank">What’s New In Python 3.0</a>。当然也可以找一些中文的文章，这个方面应该还蛮多的。反正最主要的就是大量的包改名，以及 <code>bytes</code>, <code>str</code>, <code>unicode</code> 三者的变化。或者你可以先读一读 <a href="http://python-future.org/compatible_idioms.html" target="_blank">Cheat Sheet</a>，虽然等下我们还需要它。</p><p>好，现在可以来看看你的包依赖是否支持 Python 3 了。并不是 pip 能安装的包就是支持 Python 3 的，可能装上了依旧不能工作。你可以用 <a href="https://caniusepython3.com/" target="_blank">Can I Use Python 3</a> 检测包是否支持。不过我更推荐 <a href="https://python3wos.appspot.com/" target="_blank">PYTHON 3 WALL OF SUPERPOWERS</a> （需要翻墙）。不过也不用担心，大部分包都是支持 Python 3 的，如果不支持，一般都会有替代，例如 pika 就可以被 ampq 替换，而 MySQL-python 能被 mysql-connector-python 替代。</p><h2><a href="https://binux.blog/2014/12/porting-to-python-3/#第一步——查找替换"></a>第一步——查找替换</h2><p>首先我们从大的方向入手，把一些改名了的包和函数处理一下。请打开 <a href="http://python-future.org/compatible_idioms.html" target="_blank">Cheat Sheet: Writing Python 2-3 compatible code</a> 参照它们一条条进行。在能搜索的地方，使用搜索统一修改，不然挨个文件太慢，而且会忘记的。因为我用的是 six 作为多环境间的桥梁。所以需要同时参考 <a href="https://pythonhosted.org/six/" target="_blank">six的文档</a>。你可能需要打开两个窗口，同时运行 Python 2 和 Python 3，确认语句在两个环境下都能执行。</p><p>在这一步，我做了以下处理：</p><ul><li>相对导入 - <a href="http://python-future.org/compatible_idioms.html#imports-relative-to-a-package" target="_blank">Imports relative to a package</a></li><li>urlparse / urllib 库改名 - <a href="https://pythonhosted.org/six/#module-six.moves.urllib.parse" target="_blank">six</a></li><li>thread 包改名，而且 <code>get_ident</code> 函数不再存在了。将 <code>thread.get_ident()</code> 改为 <code>threading.current_thread().ident</code> <a href="https://pythonhosted.org/six/#module-six.moves" target="_blank">six</a></li><li><code>basestring</code> 类型不再存在，用 <code>six.string_types</code> 代替 <a href="http://python-future.org/compatible_idioms.html#basestring" target="_blank">sheet</a></li><li><code>__metaclass__</code> 不再存在，用 <code>six.add_metaclass</code> 代替 <a href="http://python-future.org/compatible_idioms.html#metaclasses" target="_blank">sheet</a></li><li><code>UserDict.DictMixin</code> 不再存在，用 <code>collections.Mapping</code> 或者 <code>collections.MutableMapping</code> 代替</li><li><code>/</code> 现在是真的除法了，也就是说 int / int 会得到一个 float，使用 <code>//</code> 获得地板除效果（由于在 python 中，地板除用得少，实际上不改关系不大） <a href="http://python-future.org/compatible_idioms.html#division" target="_blank">sheet</a></li><li><code>StringIO</code> 现在分为 <code>io.BytesIO</code> 和 <code>io.StringIO</code> 视情况使用</li><li>print 现在是一个 function 了 <a href="http://python-future.org/compatible_idioms.html#stringio" target="_blank">sheet</a></li><li><code>unicode</code> 关键字不再存在 使用 <code>six.text_type</code> 代替</li><li><code>__builtins__</code> 不存在了，<a href="https://pythonhosted.org/six/#module-six.moves" target="_blank"><code>six.moves.builtins</code></a> <a href="http://python-future.org/compatible_idioms.html#unicode-text-string-literals" target="_blank">sheet</a></li><li><code>reload</code> 改为 <a href="https://pythonhosted.org/six/#module-six.moves" target="_blank"><code>six.reload_module</code></a></li><li>dict 的 <code>keys</code>， <code>items</code>， <code>values</code> 现在都是迭代器了，不返回列表，原来的 <code>iteritems</code>, <code>itervalues</code> 不再存在，使用 <a href="https://pythonhosted.org/six/#six.iterkeys" target="_blank">six.iterkeys</a> 等函数代替。</li><li><code>raise exc_type, exc_value, tb</code> 的形式不再支持，使用 <code>six.reraise(exc_type, exc_value, tb)</code> 代替。</li></ul><p>其他的例如 try…catch，如果你在 Python 2 中就比较标准地使用 <code>as</code>，那么这时就不用修改了。</p><p>另外，如果你和我一样有 str(object) 来获得 object 的文字结果的习惯话，每次写 <code>six.text_type(object)</code> 太长了。可以写一些兼容性函数，然后在整个项目中使用。</p><p>注意到这里，我们并没有处理 <code>bytes</code>, <code>string</code>, <code>unicode</code>，请放下他们，我们在下一节处理这些问题。</p><h2><a href="https://binux.blog/2014/12/porting-to-python-3/#第二步——处理-unicode"></a>第二步——处理 unicode</h2><p>由于在 Python 3 中，所有的 <code>'text'</code> 都变成 unicode 了，所以你会觉得它会是一个大问题，是否需要给所有的 <code>'text'</code> 加上 <code>u</code> ，或者干脆所有文件都加上 <code>from __future__ import unicode_literals</code>？</p><p>实际上，大部分时候不需要。</p><p>在 Python 2 中，我们很少有意识地区分 <code>str</code> 和 <code>unicode</code>，对于大部分函数调用来说，给它 <code>str</code> 或者 <code>unicode</code> 都是一样的，因为他们共享大部分行为。但是在 Python 3 中，<code>bytes</code> 和 <code>str</code>(<code>unicode</code>) 却大不一样。例如当你 <code>for c in bytes</code> 时，得到的是一个 <code>int</code> 而不是一个 <code>str</code>。</p><p>虽然不做任何修改，<code>'text'</code> 在 Python 2 中，是 <code>str</code>(<code>bytes</code>)，而在 Python 3 中是 <code>str</code>(<code>unicode</code>)。但是提交给函数时，既然 Python 2 的函数同时支持 <code>str</code> 和 <code>unicode</code>，所以没有任何问题。而且，在 Python 2 中，<code>'text'+u'中文'</code> 会自动升级为 <code>unicode</code>，所以，只需要注意在出现中文的地方使用 <code>u'中文'</code> 就好了（即使在 Python 2 中，这也是一个好的习惯）。而 <code>b'bytes'</code> 的场合非常少，更多的是使用 <code>text.encode</code> 进行转换。所以，对于习惯良好的 Python 2 代码来说，是几乎不需要修改的。</p><p>除了源代码之中的 unicode 问题，其他主要问题出现在输入输出上。但是，只要遵循：程序中流通的数据，只能是 unicode。数据进来之后必须转换成 unicode 即可。</p><h2><a href="https://binux.blog/2014/12/porting-to-python-3/#最后"></a>最后</h2><p>运行测试，哪报错改哪就好了。</p>]]></content>
        
        <summary type="html">
            
            使用 Python 3 的呼声一直很高，Python 3 解决了很多 2 中的坑，比如 unicode，在向他们解释为什么 print str 乱码，fp.write(str) 时报错，在什么时候需要 encode，更容易了。但是由于一开始接触的就是 Python 2，熟悉的包
            
        </summary>
        
        <category term="python"/>
        
        <category term="porting"/>
        
    </entry>
    
    <entry>
        <title>学术讲座通知</title>
        <link href="http://www.pris.net.cn/archives/2552"/>
        <id>http://www.pris.net.cn/archives/2552</id>
        
        <author>
            <name>马 占宇</name>
        </author>
        
        <published>2014-12-08T20:17:50+00:00</published>
        <updated>2014-12-08T20:17:50+00:00</updated>
        
        <content type="html"><![CDATA[<p>香港中文大学的Tan Lee副教授和Ken Ma副教授应高等智能与网络服务111引智基地的邀请，将于12月15日来北邮作学术报告。欢迎有兴趣的师生踊跃参与。</p>
<p><strong>报告一：</strong></p>
<p><strong>题目：</strong><strong>Unsupervised Acoustic Modeling for Spoken Language Applications </strong></p>
<p><strong>主讲人：</strong><strong>Tan Lee </strong><strong>副教授</strong></p>
<p><strong>主持人：王小捷</strong> <strong>教授</strong></p>
<p><strong>时间：</strong><strong>2014</strong><strong>年</strong><strong>12</strong><strong>月</strong><strong>15</strong><strong>日（星期一）上午</strong><strong>9:00-10:00</strong></p>
<p><strong>地点：</strong><strong>教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>报告摘要：</strong></p>
<p>Acoustic modeling is an important problem in many spoken language applications. It aims at providing compact yet accurate statistical representations for a set of sub-word units. Conventional acoustic modeling is a highly supervised process that requires plenty of speech data with transcriptions. Such resources may not be available for many languages and in many real-world situations. In this lecture, a new framework of unsupervised acoustic modeling is presented. Different types of posterior features are proposed as segment representations. Spectral clustering algorithms are applied to group short speech segments into phone-like units. The resulted acoustic models can be used in many spoken language applications, including spoken term detection, language recognition, and topic identification.</p>
<p><strong>主讲人简介：</strong></p>
<p>Tan Lee is an Associate Professor at the Department of Electronic Engineering, the Chinese University of Hong Kong (CUHK). He has been working on speech and language related research since early 90s. His works cover many different areas, including automatic speech and speaker recognition, text-to-speech, speech enhancement, language identification, pathological speech analysis, hearing and speaking aids, and music signal processing. Tan Lee initiated and coordinated a number of pioneering projects on the research and development of Chinese spoken language technologies in Hong Kong. He led 8 projects funded by the General Research Funds (GRF) from the Hong Kong Research Grants Council (RGC). Tan Lee works closely with medical doctors, and speech and hearing professionals, in applying signal processing techniques to human communication disorder problems. He is the Director of the newly established Language and Communication Disorders Research Laboratory at CUHK Shenzhen Research Institute. Tan Lee was the Chairman of the IEEE Hong Kong Chapter of Signal Processing in 2005-2006. He is an associate editor of the EURASIP Journal on Advances in Signal Processing. Tan Lee received the CUHK Vice-Chancellor’s Exemplary Teaching Award in 2004.</p>
<p><strong>报告二：</strong></p>
<p><strong>题目：</strong><strong>Hyperspectral Unmixing in Remote Sensing: What Do Signal Processing People Learn from There? </strong></p>
<p><strong>主讲人：</strong><strong>Ken Ma</strong><strong>副教授</strong></p>
<p><strong>主持人：马占宇</strong></p>
<p><strong>时间：</strong><strong>2014</strong><strong>年</strong><strong>12</strong><strong>月</strong><strong>15</strong><strong>日（星期一）上午</strong><strong>10:00-11:00</strong></p>
<p><strong>地点：</strong><strong>教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>报告摘要：</strong></p>
<p>The aim of this talk is to overview hyperspectral unmixing (HU) techniques from a signal processing researcher’s perspective. HU is one of the most prominent research topics in hyperspectral remote sensing. The problem is to identify materials and their corresponding compositions in a captured scene, using the high spectral degrees of freedom of hyperspectral sensors. From a signal processing viewpoint, this is a blind source separation (BSS) problem. We will review how clever insights from remote sensing researchers and recent involvements from other fields, such as signal processing, optimization and machine learning, lead to elegant HU theory and methods – which depart quite significantly from conventional BSS techniques, and in fact, give new insights to BSS theory and methods. The connections of HU to other areas, such as text mining, biomedical imaging and computer vision, may also be discussed, depending on the availability of time.</p>
<p><strong>主讲人简介：</strong></p>
<p>Wing-Kin (Ken) Ma is currently an Associate Professor with the Department of Electronic Engineering, The Chinese University of Hong Kong. His research interests are in signal processing and communications, with recent activities focused on optimization, MIMO transceiver designs and interference management, blind signal processing theory, methods and applications.</p>
<p>Dr. Ma is active in the Signal Processing Society. He is currently serving or has served Associate Editor and Guest Editor of several journals, which include IEEE Transactions on Signal Processing, Signal Processing, IEEE Journal of Selected Areas in Communications and IEEE Signal Processing Magazine. He is a Member of the Signal Processing Theory and Methods (SPTM) Technical Committee. His students won ICASSP Best Student Paper Awards in 2011 and 2014, respectively. He was a tutorial speaker of EUSIPCO 2011 and ICASSP 2014, respectively.</p>]]></content>
        
        <summary type="html">
            
            香港中文大学的Tan Lee副教授和Ken Ma副教授应高等智能与网络服务111引智基地的邀请，将于12月15日来北邮作学术报告。欢迎有兴趣的师生踊跃参与。 报告一： 题目：Unsupervised Acoustic Modeling for Spoken Language A
            
        </summary>
        
        <category term="PRIS快讯"/>
        
        <category term="学术快讯"/>
        
    </entry>
    
    <entry>
        <title>pyspider介绍</title>
        <link href="https://binux.blog/2014/11/introduction-to-pyspider/"/>
        <id>https://binux.blog/2014/11/introduction-to-pyspider/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>虽然已经发过一篇<a href="http://blog.binux.me/2014/02/pyspider-architecture/" target="_blank">架构设计</a>，但是觉得还是有必要发一篇介绍。而且拖了那么久的第二里程碑的commit数已经超过第一个版本了。。</p><p>那么由我再次介绍一下 pyspider。</p><h1><a href="https://binux.blog/2014/11/introduction-to-pyspider/#缘起"></a>缘起</h1><p>pyspider 来源于以前做的一个垂直搜索引擎使用的爬虫后端。我们需要从200个站点（由于站点失效，不是都同时啦，同时有100+在跑吧）采集数据，并要求在5分钟内将对方网站的更新更新到库中。</p><p>所以，灵活的抓取控制是必须的。同时，由于100个站点，每天都可能会有站点失效或者改版，所以需要能够监控模板失效，以及查看抓取状态。</p><p>为了达到5分钟更新，我们使用抓取最近更新页上面的最后更新时间，以此来判断页面是否需要再次抓取。</p><p>可见，这个项目对于爬虫的监控和调度要求是非常高的。</p><h1><a href="https://binux.blog/2014/11/introduction-to-pyspider/#pyspider-的主要特性"></a>pyspider 的主要特性</h1><ul><li>python 脚本控制，可以用任何你喜欢的html解析包（内置 pyquery）</li><li>WEB 界面编写调试脚本，起停脚本，监控执行状态，查看活动历史，获取结果产出</li><li>支持 MySQL, MongoDB, SQLite</li><li>支持抓取 JavaScript 的页面</li><li>组件可替换，支持单机/分布式部署，支持 Docker 部署</li><li>强大的调度控制</li></ul><p>由于功能太多，更多请参考<a href="https://github.com/binux/pyspider/wiki/%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97" target="_blank">脚本编写指南</a></p><p>感谢 <a href="https://plus.google.com/u/0/+PhoenixNemo/" target="_blank">+PhoenixNemo</a> 提供的VPS，提供了一个 demo： <a href="http://demo.pyspider.org/" target="_blank">demo.pyspider.org</a>。无需安装即可体验。</p><p><a href="http://demo.pyspider.org/" target="_blank"><img src="http://ww1.sinaimg.cn/large/7d46d69fjw1emavy6e9gij21kw0uldvy.jpg" /></a></p><h1><a href="https://binux.blog/2014/11/introduction-to-pyspider/#脚本样例"></a>脚本样例</h1><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /><span>6</span><br /><span>7</span><br /><span>8</span><br /><span>9</span><br /><span>10</span><br /><span>11</span><br /><span>12</span><br /><span>13</span><br /><span>14</span><br /><span>15</span><br /><span>16</span><br /><span>17</span><br /><span>18</span><br /><span>19</span><br /><span>20</span><br /></pre></td><td><pre><span><span>from</span> libs.base_handler <span>import</span> *</span><br /><span></span><br /><span><span><span>class</span> <span>Handler</span><span>(BaseHandler)</span>:</span></span><br /><span>    <span>'''</span></span><br /><span><span>    this is a sample handler</span></span><br /><span><span>    '''</span></span><br /><span><span>    @every(minutes=24*60, seconds=0)</span></span><br /><span>    <span><span>def</span> <span>on_start</span><span>(self)</span>:</span></span><br /><span>        self.crawl(<span>'http://scrapy.org/'</span>, callback=self.index_page)</span><br /><span></span><br /><span><span>    @config(age=10*24*60*60)</span></span><br /><span>    <span><span>def</span> <span>index_page</span><span>(self, response)</span>:</span></span><br /><span>        <span>for</span> each <span>in</span> response.doc(<span>'a[href^="http://"]'</span>).items():</span><br /><span>            self.crawl(each.attr.href, callback=self.detail_page)</span><br /><span></span><br /><span>    <span><span>def</span> <span>detail_page</span><span>(self, response)</span>:</span></span><br /><span>        <span>return</span> {</span><br /><span>                <span>"url"</span>: response.url,</span><br /><span>                <span>"title"</span>: response.doc(<span>'title'</span>).text(),</span><br /><span>                }</span><br /></pre></td></tr></table><p>例如这就是创建任务后默认生成的一个脚本示例。</p><ul><li>通过 <code>on_start</code> 回调函数，作为爬取的入口点，当点击主面板上的 <code>run</code> 的时候，就是调用这个函数，启动抓取。</li><li><code>self.crawl</code> 告诉调度器，我们需要抓取 <code>'http://scrapy.org/'</code> 这个页面，然后使用 <code>callback=self.index_page</code> 这个回调函数进行解析。</li><li>所有 <code>return</code> 的内容默认会被捕获到 <code>resultdb</code> 中，可以直接在 WEBUI 上看到。</li></ul><h1><a href="https://binux.blog/2014/11/introduction-to-pyspider/#更多特性和文档"></a>更多特性和文档</h1><ul><li><a href="https://github.com/binux/pyspider/wiki" target="_blank">Wiki</a></li><li><a href="https://github.com/binux/pyspider/wiki/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97" target="_blank">快速指南</a></li><li><a href="https://github.com/binux/pyspider/wiki/%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97" target="_blank">脚本编写指南</a></li></ul>]]></content>
        
        <summary type="html">
            
            虽然已经发过一篇架构设计，但是觉得还是有必要发一篇介绍。而且拖了那么久的第二里程碑的commit数已经超过第一个版本了。。那么由我再次介绍一下 pyspider。缘起pyspider 来源于以前做的一个垂直搜索引擎使用的爬虫后端。我们需要从200个站点（由于站点失效，不是都同时
            
        </summary>
        
        <category term="python"/>
        
        <category term="javascript"/>
        
        <category term="crawler"/>
        
        <category term="opensource"/>
        
    </entry>
    
    <entry>
        <title>学术讲座通知</title>
        <link href="http://www.pris.net.cn/archives/2399"/>
        <id>http://www.pris.net.cn/archives/2399</id>
        
        <author>
            <name>马 占宇</name>
        </author>
        
        <published>2014-10-16T19:26:31+00:00</published>
        <updated>2014-10-16T19:26:31+00:00</updated>
        
        <content type="html"><![CDATA[<p>瑞典计算机科学学院(SICS-Swedish Institute of Computer Science) 的Anders Lindgren和Fehmi Ben Abdesslem博士应高等智能与网络服务111引智基地的邀请，将于10月22日来北邮作学术报告。欢迎有兴趣的师生踊跃参与。</p>
<p><strong>报告一：</strong></p>
<p><strong>题目：</strong><strong>Keeping it real – The importance of experiencing and understanding real mobile network environments </strong></p>
<p><strong>主讲人：</strong><strong>Anders Lindgren</strong><strong>研究员</strong></p>
<p><strong>主持人：马占宇</strong></p>
<p><strong>时间：</strong><strong>2014</strong><strong>年</strong><strong>10</strong><strong>月</strong><strong>22</strong><strong>日（星期三）上午</strong><strong>10:00-11:00</strong></p>
<p><strong>地点：</strong><strong>教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>主讲人简介：</strong></p>
<p>Dr. Anders Lindgren is a senior researcher at SICS Swedish ICT and an adjunct lecturer at Luleå University of Technology. He received his Ph.D. from Luleå University of Technology in 2006, and worked as a postdoctoral researcher at University College London and University of Cambridge. His research interests include opportunistic and information-centric networking, communication and computation in challenged environments, efficient IoT, and big data analytics for mobile networks.</p>
<p><strong>报告摘要：</strong></p>
<p>Over the past decade, mobile networking has seen an explosive growth, in particular with the introduction of smart-phones. This is creating incredible new opportunities for users to stay connected and utilize our connected society in their daily life. It does however also come with problems as operator networks become overloaded, without operators necessarily understanding exactly how their customers will use the network. Furthermore, it also comes with the risk of further increasing the digital divide between the rich and poor parts of the world, as some societal services will only be available to those with access to connectivity.</p>
<p>In this talk, I will focus on the importance of keeping it real, and not solely design networks based on synthetic models and simulations. Through examples from real deployments, field experiences, and network measurements, I will show some examples of what users really want in different scenarios and this can be realized even in challenged scenarios.</p>
<p>Mobile networks span a very wide range of scenarios and use cases, and I will focus at some particular scenarios at the extreme ends of this spectrum. I will explain how they differ and are similar to more common situations, and discuss why it is important to understand the specific characteristics of these situations and how they affect network design. In particular, I will look at the following two scenarios based on previous personal experience:</p>
<p>– What can be done for users that do not have access to reliable (or low-capacity) communication infrastructure? I will explain some existing technical solutions for providing network access to people living outside the rich and well-connected parts of the world, and will, most importantly, explain the importance of properly understanding the target user groups in order to create good network designs.</p>
<p><strong>报告二：</strong></p>
<p><strong>题目：</strong><strong>Big Data in Computer Networks – From Mobile Devices to The Internet of Things </strong></p>
<p><strong>主讲人：</strong><strong>Fehmi Ben Abdesslem</strong><strong>研究员</strong></p>
<p><strong>主持人：乔媛媛</strong></p>
<p><strong>时间：</strong><strong>2014</strong><strong>年</strong><strong>10</strong><strong>月</strong><strong>22</strong><strong>日（星期三）上午</strong><strong>11:00-12:00</strong></p>
<p><strong>地点：</strong><strong>教三楼</strong><strong>811</strong><strong>会议室</strong></p>
<p><strong>主讲人简介：</strong></p>
<p>Dr Fehmi Ben Abdesslem received his M.Sc and PhD from the University of Paris 6 in 2008, before working as a research associate at the University of St Andrews, and at the University of Cambridge. He has then been awarded a Marie-Curie research fellowship from the European Commission (ERCIM) to join SICS, and is now a permanent Senior Research Scientist at the Decisions Networks and Analytics laboratory.</p>
<p><strong>报告摘要：</strong></p>
<p>Big data is nowadays a common term regularly appearing in the news as part of our every day life. Large amounts of data are constantly collected, stored and analysed. In this presentation, we will first explain and discuss this trend before highlighting the research challenges in computers networks. We will then describe an example of big dataset collected from mobile phones, and show the applications of analysing such datasets. Finally, we will provide a short introduction about the potential benefits of the big data generated by the Internet of things.</p>]]></content>
        
        <summary type="html">
            
            瑞典计算机科学学院(SICS-Swedish Institute of Computer Science) 的Anders Lindgren和Fehmi Ben Abdesslem博士应高等智能与网络服务111引智基地的邀请，将于10月22日来北邮作学术报告。欢迎有兴趣的师生踊
            
        </summary>
        
        <category term="PRIS快讯"/>
        
        <category term="学术快讯"/>
        
    </entry>
    
    <entry>
        <title>钉子的谜之 SETUP</title>
        <link href="http://blog.dimpurr.com/setup-2014/"/>
        <id>http://blog.dimpurr.com/setup-2014/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-10-02T14:20:51+00:00</published>
        <updated>2014-10-02T14:20:51+00:00</updated>
        
        <content type="html"><![CDATA[<p>高中充实的有点过了头。基本每天都满满的有事干，平常周末也几乎在上课和作业中一晃而过。即使勉强能算可以自由支配的长假，也总是因为这样那样的事情，连想回来码下项目或者维护下博客都做不到。</p>
<p>…… 还是要学习好好的珍惜时间呢。</p>
<p>那么，先趁这个国庆来介绍一下我的设备栈吧。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0004_8.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0004_8-600x338.jpg" /></a><p>书桌大合照 (XPERIA Z1 用于拍照)</p></div>
<p><span></span></p>
<h3><a href="www.apple.com/cn/macbook-pro/" target="_blank">MacBook Pro</a> with Retina 15` (港行 Mid 2014, 16GB x 256GB)</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0014_4.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0014_4-600x338.jpg" /></a><p>MacBook Pro with Retina 15` &amp; Haier Extended Display</p></div>
<p>对我来说 MBP 给生产力带来的最直接影响是因为配置，然后才是 OS X。</p>
<p>毕竟 16GB 的内存保证了 Parallels 虚拟的 Windows 8.1 可以一直挂在后台都不会有影响，同时 UNIX 终端仍然那么熟悉 (iTerm2 + ZSH) 。作为一只跨三系统生存党，先不说本来很多解决方案就已经是妥妥的跨平台了，方便的集三系统为一身的 OS X 工作流迁移更是各种无压力。调试一下 LAMP (MAMP)，打打心绮楼 (Wine / Parallels)，重启都免了是吧。</p>
<p>哦对了，对一只视觉动物来说， OS X 真的漂亮，水果真的能改变你的来福式戴尔 (Life Style)。</p>
<p>屏幕是之前卡到不行的 Haier PC (轰天雷 T5, Core i3 二代, 4GB x 2.5TB) 留下来的， 21` 外接起来还是很酸爽，屏幕下面那个大白块就是 DisplayPort 转接器，这里用的 HDMI 线。嗯，可以看得出我的 MBPr 日常其实就是当个主机，偶尔当移动工作站用的，所以选择了大屏大容量版本。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/2014-10-02-下午8.15.00.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/2014-10-02-下午8.15.00-600x375.png" /></a><p>LaunchPad</p></div>
<h3><a href="http://store.apple.com/cn/product/MB110CH/B/%E9%85%8D%E6%9C%89%E6%95%B0%E5%AD%97%E5%B0%8F%E9%94%AE%E7%9B%98%E7%9A%84-apple-keyboard" target="_blank">Apple Keyboard with Numeric Key</a></h3>
<p>…… 这是我家第一个水果产品，第二个就是 MBPr 。是的，所以我才一直不是个果粉。</p>
<p>买不起机械键盘装逼，而且知乎上说手感确实不错，于是入了（而且当时还以为过段时间会买垃圾桶的，现在想想真是 So Naive）。嘛，虽然给台式机用巧克力（孤岛？）键盘感觉有点怪怪的，但是的确手感不错。另外，当时要换键盘的真实理由是原来的键盘响声太大，不适合偷偷敲代码，于是你们懂了。</p>
<h3><a href="http://www.microsoft.com/hardware/zh-cn/p/sculpt-comfort-mouse" target="_blank">Microsoft Sculpt Comfort Mouse</a></h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0009_8.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0009_8-600x338.jpg" /></a><p>Microsoft Sculpt Comfort Mouse</p></div>
<p>手感其实也就那样，不过对于各种水平介质适应性特别好，蓝牙距离也长，在客厅控制被当成机顶盒的 MBPr 时很好用。是的，这个就是在 MBPr 的经销商那入的。</p>
<p>那个带触摸的 Windows 徽标键用 BetterTouchTool 设置成了双击 Alfred，上滑 Mission Control 下滑 LaunchPad 。</p>
<h3><a href="http://www.sonymobile.com/cn/products/phones/xperia-z1/" target="_blank">Sony XPERIA Z1</a> (国行 L39h, 5`, 2GB x 16GB + 64GB, 5`)</h3>
<p>简直是个尤物，我只能这样说。美得令人窒息。索尼大法好。</p>
<p>其实一开始我只是在 2k 的价位上下选机，最后还是因为亚马逊上没有 HTC ONE M8 的非定制版和 One Plus One 64GB 缺货才忍痛超了三百预算入了当时 2k6 的大法。然后摸到机器我感动的哭了。</p>
<p>说实话要不是我为了 Root (官方 4.2 以上不能 Root) 作死刷了个不太稳定的第三方 Rom 不然简直流畅的飞起。仅有的几个缺点是，跑大游戏偶尔会烫，因为薄，真的是由内而外的酸爽；还有算不上大问题的我个人不是很喜欢超过 4.5` 的手机。</p>
<p>噢噢噢噢噢 XPERIA UI 实在太美你造嘛！ Android 体验十分完整同时又不失清新字体渲染特别漂亮内置主题系统也很给力简直见不到更好的厂家定制 UI 了噢噢噢噢！(曾经我更喜欢 Flyme 2，可惜 Flyme 3 已经从 Android UI 叛变到 iOS 8 Style 了 ……)</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/IMG_20141002_205608.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/IMG_20141002_205608-600x450.jpg" /></a><p>主屏</p></div>
<p>和 Miku 酱实在太配了。毕竟 XPERIA 的基因那样的适合 Hatsune Miku 纪念版。壁纸是「八王子P feat.初音ミク – Electronic Love」的专辑封面，入了正版 CD，扫图中能看出油墨颗粒反而增加了酷炫感。</p>
<p>对了，如果你在这张图里看到了像素颗粒，那只是因为母上的 Lenovo A789t 相机实在太渣。拍不出那种美哭的质感，很遗憾。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/IMG_20141002_205402.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/IMG_20141002_205402-600x450.jpg" /></a><p>自带底座</p></div>
<p>虽然 PPI 算不上特别高，但是总体来说屏幕还是很赞，靓丽舒服。玻璃也相当硬朗耐划，这手感实在不忍心贴膜啊。平常只要往上一按就可以充电了，比插线方便一些，看视频时也很实用。另外那个 Widget 是 Google Now 。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/IMG_20140709_130627.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/IMG_20140709_130627-600x450.jpg" /></a><p>奇葩的 CE 标识位置</p></div>
<p>这块大 G 摄像头也是一个意外惊喜，高达 2240 万像素，继承了索大相机的优良血统，还真不是随便个应用能驱动的起的。所以自然内置的相机应用可以和市场上所有主流卡片机媲美，特效各种好玩。那个 N 的标识是所谓的 Sony 醇音技术，虽然我觉得开起来比不开音质要差 ……</p>
<p>对了，如果你在这张图里看到了抖动，那只是因为我原来那部 Lenovo A789 相机实在太渣。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-02-19-08-05.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-02-19-08-05-563x1000.png" /></a><p>主页</p></div>
<p>主题名字叫 Tri Flat ，基于内置 XPERIA 主题 系统，在 Play 市场发现的。略骚，要是机器是紫色款的话就更骚了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-02-19-08-52.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-02-19-08-52-563x1000.png" /></a><p>锁屏</p></div>
<p>锁屏。 4.3 以上 XPERIA 经典的百叶窗解锁动画没了挺可惜，不过有锁屏密码的话都差不多。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-01-18-47-27.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-10-01-18-47-27-563x1000.png" /></a><p>版本</p></div>
<p>Rom 是机锋论坛的 EXR.Ming 。当然 XPERIA Xposed 什么的是必备的。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-09-07-22-41-25.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-09-07-22-41-25-563x1000.png" /></a><p>Sony 生活轨迹</p></div>
<p>这个生活轨迹应用也是挺好玩的，记录应用历史的功能有点像简略版的 RescueTime ，不过详细的生活数据要配合 Sony SmartWatch 才记录的到睡眠时间这些。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-07-23-15-14-47.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screenshot_2014-07-23-15-14-47-563x1000.png" /></a><p>PowerAMP</p></div>
<p>壮哉我大 PowerAMP 。不过唯一值得吐槽的一点是网站购买和 Play 购买的程序是两个版本，结果有时候不小心从 Play 更新了得卸了从官网重下并激活。</p>
<h3><a href="http://www.philips.com.cn/c/mobile-phone/mobile-phone-cte1300bk_40/prd/" target="_blank">Philips E130</a></h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0006_9.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0006_9-600x338.jpg" /></a><p>Philips E130</p></div>
<p>为了高中我也是挺拼的。</p>
<p>只要 130¥ ，30 万像素相机， MP3 播放器， FM 收音机，广场舞级超大声音响，WAP 浏览器，没错你没有听错，全部集于这个可以从三楼扔下去毫发无损的超轻迷你机身中！</p>
<p>…… 从这个价位和定位来说，确实是相当可以的机子了。相当价格的诺基亚神机 1080 还完全没有网络收音等功能呢，不过这机子确实上下网就挺不过三天。不过 WAP 浏览器的解析实在太弱，也不支持 Cookie ，在下不怎么看小说，平常除了查下资料基本没什么用处 …… 果然还是安心学习吧。</p>
<h3><a href="http://www.colorfly.net/ch/product_index_c3.html" target="_blank">Colorfly C3</a> (16GB + 32GB)</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0008_9.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0008_9-600x338.jpg" /></a><p>Colorfly C3 (16GB)</p></div>
<p>我只能说音质绝对横扫 500¥ 价位的一切号称 Pocket Hifi 的播放器，甚至媲美相当不错的电脑声卡，只是功能目测百元级的 MP3 都能横扫。两行屏幕只能放歌 TXT 都读不了倒是挺正常，但是你没队列，没睡眠定时，触摸还各种抽风等等怎么解释 ……</p>
<p>总体来说输出还是中规中矩，不同音域的风格化增强基本交给了耳机。对新格式的支持也不是很好，还好我的曲库都统一整理成 FLAC 了。对音质之外没什么要求的话这是个性价比很高的选择。</p>
<h3><a href="http://shop.sennheiser.com.cn/ProductDetail/CX300-IIPrecisionBlack_38.html" target="_blank">Sennheiser CX300 II</a></h3>
<p>声道剥离感人，立体混响美哭，<del>耳扒谱子必备，</del>人声解析带感。不过这还真的妥妥的是个高音耳机，听电音的时候那个沙拉沙拉轰隆轰隆，真的能听到头晕，低音也有点薄。从 300¥ 的价位和我个人的听歌偏好来说还是物有所值了。</p>
<p>拿 XPERIA Z1 推的时候人声也会特别薄，通透感倒是挺不错。至于拿 MBPr 推时低音就全部出来了，相当醇。</p>
<h3>Skyworth Coocaa E83RS (Android 2.3)</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/DSC_0017_4.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/10/DSC_0017_4-600x338.jpg" /></a><p>Skyworth Coocaa E83RS</p></div>
<p>呵呵呵这个酷开市场在我们把电视买回来的那天开始就没更新过。真是傻了才贪便宜没入 4.0 的智能电视，搞得我好不容易越狱了还连 Bilibili 客户端都安不了。不过平心而论，内置的浏览器倒是挺好用，当然支持 Flash 。</p>
<p>硬件上诚意倒是很足，支持 3D 不说还送了个低音炮。自入了 MBPr 之后这货终于焕发了第二春，HDMI 接上之后就可以当机顶盒用了。躺在沙发上拿无线鼠标简单操控一下，刷刷新闻看看弹幕，赞。</p>
<h3><a href="http://h10025.www1.hp.com/ewfrf/wc/product?cc=cn&amp;dlc=zh-hans&amp;lc=zh-hans&amp;product=391174" target="_blank">HP Officejet 7208 All-in-One Printer</a></h3>
<p>我也不清楚这是0几年的东西了，不过卡纸或者一次进多张已经各种家常便饭，双面打印简直是噩梦。不过自带扫描还是真心方便，至少各种设计图纸扫进去比拍照清新多了。 HP 自带的软件套件也不错，就是在 Mac 下 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/10/Screen-Shot-2014-08-22-at-9.18.16-PM.png"><img src="http://img1.dimpurr.com/dimblog/2014/10/Screen-Shot-2014-08-22-at-9.18.16-PM-600x375.png" /></a><p>HP 你给我死一万年</p></div>
<p>最后还是想说一句，在下不是壕。我的电脑确实是我们全家除了桌子以外最壕的地方 …… 但是现在对我来说，我宁肯花 5 元去淘宝买个 Windows 8 Key ，甚至购买某些相对便宜的软件的正版，也不愿意花两个小时去找破解办法。我也曾经浪费了一年为了找几个免费空间和域名，现在想起来各种后悔。</p>
<p>因为你的时间值钱，你会用这些时间把你的时间变得更值钱。</p>
<p>…… 咱也是接了那么几单，赚了点小钱，父母才稍微愿意支持咱的 ……</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/setup-2014/">钉子的谜之 SETUP</a></p>]]></content>
        
        <summary type="html">
            
            高中充实的有点过了头。基本每天都满满的有事干，平常周末也几乎在上课和作业中一晃而过。即使勉强能算可以自由支配的长假，也总是因为这样那样的事情，连想回来码下项目或者维护下博客都做不到。 …… 还是要学习好好的珍惜时间呢。 那么，先趁这个国庆来介绍一下我的设备栈吧。 书桌大合照 (
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="Android"/>
        
        <category term="Apple"/>
        
        <category term="Colorfly"/>
        
        <category term="Mac"/>
        
        <category term="Microsoft"/>
        
        <category term="Setup"/>
        
        <category term="Sony"/>
        
        <category term="XPERIA"/>
        
        <category term="设备"/>
        
        <category term="音乐"/>
        
    </entry>
    
    <entry>
        <title>签到 —— qiandao.today 介绍</title>
        <link href="https://binux.blog/2014/09/introduction-to-qiandao-today/"/>
        <id>https://binux.blog/2014/09/introduction-to-qiandao-today/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p><a href="https://qiandao.today/" target="_blank">qiandao.today</a> 已经上线了一个半月，这篇blog一个半月以前就应该写了。直到我刷了14遍水晶塔没有ROLL到任何装备（不对，我最后通过贪婪ROLL到了！），打了两晚麻将，把把最小胡牌距离大于5（任意更换手牌达到胡牌的最小张数），房子里刷JJ怪之后。我觉得我必须做点什么。。。</p><p>好了，不扯蛋了。自动签到是我对于 “如何请求到数据” ，进行请求自动分析的一个尝试（实际是我 <a href="http://u2.dmhy.org/" target="_blank">U2</a> 因为45天没登录被封了）。通过<strong>浏览器捕获页面请求瀑布流，进行内容/请求分析，找出关键请求</strong>。所以，签到这个项目，我就是先从 <a href="https://qiandao.today/har/edit" target="_blank">HAR编辑器</a> 开始做的。做的时候还玩了一下 <a href="http://angularjs.org/" target="_blank">angularjs</a>。<del>然后其他部分都是随便写的</del></p><p>但是，对于签到来说，哪些请求是必要的，这个请求是怎么组装的（例如 token 参数怎么来），特征不明显。自动分析出来就能直接用的概率太低了，即使是人还得单步测试呢。于是 HAR编辑器 成为编辑和单步调试的辅助。自动分析变成了 “推荐相关请求”。</p><ul><li>用户部分系统尝试了一下 <a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank">PBKDF2</a> 进行密码加密。PBKDF2 的优势在于通过随机盐 加 可配置的多轮加密，加大了单个key的运算代价。</li><li>模板执行部分通过提取页面信息，和 jinja2 引擎渲染，可以动态地改变请求的 url、header、data 各个部分。</li><li>执行断言加上邮件系统，可以检测签到是否成功，在失败的时候给用户发送邮件提醒。</li></ul><p>本来还想要做互助打码的验证码系统的，但是通过 <a href="https://plus.google.com/u/0/+%E9%9B%AA%E6%9C%88%E7%A7%8B%E6%B0%B4%E9%85%B1" target="_blank">雪月秋水</a> 的 <a href="https://github.com/acgotaku/GetCookies" target="_blank">cookie插件</a>，其实大部分只有登录需要验证码，签到并不需要。<del>关键是做这个东西不好玩</del>，于是就算了。</p><p>运行了一个半月，目前有11个公开签到模板，400+个签到任务，每天进行300次签到。不过由于担心单IP登录帐号过多被封，只在v2ex做了一次广告，不敢大范围推广。。。</p><hr /><p>以下是面向普通用户的简介：</p><ul><li>云代签</li><li>支持多个网站</li><li>失败邮件提醒</li><li>自制模板并分享（<a href="https://github.com/binux/qiandao/blob/master/docs/har-howto.md" target="_blank">文档</a>）</li><li>https 传输安全保证</li><li>一号一密用户数据加密</li><li>开放源码，支持本地执行（提供本地lite版）</li></ul><p>github: <a href="https://github.com/binux/qiandao" target="_blank">binux/qiandao</a><br />网站: <a href="https://qiandao.today/" target="_blank">https://qiandao.today</a></p>]]></content>
        
        <summary type="html">
            
            qiandao.today 已经上线了一个半月，这篇blog一个半月以前就应该写了。直到我刷了14遍水晶塔没有ROLL到任何装备（不对，我最后通过贪婪ROLL到了！），打了两晚麻将，把把最小胡牌距离大于5（任意更换手牌达到胡牌的最小张数），房子里刷JJ怪之后。我觉得我必须做点什
            
        </summary>
        
        <category term="qiandao.today"/>
        
    </entry>
    
    <entry>
        <title>ADC 2014 如何成为一位合格的产品策划者 – 青少年开发者大会 EVENT 14 演讲稿</title>
        <link href="http://blog.dimpurr.com/event14/"/>
        <id>http://blog.dimpurr.com/event14/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-07-20T05:30:06+00:00</published>
        <updated>2014-07-20T05:30:06+00:00</updated>
        
        <content type="html"><![CDATA[<p>转载请注明：ADC 2014 – 如何成为一位合格的产品策划者 – 青少年开发者大会演讲稿 | 钉子の次元 http://blog.dimpurr.com/event14/</p>
<blockquote><p>这是本次 EVENT 14 青少年开发者大会我的个人演讲稿。于 2014 年 7 月 20 日下午第二场。</p>
<p>PPT 源文件包下载：<a href="http://pan.baidu.com/s/1hqf57hi" target="_blank">http://pan.baidu.com/s/1hqf57hi</a></p></blockquote>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/11.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/11-600x375.png" /></a><p>Idea 开花结果：如何成为一位合格的产品策划者</p></div>
<p>诸位好，这里是陈旸，也可以称呼我 dimpurr 。零零后，初中毕业生，强迫症，多媒体设计爱好者，交互前端略懂，后端算法硬伤。</p>
<p>不过虽然自诩为一位设计师，都说巧妇难为无米之炊，美工也要码农衬嘛。这种时候团队的力量就出现了，为了实现自己的设计，组建一个有各路大神的开发团队是必不可少的。不过做项目不是来一段说写就写的代码，今天在这里就是想以 悦调 Rhytune 这个项目为例，不止讲讲一路上来产品设计的历程，更从一个创业者和管理者的角度来谈一谈怎么做到让自己的创意经受住检验。</p>
<p><span></span></p>
<h2>抓住灵感：如果苹果敢砸你，你就砍了苹果树</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/26.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/26-600x375.png" /></a><p>抓住灵感：如果苹果敢砸你，你就砍了苹果树</p></div>
<p>嗯 …… 请忽略副标题。</p>
<p>了解我的人都知道，在音乐方面我是个完完全全的强迫症。我家那块 2TB 的希捷硬盘中将近三分之一，都被我精心搜集整理、全部切割为单轨 FLAC 的无损音乐给填满了。</p>
<p>那天，此人秉承着作为一位设计师的作死天性和强迫症，为了打印用来背歌词的文档，如图所示，正在流畅地进行着 Google 搜索歌词， Pascal 脚本排列， Word 手动排版的流水线。终于在在下的简单过滤脚本不堪忍受 百度知道 和 各类歌词网站 中，造型各异、时而罗马音不加空格、时而片假名注音混杂、时而怎样怎样 …… 的歌词重负之后，咱一摔桌：为什么这些网站不能把歌词直接导出文档啊！</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/31.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/31-600x375.png" /></a><p>幻灯片3</p></div>
<p>回到我们的话题中来。前面讲的这个故事，就是一个关于发现自身需求的例子。各位一定都拥有一定程度自己解决问题的能力，比如我后来研究 lrc 转 HTML 去了 …… 这也说明了一点，就是大家所面对的问题，几乎都是确确实实没有被满足的需求。简而言之，我们生活中遇到的不便，便是绝好的 idea 来源。</p>
<p>为了这个小小的不满，本人毅然决定自己做一个提供完善的导出文档和 lrc 的歌词库，让歌词网站走向现代化、革新化，于是， Project LYRICS 就诞生了。</p>
<h2>发散思维：离开妻子在外打工多年的小明听说生了后大喜过望</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/51.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/51-600x375.png" /></a><p>幻灯片5</p></div>
<p>嗯 …… 请忽略副标题。</p>
<p>往往在我们遇到一些问题时，二逼码农的解决方法就是自己撸一段高端大气上档次的脚本，总之解决了就好。有分享精神的普通码农或许会把脚本修改一下分享出来，供相似需求的人下载使用。至于有战略眼光的伪码农真PM，会敏锐的发现市场的空缺，并且创造出好的 idea 。</p>
<p>那么上回说道，咱因为编撰歌词的麻烦萌生了做歌词库的想法。这时，我逐渐发现了我在 寻找 &gt; 聆听 &gt; 整理 音乐的过程中，还有许多地方缺乏合适的服务。例如，我寻找资源时，总要去 Google 或者 nyaa.se 等地搜索，在各大论坛水贴下载，能否为音乐做一个 萌否 那样的资源聚合服务；我总是要去 Bilibili 等视频网站寻找 MV 和 翻唱 ，能否为音乐做一个关联各类 MV 视频的 BGM 式百科 …… 于是我决定，将理想中的产品，打造成一个「歌词百科」的形式。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/61.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/61-600x375.png" /></a><p>幻灯片6</p></div>
<p>当然， UNIX 哲学中有一条是“各司其职”。换句话说，不是什么相关的功能都能添加上去的，而是经过取舍，确定出围绕一个中心的需求，最后组成一个完整的产品。</p>
<h2>虎视眈眈：竞品分析，确保有实力争一席之地</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/81.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/81-600x375.png" /></a><p>虎视眈眈：竞品分析，确保有实力争一席之地</p></div>
<p>这次请忽略 …… 对不起，这一段内容比较重要，我就不废话了。</p>
<p>做完之前的两步之后，相信一个 idea 也算是羽翼渐丰，基本成型了。对某些人来说，做到这一步，就基本可以上代码垒技术栈了。正因如此，这就成为了导致无数一腔热血的创业项目半途夭折的罪恶之源 ╮(╯-╰)╭</p>
<p>竞品分析这一步，不仅是产品设计开发中极其重要的流程，也是在正式立项之前必须做好准备的一步。你需要利用手中的媒体和搜索引擎，在浩瀚如烟的互联网上搜寻有朝一日可能和你针锋相对括号争风吃醋的现有产品。如果不幸发现某企鹅或者某数字企业已有同类产品，我只能说，差不多打道回府吧。</p>
<p>不过，如果你仍然相信你的 idea 有坚持的价值，在研究寻找相关产品时，请务必注意下这些方面：</p>
<ul>
<li>有哪些现存的同类产品？它和我们是功能性质相同，运营模式相同，用户群相同，还是几乎一模一样？</li>
<li>我的 idea 独特的地方在哪里？能作为差异化或者是噱头的设计有哪些？还有哪些没有被关注的方向？</li>
<li>我的产品能否从现有的产品中争夺一席之地？我能否提供足够的技术实力来完成设想？</li>
</ul>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/91.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/91-600x375.png" /></a><p>幻灯片9</p></div>
<p>前面说产品的心态确定为歌词百科后，我立刻调查了歌词相关的软件和网站，最终总结出我们的竞争对手主要有以下几类：</p>
<ul>
<li>现有的使用文章类 CMS 系统的歌词网站。
<ul>
<li>我们的优势是方便和可自定义的歌词显示、导出；对方的优势是完整的歌词制作生态链。因此在社区运行的早期，我们引入有经验的歌词制作用户。</li>
</ul>
</li>
<li>音乐播放器的内置歌词系统。
<ul>
<li>我们的优势是更广的受众和可导出作多种用途；对方的优势是稳定的用户群和无缝的使用体验。因此我们可以考虑推出客户端。</li>
</ul>
</li>
<li>豆瓣模式的音乐分享和鉴赏网站。
<ul>
<li>我们的优势是完善的歌曲数据和周边的服务；对方的优势是优质的内容质量和社区氛围。因此我们可以考虑通过推出认证媒体帐号等方式，扩展我们的平台，化敌为友。</li>
</ul>
</li>
</ul>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/101.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/101-600x375.png" /></a><p>幻灯片10</p></div>
<p>就像这样，在调查的过程中，逐渐完善和修改构思，当你最终可以自信的回答以上问题时，我们就可以走进下一步了。</p>
<h2>走进科学：访谈调查，将产品带向真实用户需求</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/111.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/111-600x375.png" /></a><p>走进科学：访谈调查，将产品带向真实用户需求</p></div>
<p>咳咳。大家好，我是陈旸，也可以称呼我 Dimpurr 。我是一名设计师，同时也是划时代的歌曲百科和音乐服务 悦调 Rhytune 的创始人。要说我的非凡灵感，当然是来自于平常孜孜不倦的钻研和开发，才有了这个集音乐视听、资源、百科、社交等于一身的史无前例的产品。我们一定能改写未来互联网音乐分享的篇章，为广大深度音乐用户带来福音！好吧，我已经看见台下有人准备好臭鸡蛋了 ……</p>
<p>作为项目的发起人，还通过自身的需求和市场调查，最终讲 idea 确立为一个完善的产品形态，那当然会自我感觉良好 —— 简直 Amazing 。但是自己的需求终究只是特例，如果产品推出之后，才发现设计出来的功能是风中摇曳的一朵奇葩，没有用户欢迎，那时就后悔也来不及了。</p>
<p>及时避免这种情况的办法，当然是提前接触用户，了解他们的实际情况。以下几种途径，我们可以选择最方便的方式，也可以多管齐下，达到最好的效果：</p>
<ul>
<li>对身边的人一对一访问。现实中的家人朋友，网络上的朋友，都可以通过聊天、即时通讯等方式进行对话。向他们咨询他们平常是怎么使用你的项目的同类产品的，或者简要描述下你的蓝图，听听他们的感想。
<ul>
<li>以 Project LYRICS 为例，我不仅在和朋友们介绍想法、征求意见的过程中，从身边的音乐爱好者们听到了对各种歌词网站的牢骚、对一些媒体中心设计的赞美，也从一些平常只是拿手机偶尔听听网络电台的朋友们了解到了客户端渠道的重要性。更难能可贵的是通过访问，我还得到了几位早期开发人员。</li>
</ul>
</li>
<li>在熟悉的社区里，邀请朋友回答问卷。这种时候就需要学习正确的问卷设计姿势了，简洁明了、精准明确的提出问题是要诀，对于复杂的问题不要直接让被调查者回答，而可以拆分成多个旁侧敲击的简单问题。利用熟悉社区的优势，你能更方便的获得大样本而且有价值的数据，被调查者往往也乐意配合你回答问题。
<ul>
<li>在知乎上提问，在 V2EX 上让大家谈谈自己的音乐习惯，在开源社区调查各平台的音乐客户端占有率，或许还可以了解到有趣的音乐方面的 Geek 小工具，也不失为一种做法。</li>
</ul>
</li>
<li>潜入目标用户群体。某些人本身就是因为是用户群体中的典型所以萌发的构思，这种时候就具有天然优势。如果有一部分用户你还不了解，这种时候不妨悄悄的来场谍中谍，在目标社区中研究他们的交流习惯，学习他们的模式。
<ul>
<li>Project LYRICS 的设计很大一部分得益于我一段时间的歌词组参与制作经历，这种时候就需要重回社区，温习一遍社区里的歌词制作、发布工具和渠道。你在社区里混熟了之后，还可以毫不费力的向大家推广你的产品呢。</li>
</ul>
</li>
</ul>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/121.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/121-600x375.png" /></a><p>幻灯片12</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/131.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/131-600x375.png" /></a><p>幻灯片12</p></div>
<h2>拉帮结派：不会写代码的美工不是好 PM</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/172.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/172-600x375.png" /></a><p>拉帮结派：不会写代码的美工不是好 PM</p></div>
<p>经过重重历练，你的 idea 终于百炼成钢，确定将来能经得住市场检验了，或许还已经有了初期的代码框架和开发人员。不过没有也不要急，类似 V2EX 、知乎、之前 JoyNeop 介绍的 实现 这类平台，都是你公布设想和寻求合作伙伴的好去处。类似 ADC 这样的机会，还可以将你的项目广而告之、寻找风投。</p>
<p>不过相对于公开招募，如果有个人渠道中熟悉的开发者，显然是契合度更高更利于行程团队的选择。各位的技术之路一路走来，相信也不是单打独斗，而是经过了各种社区和朋友的帮助指导。如果你真的是靠着基本砖头不借外力自学成才，我只能说，在互联网时代，你 Out 了。混社区，交朋友，是成为技术大牛，获得良好发展资源的的必经之路。</p>
<p>程序员乃产品之本，设计师乃产品之魂，PM 却是产品之师。之前那么长的篇幅，相信诸位也明白到了我想传递的另一层意思：并不是埋头写代码就能让项目成功的。作为团队，即使你对大家的技术和配合再有信心，务必去物色以为合适的产品经理或者亲自学习创业技能，才能让项目的路走的更远。作为团队的灵魂，适当的知道不同领域的基础知识对于开发的帮助也是非常大的。</p>
<p>作为一剂强心剂，再提提我之前黑过的一点，也是无数创业者日夜担惊受怕，夜不能寐的一个威胁，就是巨头进入自己项目的领域带来的威胁。任凭你多么辛苦从前面几步锁定了完美针对市场空缺和用户需求的方向，巨头也能凭借强大的用户资源和技术实力把你微创新掉，順便接纳了被你培养好习惯的用户。都说开心农场的流量下滑之日约等于 QQ 农场推出之日，我们要在几乎没有知识产权的现状下求得生存，只有保持创新能力，并且在无法偷走的社区氛围、内容资源等反面发力。</p>
<h2>打造品牌：高端大气上档次，低调奢华有内涵</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/141.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/141-600x375.png" /></a><p>打造品牌：高端大气上档次，低调奢华有内涵</p></div>
<p>如果你以为我的产品就准备叫 Project LYRICS 了，我会以设计师的尊严向你发送无限的怨念。就和许多人常犯的埋头写代码的毛病一样，萌XX啊XX酷啊XX云啊这种名字真是屡见不鲜。如果拥有 SEO 的相关知识你就会知道，一个好的名字对于推广产品有多么重要。所以，在设计品牌的识别体系时，你需要注意一下方面：</p>
<ul>
<li>产品名字务必优美，清晰，易于理解，独特好记，读起来悦耳动听，切合产品形象。嘛，这个可以说是大家都知道的好名字的标准了</li>
<li>中英结合，慎用拼音作为英文名，最好中英名字皆有意义，读音相近更佳，可以考虑自造词、合成词。</li>
<li>名字没有山寨感，不会让人联想到其他厂商，搜索结果中没有知名度高的站点，域名有空余。当然现在各种后缀已经流行起来，没有 .com 域名已经不再是致命的问题了</li>
<li>取一个朗朗上口的标语，传递产品的愿景，让用户快速理解产品的定位。</li>
<li>设计一个简洁耐看的 LOGO ，贴合产品，富有寓意，形状有特征。考虑到缩小到系统托盘区、单色出现在手机通知栏时能保证容易辨认</li>
<li>对品牌色、品牌形状、品牌字体等提前做好一定程度的规划，利于统一产品形象，增加辨识度。</li>
</ul>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/151.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/151-600x375.png" /></a><p>幻灯片15</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/161.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/161-600x375.png" /></a><p>幻灯片16</p></div>
<h2>群策群力：已经没有什么好害怕的了</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/181.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/181-600x375.png" /></a><p>群策群力：已经没有什么好害怕的了</p></div>
<p>你征求意见的帖子反馈良好，也有各路大神愿意参与开发。群里一片欣欣向荣之势，作为创始人的你感到十分欣慰。不过，在有实际成果前千万不能高兴的太早，在开发过程中，还有很多的问题值得注意。</p>
<p>虽然你经过层层考量，对项目已经胸有成竹胜券在握，不过被你求爷爷告奶奶拉来的苦力门却未必能对此了然于心。写个文档把你对项目的概念说出来，同样，把前几步你对市场定位、用户需求、竞品分析的小笔记贴上去，才能让大家明白你的构想。如果实在不知道该写些什么内容，不妨去网络上搜索一下 MRD 文档的范例作为参考，但是最忌讳文风形式化，完全套模板。清晰简洁的诉说你的设计，诚实的指出当前的困难，杜绝假大空装逼语句，适当的还要辅以流程图和插画表达清楚你的构想。一千个读者就有一千个哈姆雷特，如果总有几个人无法理解你的文章，一定不要失去耐心，逐个沟通，同时征求他们对你的文档风格的意见。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/191.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/191-600x375.png" /></a><p>幻灯片19</p></div>
<p>既然是一个团队，而且可能是在远隔千里的时空中协同工作，必然会需要一些提高沟通效率的工具。如果你告诉我一个 QQ 群和一个网盘就是你们团队讨论和交换代码的全部，嗯 …… 我没说不可以，毕竟少一个竞争对手是好事嘛 ╮(╯-╰)╭ 总之，作为团队管理者，如果你决心让自己的团队工作流更加高效化、专业化，你有必要了解一下以下工具：</p>
<ul>
<li>代码：Github BitBucket Gitlab</li>
<li>设计： Axure在线原型 快现 DesignBoard</li>
<li>OA：格子云 GoogleApps Office365</li>
<li>项目：Tower.im MicrosoftProject</li>
<li>通讯：QQEXMAIL QQ GoogleGroups 内部论坛</li>
<li>自动化：.idea Gulp Grunt Vagrant Docker</li>
</ul>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/201.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/201-600x375.png" /></a><p>幻灯片20</p></div>
<p>管理的艺术，这是一个永恒的话题。作为暂时没有盈利的没有工资的，单凭一腔热血聚集起来的团队，没有有效的管理，是很容易涣散的。当然凭我没法在这里大谈特谈如何管理好一个团队，但是，对于我们这种类型的团队，我还是有几点小建议：</p>
<ul>
<li>人员宁缺毋滥，责任分配清晰
<ul>
<li>在小型项目中，就算你找几桌麻将的人回来，还不如让每个人都发挥出十倍的战斗力。每个人的任务和工期都要有明确规定，记录在案，才能让人有责任感，给团队中的各位确确实实的参与感、主人翁意识和对进度的信心</li>
</ul>
</li>
<li>定期开会讨论，撰写总结，增加归属感和凝聚力
<ul>
<li>有新人的时候要确保沟通，让他们了解协作流程，熟悉团队中的其他人。不时的开会讨论、工作总结，会给团队中的各位确确实实的参与感、主人翁意识和对进度的信心</li>
</ul>
</li>
<li>沟通最重要，懂得坚持和妥协
<ul>
<li>美工和程序猿的关系在开发中永远十分紧张，尤其是产品经理还两边不讨好。该坚持的决策要坚持，但是在自己不了解的范畴上，切不可随意发言，即使是自己觉得有必要的问题，也应该先问过大家的意见，说清楚自己的想法，投票决定</li>
</ul>
</li>
<li>快速迭代，不要试图慢工出细活
<ul>
<li>对我们来说，因为学业和生活上各种繁琐的原因，是不一定有非常稳定的时间参与开发的。这种时候你就需要掌握快速迭代和精益创业的精髓，迅速上线，边接受反馈边修改更新。如果你指望闭门造车，一鸣惊人，到时候可能就胎死腹中咯。</li>
</ul>
</li>
</ul>
<h2>开花结果：我种下一颗种子 终于长出了果实 今天是个伟大日子</h2>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/211.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/211-600x375.png" /></a><p>开花结果：我种下一颗种子 终于长出了果实 今天是个伟大日子</p></div>
<p>DNET Tech News (@DNETNews) 2025/2/30 – 09:61<br />
今天，在帝都举办了当今世界科技巨头之一 Rhytune 的开发者大会，由 CEO Dimpurr 带来了全新的跨平台媒体库客户端“有词”。产品采用了全新的设计语言，我们将继续在 Twiiter+ 上直播这次大会。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/221.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/221-600x375.png" /></a><p>幻灯片22</p></div>
<p>多年以后，你们或是已经成为了硅谷新星团队，或是行将成为国内纳税大户企业，或是正在开发人造变形金刚。当你作为嘉宾出席青少年开发者大会， Hein 姐请你为台上台下初出茅庐的小开发者们传授一下你当年的创业经。这时候你会发现，其实一切不过起源于一个小小的创意，还有不断的学习。</p>
<p>虽然是老生常谈，不过在互联网时代，只有不断的质疑自己、接纳新知识才是最重要的。不管是我们今天领导项目、参与开发还是努力学习，都是为了提升自己的实力，得到更好的资源，百尺竿头更进一步。年轻是我们的资本，对待项目，不应该草草了事，或是希望出名走红，而是应该抓住难得的学习机会，精益求精，为真正长远的技术之路服务。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/241.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/241-600x375.png" /></a><p>幻灯片24</p></div>
<p>以上。这些都不过是我的个人见解，或许还错漏百出。不过我希望我一路上通过亲身体验总结出来的这些经验，能够在大家在技术之路上，引发一些有益的思考。或许在座的各位，有朝一日将会成为技术界知名的黑客，或是产品享誉世界的设计师，或是互联网上弄潮的企业家。总之我相信，我们青少年开发者现在站在时代的最前沿，今后也必定能引领互联网时代的潮流！谢谢大家！</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/07/251.png"><img src="http://img1.dimpurr.com/dimblog/2014/07/251-600x375.png" /></a><p>幻灯片25</p></div>
<p><del>嗯。我觉得我讲的很好了，不过据说一定要有观众提问的环节，好吧，正面上吧。╮(╯-╰)╭</del></p>
<p>PPT 下载：<a href="http://pan.baidu.com/s/1c09xSRI" target="_blank">http://pan.baidu.com/s/1c09xSRI</a></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/event14/">ADC 2014 如何成为一位合格的产品策划者 – 青少年开发者大会 EVENT 14 演讲稿</a></p>]]></content>
        
        <summary type="html">
            
            转载请注明：ADC 2014 – 如何成为一位合格的产品策划者 – 青少年开发者大会演讲稿 | 钉子の次元 http://blog.dimpurr.com/event14/ 这是本次 EVENT 14 青少年开发者大会我的个人演讲稿。于 2014 年 7 月 20 日下午第二场
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="ADC"/>
        
        <category term="EVENT14"/>
        
        <category term="PM"/>
        
        <category term="团队"/>
        
        <category term="开发"/>
        
        <category term="悦调"/>
        
        <category term="管理"/>
        
        <category term="设计"/>
        
        <category term="项目"/>
        
    </entry>
    
    <entry>
        <title>如何从 WEB 页面中提取信息</title>
        <link href="https://binux.blog/2014/07/how-to-extract-data-from-web/"/>
        <id>https://binux.blog/2014/07/how-to-extract-data-from-web/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>已经五个月没有更新 blog 了，这五个月全身心投入到了两个关于如何从页面上抽取结构化数据的项目上。这也是我加入某厂最主要的原因。其中一个全自动模板生成抽取器，虽然还不完全能够实用，但比1年前效果好太多，同时也让我想明白了一些问题。这都是下文主要讨论的问题。</p><p>关于 <a href="https://github.com/binux/pyspider" target="_blank">pyspider</a> 项目，这几天我也在慢慢填上这延期了3个月的坑，至少完成第二里程碑吧。但缺少实际应用的环境，很多东西是否工作得很好，我也不是很有把握。如果有的话，还是希望支持1-2个实际的抓取项目吧。</p><p>而 “如何获得页面/数据” 这个问题依旧是我持续关注中，想要去解决的问题。但是，既然某厂的后续解决方案是将所有抓取页面过 webkit 渲染（虽然很多时候渲染不出 或 需要点击动作，代价往往大于直接抓 API），不会有很多精力投入，待我慢慢想想。。</p><p>##四种解析模式</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#xpath-css选择器-正则表达式"></a>xpath / css选择器 / 正则表达式</h3><p><strong>示例:</strong> <a href="https://www.kimonolabs.com/" target="_blank">https://www.kimonolabs.com/</a></p><p>通过手动、自动、半自动方式，设定需要抽取元素的 <a href="http://www.w3schools.com/xpath/default.asp" target="_blank">xpath</a>、 <a href="http://www.w3schools.com/cssref/css_selectors.asp" target="_blank">css选择器</a> 或 正则表达式 进行定位提取的方法（这里需要指出的是，html 并不是正则的，正则表达式可能在部分简单提取时有效，但 <strong>不要用正则表达式进行页面提取</strong>）。其根本思想是提供一种定位元素的规则进行页面抽取。</p><p>这个方法被用得最多，好处是有效，嗯。缺陷在于用户需要会 xpath / css选择器 / 正则语法，虽然有一些工具（例如上面的kimono、chrome的调试工具、pyspider里面的脚本）辅助生成规则，但可能通用性不足 或 区分度不够，选取到不需要的内容。这在大批量抽取时需要大量的高级人力去配置，即使是熟练工也需要5-10分钟配置一个页面（6-8个属性），需要耗费大量精力。</p><p>这种抽取方式的一种变形是：将 key 和 value 同时在页面中标出，通过 key 和 value 总是穿插出现的这一假设，省去单独为每个属性设置规则的人力，极大增快标注效率。<br />例如：<a href="http://movie.douban.com/subject/7054604/" target="_blank">http://movie.douban.com/subject/7054604/</a> 这个页面中的  </p><blockquote><p>导演: 迈克尔·贝<br />编剧: 伊伦·克鲁格<br />主演: 马克·沃尔伯格…<br />类型: 动作 / 科幻 / 冒险<br />制片国家/地区: 美国 / 中国大陆<br />语言: 英语 / 汉语普通话 / 粤语<br />上映日期: 2014-06-27(美国/中国大陆)<br />片长: 166分钟<br />又名: 变形金刚：歼灭世纪(港) / 变形金刚4：灭绝时代 / 变形金刚4 / 变4 / Transformers 4<br />IMDb链接: tt2109248  </p></blockquote><p>导演/编剧/类型等 属性名 往往拥有相同的 xpath，而值的 xpath 也是独立的几种。他们一定是 key: value 的形式组织的，通过用 key 分割 value 的方式能轻松将所有信息提取出来。</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#data-highlighter"></a>data highlighter</h3><p><strong>示例:</strong> <a href="http://googlewebmastercentral.blogspot.com/2012/12/introducing-data-highlighter-for-event.html" target="_blank">http://googlewebmastercentral.blogspot.com/2012/12/introducing-data-highlighter-for-event.html</a></p><p>Data Highlighter 的标注方式是：给一系列相似的页面，让用户标出（高亮）每个属性在页面中的位置。通过多个页面的标注信息，寻找每个属性的特征。当然了，这个特征可以是 xpath，也可以是上下文，也有可能是机器学习的特征向量。</p><p>Data Hightlighter 通过高亮 <strong>多个页面中相同属性</strong> 进行规则学习，省去了人为设置规则时的学习成本。实践表明，在单一页面模板下，标记2个页面就足以生成规则了。效率远大于手工设置规则。Google Data Highlighter 甚至对文字进行了切分，能在 <code>英语 / 汉语普通话 / 粤语</code> xpath 相同的情况下，分别选出三种语言。是我目前见过的成熟度最高、通用性最好、最简便的数据抽取方式。</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#micro-data"></a>micro-data</h3><p><strong>示例:</strong> <a href="http://microformats.org/" target="_blank">http://microformats.org/</a> 以及各大网站</p><p>页面属性标记，通过在页面数据元素上增加属性标识，通过开放的标准格式，为数据提取提供便利，例如这是豆瓣的评论数据：</p><table><tr><td><pre><span>1</span><br /><span>2</span><br /><span>3</span><br /><span>4</span><br /><span>5</span><br /></pre></td><td><pre><span>&lt; p class="rating_self clearfix" typeof="v:Rating"&gt;</span><br /><span>  &lt;span class="ll bigstar35"&gt;&lt;/span&gt;</span><br /><span>  &lt;strong class="ll rating_num" property="v:average"&gt;6.7&lt;/strong&gt;</span><br /><span>  &lt;span property="v:best" content="10.0"&gt;&lt;/span&gt;</span><br /><span>&lt;/p&gt;</span><br /></pre></td></tr></table><p><code>typeof="v:Rating"</code> 表明这里是 rating 数据，<code>v:best</code> 表明 rating 的最大值。通过开放的 data format 标准，只按照标准抽取，就能得到包含的结构化数据。但是，需要站长的支持，在页面中加入标记才可以。</p><p>从广义上讲，主图识别，页面发布时间这样的属性，其实也可以是通过对页面内容进行分析获得的。这与 micro-data 一样，通过元素足够强的特征，对元素的含义进行理解分析。</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#模板生成与提取"></a>模板生成与提取</h3><p><img src="https://binux.blog/assets/image/screenshot_2014-06-17_19.49.40.png" /></p><p>页面模板（wrapper）抽取是基于这样一个假设：结构化页面都是 通过模板 将数据库中的数据 映射成页面的。通过页面分析，得到页面模板，通过模板提取出实际的结构化数据。</p><p>例如，我使用过的方法，将多个相似页面放在一起比对，寻找等位节点（具有相同结构或表示相同数据类型的元素），将 DOM树 合并。通过比较不同页面上的同类节点，能够获知页面中哪部分是变化的，哪部分是不变的。变化的部分为数据，不变部分为模板。最后形成如上图所示的模板，页面变化部分被涂黑。这个方法类似于将多张纸叠在一起，透过光去看，就会发现变化的文字部分会比其他部分更黑。</p><p>当然了，这个方法也有缺陷，例如：<a href="http://www.xdowns.com/soft/1/2/2006/Soft_34115.html" target="_blank">页面一</a>，<a href="http://www.xdowns.com/soft/10/35/2007/Soft_34731.html" target="_blank">页面二</a> 的标题部分，一个是蓝色，一个是绿色，虽然在人类视觉上它们相差不大，但从页面结构上绿色多了一层 <code>&lt;font&gt;</code>，作为算法很难理解，这样的样式表示他们是否有相同的含义，是否有区别。同理左侧推荐的蓝绿相间，即使作为人也很难理解它们有什么区别。</p><p>##两个核心问题</p><p>总结起来，以上四种解析模式都在尝试解决以下两个问题：</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#一个元素在说什么"></a>一个元素在说什么</h3><p>当你打开一个页面，你怎么知道一个页面在传递什么信息？你怎么知道一个元素是文章的标题？怎么知道一个元素是作者？作为人类，我们可能会看到一个元素的位置是否在页面中间，元素的字体大小、颜色，元素前面是不是有一个 “作者：”，元素内容是否长得像一个人名/时间，上下文中这个元素都在讲什么，这篇文章是什么领域，等等。人类可能会有非常多的 <strong>经验知识</strong> ，当看到一个页面的时候能够解读出页面上的信息。</p><p>在 “xpath / css选择器 / 正则表达式” 的解析模式中，这个工作正是人肉去完成的，人去解读这个页面，找到信息所在元素。而在 “data highlighter” 的解析模式中，也需要人在多个页面中进行标注，告诉机器每个属性所在。</p><p>但是作为计算机，是否能做到这一点？micro-data 通过开放的格式约定，通过 <code>property</code> 这一个特殊的属性标记告诉计算机一个元素说的是什么。而模板挖掘通过：xpath，元素class，id属性，上下文等特征去挖掘元素的含义。</p><p>但是，页面样式结构，在人类在没有足够的知识情况下，也有可能会无法解读，例如我们的爷爷奶奶可能就看不懂网页上说的是什么。同时，正如语言是有二义性的一样，页面结构也会如此，这给计算机去理解，页面说的是什么，带来了巨大的困难。</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#这个元素和其他的元素有什么区别"></a>这个元素和其他的元素有什么区别</h3><p>因为，大批量数据抽取是计算机的活，这需要 <strong>准确</strong> 地告诉计算机，你想要抽取的元素是哪一个。在 “xpath / css选择器 / 正则表达式” 的解析模式中，xpath、css选择器、正则表达式正是对这一信息的描述。选取一个正确的表达式，即涵盖不同页面，又和其他属性有所区分，是一件需要经验和技巧的工作。而 “data highlighter” 将这个工作交给了计算机。“模板生成和套用” 过程中也由计算机分析出了规则。</p><p>而对于 “micro-data” 来说，这个问题有些特殊。通过开放的标准格式，程序已经能够了解每个元素在说什么了，那么定位就不再有意义。但是反过来，这又何尝不是一种定位。</p><h3><a href="https://binux.blog/2014/07/how-to-extract-data-from-web/#结构化解析"></a>结构化解析</h3><p>结构化解析实质是计算机对一个页面的理解，无论这种理解是人去创建规则、做出某种约定 还是 机器学习。上面列举的四种解析方式，“xpath / css选择器 / 正则表达式” 和 “data highlighter” 回答了这个元素和其他的有什么区别。 “micro-data” 利用了一个元素在说什么。而 “模板生成与提取” 同时涉及元素说什么，它在哪。</p><p>那么作为结构化解析的究级形态是怎样？我们可以假想一个人，他打开一个页面就能知道上面说的是什么，有什么样的信息，这是人类对于：通过网页获取知识的一种能力，一种方式。计算机也是一样，结构化抽取 就是 计算机从网页中获取知识的过程。“这个元素和其他的元素有什么区别” 终究只是在无法达到：计算机理解 <strong>一个页面在说什么</strong> 的辅助手段。理解 “一个元素在说什么” 乃至 “一个页面在说什么” 我认为是才是其究级形态，而结构化数据也不过是计算机，对于浩瀚互联网信息理解的一种表达罢了。</p>]]></content>
        
        <summary type="html">
            
            已经五个月没有更新 blog 了，这五个月全身心投入到了两个关于如何从页面上抽取结构化数据的项目上。这也是我加入某厂最主要的原因。其中一个全自动模板生成抽取器，虽然还不完全能够实用，但比1年前效果好太多，同时也让我想明白了一些问题。这都是下文主要讨论的问题。关于 pyspide
            
        </summary>
        
        <category term="html"/>
        
        <category term="infomation-extraction"/>
        
        <category term="wrapper-genaration"/>
        
        <category term="xpath"/>
        
        <category term="css-selector"/>
        
    </entry>
    
    <entry>
        <title>Adagiio V1.1.1 – 宽屏大图 ACG 风格单栏 WordPress 主题</title>
        <link href="http://blog.dimpurr.com/adagiio/"/>
        <id>http://blog.dimpurr.com/adagiio/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-06-26T07:50:27+00:00</published>
        <updated>2014-06-26T07:50:27+00:00</updated>
        
        <content type="html"><![CDATA[<p>Adagiio 是一个 HTML5 的宽屏大图 ACG 风格单栏 WordPress 主题，又名 Sankarea ，配色灵感来自绣球花的叶。适合文艺向、动漫向个人博客和大图风格 CMS 站点。附带移动版响应式页面，支持中英文。感谢 (null) 群的各位在开发过程中的帮助，没有你们这个主题也做不出来 ……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/06/screenshot3.png"><img src="http://img1.dimpurr.com/dimblog/2014/06/screenshot3-600x400.png" /></a><p>Adagiio 首页</p></div>
<p>欢迎在此页提出相关问题和建议！</p>
<p><span></span></p>
<h3>功能特点</h3>
<ul>
<li>自定义大头图随机切换</li>
<li>文章缩略图显示</li>
<li>自适应宽屏和响应式移动版</li>
<li>中/英语言支持</li>
<li>HTML5 语义标签和 CSS3 特效，兼容到 IE8 及以上</li>
</ul>
<h3>主题演示</h3>
<ul>
<li><a href="http://work.dimpurr.com/demo/wp/adagiio/" target="_blank">主题演示</a></li>
</ul>
<h3>获取主题</h3>
<ul>
<li><a href="http://pan.baidu.com/s/1jG0xSvO" target="_blank">百度网盘</a></li>
<li><a href="http://work.dimpurr.com/theme/adagiio/update/adagiio.zip" target="_blank">测试版更新源</a> (随时更新最新测试版本，可能不稳定)</li>
</ul>
<h3>使用说明</h3>
<ul>
<li>将会随机输出 /bannner/ 下的文件作为随机头图，请确保有至少一个文件且全部为有效图片</li>
<li>将会自动选取文章第一张图片作为特色图片，可自行删除。如果找不到设置特色图片的地方，请在文章编辑页右上勾选 显示选项 &gt; 特色图像</li>
<li>首页显示的摘要，请在文章编辑页右上勾选 显示选项 &gt; 摘要，然后在摘要框编辑</li>
<li>正式版功能更加稳定，希望使用最新版可以下载正式版后在后台更新到最新测试版或者从测试版更新源下载</li>
<li>直接在后台主题安装上传 Zip 文件即可使用，也可以手动解压至 wp-content/theme 目录</li>
<li>推荐使用 WordPress 子主题进行修改，这样还可以继续享受更新，详细可搜索相关教程</li>
<li>&lt;pre&gt; 为多行代码， &lt;code&gt; 为行内代码</li>
</ul>
<h3>更新历史</h3>
<ul>
<li>v1.0 主题发布</li>
<li>v1.1 微调动画和完善后台</li>
</ul>
<h3>截图预览</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/06/201406261351341.png"><img src="http://img1.dimpurr.com/dimblog/2014/06/201406261351341-600x399.png" /></a><p>页脚小工具</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/06/201406261355591.png"><img src="http://img1.dimpurr.com/dimblog/2014/06/201406261355591-600x400.png" /></a><p>内文</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/06/20140626135955.png"><img src="http://img1.dimpurr.com/dimblog/2014/06/20140626135955-600x400.png" /></a><p>评论区</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/06/20140626150724.png"><img src="http://img1.dimpurr.com/dimblog/2014/06/20140626150724.png" /></a><p>移动版</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/adagiio/">Adagiio V1.1.1 – 宽屏大图 ACG 风格单栏 WordPress 主题</a></p>]]></content>
        
        <summary type="html">
            
            Adagiio 是一个 HTML5 的宽屏大图 ACG 风格单栏 WordPress 主题，又名 Sankarea ，配色灵感来自绣球花的叶。适合文艺向、动漫向个人博客和大图风格 CMS 站点。附带移动版响应式页面，支持中英文。感谢 (null) 群的各位在开发过程中的帮助，没
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Adagiio"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>madoro – 扁平黑色自适应窄单栏 WordPress 主题</title>
        <link href="http://blog.dimpurr.com/madoro/"/>
        <id>http://blog.dimpurr.com/madoro/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-03-16T13:29:13+00:00</published>
        <updated>2014-03-16T13:29:13+00:00</updated>
        
        <content type="html"><![CDATA[<p>madoro 是我花了一个下午一个晚上单曲循环「まどろみの约束」速成的以星空为主题的新单栏主题，没有用背景以外的任何一张图片素材，大概可以用在文字为主或想自定义背景的简洁风格博客。附带移动版响应式页面。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/screenshot.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/screenshot-600x378.png" /></a><p>madoro</p></div>
<h3>千反田える (佐藤聡美) &amp; 伊原摩耶花 (茅野愛衣) – まどろみの約束</h3>
<p></p>
<p><br />
<span></span></p>
<h3>功能特点</h3>
<ul>
<li>自适应宽屏（增大到 800px）和响应式移动版</li>
<li>HTML5 语义标签和 CSS3 特效，兼容到 IE8 及以上</li>
<li>简单的后台设置</li>
<li>英文语言包支持</li>
<li><a href="http://work.dimpurr.com/demo/wp/madoro/" target="_blank">主题演示</a></li>
</ul>
<h3>获取主题</h3>
<ul>
<li><a href="http://pan.baidu.com/s/1o6oFHYq" target="_blank">百度网盘</a> (V1.1正式版)</li>
<li><a href="https://github.com/dimpurr/madoro/releases/tag/v1.11" target="_blank">Github</a> (V1.1正式版)</li>
<li><a href="ftp://work.dimpurr.com/theme/madoro/update/madoro.zip" target="_blank">测试版更新源</a> (随时更新最新测试版本，可能不稳定)</li>
</ul>
<h3>使用说明</h3>
<ul>
<li>直接在后台主题安装上传 Zip 文件即可使用，也可以手动解压至 wp-content/theme 目录</li>
<li>若有任何问题或希望什么新特性请在此页面回复，会尽力帮忙</li>
</ul>
<h3>更新历史</h3>
<ul>
<li>v1.0 基本样式和响应式</li>
<li>v1.1 后台设置和英文语言支持</li>
</ul>
<h3>截图预览</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/20140316211549.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/20140316211549-600x377.png" /></a><p>小工具和尾部</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/20140316211640.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/20140316211640-600x378.png" /></a><p>评论区</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/madoro/">madoro – 扁平黑色自适应窄单栏 WordPress 主题</a></p>]]></content>
        
        <summary type="html">
            
            madoro 是我花了一个下午一个晚上单曲循环「まどろみの约束」速成的以星空为主题的新单栏主题，没有用背景以外的任何一张图片素材，大概可以用在文字为主或想自定义背景的简洁风格博客。附带移动版响应式页面。 madoro 千反田える (佐藤聡美) &amp;amp; 伊原摩耶花 (茅野愛衣
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="ACG"/>
        
        <category term="madoro"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="冰菓"/>
        
        <category term="前端"/>
        
        <category term="动漫"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>Ticker – 个人时间管理应用概念原型</title>
        <link href="http://blog.dimpurr.com/ui-ticker/"/>
        <id>http://blog.dimpurr.com/ui-ticker/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-03-09T12:15:16+00:00</published>
        <updated>2014-03-09T12:15:16+00:00</updated>
        
        <content type="html"><![CDATA[<p>取了个有点装逼的名字，其实只是忽然想到博客里除了各种前端和各种折腾之外也该扔点交互相关的内容了，于是除了稀薄到可以忽略不计的两篇交互研讨文之外决定陆续把闲时无聊构思的进行中抑或是被毙的项目线稿什么的搬上来了。嘛但是相比交互更多设计稿反而仅仅草草的做了个做信息架构这方面也请不要吐槽。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/Scan-0005.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/Scan-0005-600x390.png" /></a><p>Ticker 线稿 (字球不吐槽，建议戳开大图)</p></div>
<p>Ticker 是去年设计的一个用于管理时间的应用，简而言之就是增强版的 Todo 。</p>
<p>构思来源于健忘的某人正极其依赖 Google Keep 和 Google Calendar 的时期，经常会为一项任务是添加到 Todo 还是日历而感到纠结。更别说 Google Keep 将备忘便签和 Todo 融合已经让我少开了一个应用， Aviate Launcher 对于日历事项的展示方式更是硬生生变成了 Todo ，因此我就想到——以待办事项为共同核心，能否将 Todo 、日历和便签融合到一起？</p>
<p><span></span></p>
<p>当然马上不可避免的就是可观的复杂度增长，因此定位是重度依赖时间管理类应用的人群。</p>
<p>毫无疑问<span>首先</span><span>依次测试了类似的竞品，其中在模式的融合方面几种最有参考价值的是 Todo + 便签的 Google Keep 和 Todo + 便签 + 日历的 ColorNote 。当时还针对每种产品的竞争力和优秀特性列了一个表单，已几乎回想不起来所以不在此赘述。</span></p>
<p>在此之中确定了任务分类和进度系统、 Todo 日历和笔记三个系统之间可以互相绑定的思路。举个栗子，我为明天的会议创建一个日历日程，在标注了具体时间之后就会被显示在日历上，同时我可以把备忘的信息写在关联的便签上。</p>
<p>从整个产品的维度来考虑，「任务」应该是沟通三个组件的概念，最后选用了类似 Any.Do 的任务列表作为设计出发点。画线稿的过程中自然而然的发现原生 Holo 风格非常适合这类结构清晰的应用于是就上手了，最后的成品是一个以侧边栏（现在看来应该改用原生 Drawer ）区分 Todo 、记录和日历，以 Tab 切换视图的 Holo 风格界面。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/Index-Floder.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/Index-Floder.png" /></a><p>Ticker Index-Floder Pencil 原型</p></div>
<p>后来使用 Evolus Pencil 的 Holo 元件简单制作了一个 Todo 列表的原型。中间的 Tab 可以切换时间和文件夹两种视图，其下是点击标题可以被折叠的层叠卡片。任务右侧的数值可能代表子任务数、时间或者价格等和任务最相关的信息，在任务上自左向右轻扫标记完成，再次右滑删除，向左滑动展开操作，点击展开子任务和详情。</p>
<p>现在回顾设计还存在几个问题，都集中在对任务的操作上。其一是左右滑动的手势被任务操作占用之后，违反了 Andriod Design 中对于 Tab 应该可以被滑动切换的要求。其二是操作的隐喻，虽然可以通过新手教学等告诉用户两个滑动手势的意义，但是明显应该在最常规的心里模型即点击后展开详情同时提供操作按钮，否则很可能出现摸不着头脑的情况。</p>
<p>随后值得注意的是新建事件的界面。这个页面借鉴的是 Google 日历的新建日程风格，除了必要的选项还表达了简要注释或关联记录、将日程分享给其他参与者、增加自定义的元数据和子任务等构思。至于查看单个事件的界面就非常简单，只是标题、元数据和子任务展示以及分享编辑等操作了。</p>
<p>最后还有一个没有来得及呈现在纸上但却是至关重要的构思，就是名为「时间」的一个页面，展示了当前时间日期、正在进行的任务和其操作、接下来进行的一项任务的界面，是使用我要当学霸时看到记时界面灵机一动想到的。这同样是一个场景出发的设计，思路大致如下：之所以想到把这几个方面的功能整合为一个应用，都是因为他们关于「我要做什么」。那么正好应该有一个页面告诉我现在和马上应该干什么，这胜过让我看一串长长的 Todo 列表。可惜当时的原型和聊天记录都不知道死哪里去了，现在也没有心情重画。</p>
<p>当时与螺丝、E姐交流过关于这个构思的事情，包括考虑有没有 Java 开发的人手、要不要做开源项目之类的。螺丝也提出了记录等其实不是痛点的功能可以拆开做成可选插件，还有和 Google Calendar 的同步之类的想法。但是最后没有考虑去实现原因还是真的对时间管理有如此复杂需求的用户实在不多，庞杂的设计显得过于累赘（虽然我保证我都会用）开发的成本过高。不过如果谁无聊想把这个设计实现了，记得署我一个名就好了 ……</p>
<p>更新：附一张更详细的 Pencil 原型设计图。</p>
<div><img src="http://img1.dimpurr.com/dimblog/2014/03/设计-手机应用-TODOAndroid-600x698.jpg" /><p>Ticker Pencil 原型</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/ui-ticker/">Ticker – 个人时间管理应用概念原型</a></p>]]></content>
        
        <summary type="html">
            
            取了个有点装逼的名字，其实只是忽然想到博客里除了各种前端和各种折腾之外也该扔点交互相关的内容了，于是除了稀薄到可以忽略不计的两篇交互研讨文之外决定陆续把闲时无聊构思的进行中抑或是被毙的项目线稿什么的搬上来了。嘛但是相比交互更多设计稿反而仅仅草草的做了个做信息架构这方面也请不要吐
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="Andriod"/>
        
        <category term="Andriod Design"/>
        
        <category term="Pencil"/>
        
        <category term="Ticker"/>
        
        <category term="Todo"/>
        
        <category term="交互"/>
        
        <category term="原型"/>
        
        <category term="应用"/>
        
        <category term="线框"/>
        
    </entry>
    
    <entry>
        <title>OpenSUSE (Linux) 下安装 Sublime Text</title>
        <link href="http://blog.dimpurr.com/linux-sublime/"/>
        <id>http://blog.dimpurr.com/linux-sublime/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-03-01T14:51:50+00:00</published>
        <updated>2014-03-01T14:51:50+00:00</updated>
        
        <content type="html"><![CDATA[<p>Sublime Text 作为某人御用的编辑器已经到了没有 ST 就不想写代码的地步了 …… 当然因为是 Python 编写， ST 在 Linux 下的安装使用实际上非常简单，唯一需要注意的是输入法 bug 的修复。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/03/shot7.png"><img src="http://img1.dimpurr.com/dimblog/2014/03/shot7-600x458.png" /></a><p>Sublime Text 3 with OpenSUSE &amp; fcitx &amp; Google Pinyin</p></div>
<h3>一 下载主程序</h3>
<p>首先进入官网下载官方提供的 Linux 版 tar 压缩包：<a href="http://www.sublimetext.com/" target="_blank">http://www.sublimetext.com/</a></p>
<p><span></span></p>
<pre>tar -xvf sublime*.tar.bz2 # 解压 tar 压缩包
cd sublime*
sudo mkdir /opt/sublime_text/
sudo cp -rf * /opt/sublime_text/ # 拷贝到系统程序目录</pre>
<p>实际上此时就已经可以执行其中的 sublime.py 运行了，但是这种情况下会导致 ibus 和 fctix 等中文输入框架无法被激活，另外在 OpenSUSE 下还可以导致菜单栏不正常显示的 bug ，因此需要打个补丁。</p>
<h3>二 输入法补丁和菜单项</h3>
<p>首先下载稍后需要用到的输入法修复补丁和菜单图标：<a href="http://pan.baidu.com/s/1bnvMRDH" target="_blank">http://pan.baidu.com/s/1bnvMRDH</a></p>
<p>注：此链接已失效，请常见 <a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=7006&amp;start=10#p41343" target="_blank">http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=7006&amp;start=10#p41343</a></p>
<p>然后要记得安装好编译环境，如果已经完成了请忽略此步：</p>
<pre>sudo zypper in build-essential # 其他发行版同理</pre>
<p>然后编译输入法补丁并拷贝到 Sublime Text 目录：</p>
<pre>gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC # 编译 libsublime-imfix.so
sudo cp libsublime-imfix.so /opt/sublime_text/ # 拷贝至安装目录</pre>
<p>最后为了方便使用在菜单中添加 Sublime Text 的菜单项：</p>
<pre>sudo cp sublime_text.desktop /usr/share/applications/ # 拷贝编辑好的 .desktop 菜单项到系统目录
sudo chmod 777 /usr/share/applications/sublime_text.desktop # 修改权限以使其可识别</pre>
<h3>三 完成</h3>
<p>至此 Sublime Text 就可以正常使用了。剩下的各种配置和安装插件就请自行查阅资料了，不过相信只要安装好包管理器菊苣们就知道该做啥了。在 ST2 中使用 Ctrl + ~ 启动控制台敲入以下命令回车即可：</p>
<pre>import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation')</pre>
<p>至于 Sublime Text 3 则是：</p>
<pre>import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())</pre>
<p>最后是吐槽。</p>
<p>之前在查询输入法问题解决办法时找到了官方论坛上的这个反馈贴：<a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=7006&amp;start=0" target="_blank">Input method support</a> 后来果不其然的在 Hangouts 中提到这个问题时 <a href="https://www.csslayer.info/wordpress/" target="_blank">csslayer</a> 马上开始抱怨 「我都把问题和解决的源码扔上去了这作者还高贵冷艳 <a href="https://www.csslayer.info/wordpress/fcitx-dev/wrong-and-wrong/" target="_blank">再加上这破玩意是闭源的老子连替他擦屁股的方法都没有</a> 」…… 当然其中的 <a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=7006&amp;start=10" target="_blank">某一楼</a> 还可以看到之前使用的输入法补丁的作者 Cjacker 提供的源码。</p>
<p>而我想表达的是，总觉得作者用的一定是 Mac ……</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/linux-sublime/">OpenSUSE (Linux) 下安装 Sublime Text</a></p>]]></content>
        
        <summary type="html">
            
            Sublime Text 作为某人御用的编辑器已经到了没有 ST 就不想写代码的地步了 …… 当然因为是 Python 编写， ST 在 Linux 下的安装使用实际上非常简单，唯一需要注意的是输入法 bug 的修复。 Sublime Text 3 with OpenSUSE 
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="fctix"/>
        
        <category term="IDE"/>
        
        <category term="KDE"/>
        
        <category term="Linux"/>
        
        <category term="OpenSUSE"/>
        
        <category term="Sublime"/>
        
        <category term="编辑器"/>
        
    </entry>
    
    <entry>
        <title>pyspider架构设计</title>
        <link href="https://binux.blog/2014/02/pyspider-architecture/"/>
        <id>https://binux.blog/2014/02/pyspider-architecture/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<h1><a href="https://binux.blog/2014/02/pyspider-architecture/#前言"></a>前言</h1><p><a href="https://github.com/binux/pyspider" target="_blank">pyspider</a>是我一年多之前做的一个爬虫架构的开源化实现。主要的功能需求是：</p><ul><li>抓取、更新调度多站点的特定的页面</li><li>需要对页面进行结构化信息提取</li><li>灵活可扩展，稳定可监控</li></ul><p>而这也是绝大多数python爬虫的需求 —— 定向抓取，结构化化解析。但是面对结构迥异的各种网站，单一的抓取模式并不一定能满足，灵活的抓取控制是必须的。为了达到这个目的，单纯的配置文件往往不够灵活，于是，通过脚本去控制抓取是我最后的选择。<br />而去重调度，队列，抓取，异常处理，监控等功能作为框架，提供给抓取脚本，并保证灵活性。最后加上web的编辑调试环境，以及web任务监控，即成为了这套框架。</p><p>pyspider的设计基础是：<strong>以python脚本驱动的抓取环模型爬虫</strong></p><ul><li>通过python脚本进行结构化信息的提取，follow链接调度抓取控制，实现最大的灵活性</li><li>通过web化的脚本编写、调试环境。web展现调度状态</li><li>抓取环模型成熟稳定，模块间相互独立，通过消息队列连接，从单进程到多机分布式灵活拓展</li></ul><p><del>这与后来在某厂看到的spider系统整体架构上区别不大</del></p><p><img src="https://binux.blog/assets/image/pyspider.png" /></p><h1><a href="https://binux.blog/2014/02/pyspider-architecture/#功能"></a>功能</h1><p><strong>webui</strong></p><ul><li>web的可视化任务监控</li><li>web脚本编写，单步调试</li><li>异常捕获、log捕获，print捕获等</li></ul><p>scheduler</p><ul><li>任务优先级</li><li>周期定时任务</li><li>流量控制</li><li>基于时间周期 或 前链标签（例如更新时间）的重抓取调度</li></ul><p>fetcher</p><ul><li>dataurl支持，用于假抓取模拟传递</li><li>method, header, cookie, proxy, etag, last_modified, timeout 等等抓取调度控制</li><li><em>可以通过适配类似 <a href="http://phantomjs.org/" target="_blank">phantomjs</a> 的webkit引擎支持渲染</em></li></ul><p>processor</p><ul><li>内置的pyquery，以jQuery解析页面</li><li>在脚本中完全控制调度抓取的各项参数</li><li>可以向后链传递信息</li><li>异常捕获</li></ul><h1><a href="https://binux.blog/2014/02/pyspider-architecture/#架构"></a>架构</h1><p>pyspider的架构主要分为 scheduler（调度器）, fetcher（抓取器）, processor（脚本执行）：</p><p><img src="https://binux.blog/assets/image/pyspider-arch.png" /></p><ul><li><p>各个组件间使用消息队列连接，除了scheduler是单点的，fetcher 和 processor 都是可以多实例分布式部署的。 scheduler 负责整体的调度控制</p></li><li><p>任务由 scheduler 发起调度，fetcher 抓取网页内容， processor 执行预先编写的python脚本，输出结果或产生新的提链任务（发往 scheduler），形成闭环。</p></li><li><p>每个脚本可以灵活使用各种python库对页面进行解析，使用框架API控制下一步抓取动作，通过设置回调控制解析动作。</p></li></ul><p><strong><em>注：output部分设计尚未决定，因为希望输出也可以很灵活地进行。现在是在脚本中有一个<code>on_result</code>的回调，在里面可以自行实现结果输出。</em></strong></p>]]></content>
        
        <summary type="html">
            
            前言pyspider是我一年多之前做的一个爬虫架构的开源化实现。主要的功能需求是：抓取、更新调度多站点的特定的页面需要对页面进行结构化信息提取灵活可扩展，稳定可监控而这也是绝大多数python爬虫的需求 —— 定向抓取，结构化化解析。但是面对结构迥异的各种网站，单一的抓取模式并
            
        </summary>
        
        <category term="python"/>
        
        <category term="spider"/>
        
        <category term="opensource"/>
        
    </entry>
    
    <entry>
        <title>KDE 上安装 Elementary Luna 窗口风格</title>
        <link href="http://blog.dimpurr.com/kde-elementary/"/>
        <id>http://blog.dimpurr.com/kde-elementary/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-02-11T08:47:49+00:00</published>
        <updated>2014-02-11T08:47:49+00:00</updated>
        
        <content type="html"><![CDATA[<p>这段时间一直在 OpenSUSE 下各种折腾，当然这次明智的选择了 KDE 作为桌面环境。说实话上手相当的辛苦但是也相当的有趣。KDE 没有辜负其极其强大和可自定义的名声，但是和我一直以来的印象一样即使是在曾经号称最美 Linux 的 OpenSUSE 下也恍若上个世纪的默认视觉风格实在有点让人不满。另外一段时间后的使用后更加坚信 KDE 只有程序员没有设计师了，各种强大的一塌糊涂也滥用的一塌糊涂的界面和功能简直无法吐槽。不过无论如何，对于 SUSE 和 KDE 包括其社区自己还是非常的感冒，就是不知道会不会在 Yast2 和 Zypper 安定下来了。</p>
<p>前面说到过默认的 Oxygen 风格至少我是不怎么能接受，于是在调教界面设置时无意间就注意到了熟悉的 Elementary 样式。于是最终效果是这样的：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/02/shot6.png"><img src="http://img1.dimpurr.com/dimblog/2014/02/shot6-600x371.png" /></a><p>KDE4 with Elementary Theme on OpenSUSE</p></div>
<p><span></span></p>
<p>QtCurve 是一款具有极其强大自定义功能的主题，几乎可以通过配置模拟出各种样式，当然也可以被调教的非常丑。不过重点在于我们这个 Elementary 风格的界面样式也是通过这个主题进行配置的，因此我们要首先进行安装：</p>
<pre>sudo zypper in qtcurve-kde4 // OpenSUSE
sudo apt-get install qtcurve // Debian / Kubuntu</pre>
<p>然后下载 Elementary 风格包：<a href="http://kde-look.org/CONTENT/content-files/162259-ELunaPack-forKDE.zip" target="_blank"><strong>http://kde-look.org/CONTENT/content-files/162259-ELunaPack-forKDE.zip</strong></a></p>
<p>下载后解压，直接 ./install.sh 执行脚本即可。如果是 OpenSUSE 需要手动编辑其中的所有 /.kde/ 为 /.kde4/ 方可安装到正确的路径。安装完成后前往系统设置，执行以下设置：</p>
<ol>
<li>应用程序外观 &gt; 风格 &gt; 部件样式 &gt; QtCure</li>
<li>应用程序外观 &gt; 风格 &gt; 部件样式 &gt; 配置 … &gt; 预设 &gt; ElementaryLuna2.1</li>
<li>应用程序外观 &gt; 颜色 &gt; 方案 &gt; ElementaryLuna</li>
<li>工作空间外观 &gt; 窗口装饰 &gt; ElementaryLuna</li>
</ol>
<p>这样就算完成了窗口样式的设置了。至于图标集推荐使用 <a href="https://www.dropbox.com/s/nu8o3npcqczp3po/KFaenza%20Oxygen.tar.gz?n=224777243" target="_blank">KFaenza Oxygen</a> ，是我之前在 eOS 下使用的图标集与 Oxygen 默认图标的拼合版本。下载完成之后，进入应用程序外观 &gt; 图标 &gt; 安装主题文件选择下载的压缩文件即可</p>
<p>虽然不能在显示效果上完全媲美 eOS 本尊，但是相对来说还是顺眼多了。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/kde-elementary/">KDE 上安装 Elementary Luna 窗口风格</a></p>]]></content>
        
        <summary type="html">
            
            这段时间一直在 OpenSUSE 下各种折腾，当然这次明智的选择了 KDE 作为桌面环境。说实话上手相当的辛苦但是也相当的有趣。KDE 没有辜负其极其强大和可自定义的名声，但是和我一直以来的印象一样即使是在曾经号称最美 Linux 的 OpenSUSE 下也恍若上个世纪的默认视
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Elementary"/>
        
        <category term="KDE"/>
        
        <category term="Linux"/>
        
        <category term="OpenSUSE"/>
        
        <category term="美化"/>
        
    </entry>
    
    <entry>
        <title>基于封禁IP名单的自动路由</title>
        <link href="https://binux.blog/2014/01/add-blocked-ip-to-route/"/>
        <id>https://binux.blog/2014/01/add-blocked-ip-to-route/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>年末本来很闲的，一个月把标日初级上看完了；结果前天开始被拉去做一个要求年后第一周上线的的项目。。还是本来是一个部门做的那种。。于是本月的blog只好凑字数了。。</p><p><i>翻<del>自动</del></i>墙路由基本除去apnic的国内ipv4白名单走国内方案，就剩下autoddvpn的封禁ip列表了（透明代理不考虑）。国内ip白名单的问题是，如果要玩外服DOTA，还得手动加上各种游戏的服务器IP，而autoddvpn万年不更新，很多时候根本命中不了。</p><p>于是，有了下面这个根据DNS查询记录添加封禁IP记录的方法：</p><ul><li>Linux环境</li><li>有VPN</li><li>通过dnsmasq查询DNS，并打开日志</li><li>通过匹配gfwlist的域名判断对应ip是否被封禁，然后添加到路由表中</li></ul><p>通过脚本</p><p><code>logread -f</code> 可以替换为 <code>tail -f 日志文件</code><br /><code>dev pptp-vpn</code> 可以替换为建立VPN的链接的名字</p><p>不过，缺陷是。。第一次访问时需要过1分钟左右才能生效。。</p><p>另外，这个是福利： <a href="http://f.binux.me/lifandb.html" target="_blank">lifandb.html</a> 来自 <a href="https://github.com/youxiachai/lifandb/" target="_blank">github/youxiachai/lifandb</a> （请用chrome打开，如果安装了adblock-plus请先禁用）</p>]]></content>
        
        <summary type="html">
            
            年末本来很闲的，一个月把标日初级上看完了；结果前天开始被拉去做一个要求年后第一周上线的的项目。。还是本来是一个部门做的那种。。于是本月的blog只好凑字数了。。翻自动墙路由基本除去apnic的国内ipv4白名单走国内方案，就剩下autoddvpn的封禁ip列表了（透明代理不考虑
            
        </summary>
        
        <category term="vpn"/>
        
        <category term="route"/>
        
    </entry>
    
    <entry>
        <title>Modern Sci-Fi Personal Page</title>
        <link href="http://blog.dimpurr.com/modern-page/"/>
        <id>http://blog.dimpurr.com/modern-page/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-01-23T06:16:07+00:00</published>
        <updated>2014-01-23T06:16:07+00:00</updated>
        
        <content type="html"><![CDATA[<p>唔 …… 大概可以说是预谋很久了，至少是在公布 dp-card 即上一个个人页之前，就准备好要写一个新的主页了。要说直接原因，或许是因为被 <a href="http://www.joyneop.com/" target="_blank">JN</a> 吐槽了很多次请换一个，抑或是一时急躁提前公布了之前的个人页无法再用下去了？至少还是在寒假的第二天开工，花了两个下午把这个新的页面完成了。<a href="http://im.dimpurr.com/" target="_blank">围观→</a></p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/01/20140122221511.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/01/20140122221511-600x320.jpg" /></a><p>dp-modern</p></div>
<p>其实很早就有过好几个版本的设想了，但是脑子里浮现出来的基本上是 iOS7 风的单页长视差。大气一点的原则自不必说，之前的个人页自己烦恼了挺久的隐蔽的博客入口的问题也得好好解决。不过等到某天骑着单车准备补课的时候，脑子里却冒出来一个与之前完全迥异的思路。然后等到做完数学试卷后，某人就开始在本子上涂画了起来。</p>
<p><span></span></p>
<p>于是这个被 <a href="http://imnerd.org/" target="_blank">公子</a> 当成了明信片的 Windows Design 风横向卷动的草稿就出现了。没错，整个构思就开始于 Start 右上角的用户名区域和一个由斜方块构成的背景。灵感来源实际上是当初刚见到 Windows 8 尚热衷于折腾 Metro 应用时的一款介绍 Win8 技巧的应用其中交错的菱形 Tile 设计，刚试图搜索了记忆中的几个关键字却没有相同的应用，只剩下曾经上过官方 UI 指南作为示例一个线索。</p>
<p>总之这样的黑白配色也是没有提前预料到只是动手码页面时顺手做出的，在自然而然的给黑色加上了白线作为纹理后，也接受了 JN 评价的「Sci-Fi 风格」。尽管实际上大部分并没有去遵守巨硬的交互，但是包括头像区、按下后的缩放、后面链接 hover 时的边框，都是毫无疑问的 Windows UI 元素。最后的效果可以说是自己相当的满意，只不过条件是你在性能良好的机器上用着 Webkit 访问。</p>
<p>——没错，作为硬伤，浏览器兼容性和性能都差的有点可怕。通过监听鼠标事件实现的横向滚动在 Gecko 下并不存在这个属性，于是因为某人觉得除了首页必须提供提示之外其他页面无法容纳翻页剪头导致狐娘光荣的享受了必须手动拖动滚动条的待遇。因为初期只针对小屏幕进行了布局于是在大屏幕上偷懒使用了响应式配合 html { zoom } 进行了等比缩放，结果放大逻辑被吐槽了很久和根本不支持放大——别和我说 transform scale ——的狐娘被 Webkit Hack 后排除在外，感受到了大屏幕下无力的背景和内容比例。</p>
<pre>@media screen and (-webkit-min-device-pixel-ratio:0) { /* Webkit 专属样式 */ }</pre>
<p>不过说起布局，最开始甚至丧心病狂到用 vw 单位和 calc() 就差动用 gird 布局实现横向多页自适应的某人，最后还是在公子的启发下用百分比辛苦的完成了。除此之外还有用到的技巧是研究 Zespia 菊苣博客中 blockquote 样式后学到的纯 CSS 配合渐变实现的条纹，虽然事实证明大面积利用这个技术极其影响性能并且在某些电脑上会被渲染的极其恐怖之后某人只能择日换成位图了。</p>
<pre>background-color: #010203;
background-image: linear-gradient(to right, rgba(255, 255, 255, 0.25), rgba(0, 0, 0, 0) 1px);
/* 1px 的实色和透明作为间距 */
background-size: 4px 100%;
/* 利用背景尺寸控制重复 */</pre>
<p>当然还有一个用到了 Webkit Hack 的就是 -webkit-filter: brightness(0); 下白色图片转为纯黑的神奇逻辑，成功实现了链接处四个大磁贴某人懒得转换位图图标为 icon font 的图片反色 transition 。至于其他浏览器就只有和文字反色不协调的瞬间切换图片的待遇了，嘛人懒没办法 …… 至于 -webkit-scrollbar 之类的 Webkit 特权就不再多言，至少我不想去手动模拟一个滚动条了。什么，低版本浏览器？没人权。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/01/20140122221553.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/01/20140122221553-600x633.jpg" /></a><p>利用响应式配合 zoom 实现的大屏幕纵向窗口放大移动视图</p></div>
<p>还有值得一提的话，白色背景图是未经提前说明的的盗自 <a href="http://blog.ysmood.org/" target="_blank">YS</a> 的博客然后经 PS 调整了对比度和亮度，关于的文章准备单独写篇目前只是占位而且还没从随手复制的 NOIP 纪念文换成 Fly Out。在姬加提前发 PO 后思萌菊苣的反馈非常感谢，嘛<span>虽然 <a href="http://yufan.me/" target="_blank">雨帆</a> 菊苣在群里扬言说要扒皮，不过我也只能说纯静态的页面我也懒得去做什么保护或者混淆了吧。对了</span><span>作品区说是施工中但是其实不知道这个疲于奔命的寒假什么时候才能搞定，那么，就这些了。</span></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/modern-page/">Modern Sci-Fi Personal Page</a></p>]]></content>
        
        <summary type="html">
            
            唔 …… 大概可以说是预谋很久了，至少是在公布 dp-card 即上一个个人页之前，就准备好要写一个新的主页了。要说直接原因，或许是因为被 JN 吐槽了很多次请换一个，抑或是一时急躁提前公布了之前的个人页无法再用下去了？至少还是在寒假的第二天开工，花了两个下午把这个新的页面完成
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS3"/>
        
        <category term="HTML5"/>
        
        <category term="Webkit"/>
        
        <category term="个人页"/>
        
    </entry>
    
    <entry>
        <title>一个 Div 可以做到的 ……</title>
        <link href="http://blog.dimpurr.com/one-div-css3-cd/"/>
        <id>http://blog.dimpurr.com/one-div-css3-cd/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2014-01-12T11:14:24+00:00</published>
        <updated>2014-01-12T11:14:24+00:00</updated>
        
        <content type="html"><![CDATA[<p>起因是 <a href="http://feelbug.tumblr.com/" target="_blank">Cry</a> 姐在群里提到了 box-shaodow 的 Spread Distanc 属性，于是在测试时钉子就想到做了这样一个模拟了一张 CD 的页面。整个页面只用了一个 div 元素，全部效果完全通过 CSS 实现。<a href="http://work.dimpurr.com/lab/One-Div-CSS3-CD/" target="_blank">查看效果→</a></p>
<div><a href="http://img1.dimpurr.com/dimblog/2014/01/20140106180551.jpg"><img src="http://img1.dimpurr.com/dimblog/2014/01/20140106180551-600x317.jpg" /></a><p>One-Div-CSS3-CD</p></div>
<p>DOM 如下：</p>
<pre>&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;</pre>
<p>光盘整体通过多 box-shadow 和控制阴影距离以及模糊实现，为了保证透明后配色能看调了半天。上下的文字都通过伪元素添加，其中上方的标题用到了 text-shadow 模拟立体效果。四个小点是利用了 border-image 在 Webkit 下诡异的默认渲染和 linear-gradient 的错误打开方式模拟，在别的内核下貌似没有效果。</p>
<p><span></span></p>
<p>下方的换行尝试用 Unicode 换行符失败，最后在 Cry 姐建议下用 white-space: pre; 加空格模拟成功，最后在 <a href="https://plus.google.com/u/0/117654615200385722003" target="_blank">+Kerwin Che</a> 的 <a href="https://plus.google.com/113009935346267402225/posts/gbPUjNiaS4k" target="_blank">建议下</a> 发现只要在 pre 模式下就可以使用 /A 换行了 …… 尝试把 div 元素本身的内容利用起来，但是发现无法完成文字弯曲围绕在光盘内盘的效果只好作罢。暂时就想到了这些玩法，如果还有不破坏美观继续给页面添加元素的纯 CSS 方法敬请告知~</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/one-div-css3-cd/">一个 Div 可以做到的 ……</a></p>]]></content>
        
        <summary type="html">
            
            起因是 Cry 姐在群里提到了 box-shaodow 的 Spread Distanc 属性，于是在测试时钉子就想到做了这样一个模拟了一张 CD 的页面。整个页面只用了一个 div 元素，全部效果完全通过 CSS 实现。查看效果→ One-Div-CSS3-CD DOM 如下
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CD"/>
        
        <category term="CSS3"/>
        
        <category term="HTML5"/>
        
        <category term="Lab"/>
        
        <category term="错误打开方式"/>
        
    </entry>
    
    <entry>
        <title>足兆叉虫的2013</title>
        <link href="https://binux.blog/2013/12/2013/"/>
        <id>https://binux.blog/2013/12/2013/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>我是从来不记日子的，这导致我也不知道有些事情是2013年发生的，还是2012年发生的，亦或只是我的臆想。即便如此，2013年也是变化的一年。</p><p>跳槽，工资没涨，工作忙了2倍，但经手了更大的系统（虽然设计很渣），更多协调，带小弟，基本达到了初衷，也说不上是好是坏。搬离大学生活圈、一个人住，第一次有家的感觉，虽然依旧一个人。</p><p>想学日语，想出国，但完全没有干劲。</p><p>依旧是没有理想，没有希望的一年，就这样一觉不起就好了。</p>]]></content>
        
        <summary type="html">
            
            我是从来不记日子的，这导致我也不知道有些事情是2013年发生的，还是2012年发生的，亦或只是我的臆想。即便如此，2013年也是变化的一年。跳槽，工资没涨，工作忙了2倍，但经手了更大的系统（虽然设计很渣），更多协调，带小弟，基本达到了初衷，也说不上是好是坏。搬离大学生活圈、一个
            
        </summary>
        
        <category term="2013"/>
        
    </entry>
    
    <entry>
        <title>dp-card – 钉子的个人页一代</title>
        <link href="http://blog.dimpurr.com/dp-card/"/>
        <id>http://blog.dimpurr.com/dp-card/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-12-27T13:15:55+00:00</published>
        <updated>2013-12-27T13:15:55+00:00</updated>
        
        <content type="html"><![CDATA[<p>这是一个 HTML5 + CSS3 的个人名片页，附带响应式移动版，兼容 IE9 及以上浏览器。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/20131227195958.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/12/20131227195958-600x334.jpg" /></a><p>dp-card</p></div>
<p>最近有不少同学表示了对钉子目前个人页的喜爱，<del>虽然个人觉得并不咋滴，</del> 正好准备过段时间重新设计新版的个人页，于是好好修正了一下放出来了。出于无聊重新修改了各种语义化标记，把脚本也重做了，并且通过了 W3C 验证，感谢 <a href="http://www.joyneop.com/">@JoyNeop</a> 菊苣的挑刺 …… 纯 HTML5 页面，需要请自行修改相关内容。有问题可以回复，可能不接受新的功能需求。</p>
<h3><span></span>获取源码：</h3>
<ul>
<li><a href="https://github.com/dimpurr/DimPage" target="_blank">Github</a></li>
<li><a href="https://github.com/dimpurr/DimPage/releases/tag/dc-1.1" target="_blank">Github Release</a> v1.1</li>
</ul>
<h3>更新历史：</h3>
<ul>
<li>13-07-03：第一版本完成</li>
<li>13-10-28：万圣节样式更新</li>
<li>13-12-07：添加微数据，谷歌结构化数据检测通过。</li>
<li>13-12-26：HTML结构重写，脚本和细节样式修改，W3C验证通过</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/dp-card/">dp-card – 钉子的个人页一代</a></p>]]></content>
        
        <summary type="html">
            
            这是一个 HTML5 + CSS3 的个人名片页，附带响应式移动版，兼容 IE9 及以上浏览器。 dp-card 最近有不少同学表示了对钉子目前个人页的喜爱，虽然个人觉得并不咋滴， 正好准备过段时间重新设计新版的个人页，于是好好修正了一下放出来了。出于无聊重新修改了各种语义化标
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS3"/>
        
        <category term="HTML5"/>
        
        <category term="个人页"/>
        
        <category term="介绍"/>
        
        <category term="前端"/>
        
    </entry>
    
    <entry>
        <title>Fly Out.</title>
        <link href="http://blog.dimpurr.com/fly-out/"/>
        <id>http://blog.dimpurr.com/fly-out/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-12-23T15:34:50+00:00</published>
        <updated>2013-12-23T15:34:50+00:00</updated>
        
        <content type="html"><![CDATA[<p>大概也不过是 2013 年 6 月 20 日，也就是正好半年前， Dimpurr 这个奇怪的拼写被赋予了含义。自此之后又过了无数个白天和夜晚，直到某天大概仅仅是觉得有必要再为自己写一篇相对详细的自述了，亦或是忽然间有些无聊，总而言之，就有了这篇间杂了回忆和痴想的意识流文章的存在。</p>
<p><span></span></p>
<p>——童年总是不会缺少满满的中二，每天和密友激烈思辨名为科幻小说实为无下限臆想的故事，也因此让无数个只用了数页的本子含冤而逝。直到三年级的时候钉子遇到了那位将改变钉子一生的人，从此之后每天写写画画涂涂改改打打闹闹的朦胧而又五彩缤纷的日常带着些许稚气拉开序幕。现在回想起来当时的钉子是个十足的矛盾体，在学习上是个十足的好学生但是纪律方面几乎无恶不作。就算放着惬意而无法无天的日常作死不谈，无论是班级大陆间奇葩设定辈出的国家混战还是致力于驱除三大老师聚齐带来的厄运的宗教抑或又是每年必有的神级绘师负责的年终特典，那群创造力过剩的死党们总是能发明新鲜的玩意儿。真的是，曾经觉得什么都能做到的岁月。</p>
<p>当然估计现在应该感谢学校的电脑封锁了4399等一系列网站，因为母亲是教师所以常年霸占办公室电脑的某钉子感到极其不满，不知何时已经能把优化系统和浏览 System32 作为娱乐时，就已经彻底走向了一条不归路。曾经的大数字刚推出软件管家还是业界良心，曾经的疼讯TT还是微创新MyIE的绝赞多标签浏览器，曾经的谷攻中国研究院还在为发展中国市场而努力，曾经S60V3的诺记N95还是世界一流的机皇……嘛扯远了总之在某人对把所有输入法挨个安装试用一遍然后被母上痛骂一顿这样的玩法感到腻味之后终于开始在本子上写写画画起来。然后从乱画到照抄再到加上功能设计，从软件到硬件再到企业形象，线框到视觉再到平面广告，至今钉子还保留着成为一名交互设计师的梦想。</p>
<p>——因此现在还是可以看着那满柜子的本子回忆自己幼稚的笔触，除了数码的两摞，依次还有记录着不忍直视的天坑和透视错误的汽车造型以及一本被用来抄了两年书和写了两年检讨的所谓生日礼物的本子。当然从技术的维度来说此时的钉子只是个喜欢用会声会影的模板和 3DS Max 的粒子系统小打小闹的渣渣，虽然某人自己坚持认为要不是为了找免费域名和空间浪费了整个五年级大概还会更有些进步。只是作为电脑方面的特长也没有被眼尖的老师们浪费，于是在主动给班级建立了博客之后制作班报剪辑纪念视频这种任务也毫无疑问的落到了身上。因此说当时在摆弄 Publish 的钉子心里确实是以为自己以后会从事出版或者平媒方面的行业，直到有一天知道了交互这个词的涵义。</p>
<p>也不知道是该说小宇宙爆发还是怎么的，五年级还考出过不及格的某人意外的体验到了年级第一的滋味然后成为了藏龙卧虎的市重点实验班里的一只大熊猫。只是初一初二时学习压力还不是什么值得一谈的问题，倒是在小学毕业的暑假中成功用 IIS6 + Fast-Cgi 配合花生壳在自家电脑上搭起了一个 Dedecms ，随后开始琢磨起了建站方面的事情的钉子最后还是耐不住性子放弃了当一名站长的想法。与此同时书柜里属于用户体验的空间终于已经慢慢逼近了量子力学的时候，也代表了成为科学家这个每个孩子都曾有过的单纯梦想在钉子意味上的结束。</p>
<p>——今年在YY上过的那个元旦互道「新年快乐」的声音仍然犹在耳边，然而转眼间一切的事情就已物是人非。年初第一次完全手写 HTML 的个人页仍然保存在服务器的某个目录里，暑假末承诺的 Clearision 也成为了钉子的第一个也是最受好评的作品。国庆假期拿到那两百元的时候或许还是有些踹踹不安，但是第二单就冒到了2K的时候也稍微长了点谈价方面的记性。仅仅是六个月的时间，为了躲避三次元的目光而生造出来的这个形象开始变得有存在感，无论是人气略微上涨的博客还是受到些许好评的作品居然也能以自己的方式，去影响他人了。</p>
<p>作为一名据说是稀有血统的 INTJ 梦想家 ，钉子却并不喜欢改变世界，宁可让自己轻松一点去过没那么风光但也平静幸福的生活。理想中的自己大概会是位主持创业团队和用户界面的设计师，业余不时写一些尚能入目的文字，虽说绘画因为父母的反对最终成为了手残但仍抱有一线希望，若能成为编曲广受好评的V家名P则是更好。小的时候幻想自己的公司统治着全世界的终端，每个人起床都会看到自己的 LOGO 。只是随着成长也已经没有再做白日梦的余地，只能化为所谓不断督促自己前行的动力。</p>
<p>——中考的压力并不是什么令人愉悦的事情，但是大概为了自己的梦想只能直面这个挑战。稍微瞥了一眼自己为自己定下的计划表，想起来自己曾经抱怨备考 NOIP 那段时间是人生中第一次拼命，没想到马上又有了再次体验的机会。大概直到明年八月考完某场至关重要的考试超越某个曾经仰望的人站在某个万众瞩目的讲台之后，钉子才能如愿以偿的给自己再放一个长假吧。尽管完全无法保证也无从得知这些目标能不能实现，但是如果永远不去做那么只会徒增后悔吧。大概这就是成长，只能不断的这样安慰自己，然后继续每一个作死的非日常。</p>
<p>虽说本来只是想给自己写篇简单的自我介绍，结果似乎还是没有避免成为一篇自说自话的中二文的命运。说起来因为时间原因周记也没有再写下去，那么在此延续一下一直以来的小小传统以表祭奠吧。文字环境依旧 Power Write 加 Google Keep 完成，历时大概两个晚上，标题来自至今为止循环次数最多但仍然最喜欢的专辑「Re:Dial」。时针仍然在随着石英的震荡缓缓向前，未来还不可预见而需要用双手去缔造。就算抛开其他的不谈，至少为了让自己以后不会为了此刻的举动后悔，那么就尽最大努力去前进吧。</p>
<p>千里之行，始於足下。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/fly-out/">Fly Out.</a></p>]]></content>
        
        <summary type="html">
            
            大概也不过是 2013 年 6 月 20 日，也就是正好半年前， Dimpurr 这个奇怪的拼写被赋予了含义。自此之后又过了无数个白天和夜晚，直到某天大概仅仅是觉得有必要再为自己写一篇相对详细的自述了，亦或是忽然间有些无聊，总而言之，就有了这篇间杂了回忆和痴想的意识流文章的存在
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="ADC"/>
        
        <category term="中考"/>
        
        <category term="出版"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
        <category term="回忆"/>
        
        <category term="平媒"/>
        
        <category term="成长"/>
        
        <category term="期末考"/>
        
        <category term="青春"/>
        
    </entry>
    
    <entry>
        <title>StartPress – 空 WordPress 主题脚手架</title>
        <link href="http://blog.dimpurr.com/startpress/"/>
        <id>http://blog.dimpurr.com/startpress/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-12-11T15:13:04+00:00</published>
        <updated>2013-12-11T15:13:04+00:00</updated>
        
        <content type="html"><![CDATA[<p>这是一个 HTML5 的空 WordPress 主题，可以基于此快速开始新主题的创作。内置了基本的输出结构和函数，没有任何多余样式标签。目前处于早期测试版本还较不稳定，欢迎试用和反馈。<a href="https://github.com/dimpurr/StartPress" target="_blank">Github 项目地址→</a></p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/20131211225917.png"><img src="http://img1.dimpurr.com/dimblog/2013/12/20131211225917-600x450.png" /></a><p>StartPress</p></div>
<p>因为连续制作了几个主题之后遇到了例如首页 meta 标签等的复用问题，于是就花了一晚上在几个主题的基础上修改合并成了这个空主题，并加上了注释。这只是一个单纯的空白主题，并且内置了一些常用函数，并不是一个框架，也没有复杂的功能。代码格式和文件结构有一定的个人风格，也欢迎诸位来添砖加瓦。预计将会在今后增加关于后台设置的框架。</p>
<p><span></span></p>
<p>一切以 Github 的最新版本和 README 为准。</p>
<h3>获取</h3>
<ul>
<li><a href="https://github.com/dimpurr/StartPress" target="_blank">Github</a></li>
</ul>
<h3>特点</h3>
<ul>
<li>完善的注释说明</li>
<li>仅进行基本文章输出，没有多余的标签、容器和 ID \ Class</li>
<li>文章输出默认剥离到 <em>content.php</em> ，无内置 <em>single.php</em> 和 <em>page.php</em></li>
<li>内置了导航栏、侧边栏、语言包的注册函数</li>
<li>内置了评论、页码、检查更新、使用统计等常用函数</li>
<li>仅内置了 Reset 重置样式表和一个 <em>#page</em> 页面容器，无多余样式</li>
</ul>
<h3><a href="https://github.com/dimpurr/StartPress#%E6%B3%A8%E6%84%8F" name="%E6%B3%A8%E6%84%8F"></a>注意</h3>
<ul>
<li>请将 <em>,’dpt’</em> 使用编辑器查找替换为<em> ,’主题的文本域’ </em>，当然也可以直接使用 <em>dpt</em></li>
<li>若需使用检查更新，请将 <em>func/info.json</em> 上传到服务器并填写正确的版本号和安装包地址，更新时只需更新<em> info.json </em>和安装包</li>
<li>若需使用使用统计，请将 <em>func/theme_tj.php</em> 上传到服务器并设置数据库和密码</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/startpress/">StartPress – 空 WordPress 主题脚手架</a></p>]]></content>
        
        <summary type="html">
            
            这是一个 HTML5 的空 WordPress 主题，可以基于此快速开始新主题的创作。内置了基本的输出结构和函数，没有任何多余样式标签。目前处于早期测试版本还较不稳定，欢迎试用和反馈。Github 项目地址→ StartPress 因为连续制作了几个主题之后遇到了例如首页 me
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="HTML5"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
        <category term="模版"/>
        
    </entry>
    
    <entry>
        <title>カラフルなのダイヤルパッド</title>
        <link href="http://blog.dimpurr.com/030-buy/"/>
        <id>http://blog.dimpurr.com/030-buy/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-12-08T02:21:29+00:00</published>
        <updated>2013-12-08T02:21:29+00:00</updated>
        
        <content type="html"><![CDATA[<p>大概当时的钉子，还处在非常好的状态。期中考做好历史新低的准备，结果是历史新高；只接过两百元的第一单，然后就接到了一千五的第二单……于是某人果断决定出血一回，稍微慰劳一下自己劳累的心灵——</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131207_214959.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131207_214959-600x450.jpg" /></a><p>钉子の无脑购物行为 案发现场底片</p></div>
<p><span></span></p>
<p>当然预谋已久的，而且估计也就会入那么一两次的，钉子首先开始了 Vocaloid 专辑的挑选。经过在萌购上不断挑选和虾米上不断试听，某人终于确定了一个候选列表：</p>
<ul>
<li>supercell (通常盤) [CD+DVD]</li>
<li>花楽里漫葉集 feat.初音ミク(DVD付) [CD+DVD]</li>
<li>EXIT TUNES PRESENTS Vocalostar feat.初音ミク [CD-ROM]</li>
<li>EXIT TUNES PRESENTS Vocalogenesis(ボカロジェネシス)feat. 初音ミク(ジャケットイラストレーター 三輪士郎) [CD-ROM]</li>
<li>EXIT TUNES PRESENTS Vocaloconnection (ボカロコネクション) feat.初音ミク (ジャケットイラストレーター:左) (数量限定オリジナルマウスパッド&amp;ストラップ付)</li>
<li>EXIT TUNES PRESENTS Vocalonation(ボカロネイション) feat.初音ミク（ジャケットイラストレーター　左） 【数量限定オリジナルストラップ付き】 [CD-ROM]</li>
<li>EXIT TUNES PRESENTS Vocaloanthems(ボカロアンセムズ) feat.初音ミク(ジャケットイラストレーター redjuice) 【数量限定オリジナルストラップ付き】 [CD-ROM]</li>
<li>EXIT TUNES PRESENTS Vocalogemini(ボカロジェミナイ) feat.鏡音リン、鏡音レン（ジャケットイラスト：2D）【数量限定ラバーストラップ＆マウスパッド付】</li>
<li>EXIT TUNES PRESENTS Vocalonexus (ボカロネクサス) feat.初音ミク(ジャケットイラストレーター 左) 【数量限定オリジナルストラップ付き】 [CD-ROM]</li>
</ul>
<p>…… 嗯，价格总和非常可观。经过和母上大人诚恳感人，情深意切，哭天喊地的协商交涉，某人终于成功把预算从两张提到了三张。又是一番割肉之后，成功下单：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/20131207235307.png"><img src="http://img1.dimpurr.com/dimblog/2013/12/20131207235307-600x208.png" /></a><p>萌购订单</p></div>
<p>正好是阴雨连绵的时节，两个包裹都是在愉快的冒雨赶到小区传达室拿的。第一次拿到 Re:Dial 期间限定版时还对「萌购封印」什么的饶有兴趣，拆第二箱时也已经轻车熟路了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131127_203703.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131127_203703-600x450.jpg" /></a><p>Livetune – Re:Dial</p></div>
<p>大概是钉子刚入宅的时候，无意间在B站首页看到了 Re:Dial 的 1080P PV ，从此才控上了V家。作为钉子从320K到FLAC到ISO，在各种码字、码页面、码程序、跑步、写作业、睡觉的场景下洗脑循环无数次的专辑，无论如何也从没有听厌过。虽然本着省钱原则希望收几张资源不多的专辑，但是最后还是因为期间限定DVD再次入了CD。</p>
<p>拿到手之后只能说，装帧真心非常漂亮，材质也十分良心。唯一的遗憾是 Cover 上那张巨大的横图本以为会是海报，结果实际上只是纸底板而已……当然马上塞进家里的DVD用创维酷开观赏了自带的四个PV，只是最后因为不堪忍受附送的劣质音响决定用电脑导出再看。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131130_213320.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131130_213320-600x450.jpg" /></a><p>EXIT TUNES PRESENTS Vocalostar &amp; Vocaloanthem</p></div>
<p>相对之下 EXIT TUNES PRESENTS 的两张专辑就显得十分普通了，倒是 Vocaloanthems 附送了个卡片和钥匙扣（虽然又重而且图案泛黄……）。当然最重要的还是歌，既然装帧本身观赏价值不搞，要做的自然是推进家里的可移动 DVD-RW 开始烧录了呐。</p>
<p>……中略，总之经过九九八十一难，钉子&amp;螺丝&amp;囧叔的赔钱计划实行小组终于成功靠着坚韧不拔的毅力，卡住不松的定力，还有赚钱吃饭的动力拿到了 ￥1500 大洋。分到 ￥750 的钉子当然准备用自己得来的这笔巨款升级一下身边的设备，首当其冲就是手机堪比地摊MP3的劣质输出了。</p>
<p>说到这个不得不提到一个悲伤的故事。之所以会接这一单，实际上是因为钉子对 RMB 意外只需 1K2 的小圆脸纪念 WalkMan 垂涎已久。然后在拿到钱的前天晚上，嗯，不过是前天晚上而已，就连愿意帮忙代购的 +Nanachi Pan 菊苣都联系好了的钉子，惊讶的发现限量版售完了……</p>
<p>放弃治疗的钉子一通心里斗争和比价选购，在 1K9 的 WalkMan F886 ，1K3 的 Meizu MX2 ， 1K4 的 Nexus 4 ， 499 的 Colorfly C3 之间选择了 Nexus 4 。然后，发现四太子也没货了……最后看在可接受的价格范围，最后选择了性价比不错，音质好评，外观先进的七彩虹 Pocket Hifi C3 。于是——</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131201_113654.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/12/IMG_20131201_113654-600x450.jpg" /></a><p>Colorfly Pocket HiFi C3</p></div>
<p>一切看起来都是那么完美，直到开始实际使用时，钉子开始后悔之前狠心没有听取一直很信任的亚马逊评论。 以下摘自某人的 Z.CN 评论：</p>
<blockquote><p>抱歉二货亚马逊女战士们还没审核通过看不到那评论懒得再写一遍过几天再补上吧总之大致意思就是音质什么的确实不错音轨层次很清晰就是设计太TM的难用了谁想出来的触摸设计啊换个歌都不能盲操而且重启不记忆播放进度不知道是不是固件原因另外开关机都啵的一声据官方说是为音质做出的牺牲牺牲你妹啊</p></blockquote>
<p>当然在是否退货间迟疑了很久，最后还是因为几乎完全没有同价位的音质主打产品而放弃了。于是一旦接受了这些设定，其实这 MP3 还是蛮高端大气上档次悦耳动听感人心的 ……</p>
<p>于是这就是钉子的无脑烧钱纪念文一篇，因为在极其复杂的环境下完成质量有点不忍直视。总而言之著文以表纪念，以上。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/030-buy/">カラフルなのダイヤルパッド</a></p>]]></content>
        
        <summary type="html">
            
            大概当时的钉子，还处在非常好的状态。期中考做好历史新低的准备，结果是历史新高；只接过两百元的第一单，然后就接到了一千五的第二单……于是某人果断决定出血一回，稍微慰劳一下自己劳累的心灵—— 钉子の无脑购物行为 案发现场底片  当然预谋已久的，而且估计也就会入那么一两次的，钉子首先
            
        </summary>
        
        <category term="次元爱"/>
        
        <category term="ACG"/>
        
        <category term="CD"/>
        
        <category term="MP3"/>
        
        <category term="Vocaloid"/>
        
        <category term="专辑"/>
        
        <category term="亚马逊"/>
        
        <category term="初音"/>
        
        <category term="无损"/>
        
        <category term="萌购"/>
        
        <category term="购物"/>
        
        <category term="音乐"/>
        
    </entry>
    
    <entry>
        <title>页面布局孰优孰劣：基于REM的EMs弹性布局——可用性的胜利</title>
        <link href="http://blog.dimpurr.com/ems-layout/"/>
        <id>http://blog.dimpurr.com/ems-layout/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-12-06T13:12:22+00:00</published>
        <updated>2013-12-06T13:12:22+00:00</updated>
        
        <content type="html"><![CDATA[<p>页面布局的方式总是随着技术的更新和创意的涌现不断的更新换代。从最开始的 Fixed 固定布局，到因为宽屏设备和移动互联网的普及产生的响应式和自适应，再到「Mobile First」的设计理念，前端们在可用性方面做的努力越来越多。</p>
<p>REM 是一个在 CSS3 中被提出的新单位，相对 EM 变为了针对根元素 &lt;html&gt; 的 font-size 计算，使得便利性大为提升的弹性布局再次被提上话题。在介绍具体实现之前，不妨先说说为何要选择 EMs 进行布局。</p>
<p>脱离了表格布局的蛮荒时代后，越来越多的基本布局方式被应用在了实践中，当然也不乏多种配合。以下就是几个常用技术的对比。<i>（响应式和自适应这两个名词经常被错误使用，例如 <a href="http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html">自适应网页设计（Responsive Web Design）</a> 这篇文章</i></p>
<ul>
<li><b>固定 Fixed</b><br />
使用 px 和 pt 这样的绝对单位进行固定布局。在无论什么设备上保持固定的尺寸，在不适合的分辨率下可能导致大面积空白或横向滚动条。最经典，也是被证明极其不友好、维护困难的方法。</li>
<li><b>流动 Fluid</b><br />
使用 % 百分比进行相对布局。可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。某些情况下可能导致错误的伸缩或者布局被破坏。</li>
<li><b>弹性 Elastic</b><br />
使用 em 或 rem 单位进行相对布局。避免了根据 px 布局在高分辨率下几乎无法辨认的缺点，又相对 % 百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示。需要一段时间适应而且不易从其他布局转换过来，但几乎是目前最好的布局方式。</li>
<li><b>伸缩 Flexbox</b><br />
使用 CSS3 Flex 系列属性进行相对布局。对于富媒体和复杂排版的支持非常强大，但是还未普及并且兼容性较差。</li>
<li><b>响应式 Responsive</b><br />
使用 <a href="http://blog.dimpurr.com/css-media/">@media 媒体查询</a> 给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，但是在同一个设备下实际还是固定的布局，并且因为浏览器的支持原因对介质的检测还不实用。</li>
<li><b>自适应 Adaptive</b><br />
通常使用 <a href="http://blog.dimpurr.com/css-media/">@media 媒体查询</a> 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是利用响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术综合统称。自适应几乎已经成为优秀页面布局的标准。</li>
</ul>
<p><span></span></p>
<p>弹性布局在一众相对布局中毫无疑问拥有极大的优势。除了以上提到的几点之外，以下几点也是非常有用的特性：</p>
<ul>
<li><b>优秀的兼容性</b><br />
不同于 FlexBox 等初生标准，浏览器对于 em 的支持非常的好，同时对于 rem 的支持也比预料中稍佳。如果使用 LESS 或者 SASS 等 CSS 预处理器，还可以做对于低版本浏览器 (IE8-) 的 px 降级处理。<a href="http://caniuse.com/rem">CanIUse 的兼容表</a></li>
<li><b>哇！我看不到像素点</b><br />
使用绝对尺寸单位进行布局的最大缺点，就是在动辄1080P的手机屏幕上将小到难以阅读，同时过高的分辨率也会使媒体查询无法发挥应有的功效。但是如果使用 em 字体大小进行布局，就可以方便的利用系统默认字号设定了。</li>
<li><b>对于浏览器用户字体大小设置的支持</b><br />
对于视力障碍和残障人士，可以在浏览器的设置中更改字体的大小，但不同浏览器迥异的缩放模式经常使得使用固定尺寸单位的网站布局崩溃，而这种时候 EMs 单位可以保证完全一致自然的效果。</li>
<li><b>对于页面缩放的响应式支持</b><br />
在平常阅读中也常有缩放页面的需要，弹性布局可以在缩放中正确的激活响应式。反观使用绝对单位判断的响应式，可能在部分浏览器中当缩放的实际显示空间不够时仍然使用为大可视区域设计的样式，容易导致布局崩溃。不过在现代浏览器中已经会激活对应的查询。</li>
<li><b>保持一致的换行</b><br />
完全使用 EMs 单位进行布局的话，缩放过程中文字和图片不会产生流动，可以完美的保持布局的美观和稳定。</li>
</ul>
<p>尽管如此，随之而来的还有一些美中不足的小问题。如果还有发现其他弊端，也欢迎 <a href="http://blog.dimpurr.com/ems-layout/#comments">在此回复</a> 。</p>
<ul>
<li><b>如何惹恼 Work Flow 上的其他人</b><br />
在完整的工作流程中，各种原型、视觉、切图很难全部使用 em 作为计量单位，只能在前端实现的时候转换。而且默认的 1em:16px 计算也较为不便，后面会提到一个巧妙的解决方法。</li>
<li><b>麻烦的父级元素 font-size 继承</b><br />
如果使用 em 作为尺寸单位，因为 em 相对父元素 font-size 值进行计算的特性，如果中间有对元素的字体大小进行更改，子元素的全部布局就会出错。这点现在可以很方便的通过相对于根元素的 rem 单位计量来避免。</li>
<li><b>不该放大的图片</b><br />
假如为图片使用了 em 设定尺寸，在响应不同设备的字体时就会按比例增大而导致模糊。但是如果使用常规的 px 设定尺寸，又会失去文字排版均一的好处。考虑到平常的设计中文字流动并没有影响，可以稍微牺牲可用性而用 px 设定图片尺寸。</li>
<li><strong>养成坏习惯容易，好习惯难</strong><br />
从 ems 单位切换到 px 或者 pt 只需要简单的单位转换，而从绝对单位向弹性布局转换绝对不是一个好的体验。因此在项目开始时就应该确定好弹性布局的基础，否则后期迁移并不容易。</li>
</ul>
<p>那么如何开始一个弹性布局的页面呢？不不不，除了使用 em 作为单位表示尺寸之外，还有一些可以用到的技巧：</p>
<ul>
<li><strong>为根元素设置 font-size: 100%</strong><br />
在 IE 上的文字缩放选项并不符合常规情况下的预期，即在特大和特小的情况下缩放不是平滑的，很容易导致文字被缩放到难以阅读的程度。此时就可以为 &lt;html&gt; 元素指定 100% 的字体大小，以即时响应用户的缩放。</li>
<li><strong>为文档元素设置 font-size: 62.5%</strong><br />
先前已经提到过，尽管所有浏览器都一致的保持着 16px 的默认字号，但是 1:16 的比例明显十分不方便计算。将字号设为 10px 会使 Ems 布局前功尽弃，此时通过设置为 16px 的 62.5% 就可以很方便的利用十进制进行计算了。当然如果你选择使用的是 rem 为单位，需要牺牲低版本 IE 的兼容性将 &lt;html&gt; 的 font-size 设为 62.5% 。</li>
<li><strong>为媒体查询使用 ems</strong><br />
对于前面提到的对 Retina 高清分辨率屏幕的支持，使用 em 为单位的媒体查询就是一个有用的技巧。当每行能容纳的文本少于某个值时进行响应而不是宽度为某个像素进行响应，将会大大改善响应式设计的使用体验。</li>
<li><strong>为 rem 使用预处理器</strong><br />
随着 rem 的推出，弹性布局最大的麻烦之一得到解决。但是尽管 em 的支持已很有历史， rem 却仅支持最新的几个浏览器版本，在低版本浏览器上的显示效果将会是灾难级的。提前使用 SASS 等 CSS 预处理器为低版本浏览器准备好一个 px 为单位的降级很有必要，这里不再详述，可自行查找相关资料。</li>
</ul>
<p>基本上只要明确了以上几点，就可以按平常的方法继续进行网页的布局。不过正因为弹性布局是一个为阅读体验而生的技术，在这方面稍加注意，还可以更好的发挥弹性布局的优势。</p>
<ul>
<li><strong>让行高保持节奏</strong><br />
这是一个提高阅读体验的绝妙方法 —— 让所有元素的行高始终保持为一个值的倍数，想想网页是平铺在一个有行线的笔记本上，让每个元素都完美的占据多格的中间而不压线。请注意，没有阅读体验的弹性布局一文不值。</li>
<li><strong>提供不同文字大小的样式</strong><br />
很多站点都会为了照顾不同用户提供大中小的样式表，在弹性布局下的实现更加容易。如果用户不懂得更改浏览器的显示设定，仅需要提供 body 元素 font-size 不同的几个样式表，即可马上对整个网页进行缩放。</li>
<li><strong>不必关注像素，而是比例</strong><br />
尽管为了配合视觉设计我们需要在实际过程中进行 px 到 em 的转换，但是因为缩放的存在，实际需要聚焦的核心不是尺寸本身而是整体布局的比例。只要确定正常视图下布局处在一个合理的大小和位置，剩下的交给 ems 就好了。</li>
<li><strong>脱离样式表可用</strong><br />
这是和弹性布局无关的一条可用性建议。永远为网页保持合理的 DOM 结构，不为了样式服务颠倒顺序，让网页即使脱离样式表也十分完美。如此一来就算是在屏幕阅读器、字符浏览器等极端环境下，仍然可以保持最大化的体验。</li>
</ul>
<p>尽管在中国并不十分流行，弹性布局仍然是一个极其优秀和体验良好的布局方式。互联网的发展促进了信息的传播，然而推广网页设计的无障碍化仍然需要很多的努力。在日新月异的网格、瀑布流等布局出现的今天，弹性布局依旧不失为追求简洁和阅读享受的网页设计师的一具利器。</p>
<p>最后吐槽一下，经过长时间的搜集资料和准备，花了两天晚上且中间间隔两周才把这篇文章写了出来。感觉依旧完全是在罗列要点，没有多少文采和趣味可言，不知何时写技术文章的文笔才能好一点呢……</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/ems-layout/">页面布局孰优孰劣：基于REM的EMs弹性布局——可用性的胜利</a></p>]]></content>
        
        <summary type="html">
            
            页面布局的方式总是随着技术的更新和创意的涌现不断的更新换代。从最开始的 Fixed 固定布局，到因为宽屏设备和移动互联网的普及产生的响应式和自适应，再到「Mobile First」的设计理念，前端们在可用性方面做的努力越来越多。 REM 是一个在 CSS3 中被提出的新单位，相
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS"/>
        
        <category term="HTML5"/>
        
        <category term="前端"/>
        
        <category term="响应式"/>
        
        <category term="布局"/>
        
        <category term="弹性布局"/>
        
        <category term="流动布局"/>
        
        <category term="自适应"/>
        
    </entry>
    
    <entry>
        <title>为 WordPress 主题添加文章形式支持和注册自定义类型</title>
        <link href="http://blog.dimpurr.com/wp-postformats/"/>
        <id>http://blog.dimpurr.com/wp-postformats/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-11-24T14:39:41+00:00</published>
        <updated>2013-11-24T14:39:41+00:00</updated>
        
        <content type="html"><![CDATA[<p>WordPress 3.1 之后，推出了一个模仿 Tumblr 的「文章形式」功能，可以让博客中除了默认的文章之外展现出更多的特殊样式。不同的文章形式，可以支持在输出时进行判断处理，以及列出存档等等……很多细心的主题里面都会加上对一些文章形式的支持，如果在面临特殊需求时，希望能够自定义专门的编辑器或者分类目录，那么还可以去注册一个自定义的文章类型。</p>
<h3>一 内置形式</h3>
<p>WordPress 已经内置对几种常用的文章形式的支持，如果可以满足需要，那么就不需要再重复造轮子了，只需要添加主题对已有形式的支持就好了。内置形式列表如下：</p>
<ul>
<li>standard – 标准，也就是默认的文章形式</li>
<li>aisde – 日志，实质上就是个不显示标题的标准文章</li>
<li>link – 链接，类似 Tumblr 的链接分享</li>
<li>quote – 引语，展示为引用的一段文字</li>
<li>status – 状态，简而言之就像是一条 Tweet</li>
<li>image – 图像，发布单张图片</li>
<li>gallery – 相册，也就是扩充的图像功能</li>
<li>audio – 音频，……需要说吗</li>
<li>video – 视频，……同上</li>
<li>chat – 聊天，以专门格式显示聊天记录</li>
</ul>
<p>如果想添加对以上形式的支持，只需要在 functions.php 里添加对应的项目即可，然后在输出文章的时候使用函数判断切换不同的样式：</p>
<p><span></span></p>
<pre>// 添加对文章样式的支持，在数组中增加以上列表的类型别名即可
add_theme_support( 'post-formats', array( 'status', 'chat' ) );

// 在输出文章时，增加一个判断语句来使用不同的输出格式
// has_post_format() 函数返回判断是否是该形式的布尔值
if ( has_post_format( 'chat' )) { echo 'orzFly 22:27:28: 我勒个去我说好像在哪儿听说过三三。。'; }
// get_post_format() 函数返回文章形式的别名
if ( get_post_format() == 'status' ) { echo '不愉快です。'; }
// 还可以利用 post_class() 函数给每个形式输出专有类的功能，在HTML结构差异不大无需更改的情况下使用
&lt;div id="post-&lt;?php the_ID(); ?&gt;" &lt;?php post_class(); ?&gt;&gt;</pre>
<h3>二 注册自定义类型</h3>
<p>如果以上自带的函数无法满足贪得无厌的你的需求，除了自定义栏目以外，还可以来定制一个属于自己的文章类型。示例如下：</p>
<pre>function custom_format() {
// 文章形式设置
	$args = array(
		'public'	=&gt; true,
		'label'		=&gt; '时间轴'
	);
// 注册文章形式函数，需要别名和设置数组两个参数
	register_post_type( 'timeline', $args );
}
// 添加注册动作
add_action( 'init', 'custom_format' );</pre>
<p>至于设置的内容，这个就多了。常用的设置属性如下，是否开头的项值都是 true 或者 false：</p>
<ul>
<li>label – 标签，也就是文章形式的显示名称</li>
<li>labels – 实际上是重命名编辑器对于该文章形式显示的界面提示文字内容，例如菜单名称或者文章保存之后的提示信息。需要传送一个数组，贴心的你一定会挨个自定义一遍，是吧……包括的数组值 id 如下：
<ul>
<li>name</li>
<li>singular_name</li>
<li>menu_name</li>
<li>all_items</li>
<li>add_new</li>
<li>add_new_item</li>
<li>edit_item</li>
<li>new_item</li>
<li>view_item</li>
<li>search_items</li>
<li>not_found</li>
<li>not_found_in_trash</li>
<li>parent_item_colon</li>
</ul>
</li>
<li>description – 对文章类型的描述</li>
<li>public – 是否默认公开，或者只在后台显示</li>
<li>exclude_from_search – 是否从搜索中排除</li>
<li>publicly_queryable – 是否可以使用 parse_request() 在前端公开查询</li>
<li>show_ui – 是否在后台显示默认的管理界面</li>
<li>show_in_nav_menus – 是否显示在菜单管理的添加提示里</li>
<li>show_in_menu – 是否在开启 show_ui 的情况下在管理菜单中显示</li>
<li>show_in_admin_bar – 是否在 Admin Bar 的新文章菜单中显示，默认同上值</li>
<li>menu_position – 在管理菜单中显示的位置，使用数字指定。放上几个常用的值参考：
<ul>
<li>5 &gt; n – 整个菜单的顶部</li>
<li>10 &gt; n &gt; 5 – 在文章和媒体菜单之间</li>
<li>n &gt; 25 – 在评论菜单之后</li>
<li>n &gt; 60 – 在第一个分隔符后</li>
<li>100 &gt; n &gt; 80 – 在设置菜单之后</li>
<li>n &gt; 100 – 在第二个分隔符后</li>
</ul>
</li>
<li>menu_icon – 菜单的图标，不指定使用一个齿轮的默认图标</li>
<li>capability_type – 编辑模式，可以指定如下值：
<ul>
<li>post – 文章，默认的文章编辑器</li>
<li>page – 页面</li>
<li>attachment – 附件</li>
<li>mediapage – 媒体页面</li>
</ul>
</li>
<li>capabilities – 最强大也是最复杂编辑器设置。传入的值是一个数组，一般来说就用到其中的七个数组，也可以用到扩展的更多项，对其设置可以完全自定义其编辑页面：
<ul>
<li>edit_post, read_post, delete_post – 编辑，读取，删除操作</li>
<li>edit_posts – 文章编辑器</li>
<li>edit_others_posts – 编辑非用户所有的文章时的编辑器</li>
<li>publish_posts – 文章公共项目的管理</li>
<li>read_private_posts – 可以被读取的私有项目</li>
<li>非核心的扩展项目不再叙述。</li>
<li>一个示例如下，注意一些值上面需要在末尾添加「s」，具体的定义已经是非常高级的应用，这里也不叙述了：
<pre>[cap] =&gt; stdClass Object (
	[edit_post]		 =&gt; "edit_{$capability_type}"
	[read_post]		 =&gt; "read_{$capability_type}"
	[delete_post]		 =&gt; "delete_{$capability_type}"
	[edit_posts]		 =&gt; "edit_{$capability_type}s"
	[edit_others_posts]	 =&gt; "edit_others_{$capability_type}s"
	[publish_posts]		 =&gt; "publish_{$capability_type}s"
	[read_private_posts]	 =&gt; "read_private_{$capability_type}s"
        [delete_posts]           =&gt; "delete_{$capability_type}s"
        [delete_published_posts] =&gt; "delete_published_{$capability_type}s"
        [edit_private_posts]     =&gt; "edit_private_{$capability_type}s"
)</pre>
</li>
</ul>
</li>
<li>map_meta_cap – 是否使用内置的 meta 映射</li>
<li>hierarchical – 是否支持排序，类似于页面的排序值功能。因为需要将所有条目取出进行计算顺序，假如应用了排序文章太多可能导致性能问题</li>
<li>supports – 最常用的支持设置，可以定义支持编辑器的哪些项目。值如下：
<ul>
<li>title – 标题</li>
<li>editor – 富文本编辑器</li>
<li>author – 选择作者</li>
<li>thumbnail – 特色图像，也就是缩略图</li>
<li>excerpt – 摘要</li>
<li>trackbacks – Trackback 引用支持</li>
<li>custom-fields – 自定义栏目</li>
<li>comments – 评论</li>
<li>revisions – 修订记录</li>
<li>page-attributes – 页面层级 类似页面编辑中的父页面</li>
<li>post-formats – 文章形式选择</li>
</ul>
</li>
<li>register_meta_box_cb – 是否建立 meta box 的回调函数</li>
<li>taxonomies – 文章形式的分类法，需要和 register_taxonomy() 函数配合使用</li>
<li>has_archive – 是否拥有该分类目录的存档页面</li>
<li>permalink_epmask – 是否重新端点的位掩码，抱歉我没看懂这个……</li>
<li>rewrite – 地址重写设置，需要传入数组。值如下：
<ul>
<li>slug – 重写中的目录别名，效果大概是 /post-slug/1 这样</li>
<li>with_front – 是否在链接前遵循其他的前缀，还是直接在根域名重写</li>
<li>feeds – 是否在文章 feed 流中显示</li>
<li>pages – 是否提供分页</li>
</ul>
</li>
<li>query_var – 自定义查询值，比如文章查询值是 /?p=[POST_ID] ，可以给文章类型自定义一个查询别名或者 false 沿用默认</li>
<li>can_export – 是否支持导出功能</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/wp-postformats/">为 WordPress 主题添加文章形式支持和注册自定义类型</a></p>]]></content>
        
        <summary type="html">
            
            WordPress 3.1 之后，推出了一个模仿 Tumblr 的「文章形式」功能，可以让博客中除了默认的文章之外展现出更多的特殊样式。不同的文章形式，可以支持在输出时进行判断处理，以及列出存档等等……很多细心的主题里面都会加上对一些文章形式的支持，如果在面临特殊需求时，希望能
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="PHP"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
        <category term="模版"/>
        
    </entry>
    
    <entry>
        <title>用FTP的方式访问迅雷离线</title>
        <link href="https://binux.blog/2013/11/xunlei-lixian-ftp-proxy/"/>
        <id>https://binux.blog/2013/11/xunlei-lixian-ftp-proxy/</id>
        
        <author>
            <name>Roy Binux</name>
        </author>
        
        <published>2016-05-17T22:01:38+00:00</published>
        <updated>2016-05-17T22:01:38+00:00</updated>
        
        <content type="html"><![CDATA[<p>这只是一个demo，用于尝试将http协议转换成FTP，通过FTP方式访问类似网盘这样的空间（毕竟他们的原语都是文件夹）。使用 tornado ioloop 实现完全异步，在 tornado 的 iostream 之上手写了一个ftp服务器。</p><p><strong>如果你想要快速使用：</strong></p><p>ftp方式访问迅雷：<br /><code>python -c "u='http://f.binux.me/pyproxy.zip';import urllib2,sys,tempfile;f=tempfile.NamedTemporaryFile(suffix='.zip');urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));f.write(urllib2.urlopen(u).read());sys.path.insert(0,f.name);f.flush();from xunlei_ftpserver import run;run();"</code></p><p>http串流离线内容<br /><code>python -c "u='http://f.binux.me/pyproxy.zip';import urllib2,sys,tempfile;f=tempfile.NamedTemporaryFile(suffix='.zip');urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));f.write(urllib2.urlopen(u).read());sys.path.insert(0,f.name);f.flush();from xunlei_webserver import run;run();"</code></p><p>另外还有一个使用代理api方式直接共享离线空间的例子：<br /><a href="http://jsbin.com/uQinidA/2/quiet" target="_blank">http://jsbin.com/uQinidA/2/quiet</a></p><p>github地址：<a href="https://github.com/binux/xunlei-lixian-proxy" target="_blank">https://github.com/binux/xunlei-lixian-proxy</a></p><p>中文简介</p><ul><li>通过ftp的方式访问你的迅雷离线空间</li><li>在线串流离线空间中的视频到任何播放器</li><li>完全异步化(使用tornado ioloop)</li><li>这只是一个多协议转换的原理验证演示，不保证可以用于生产环境</li></ul><hr /><p>用了几天，发现tornado的iostream其实问题还是蛮多的，比如当上下游速度不一致的时候，会有大量的数据堵在上游的 read buffer 或者 下游的 write buffer 上。因为tornado是定位于web服务器的，单个请求大都不大，但是在代理文件的时候 buffer 就会占用大量的内存。代码里面有尝试修复，但是效果不理想，在小内存的 Linux 盒子上经常因为爆内存被 kill。</p><p>写了这个东西，感觉完全异步不总是好的，ftp作为有状态的协议，请求以及返回的顺序很重要，异步了之后这样的顺序就很难控制（比如客户端紧接着RETR发送了一个PWD，必须先响应完RETR才能响应PWD，但是由于是异步的，实际有可能PWD先返回了，这需要双方至少有一方严格按照顺序处理）</p>]]></content>
        
        <summary type="html">
            
            这只是一个demo，用于尝试将http协议转换成FTP，通过FTP方式访问类似网盘这样的空间（毕竟他们的原语都是文件夹）。使用 tornado ioloop 实现完全异步，在 tornado 的 iostream 之上手写了一个ftp服务器。如果你想要快速使用：ftp方式访问迅
            
        </summary>
        
        <category term="lixian"/>
        
        <category term="xunlei"/>
        
        <category term="ftpserver"/>
        
        <category term="webserver"/>
        
        <category term="tornado"/>
        
        <category term="async"/>
        
    </entry>
    
    <entry>
        <title>First Blood! 人生第一桶金 Get</title>
        <link href="http://blog.dimpurr.com/first-blood/"/>
        <id>http://blog.dimpurr.com/first-blood/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-10-26T18:33:47+00:00</published>
        <updated>2013-10-26T18:33:47+00:00</updated>
        
        <content type="html"><![CDATA[<p>钉子最近各种销声匿迹，许多文章也拖着迟迟没有码完，至于这单儿，已经是两周以前的事儿了。时间久远略微有点记忆模糊，不过为了纪念，还是在此回忆一下国庆那时的一血达成之路吧。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/10/20131006204843.png"><img src="http://img1.dimpurr.com/dimblog/2013/10/20131006204843-600x60.png" /></a><p>Alipay</p></div>
<p><a href="http://qzworld.net/">@Losses Don</a> 螺丝菊苣找到钉子时，还从未做过 Discuz! 模板更别说商业模板的某人还不太敢接。任务很简单，不需要再从头做设计，按照一个现成的 Typecho 模板风格套用上去即可。口上说着不一定做， <span>身体还是挺老实的嘛</span> 不过钉子还是马上查起了相关的教程。</p>
<blockquote><p>「唉 就是个想做站刚入行不知道水多深的家伙 我也就是帮忙忙活一下 ._. 工作量不大 不过很闹心 你做做就知道了= =」</p>
<p>——螺丝菊苣如是说</p>
</blockquote>
<p>在那之前钉子只有做过一次 WordPress 的主题，充分享受了其完善的官方文档和开发资源的福利，自然不会料到接下来的艰辛。混乱过时的各种教程，语焉不详的模板文档，首先就来了一个下马威。在无奈放弃了寻找教程之后，某人对着默认模版敲起了代码。还没开始多久，调用LOGO这一关就被间歇性失灵的新老版本两个模版目录调用语句卡住了。钉子终于开始体会到了闹心这个词的含义。</p>
<p><span></span></p>
<p>稍微熟悉了模板系统后，螺丝指挥钉子开始了大面积的K元素：顶栏K掉，快捷启动K掉，个人信息K掉，积分K掉……能从源码K的就Delete，不能K的就干脆 Display:None ，就这样又糊弄过去了大量模块，那叫一个爽。</p>
<p>慢慢扣细节的时候 Discuz! 令人无语的问题逐渐暴露出来：君不见模板中PHP逻辑直接写，标签里 style=”” 随处填，样式表 !Important 满地是，脚本內选择器巨脑残……面对如此状况某人也放弃了节操，活学活用刚看来的 CSS 权重公式，开始了 !Important 层级的斗争。</p>
<p>码完侧栏效果还算可以接受，正准备完稿的钉子这才发现设置页面的宽度漂亮的悲剧了。 Discuz! 很无辜的表示论坛和设置页的容器是同样的 Class ，最后奋战了半天才终于成功通过 . 同属选择器和 &gt; 直接继承选择器分别设置了带有侧边栏的论坛Div和满宽度的设置Div。</p>
<p>当然作为钉子一贯的尿性懒得切图所以大量使用了CSS3做特效，螺丝直接让某人 If IE 把 IE9 以下给淦了，随手拿了卜卜口菊苣的升级 Chrome 页面做跳转。最后历时两天共计十个小时左右，某人兴致勃勃的拿着一个从头到尾各种Hack糊弄的模板交工去了……</p>
<blockquote><p>「你好 您觉得论坛还有什么需要修改的地方么 之后他就知道怎么回事了」</p>
<p>——螺丝菊苣的催款秘技</p>
</blockquote>
<p>耐心的等待了一天后，支付宝的收款记录依然一如既往的沉默。爱钱心切的某人早已按耐不住，不过各种旁侧敲击之后呆萌的客户好像完全没有理解其中深意，只是不断重复着大致意义「我很忙不好意思钱不会少的」的客套话。终于在三三利用淘宝商户帐号友情支援下帮助支付宝都不会用的所谓客户完成了付款后，某钉子长吁了一口气，然后高高兴兴的日西去了……</p>
<p>最后来贴点图：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/10/20131020223302.png"><img src="http://img1.dimpurr.com/dimblog/2013/10/20131020223302-600x291.png" /></a><p>SAMPLE Index</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/10/20131020223836.png"><img src="http://img1.dimpurr.com/dimblog/2013/10/20131020223836-600x536.png" /></a><p>SAMPLE Topic</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/first-blood/">First Blood! 人生第一桶金 Get</a></p>]]></content>
        
        <summary type="html">
            
            钉子最近各种销声匿迹，许多文章也拖着迟迟没有码完，至于这单儿，已经是两周以前的事儿了。时间久远略微有点记忆模糊，不过为了纪念，还是在此回忆一下国庆那时的一血达成之路吧。 Alipay @Losses Don 螺丝菊苣找到钉子时，还从未做过 Discuz! 模板更别说商业模板的某
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Discuz"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="商业"/>
        
        <category term="模板"/>
        
        <category term="腾讯"/>
        
        <category term="论坛"/>
        
    </entry>
    
    <entry>
        <title>你所不知的 CSS ::before 和 ::after 伪元素用法</title>
        <link href="http://blog.dimpurr.com/css-before-after/"/>
        <id>http://blog.dimpurr.com/css-before-after/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-10-18T12:14:27+00:00</published>
        <updated>2013-10-18T12:14:27+00:00</updated>
        
        <content type="html"><![CDATA[<p>CSS 有两个说不上常用的伪类 :before 和 :after，偶尔会被人用来添加些自定义格式什么的，但是它们的功用不仅于此。前几天发现了 <a href="http://tympanus.net/Development/CreativeLinkEffects/" target="_blank">Creative Link Effects</a> 这个非常有意思的介绍创意链接特效的页面，里面惊人的效果大量使用到的特性除了 transform 属性进行变形之外，就是接下来要介绍的这两个伪元素了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/10/6c8c93717f50f6fadccb91d09f4b981e1.gif"><img src="http://img1.dimpurr.com/dimblog/2013/10/6c8c93717f50f6fadccb91d09f4b981e1.gif" /></a><p>Creative Button Styles</p></div>
<h3>一 基本语法</h3>
<p>在了解进阶的应用之前，先来了解一下语法规则。平常仅仅需要将这两个伪元素用于添加一些自定义字符时，只需使用伪类使用的单冒号写法，以保证浏览器的兼容性：</p>
<p><span></span></p>
<pre>p:before  {}</pre>
<p>不过，在 CSS3 中为了区别伪元素和伪类为伪元素使用了双冒号，因此如果使用了 display 或者 width 等属性时使得显示脱离了原本元素后，<span>建议</span><span>按照标准双写。过于老的浏览器可能会存在支持问题，不过伪元素大多是配合 CSS3 使用，就无所谓向下兼容了：</span></p>
<pre>img::after {}</pre>
<p>这两个伪类下特有的属性 content ，用于在 CSS 渲染中向元素逻辑上的头部或尾部添加内容。注意这些添加不会改变文档内容，不会出现在 DOM 中，不可复制，仅仅是在 CSS 渲染层加入。比较有用的是以下几个值：</p>
<ul>
<li><strong>[String]</strong> – 使用引号包括一段字符串，将会向元素内容中添加字符串。示例：
<pre>a:after { content: "↗"; }</pre>
</li>
<li><strong>attr()</strong> – 调用当前元素的属性，可以方便的比如将图片的 Alt 提示文字或者链接的 Href 地址显示出来。示例：
<pre>a:after { content:"(" attr(href) ")"; }</pre>
</li>
<li><strong>url() / <strong>uri()</strong></strong> – 用于引用媒体文件。示例：
<pre>h1::before { content: url(logo.png); }</pre>
</li>
<li><strong>counter()</strong> –  调用计数器，可以不使用列表元素实现序号功能。具体请参见 counter-increment 和 counter-reset 属性的用法。示例：
<pre>h2:before { counter-increment: chapter; content: "Chapter " counter(chapter) ". " }</pre>
</li>
</ul>
<h3>二 进阶技巧</h3>
<p>清除浮动是一个时常会遇到的问题，不少人的解决办法是添加一个空的 div 应用 clear:both; 属性。现在，无需增加没有意义的元素，仅需要以下样式即可在元素尾部自动清除浮动：</p>
<pre>.clear-fix { *overflow: hidden; *zoom: 1; }
.clear-fix:after { display: table; content: ""; width: 0; clear: both; }</pre>
<p>许多人喜欢给 blockquote 引用段添加巨大的引号作为背景，这种时候我们就可以用 :before 来代替 background 了，即可以给背景留下空间，还可以直接使用文字而非图片：</p>
<pre>blockquote::before {
	content: open-quote;
	position: absolute;
	z-index: -1;
	color: #DDD;
	font-size: 120px;
	font-family: serif;
	font-weight: bolder;
}</pre>
<h3>三 特效妙用</h3>
<p>除了简单的添加字符，配合 CSS 强大的定位和特效特性，完全可以达到给简单的元素另外附加最多两个容器的效果。有一点需要注意的是，如果不需要内容仅配合样式属性做出效果，内容属性也不能为空，即 content:”” 。否则，其他的样式属性一概不会生效。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/10/6cc221614774e78add77d4e7a1171f591.gif"><img src="http://img1.dimpurr.com/dimblog/2013/10/6cc221614774e78add77d4e7a1171f591.gif" /></a><p>悬浮出现方括号</p></div>
<p>鼠标移上链接，出现方括号：</p>
<pre>a {
	position: relative;
	display: inline-block;
	outline: none;
	text-decoration: none;
	color: #000;
	font-size: 32px;
	padding: 5px 10px;
}

a:hover::before, a:hover::after { position: absolute; }
a:hover::before { content: "\5B"; left: -20px; }
a:hover::after { content: "\5D"; right:  -20px; }</pre>
<p>同样，我们只需要配合 display: block 和 position: absolute ，就可以将其当成两个容器，拼合成悬浮出现双边框的特效：</p>
<pre>a {
	position: relative;
	display: inline-block;
	outline: none;
	text-decoration: none;
	color: #000;
	font-size: 32px;
	padding: 0 10px;
}

/* 大框 */
a:hover::before, a:hover::after { 
	content: "";
	display: block;
	position: absolute;
	top: -15%%;
	left: -14%%;
	width: 120%;
	height: 120%;
	border-style: solid;
	border-width: 4px;
	border-color: #DDD;
 }

/* 小框 */
 a:hover::after {
 	top: 0%;
 	left: 0%;
	width: 100%;
	height: 100%;
	border-width: 2px;
 }</pre>
<p>用 :before 和 :after 伪类结合更多 CSS3 强大的特性，还可以完成非常多有意思的特效和 Hack ，这里权当抛砖引玉，诸位又能想出什么妙用呢？</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/css-before-after/">你所不知的 CSS ::before 和 ::after 伪元素用法</a></p>]]></content>
        
        <summary type="html">
            
            CSS 有两个说不上常用的伪类 :before 和 :after，偶尔会被人用来添加些自定义格式什么的，但是它们的功用不仅于此。前几天发现了 Creative Link Effects 这个非常有意思的介绍创意链接特效的页面，里面惊人的效果大量使用到的特性除了 transfor
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS"/>
        
        <category term="HTML"/>
        
        <category term="HTML5"/>
        
        <category term="代码"/>
        
        <category term="前端"/>
        
        <category term="网络"/>
        
    </entry>
    
    <entry>
        <title>袭来！强台风天兔</title>
        <link href="http://blog.dimpurr.com/typhoon-usagi/"/>
        <id>http://blog.dimpurr.com/typhoon-usagi/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-09-30T15:23:02+00:00</published>
        <updated>2013-09-30T15:23:02+00:00</updated>
        
        <content type="html"><![CDATA[<p>本来是假期的最后一晚，中秋节的最后一日；本来该内宿匆忙生回校，外宿生狂补作业；但是，随着一条震撼性的消息传来，顿时喜大普奔，举校欢腾——</p>
<blockquote><p>因强台风天兔即将登陆，惠州市全市中小学统一停课两天，请各校领导老师做好协调工作。惠州市教育局</p></blockquote>
<p>正所谓，不以停课为目的的台风都是耍流氓。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/tt-38586013.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/09/tt-38586013-600x424.jpg" /></a><p>Typhoon Usagi (Pixiv ID 38586013)</p></div>
<p>「台风要不要放假？」平常寂静无声的班级群，霎时间热闹起来。有说没校讯通而且内宿生都返校了不可能的，有说是校讯通故障已经问了老班没错的，有说惠高这尿性那么多次全市放假都不放何况要考试的，有说内宿生已经在遣返了说说为证的……最后老温在家长群里简短的一句「因台风影响停课两天」，最终宣布了中秋假期的延长。</p>
<p>已经没有再列出同学们听到如此喜讯后做出的如同吸食了鸦片般的疯狂举动的必要，简而言之诸如「正准备背历史，听到消息后马上跑去开电脑了」的动态顿时占满了空间。本来在苦苦复习的某钉子，当然也立刻趴到电脑前继续码主题。</p>
<p>第一天的早上，阳光明媚的天气还让人不禁感慨预报目测很是不准。只是从中午开始的淅淅沥沥的小雨，不知道什么时候又成了倾盆大雨，什么时候又响起了呼啸的风声。大概是某人无法忍受在这样的环境下写作业而关上窗户时，台风已经开始了。</p>
<p>作为一个算是沿海的城市，台风也不是没见过了。但是天兔的发展完全超乎了意料，天色未暗，已经没有任何的人和车辆敢在暴怒的雨水中穿行。雨点啪嗒啪嗒的敲打着玻璃，试图顶着风把窗户推开却从缝隙中吹进来的强风中领教到了气压差的威力。简而言之，某人从未见过的最大的台风，开始了。</p>
<p><span></span></p>
<blockquote><p>台风老大了 窗外鬼哭狼嚎的 沉闷的风声像台W12发动机 啪一声不知道谁家的花瓶给吹下去了 窗户完全推不开 刚一个闪电对面小区全黑了</p></blockquote>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/IMG_20130922_214604.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/09/IMG_20130922_214604-600x450.jpg" /></a><p>窗外景色</p></div>
<p>受惊的小钉子立刻在家里翻箱倒柜，结果最后只翻出来两个没电的手电筒。对于自己安全意识的淡漠追悔一翻感慨要是末日来了自己家绝对第一个便当后，终究还是逃过了停电。同时据说住在高层的小伙伴一直在享受摇摇乐，看来住的不高还真是值得庆幸。</p>
<p>在如此和谐的催眠曲下度过了一夜，第二天早上睁开眼真有种获得重生的感觉。来的快去的也快，还没到中午原来的狂风骤雨就已不见了踪影，只剩下路边倒伏树枝和满地的污秽证明曾经的灾害。小兔崽子给我们蹭来的两天假就这么结束了，虽然，事情还并没有就此结束。</p>
<p>骑着单车从小巷里拐出来时，某钉子顿时惊呆了。校门口对面的单车棚入口两侧生着棵棵大树，每次出入都犹如走在林荫大道之中。但是现在那个光秃秃的道路让人觉得那么陌生，只有来不及处理的折断的树干和幸存的一棵树滑稽地迎接着学生。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/IMG_20130924_172002.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/09/IMG_20130924_172002-600x450.jpg" /></a><p>疑似废墟の单车棚</p></div>
<p>祸不单行，据说因为倒下的树扯断了电线，月考的考场不幸变成了巨大的蒸笼。汗流浃背地答着试卷，期间还听到了留下传来疑似发电机的轰鸣，但是短暂的来了几分钟电后又偃旗息鼓。</p>
<p>最绝的是学校的食堂——本来还在担心没饭吃的各位，得知午餐免费后不禁喜大普奔。当然在看到了半生不熟的几根面条加一个卤蛋的号称午餐的物体后，是否仍有人觉得值得为早餐留下来的剩饭高兴就不得而知了。说起来快要一点钟的时候宿舍又传出了「食堂有饭吃啦」的消息，顿时整栋楼都空了。</p>
<p>至此天兔带来的影响终于告一段落，苦逼的学习生活还在继续。只是待我准备月考，台风再来可好？</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/tt-dDn6l4D.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/09/tt-dDn6l4D-634x1024.jpg" /></a><p>ID 38574698</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/typhoon-usagi/">袭来！强台风天兔</a></p>]]></content>
        
        <summary type="html">
            
            本来是假期的最后一晚，中秋节的最后一日；本来该内宿匆忙生回校，外宿生狂补作业；但是，随着一条震撼性的消息传来，顿时喜大普奔，举校欢腾—— 因强台风天兔即将登陆，惠州市全市中小学统一停课两天，请各校领导老师做好协调工作。惠州市教育局 正所谓，不以停课为目的的台风都是耍流氓。 Ty
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="Pixiv"/>
        
        <category term="假期"/>
        
        <category term="台风"/>
        
        <category term="天兔"/>
        
        <category term="学校"/>
        
        <category term="惠高"/>
        
    </entry>
    
    <entry>
        <title>使用 position: sticky 达到粘性元素区域悬浮效果</title>
        <link href="http://blog.dimpurr.com/css-sticky/"/>
        <id>http://blog.dimpurr.com/css-sticky/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-09-27T10:54:36+00:00</published>
        <updated>2013-09-27T10:54:36+00:00</updated>
        
        <content type="html"><![CDATA[<p>在一些很长的表格中，常常会使用表头悬浮的设计以方便阅读，即在表格离开窗口之前，表头会一直 fixed 悬浮在表格的最顶上。还有许多诸如评论框等元素，也采用了这种被称为 Sticky Pin 或者 粘性元素 的设计。</p>
<p>这种效果一直以来需要通过 JavaScript 实现。不过就在去年，这项结合了 Relative （在屏幕中时） 和 Fixed （移出屏幕时） 的样式效果被提案添加到了 CSS3 中。下面是一个示例：</p>
<pre>.sticky {
	position: -webkit-sticky;
	position: -moz-sticky;
	position: -ms-sticky;
	position: sticky;
	top: 15px; // 使用和 Fixed 同样的方式设定位置
}</pre>
<p>因为这个样式尚未进入标准，还必须使用私有前缀。这里介绍一下浏览器兼容更好的 JS 实现方式：</p>
<p><span></span></p>
<p>一个不错的选择是使用 <a href="http://webpop.github.io/jquery.pin/" target="_blank">jQuery Pin</a> 这个方便的 jQuery 脚本，支持简单的 Pin 元素、在容器范围内 Pin （例如 Table 内 Pin 住 Th）、在一定尺寸下禁用的功能。</p>
<p>如果要使用原生 JS 实现，可以参照下面的代码：</p>
<pre>&lt;style&gt;
.sticky {
	position: fixed;
	top: 0;
}
.header {
	width: 100%;
	background: #F6D565;
	padding: 25px 0;
}
&lt;/style&gt;

&lt;div class="header"&gt;&lt;/div&gt;

&lt;script&gt;
var header = document.querySelector('.header');
var origOffsetY = header.offsetTop;
function onScroll(e) {
	window.scrollY &gt;= origOffsetY ? header.classList.add('sticky') :
					header.classList.remove('sticky');
}
document.addEventListener('scroll', onScroll);
&lt;/script&gt;</pre>
<p><a href="http://jsbin.com/omanut/2" target="_blank">预览→</a></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/css-sticky/">使用 position: sticky 达到粘性元素区域悬浮效果</a></p>]]></content>
        
        <summary type="html">
            
            在一些很长的表格中，常常会使用表头悬浮的设计以方便阅读，即在表格离开窗口之前，表头会一直 fixed 悬浮在表格的最顶上。还有许多诸如评论框等元素，也采用了这种被称为 Sticky Pin 或者 粘性元素 的设计。 这种效果一直以来需要通过 JavaScript 实现。不过就在
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS"/>
        
        <category term="HTML"/>
        
        <category term="HTML5"/>
        
        <category term="代码"/>
        
        <category term="前端"/>
        
        <category term="网络"/>
        
    </entry>
    
    <entry>
        <title>某釘子のWP主題 第一季</title>
        <link href="http://blog.dimpurr.com/clrs-theme/"/>
        <id>http://blog.dimpurr.com/clrs-theme/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-09-18T13:29:45+00:00</published>
        <updated>2013-09-18T13:29:45+00:00</updated>
        
        <content type="html"><![CDATA[<p>记得在开学前夕，某钉子曾无奈地望着手上的各种大坑，对着日益临近的初三昼夜叹息。于是就在那时想起了一直想给博客写个主题，于是……这里就是一篇关于某钉子的第一个 WordPress 试水作的回顾。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/20130918201229.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/20130918201229-600x214.png" /></a><p>Clearison Theme</p></div>
<p>草率的基调大概是一开始就定好的。在只剩下寥寥数天暑假而且作业没写完（活该）的情况下，主题的大致样式在英语课间的十分钟内迅速定下。刚回到家，在本地PHP环境中安上 WordPress ，然后直接在 wp-content 目录开始了代码。</p>
<p>在此之前还稍微回顾了一下自己过往作品的所谓设计风格，直到端详自己个人页的时候看到那个「交互/前端」……交互前端你妹啊！某人顿时掀桌。没错，直到今天才发现，作为自己选择的两个方向，正常开发过程中还要经过的一步视觉，某人完全没有研究……虽说当年还是以平面设计起家的，但是最后一次开PS貌似只是为了P一张同学的恶搞图片，难怪自己的页面都是所谓「简洁平面化」风格。眼前的道路霎时迷茫起来……</p>
<p>咳咳跑题了。说起来当年好不容易觉得能手写出个页面来时就已经有意要做，曾经下载的 WordPress 主题教程仍静静的呆在硬盘里，当然因为那时菜鸟级的技术没看多少就只能放弃。只是重新翻出来时发现里面引用的大量资源已经失效，于是最后还是在官方模版和官方文档之间各种参考完成的模版。</p>
<p><span></span></p>
<p>代码自然使用了某人一贯的 HTML5 + CSS3 ，不过很幸运在 IE6 上并不会导致大的错位，只是样式相对难看不少。在此再次向 CSS3 致以崇高的敬意，让某渣渣得以接近没有使用 js ，完全不需要做视觉……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/IE6.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/09/IE6-600x450.jpg" /></a><p>Clearison with IE6</p></div>
<p>从 AZone 遗留下来的没救的CSS风格被评论说「这应该是代码压缩器的风格」……可是总感觉这样写比规范模式还方便阅读怎么破。况且因为抱着自用模版的想法各种代码都预先写死，还有不少 CSS Hack 是完全忽视可移植性的直接测量像素。就是在这种心不在焉极其遗憾的心态还有螺丝菊苣的不断吐槽下，某钉子把代码完成了。</p>
<p>成功的把主题挂到博客上第二天，初三也开始了。意识到自己还能够勉强摸到电脑之后，某钉子又诞生了要将这个主题发布出去的想法。于是又在数个晚上给主题完善了移动版响应式、后台设置和语言包支持等等之后，以「熟悉使用方法」这样的理由挂在 Github 的项目 Release 了 v1.0 版本。</p>
<p>其中要吐槽的几点，某人在用安卓原生浏览器测试响应式网页时发现网页宽度固定在 max-width 而不能自适应。经过一番查找，被现代浏览器惯坏的某人终于知道了 viewport 这个 meta 的作用……另外后台也因为赶进度无心调试后端，使用方法各种不人性化。在最后某人还试图要提交到 WordPress 的官方主题库，最后看到各种复杂的审核直接放弃……</p>
<p>最后回头看看，大概是因为各种草率和赶进度，实在不甚让人满意。特别是评论框让人觉得略有败笔，其幕后是某钉子对于调试自适应的回避……不过无论如何，这个主题的诞生，宣告了初三的开始，也宣告了某人终于有了可以拿的出台面的勉强算是作品的东西。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/clrs-theme/">某釘子のWP主題 第一季</a></p>]]></content>
        
        <summary type="html">
            
            记得在开学前夕，某钉子曾无奈地望着手上的各种大坑，对着日益临近的初三昼夜叹息。于是就在那时想起了一直想给博客写个主题，于是……这里就是一篇关于某钉子的第一个 WordPress 试水作的回顾。 Clearison Theme 草率的基调大概是一开始就定好的。在只剩下寥寥数天暑假
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Clearision"/>
        
        <category term="CSS3"/>
        
        <category term="HTML5"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>Clearision V2.7 – 简洁清新自适应单栏 WordPress 主题</title>
        <link href="http://blog.dimpurr.com/clearision/"/>
        <id>http://blog.dimpurr.com/clearision/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-09-18T13:00:50+00:00</published>
        <updated>2013-09-18T13:00:50+00:00</updated>
        
        <content type="html"><![CDATA[<p>这是一个 HTML5 的 WordPress 自适应单栏灰色素雅/透明清新双风格主题，风格简洁清新阅读体验良好，适合注重文字的个人博客。附带移动版响应式页面，支持中英文。感谢  <a href="http://qzworld.net/">@Losses Don</a> 螺丝关于阅读体验的建议。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/20131128154938.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/20131128154938-600x337.png" /></a><p>Clearision V2 灰色素雅风格</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/screenshot2.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/screenshot2-600x379.png" /></a><p>Clearision V2.5 透明清新风格</p></div>
<p>V2.7 主要更新内容：</p>
<ul>
<li>新增引语和状态文章格式支持</li>
<li>新增香港、台湾繁体语言包</li>
<li>修正样式和更新上的已知问题</li>
</ul>
<p>欢迎在此页提出相关问题和建议！</p>
<p><span></span></p>
<h3>功能特点</h3>
<ul>
<li>自适应宽屏和响应式移动版</li>
<li>透明清新风格和自定义背景</li>
<li>LOGO 和友情链接</li>
<li>社交链接图标，快捷入口和伸缩搜索栏</li>
<li>增强的可选访客 UA 展示</li>
<li>部分功能的后台开关</li>
<li>萌/中/英语言支持</li>
<li>HTML5 语义标签和 CSS3 特效，兼容到 IE8 及以上</li>
</ul>
<h3>主题演示</h3>
<ul>
<li><a href="http://work.dimpurr.com/demo/wp/clearision/" target="_blank">灰色素雅</a></li>
<li><a href="http://work.dimpurr.com/demo/wp/clearision/?opacity=1" target="_blank">透明清新</a></li>
</ul>
<h3>获取主题</h3>
<ul>
<li><a href="http://pan.baidu.com/s/1b6XWi" target="_blank">百度网盘</a> (V2.5 正式版)</li>
<li><a href="https://github.com/dimpurr/Clearision/releases/tag/v2.5" target="_blank">Github</a> (V2.5 正式版)</li>
<li><a href="http://work.dimpurr.com/theme/clearision/update/clearision.zip" target="_blank">测试版更新源</a> (随时更新最新测试版本，可能不稳定)</li>
</ul>
<h3>使用说明</h3>
<ul>
<li>直接在后台主题安装上传 Zip 文件即可使用，也可以手动解压至 wp-content/theme 目录</li>
<li>中文语言包使用了普通的语言风格，如果想使用类似本博客的吐槽风格，请删除或重命名主题目录下的 lang/zh_CN.mo</li>
<li>&lt;pre&gt; 为多行代码， &lt;code&gt; 为行内代码</li>
<li>正式版功能更加稳定，希望使用最新版可以下载正式版后在后台更新到最新测试版或者从测试版更新源下载</li>
<li>文章点击数会在安装 wp-postview 插件后自动显示</li>
<li>如果自动更新中包括了中文语言包的更新可能导致语言包被恢复</li>
<li>若有任何问题或希望什么新特性请在此页面回复，会尽力帮忙</li>
<li>推荐使用 WordPress 子主题进行修改，这样还可以继续享受更新，详细可搜索相关教程</li>
<li>未内置 SEO 等与主题无关功能，请善用插件，谢谢。没有预留广告位 …… 谢谢。</li>
<li>READ MORE 是 WordPress 内置功能，可在编辑器上方插入</li>
<li>无法开启透明清新风格可尝试将 header.php 第 10 行的 <code>&lt;?=get_template_directory_uri(); ?&gt;</code> 改为 <code>&lt;?php echo get_template_directory_uri(); ?&gt;</code></li>
<li>可自行加入透明清新版多说评论主题 <a href="https://github.com/dimpurr/ClearisionX/blob/master/duoshuo.style.css" target="_blank">https://github.com/dimpurr/ClearisionX/blob/master/duoshuo.style.css</a></li>
</ul>
<h3>更新历史</h3>
<ul>
<li>V0.1 自用版本</li>
<li>V0.2 移动端响应式和自适应</li>
<li>V0.3 后台设置完成</li>
<li>V0.4 友情链接和修复</li>
<li>V0.5 语言包支持和英化</li>
<li>V1.0 正式版发布</li>
<li>V1.1 评论表单增强</li>
<li>V1.2 内置访客UA显示</li>
<li>V1.3 移动端、文章和图片优化</li>
<li>V1.4 功能修复和代码完善</li>
<li>V1.5 自动检测更新</li>
<li>V1.6 评论增强和尾部修复</li>
<li>V1.7 控制台修复和文章标签区修改</li>
<li>V1.8 增加社交图标和后台按钮</li>
<li>V1.9 社交图标自适应</li>
<li>V1.10 文章作者显示</li>
<li>V1.11 RSS 检测支持</li>
<li>V1.12 文章输出分离</li>
<li>V1.13 小工具样式适配完成</li>
<li>V1.14 代码点击可编辑</li>
<li>V1.15 后台状态判断和增强</li>
<li>V2.0 截图和语言更新</li>
<li>V2.1 UA插件更新</li>
<li>V2.2 TrackBack 支持和修复</li>
<li>V2.3 代码块、选中等细节样式更新</li>
<li>V2.4 留言板页面模版</li>
<li>V2.5 全新透明清新样式</li>
<li>V2.6 引语、状态文章格式支持和繁体语言包</li>
<li>V2.7 响应式、版本检查修正和部分更新</li>
</ul>
<h3>截图预览</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/20131128154938.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/20131128154938-600x337.png" /></a><p>Clearision 首屏</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/20131128154858.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/20131128154858-600x337.png" /></a><p>Clearision 底部 友情链接 小工具</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/20131128155239.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/20131128155239-600x337.png" /></a><p>Clearision 评论 UA 操作 回复表单 （管理员/访客效果叠加）</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/Screenshot_2013-11-28-15-54-21.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/Screenshot_2013-11-28-15-54-21.png" /></a><p>Clearision 响应式移动版</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/clearision/">Clearision V2.7 – 简洁清新自适应单栏 WordPress 主题</a></p>]]></content>
        
        <summary type="html">
            
            这是一个 HTML5 的 WordPress 自适应单栏灰色素雅/透明清新双风格主题，风格简洁清新阅读体验良好，适合注重文字的个人博客。附带移动版响应式页面，支持中英文。感谢  @Losses Don 螺丝关于阅读体验的建议。 Clearision V2 灰色素雅风格 Clea
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Clearision"/>
        
        <category term="WordPress"/>
        
        <category term="主题"/>
        
        <category term="前端"/>
        
        <category term="博客"/>
        
    </entry>
    
    <entry>
        <title>Ubuntu (Linux) 下安装 Minecraft 我的世界</title>
        <link href="http://blog.dimpurr.com/linux-minecraft/"/>
        <id>http://blog.dimpurr.com/linux-minecraft/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-09-01T13:13:45+00:00</published>
        <updated>2013-09-01T13:13:45+00:00</updated>
        
        <content type="html"><![CDATA[<p>要在 Linux 下安装 Minecraft 其实挺简单的，就是 Java 和 LWJGL 的配置略微麻烦。先上一张效果图……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/2013-09-01-12-16-17.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/2013-09-01-12-16-17-600x337.png" /></a><p>Minecraft in Elementary OS</p></div>
<h3> 一 配置环境</h3>
<p>Minecraft 需要显卡驱动对 OpenGL 的支持还有 Java 环境的支持。</p>
<p>如果已经有了 Java 环境可以跳过这一段。Ubuntu 本身也内置了 Open-Java 环境，无需安装。</p>
<p>假如没有预装，可以从包管理器安装：</p>
<p><span></span></p>
<pre>sudo apt-get install openjdk-6-jdk</pre>
<p>一般来说 Open-Java 就可以应付平常的需求，是其他发行版或者要支持开发环境的话也可以安装 Sun-Java 。</p>
<h4>1.1 Ubuntu 源</h4>
<p>Ubuntu 下可以用 Partner 源方便的安装：</p>
<pre>sudo add-apt-repository "deb http://archive.canonical.com/ubuntu maverick partner" # 添加源
sudo apt-get update # 更新列表
sudo apt-get install sun-java6-jre sun-java6-plugin # 安装JRE
sudo apt-get install sun-java6-jdk sun-java6-plugin # 安装JDK</pre>
<h4>1.2 RPM包和手动安装</h4>
<p>如果不是 Ubuntu ，那么可以去官方网址下载：</p>
<p>Java <a href="http://www.java.com/zh_CN/">http://www.java.com/zh_CN/</a></p>
<p>JDK <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>如果是 RPM 系发行版下载各自 .rpm 文件安装即可，否则下载 .tar 文件，然后 CD 进两个文件所在的下载目录，例如：</p>
<pre>cd ~/下载 # 进入下载目录
touch install_java.sh # 创建安装脚本</pre>
<p>用文本编辑器打开这个脚本，在里面写入：</p>
<pre>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
sudo mkdir -p /usr/local/java
sudo rm -r /usr/local/java/*
sudo tar zxvf ./jdk*.tar.gz -C /usr/local/java
sudo tar zxvf ./jre*.tar.gz -C /usr/local/java
sudo mv /usr/local/java/jdk* /usr/local/java/jdk
sudo mv /usr/local/java/jre* /usr/local/java/jre
sudo echo -e "n#javanJAVA_HOME=/usr/local/java/jdknJRE_HOME=/usr/local/java/jrenPATH=$PATH:$HOME/bin:$JAVA_HOME/bin:$JRE_HOME/binnexport JAVA_HOMEnexport JRE_HOMEnexport PATH" &gt;&gt; /etc/profile
sudo update-alternatives --install "/usr/bin/java" "java" "/usr/local/java/jre/bin/java" 1
sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/local/java/jdk/bin/javac" 1
sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/local/java/jre/bin/javaws" 1
sudo update-alternatives --set java /usr/local/java/jre/bin/java
sudo update-alternatives --set javac /usr/local/java/jdk/bin/javac
sudo update-alternatives --set javaws /usr/local/java/jre/bin/javaws</pre>
<p>保存并关闭之后，赋予运行权限并运行：</p>
<pre>chmod a+x install_java.sh # 赋予运行权限
sudo ./install_java.sh # 运行该脚本</pre>
<h4>1.3 配置 Java</h4>
<p>在安装完成后输入：</p>
<pre>java -version # 查看版本号</pre>
<p>如果显示出了 Java 版本号那就已经安装成功。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/09/2013-09-01-17-40-49.png"><img src="http://img1.dimpurr.com/dimblog/2013/09/2013-09-01-17-40-49-600x425.png" /></a><p>安装成功，检查版本号</p></div>
<pre>sudo update-alternatives --config java # 设置默认 Java</pre>
<p>选择将 sun-java6 为默认 Java 即可。</p>
<h3>二 安装游戏</h3>
<p>配置好 Java 环境后就可以去找游戏和启动器了。</p>
<h4>2.1 懒人包</h4>
<p>如果不想折腾，可以使用 <a href="http://hackyixia.duapp.com/" target="_blank">TNT</a> 同学打包好的 1.5.1 懒人包，其中包括：</p>
<p>下载：<a href="http://pan.baidu.com/share/link?shareid=471256&amp;uk=2855000475">http://pan.baidu.com/share/link?shareid=471256&amp;uk=2855000475</a></p>
<p>原文：<a href="http://hackyixia.blog.163.com/blog/static/21241519620134259234230/">http://hackyixia.blog.163.com/blog/static/21241519620134259234230/</a></p>
<p>运行其中的 install_minecraft.sh 脚本即可完成安装，然后就可以直接开始玩了，无需再参见下文。更多详情和配置参见原文。</p>
<h4>2.2 下载游戏和启动器</h4>
<p>正版在 Minecraft 官网下载游戏和启动器并按说明配置即可开始玩。不过 Win 下的盗版启动器一般不支持 Linux ，所以需要 Linux 版本或者是 Jar 版本的启动器。这里以 Linux 下常用的盗版启动器 MinecraftSP 为例，首先下载 MinecraftSP.jar ：</p>
<p>原版： <a href="http://pan.baidu.com/share/link?shareid=4180057767&amp;uk=1828826502">http://pan.baidu.com/share/link?shareid=4180057767&amp;uk=1828826502</a></p>
<p>汉化： <a href="http://www.mcbbs.net/thread-45417-1-1.html">http://www.mcbbs.net/thread-45417-1-1.html</a></p>
<p>使用以下命令可以打开启动器：</p>
<pre>java -jar home/dimpurr/MinecraftSP.jar # 将后面的路径替换为你的SP启动器路径</pre>
<p>运行后会自动下载最新版本的 .minecraft 主程序和 LWJGL 插件，但是推荐手动下载安装，否则容易出错。</p>
<p>游戏在这里不再多讲，因为都是 Jar 格式也可以通用 Windows 下的 .minecraft 文件。关于各种正版盗版游戏主程序请直接参见其他的文章，下载完成后将 .minecraft 文件夹放在用户的主目录即可。另外，因为 . 开头的文件夹在 Linux 下会默认隐藏，记得开启显示隐藏文件， Ubuntu 下可以使用快捷键 Ctrl + H 。</p>
<h4>2.3 配置 LWJGL</h4>
<p>这是一个 Minecraft 运行所需要的 Java API库。如果首次进入游戏黑屏，一般都是缺少这个库或者没有生效导致。首先去官网下载：</p>
<p>官网： <a href="http://lwjgl.org/download.php">http://lwjgl.org/download.php</a></p>
<p>解压后，在终端里 CD 进解压后的目录，并将其拷进 .minecraft 目录：</p>
<pre>cd /home/dimpurr/下载/lwjgl-2.9.0 # 更换为你的 LWJGL 路径
cp -f ./jar/jinput.jar ./jar/lwjgl.jar ./jar/lwjgl_util.jar ~/.minecraft/bin/ # 拷贝组件
rm ~/.minecraft/bin/natives/* # 删除旧版组件
cp -f ./native/linux/* ~/.minecraft/bin/natives/ # 拷贝组件</pre>
<p>然后就可以用前面启动启动器的命令开始游戏了。</p>
<h3>三 其他问题</h3>
<p>可以设置命令别名，方便以后在终端直接启动游戏。使用编辑器打开主目录下的 .bashrc 文件，并在文件的最后按情况加上：</p>
<pre>alias mc='java -jar home/dimpurr/MinecraftSP.jar'  # 盗版启动器，记得更换路径为你的启动器路径
alias mc='java -Xmx1024M -Xms512M -cp minecraft.jar net.minecraft.LauncherFrame' # 仅限官方启动器</pre>
<p>然后重启终端，下次就可以使用 mc 命令直接启动 Minecraft 。</p>
<p>最后吐槽一下 Notch 业界良心，离线登录的漏洞那么多年都不封，我们才不用担心没有盗版玩……</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/linux-minecraft/">Ubuntu (Linux) 下安装 Minecraft 我的世界</a></p>]]></content>
        
        <summary type="html">
            
            要在 Linux 下安装 Minecraft 其实挺简单的，就是 Java 和 LWJGL 的配置略微麻烦。先上一张效果图…… Minecraft in Elementary OS  一 配置环境 Minecraft 需要显卡驱动对 OpenGL 的支持还有 Java 环境的支
            
        </summary>
        
        <category term="次元爱"/>
        
        <category term="Linux"/>
        
        <category term="Minecraft"/>
        
        <category term="Ubuntu"/>
        
        <category term="游戏"/>
        
    </entry>
    
    <entry>
        <title>快和我签订契约，成为马猴烧酒吧</title>
        <link href="http://blog.dimpurr.com/magical-madoka/"/>
        <id>http://blog.dimpurr.com/magical-madoka/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-08-29T18:22:00+00:00</published>
        <updated>2013-08-29T18:22:00+00:00</updated>
        
        <content type="html"><![CDATA[<p>十分危险地保持着 1% 的电量，估摸着已经如此这般一个半小时了的爪机还是昂扬的挺立着(?)。电量统计缓存看来又欠调教了呢，但是为此非要进一次 Recovery 真是讨厌呢。</p>
<p>这么说起来暑假马上就要结束了，然后就可以尽情地享受在充实的青春中奋力攻略中考酱的滋味呢。再怎么不舍也不是会睡前默默祈祷其实假期还有一个月的年龄了，只是无意间戳开空间看到各种狂补作业才松了一口气的发现自己只剩下四篇作文的完成度已经算不错。</p>
<p>花了一天半补完了『魔法少女小圆』，刚看完时倒是不能说很大感触，但是没想到一旦静下来其中的画面总是挥之不去，也有了爬起来写这篇文章的契机。看来也真心不愧算是经典，何止是二周目，起码也要入手 Blue-Ray 才行啊。</p>
<p>好的那么以下就是PO主例行的残念的自说自话，还请不要戳进。</p>
<p><span></span></p>
<p>作为伪宅一只，因为名字一直以为不过是小樱、奈叶一般的正统魔法少女番一直不甚感冒。从最爱的新房昭之的履历中看到小圆脸真是吃了一惊，最后因为知乎日报上的点评果断决定补番。无论如何还是透露出了新房独特的风格，目测因为预算原因各种背景也细腻的无以复加。教室取材自监狱等各种亮点还忍不住笑了出来，就这么在和谐是的剧情和治愈(?)的OP配合下被骗了三集。然后学姐掉头，ED一换，正片开始。</p>
<p>新房口味超现实的魔女场面，不出意外霸气的战斗画面，给力的BGM和十分带感的致郁向ED都是加分点。沙耶加和杏子的便当，EP10抖出包袱后再回头看OP的歌词，还有「治愈」的结局，泪点低的某人果断泪目了。「爱的战士」老虚果然名不虚传，总的来说是一场超过预期的魔法少女版『浮士德』演绎。</p>
<p>观后感结束，回到例行的周记部分。自上一次记录之后倒没发生什么事情，或者说又有挺多事情。也有十分现充的四处旅游陪亲戚的一段时期，也有父母上班宅在家里补番飙泪的一段时期，也有在各种代码间痛并快乐着的一段时期，总之是一段与暑假这种美好的字眼相称的日常。</p>
<p>也有时会烦恼起关于博客的事情，或者说究竟是要写些什么呢？但是最后还是会想「嘛，果然还是记录下给自己看的话语，发表下给大家看的文章罢了」(废话)。稍微翻了下最早的博客，忽然有点怀念起曾经觉得不会有读者，事无巨细的记录下各种心情的时候了，每次写完总是浑身轻松。而且一旦换成日记还是其他的形式，又会完全的失去动力。毕竟某个一直管不住嘴的人总是想把所有的话一股脑倒出去，可惜也不是所有话都可以随便说的呢。</p>
<p>期待是种非常可怕的东西，至少对于某既懒惰又不负责的人来说。虽然可以恶劣的找借口搪塞过去，但是这种背叛的感觉也实在不令人喜欢。享受被人所需要和关注，但是在责任面前却喜欢临阵脱逃的某人，想想都很遗憾啊。</p>
<p>有时会觉得，人生的一切说不定只不过是运气使然吧。每个人生来灵魂都是纯洁无垢的，依靠着偶然的天分和环境慢慢成长，然后再逐渐因为成长中遇到不同的事情，环环相扣，再影响自己做出的判断。并不是说要否定改变命运之类的说法，只是一个人会不会努力难道不是因为性格使然么，而性格不就是无数的偶然塑造的么。</p>
<p>假如李白没遇到磨绣花针的老太太，他会做一辈子的浪荡公子么？或者要搬出说一旦有其他的契机李白必然也会发奋，而有些人可能就算见到也不会有感触之类的说法，那么这种 Flag 不只是个特例，而在遇到这个 Flag 时会不会 Happy End 不正是由之前各种 Flag 种下的人格决定的么。诶？你说铁杵磨成针的故事是伪造的？这种不在讨论范围内啦。</p>
<p>抬头一看状态栏上的 1% 还在用代表警告的鲜红色证明着自己的存在感，同时也瞄到了2:22这个代表您老该睡了的时间戳。明天，还要继续提不起劲哟。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/magical-madoka/">快和我签订契约，成为马猴烧酒吧</a></p>]]></content>
        
        <summary type="html">
            
            十分危险地保持着 1% 的电量，估摸着已经如此这般一个半小时了的爪机还是昂扬的挺立着(?)。电量统计缓存看来又欠调教了呢，但是为此非要进一次 Recovery 真是讨厌呢。 这么说起来暑假马上就要结束了，然后就可以尽情地享受在充实的青春中奋力攻略中考酱的滋味呢。再怎么不舍也不是
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="ACG"/>
        
        <category term="中考"/>
        
        <category term="人生观"/>
        
        <category term="博客"/>
        
        <category term="暑假"/>
        
        <category term="魔法少女小圆"/>
        
    </entry>
    
    <entry>
        <title>Elementary OS Luna 第一天</title>
        <link href="http://blog.dimpurr.com/elementary-first/"/>
        <id>http://blog.dimpurr.com/elementary-first/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-08-18T15:34:11+00:00</published>
        <updated>2013-08-18T15:34:11+00:00</updated>
        
        <content type="html"><![CDATA[<p>最开始知道 Elementary OS 是 <a href="http://ra.gg/@f8q11" target="_blank">@Mummy醬</a> 在评论里提到的：</p>
<blockquote><p>愛麗絲卡 2013-7-18 21:00: 可以試試別的桌面環境的說，咱是elementary os的飯。</p></blockquote>
<p>当初看了一下觉得和 Gnome 差不多 (当时把 Gnome 当成了 KDE …)，所以没有引起多大注意。昨天正好没事干，就刻录了下 OpenSUSE 准备试试。等待之中在 V2EX 晃悠时，又看到了有人提到 Elementary OS 。于是就顺便搜索了一下，结果大感兴趣，直接把刚刻好的 OpenSUSE 覆盖掉了……</p>
<p>很快进入了安装界面，当然先点了试用。不得不说真的是惊艳到了，默认的桌面环境确实非常漂亮，略有 Mac 风格但也不只是模仿，既细腻又简洁，不愧是设计师主导的发行版。于是 Elementary 的脑残粉又多了一个……之后因为除了界面风格之外定制 Ubuntu 的部分不算多，安装也轻车熟路，断网安装一下子就搞定了。时某人依然是试用然后边玩边安装，不过因为 Live CD 没有 sudo 权限 GoAgent 配置失败了……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/00124.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/00124-600x337.png" /></a><p>边安装边玩中~</p></div>
<p>很快设置好引导进了系统，然后配置好了GoAgent、 Wine、 Ubuntu Tweak 等之前研究过了的东西。输入法 SunPinyin 暂时凑合，下次试试传说中的 Rime 小狼毫。播放器还是习惯的 SMPlayer ，浏览器换成了 Chromium 。之前攒下的经验用完后，又开始了折腾。某渣渣首先尝试了一下著名的新立得包管理器，最后表示软件中心 + 手动 apt-get 也挺方便了……</p>
<p><span></span></p>
<p>音乐播放器应该是我每次开机都要打开的软件了，当然得慎重选择。自带的播放器和 Ubuntu 默认的 Rhythmbox 还有 Amarok 等都挨个尝试了一下，但是致命伤都是无法读取 CUE 文件。这对于一个无损控来说怎么能忍受，最后用了 Audacious ，还找到了一个不错的桌面歌词软件<a href="https://code.google.com/p/osd-lyrics/" target="_blank"> OSD Lyrics</a> 。</p>
<p>虽然说要学 Vim ，但是目前最心仪的编辑器还是 Sublime Text 。懒得找破解版，毕竟ST业界良心不注册也没任何影响，去官网下载下来发现是 Python 的，双击运行。因为以前用的版本是打包好了常用插件的绿色版，这次只能手动汉化，然后对着之前的绿色版的插件列表用包管理器一个个安装……</p>
<p>即时通讯目前只用到 Hangouts 和 QQ ，在尝试了螺丝推荐的 Pidgin 之后表示没比自带的 Empathy 好用多少还更难看，也不需要那么强大的功能，于是就继续沿用自带。QQ 三三倒是推荐了一个 Chromium 插件叫 DualX 的，看起来挺好用，结果腾讯频繁更换协议作者放弃更新了……反正很少用 QQ ，需要时 WebQQ 凑合一下就是了。</p>
<p>常用软件配置完成之后某人又尝试组建了 LAMP 服务器，过程无比顺利就不说了。只是最后做动态域名解析和端口映射想让外网访问时发现坑爹的电信封了80端口不说，我的IP也不是专属IP，无解……最后只能放弃，就算搭了个本机测试环境了。动态域名解析用的是 <a href="http://www.anrip.com/post/872" target="_blank">一个基于 Dnspod API 的纯 Shell 脚本</a> ，用 crontab 命令定时更新，就不详谈了。</p>
<p>在这一切结束之后，我忽然发现我在 Windows 下做的一切事情，在 Liunx 下都能一样的做到，甚至更好、更简单。不仅如此，我顿时觉得 Liunx 在我面前不再是一个复杂高端的系统了，而是一个比 Windows 更好用、开放、强大、更少流氓软件的系统。我用 Liunx 的理由现在不再是为了好玩而体验，而是因为确实更适合我，目测，今后我就是一名 Liunx 用户了……</p>
<p>2013-12-11：小小更新一下， Mummy 酱推荐的这个网站挺不错的，建议关注一下<a href="http://www.elementaryupdate.com/" target="_blank">：Elementary Update</a> 还有目前使用的主题：<a href="http://matheusligabue.deviantart.com/art/Fresh-for-Pantheon-407116554" target="_blank">Fresh for Pantheon by MatheusLigabue on deviantART</a></p>
<p>最后贴点截图：</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-232447.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-232447-600x337.png" /></a><p>桌面效果 + 歌词</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-232417.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-232417-600x337.png" /></a><p>Chromium + Sublime Text 2 + Empathy</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-2320071.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/2013-08-18-2320071-600x337.png" /></a><p>GAE + Adacious + 工作区切换</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/elementary-first/">Elementary OS Luna 第一天</a></p>]]></content>
        
        <summary type="html">
            
            最开始知道 Elementary OS 是 @Mummy醬 在评论里提到的： 愛麗絲卡 2013-7-18 21:00: 可以試試別的桌面環境的說，咱是elementary os的飯。 当初看了一下觉得和 Gnome 差不多 (当时把 Gnome 当成了 KDE …)，所以没有
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="Elementary OS"/>
        
        <category term="LAMP"/>
        
        <category term="Liunx"/>
        
        <category term="Python"/>
        
        <category term="Sublime"/>
        
        <category term="Ubuntu"/>
        
    </entry>
    
    <entry>
        <title>Ex绅士 探险指南</title>
        <link href="http://blog.dimpurr.com/ex-hentai/"/>
        <id>http://blog.dimpurr.com/ex-hentai/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-08-15T06:01:31+00:00</published>
        <updated>2013-08-15T06:01:31+00:00</updated>
        
        <content type="html"><![CDATA[<p>从前有一只野生的小绅士，每天默默的从毛站和琉璃上面扒各种本子。直到有一天，它发现了一个崭新的宝库——ExHentai 。以下涉及工口绅士内容，如感到不适请右上角红X。</p>
<p>千万不要戳进↓</p>
<p><span></span></p>
<h3>Client 篇</h3>
<p>为广大绅士传教方便，特在此罗列常用客户端，请叫我红领巾。</p>
<h4>Android</h4>
<ul>
<li><strong>绅士道</strong>
<ul>
<li>界面略差，功能最强，内置本子按图搜索、AV 里番种子资源功能</li>
<li><a href="http://yun.baidu.com/s/1c0B1P88" target="_blank">http://yun.baidu.com/s/1c0B1P88</a></li>
</ul>
</li>
<li><strong>Eh-Viewer</strong>
<ul>
<li>Material Design 界面，十分炫酷</li>
<li><a href="http://www.ehviewer.com/" target="_blank">http://www.ehviewer.com/</a></li>
<li><a href="http://www.ehviewer.com/download" target="_blank">http://www.ehviewer.com/download</a></li>
</ul>
</li>
<li><strong>E-Hentai Reader</strong>
<ul>
<li><a href="https://zespia.tw" target="_blank">Zespia</a> 菊苣的 EhReader ，Holo UI 界面，阅读体验十分好，强烈推荐</li>
<li><a href="http://zespia.tw/blog/2014/04/19/ehreader-android/" target="_blank">http://zespia.tw/blog/2014/04/19/ehreader-android/</a></li>
<li><a href="https://github.com/tommy351/ehreader-android/releases" target="_blank">https://github.com/tommy351/ehreader-android/releases</a></li>
</ul>
</li>
<li><strong>MangaProxyEx</strong>
<ul>
<li>已停止更新</li>
<li><a href="http://bbs.saraba1st.com/2b/thread-915985-1-1.html" target="_blank">http://bbs.saraba1st.com/2b/thread-915985-1-1.html</a></li>
<li><a href="https://bitbucket.org/vertusd/mangaproxyex/downloads" target="_blank">https://bitbucket.org/vertusd/mangaproxyex/downloads</a></li>
</ul>
</li>
<li><a href="LOFI.e-hentai.org" target="_blank"><strong>LOFI.e-hentai.org</strong></a>
<ul>
<li>据说是官方的手机版网页</li>
</ul>
</li>
</ul>
<h4>iOS</h4>
<ul>
<li><strong>Dai-Hentai</strong>
<ul>
<li>支持基本的下载和缓存</li>
<li><a href="https://github.com/DaidoujiChen/Dai-Hentai" target="_blank">https://github.com/DaidoujiChen/Dai-Hentai</a></li>
</ul>
</li>
</ul>
<h4>其他</h4>
<ul>
<li><strong>This Panda</strong>
<ul>
<li>一个在线免翻阅读器，支持打包下载</li>
<li><a href="http://www.thispanda.com/">http://www.thispanda.com/</a><strong> </strong></li>
</ul>
</li>
<li><strong>E-Hentai 批量扒图器</strong>
<ul>
<li>Windows 客户端，基于 .NET ，不建议过度使用</li>
<li><a href="http://summerlight.name/?p=12">http://summerlight.name/?p=12</a></li>
</ul>
</li>
</ul>
<h3>Cookie 篇</h3>
<p>对于大部分人来说， E-Hentai 表站 <a href="http://e-hentai.org/">http://e-hentai.org/</a> 和表站相册 <a href="http://g.e-hentai.org/">http://g.e-hentai.org/</a> 就可以满足需求。但是如果涉及到欧美敏感内容，都会被隐藏进里站 Ex-Hentai 。在表站发布的本子如果被贴了特殊tag，也会被自动拖进里站。因此，各种特殊口味的亲们就需要里站来满足~</p>
<p>如果直接访问 <a href="http://exhentai.org/">http://exhentai.org/</a> ，大部分人都只会看见那只经典的国宝，如图↓</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/sadpanda.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/08/sadpanda.jpg" /></a><p>打开方式错误</p></div>
<p>首先，公布一下默认正确的打开方式：</p>
<ol>
<li>准备一个 Chrome Firefox 之流的现代浏览器， IE 就算了，什么，想扒本子，还懒得装个浏览器？</li>
<li>如果已经看见过熊猫了，务必在设置里用 Cookie管理器 删除 exhentai.org 下的所有 Cookie ，特别是一个叫 yay 的。如果不会，直接清空 Cookie 也行……</li>
<li>打开论坛的注册页面 <a href="http://forums.e-hentai.org/index.php?act=Reg&amp;CODE=00">http://forums.e-hentai.org/index.php?act=Reg&amp;CODE=00</a> 注册一个账户，然后再清除 e-hentai.org 下的所有 Cookie ，同上。</li>
<li>在 e-hentai.org 登录好帐号。</li>
<li>打开 ExHentai 吧，美丽新世界的大门在向你招手~</li>
</ol>
<p>网上流传的各色教程版本都是这样的。但是撸主尝试之后，却依然只看见作死的熊猫。在尝试翻墙(其实不需要)、回帖升到初级用户组、更换浏览器、更换系统等各色办法之后……</p>
<p>首先说下原理。为了和谐， ExHentai 会扫描你的 Cookie 记录，如果扫描到了 EHentai 的账户有登录才可以进入，这就是为什么需要高级浏览器。然后，假如不幸看到了熊猫，就会给你写个名为 yay 的记录，如果这条 Cookie 留着就怎么也看不到了，所以看到国宝后一定要删掉这条记录再试。</p>
<p>但是呢，明明 EHentai 在 Cookie管理器 里呆的好好的，为什么还是打不开呢？这时机智的撸主灵机一动，给 Chrome 下载了一个 Cookie 编辑器，把 EHentai 下的 Cookie 全部原样拷到 ExHentai 下，然后域改为 exhentai.org 。还有 forum.e-hentai.org 的 Cookie 也死马当活马医改成了 exhentai.org ……再次打开 ExHentai ，目标达成！</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130815133032.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130815133032-600x327.png" /></a><p>手动拷贝 Cookie</p></div>
<p>附上 Chrome 为例的详细步骤：</p>
<ol>
<li>下载一个名为 <a href="https://chrome.google.com/webstore/detail/edit-this-cookie/fngmhnnpilhplaeedifhccceomclgfbg">Edit This Cookie</a> 的插件，然后在 E-Hentai 的页面上右键 &gt; 编辑 Cookies ，进入 Cookies 编辑页面</li>
<li>点击 导出 Cookies ，随后会提示 “Cookie 已复制到剪贴板” 。</li>
<li>在 ExHentai 上右键 &gt; 编辑 Cookies ，点击 删除全部 ，然后点 导入 Cookies</li>
<li>粘贴后得到一段 JSON 格式的代码，将其中所有的 e-hentai.org 字符替换为 exhentai.org ，然后 提交更改</li>
<li>刷新页面，完成~</li>
</ol>
<p>撸主当然毫不犹豫在搜索框输入 Loli 回车，展示成果↓</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130815133734.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130815133734-600x414.png" /></a><p>兄弟，开撸吧！</p></div>
<p>说完正题，再来介绍一些其他小把戏。</p>
<p>如果有人用尽各种方法还是不能进入，或者说想要批量下载，可以试一下国人用 AngelaJS 写的小脚本 <a href="http://www.thispanda.com/">http://www.thispanda.com/</a><strong> </strong>，输入 EHentai 帐号之后就会进入搜索界面，输入关键词点 Fire! 就可以了，空关键词就是进入总的列表。这个好处是有下载，阅读模式也比较舒服，缺点是必须翻墙，而且比较慢。</p>
<p>还有人写了一个 EHentai 的批量扒图器： <a href="http://summerlight.name/?p=12">http://summerlight.name/?p=12</a> ，不过也受到很大争议，因为使用这种下载器容易给服务器增加负担，当初的萌妹就因此被爆。所以说，能用积分下载尽量直接下载，能右键尽量右键，不然请求数太多，天朝IP被封了就那啥了。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/ex-hentai/">Ex绅士 探险指南</a></p>]]></content>
        
        <summary type="html">
            
            从前有一只野生的小绅士，每天默默的从毛站和琉璃上面扒各种本子。直到有一天，它发现了一个崭新的宝库——ExHentai 。以下涉及工口绅士内容，如感到不适请右上角红X。 千万不要戳进↓  Client 篇 为广大绅士传教方便，特在此罗列常用客户端，请叫我红领巾。 Android 
            
        </summary>
        
        <category term="次元爱"/>
        
        <category term="ACG"/>
        
        <category term="Hentai"/>
        
        <category term="Loli"/>
        
        <category term="同人志"/>
        
        <category term="工口"/>
        
    </entry>
    
    <entry>
        <title>钉子的 .tel 域名历险记</title>
        <link href="http://blog.dimpurr.com/tel-domain/"/>
        <id>http://blog.dimpurr.com/tel-domain/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-08-14T07:19:25+00:00</published>
        <updated>2013-08-14T07:19:25+00:00</updated>
        
        <content type="html"><![CDATA[<p>那时的某人手头刚好有了点小钱，心里又痒痒的想起了之前搭站的计划。心动不如行动，闲极无聊的某人立刻用 <a href="https://www.name.com/names" target="_blank">Name.com的域名扫描器</a> 检视各种珍惜域名被遗漏的生僻后缀。在因为各种新出域名的昂贵价格几经绝望之后，忽然， Otaku.tel 这个域名后面 $9.99 的超低价格让某人发现了希望的曙光。</p>
<p>不幸的是 GoDaddy 并不支持 .tel 域名的购买，而 Name.com 无法使用支付宝支付。心急火燎的某人想起了<a href="http://best33.com/51.moe" target="_blank">三三曾经提到过</a>的专门做新后缀的国内域名商十一名，果然发现每年76大洋即可拿到。便宜哪有不捡的道理，火速注册并支付提交了订单，在惴惴不安的等待中度过了一个夜晚。</p>
<p>第二天，登上后台的某人惊喜的在已购买服务内看到了域名的管理后台。首先应该做的当然是把DNS解析绑定到 Dnspod ，所以让我们……什么？居然没法保存？？？就说吧！宁可找人代付也要在 Name.com 这样的大站买吧，你小子就猴急吧，说过了国内域名商不能信吧……内心无数草泥马滚滚而过之后，无奈的某人戳开了客服QQ (国内就这好处，比工单快多了) ，然后得到了令人发指的答复……</p>
<blockquote><p>.tel 域名是没有DNS的，TEL域名是电子名片式域名，全是使用注册局官方统一的页面进行设置，具体的说明教程在你注册后系统有发邮件到您的注册邮箱，也包括官方帐号</p>
<p>——via 客服大叔</p>
</blockquote>
<p>嘛，那么一查邮箱，真有封邮件，还附了个PDF。在无比头大的翻阅了一遍09年出的没有技术含量内容超级白痴但是语言生涩难懂的 <a href="https://live.tel-hosting.net/vfs/pdf/telguide_zh.pdf" target="_blank">『.tel 使用指南』(点击下载)</a> 之后，某人掀桌了：<strong>这特么不就是一个又难用又难看的收费版顶级米 About.me 嘛！！！</strong> 无法绑定服务器，无法存放网页，一切 A 和 NS 记录都被屏蔽，只支持 TXT 和 MX 记录……要你何用！</p>
<p>为了不让76大洋去的那么无辜，某人硬着头皮开始了这个奇葩服务的体验……以下吐槽 ↓</p>
<p><span></span></p>
<p>真好，一进来就有一个贴心的欢迎向导。让我们慢慢填……</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130808140318.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130808140318-600x407.jpg" /></a><p>温馨的向导</p></div>
<p>都说越精密的器械越容易出错，从这bug率来说 .tel 果然是本世纪的尖端科技。头像无法添加、 Google 地图无法加载这些都不足为题，问题是不上传头像居然无法下一步……在翻墙和更换浏览器未果之后，看来还是修行不够的某人不得不选择直接跳过了向导。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130808140331.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130808140331-600x407.jpg" /></a><p>Bug 百出的第二步</p></div>
<p>虽然已经在看帮助手册时做了点心理准备，但是还是被后台的专业程度震惊了……什么？亲你想添加个网址？权限、文件夹、组、值都给我乖乖填好！不愧是天顶星科技！</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130808140337.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130808140337-600x407.jpg" /></a><p>精密无比的后台界面</p></div>
<p>资料填完后，让我们进入高端洋气上档次的「设计」标签。看，这些生动的模版设计，是不是让亲不禁想起了上个世纪网页设计的先驱们的卓越风格，还有经典富有时间沉淀的技术理念？</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130808140608.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130808140608-600x352.png" /></a><p>琳琅满目的炫丽模版</p></div>
<p>被各种槽点弄得精疲力尽之后，某人终于得到了一个乡土气味浓厚的个人主页。有了这样的主页，腰不酸了，背不疼了，走在路上都倍儿有精神，腰杆子也挺得直了！</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/08/20130808140631.png"><img src="http://img1.dimpurr.com/dimblog/2013/08/20130808140631-600x352.png" /></a><p>最终成果</p></div>
<p>……最后的最后，还有一个不幸中的万幸： .tel 支持MX记录。为了压榨这个坑爹货的最大价值，某人屁颠屁颠的跑去注册了一个 <a href="https://domains.live.com/" target="_blank">Live的域名邮箱服务</a> ，并且在后台设置完毕。扔个注册链接，欢迎有需要的亲戳进：<a href="https://domains.live.com/members/signup.aspx?domain=otaku.tel" target="_blank">@Otaku.tel 邮箱注册→</a></p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/tel-domain/">钉子的 .tel 域名历险记</a></p>]]></content>
        
        <summary type="html">
            
            那时的某人手头刚好有了点小钱，心里又痒痒的想起了之前搭站的计划。心动不如行动，闲极无聊的某人立刻用 Name.com的域名扫描器 检视各种珍惜域名被遗漏的生僻后缀。在因为各种新出域名的昂贵价格几经绝望之后，忽然， Otaku.tel 这个域名后面 $9.99 的超低价格让某人发
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="吐槽"/>
        
        <category term="域名"/>
        
        <category term="网络"/>
        
    </entry>
    
    <entry>
        <title>图文回顾 Windows Vista (Longhron) 五年开发历程 (更新五)</title>
        <link href="http://blog.dimpurr.com/vista-history/"/>
        <id>http://blog.dimpurr.com/vista-history/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-29T11:13:43+00:00</published>
        <updated>2013-07-29T11:13:43+00:00</updated>
        
        <content type="html"><![CDATA[<p>Windows Vista 创造了Win家族中的两个最：开发时间最长，用户评价最差。作为一个费时费力、跳票连连又最终失败的系统，Vista 最终丝毫没能撼动老哥 XP 的地位，默默地成为了下一个成功的老弟 Win7 的基石。但是在开发代号为 Longhorn 的无数个泄露版本中，依稀可以看见微软对于各种新特性和交互的尝试，以及对Win家族未来方向的寻找。</p>
<h3>一 摸索道路</h3>
<p>加拿大温哥华以北大概125公里的太平洋海岸山脉中，有一个一年四季白雪皑皑的名为惠斯勒 (Whistler) 的度假胜地。无数游客为惠斯勒山滑雪场举世闻名的高山滑雪和山地自行车慕名而来，同样因为其“北美第一滑雪胜地”的美誉成为了2010世界冬奥会的主赛场。而惠斯勒镇另一个举世闻名的滑雪场地黑梳山 (Blackcomb) 终年积雪，山路陡峭，是只有高手才敢挑战的圣地。</p>
<div><a href="http://skiingbc.com/New_Photos/Evolution%20Whistler%20Ski%20In%20Ski%20Out/Whistler%20Creekside%20Ski%20In%20Ski%20Out%20EvolutionWinter2-0006.jpg"><img src="http://skiingbc.com/New_Photos/Evolution%20Whistler%20Ski%20In%20Ski%20Out/Whistler%20Creekside%20Ski%20In%20Ski%20Out%20EvolutionWinter2-0006.jpg" /></a><p>Whistler, BC Canada</p></div>
<p>世纪交接时的 Microsoft 凭借着 95 和 XP 的震撼发布登上了颠峰时期。代号为 Whistler 的 XP 发布后，微软宣布了下一个代号为 Blackcomb 的新系统计划，也就是后来的 Windows 7 。不过在两座山脉间，有一个滑雪客们时常歇脚的酒吧 Longhorn ，这就是 Vista 的开发代号。正忙于销售和推广大热的 XP 的微软，对于这个过渡性的产品并未过多提起。</p>
<p><span></span></p>
<p>2001 年 7 月 XP 发布前夕的微软年度大会， 现任微软副总裁史蒂夫·古杰海默 (Steven Guggenheimer) 作为当时 MSN 事业部的主任展示了未来的 MSN 服务原型。演示使用的操作系统引起了大家的注意，它类似于 XP ，但部分界面有所变化。但是最后证据表明，这只是作为 .NET 计划的一部分于系统深度集成的 MSN 8 原型。</p>
<div><a href="http://www.techradar.me/wp-content/uploads/2013/01/MSN-Shell.gif"><img src="http://www.techradar.me/wp-content/uploads/2013/01/MSN-Shell.gif" /></a><p>MSN .NET 原型</p></div>
<p>2002 年 4 月，流出了第一个 Longhorn 的视频，拥有一个全新设计的任务窗格。5 月份，再次流出了一个拥有3D设计的界面。无数早期或实际或奇葩的概念图和第三方概念视频的流出，体现了人们对下一代系统的期待。</p>
<div><a href="http://www.techcn.com.cn/uploads/201005/1272849308t7eIKcMi.jpg"><img src="http://www.techcn.com.cn/uploads/201005/1272849308t7eIKcMi.jpg" /></a><p>Longhorn 早期概念视频</p></div>
<p>就在4月，刚刚开始的 Longhorn 就首次延期，宣布 2004 年之前将不会发布。不久后的 WinHEC 2002 硬件技术研讨大会后，微软忽然宣布 Longhorn 将会包含新的托管接口、图形结构、网络技术以及存储架构。这意味这 Longhorn 从一个过渡性的优化版本，转变成了又一个重要的里程碑版本。</p>
<p>7月份，比尔盖茨登上了财富杂志封面。在 <a href="http://blogchina.blogchina.com/464.html" target="_blank">《近距离看盖茨》</a> 一文中，他将 Longhorn 称为一次“全面检修”，重新思考操作系统的人机互动模式。当时的微软推出了 .NET计划 等一系列富有创意但最终流产的项目，李开复在自传《世界因你而不同》中提到， 在项目起初盖茨为 Longhorn 拟定了三大目标：</p>
<ol>
<li>改用 C# 撰写所有软件，在牺牲稳定性和运行速度的情况下加快开发速度以抗衡 Liunx 等开源系统。</li>
<li>开发 WinFS ，将所有文件存储成数据库，增加虚拟文件夹等新特性。</li>
<li>加入 .NET 计划的核心之一 Avalon ，使得浏览器应用获得和本地相同的体验。</li>
</ol>
<h3>二 增增补补</h3>
<p>最初期的开发进程因为微软的保持缄默，人们对其的了解仅限于BT站点和新闻组流出的泄漏版本。Build 版本仍然停留在 XP 的 3xxx 的几个泄露版本只是对 XP 的改进和更新。</p>
<p>在 3663 和 3670 两个版本 (M2) 中，相对 XP 只增加了一个名为 Plex 的新主题和更明显的设备管理器入口。当年 10 月 26 日，第一个泄漏版本 Build 3683 (M3) 出现在网络上，版本信息为 Longhorn XP Professional 。一个著名的特性之一侧边栏首次出现，还可以把开始菜单移到侧边栏上，从而让任务栏消失。早期的 WinFS 和 Avalon 服务出现，但是仅仅展示出了一小部分特性，对于测试者而言不过是个浪费内存和CPU的系统进程而已。</p>
<div><a href="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-1.jpg"><img src="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-1.jpg" /></a><p>我的硬件、图标视图、侧边栏和任务栏最右侧的折叠按钮</p></div>
<div><a href="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-2.jpg"><img src="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-2.jpg" /></a><p>Plex 新主题、使用 Avalon API 的个性化设置</p></div>
<div><a href="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-3.jpg"><img src="http://topicstock-origin.pantip.com/wahkor/topicstock/2010/01/X8744966/X8744966-3.jpg" /></a><p>整体效果</p></div>
<p>随后的 3706 和 3718 相继添加了 IE 6.05 和一些透明、动画效果，首次出现了磁盘容量条，同时新增的 DWM桌面窗口管理器 改变了传统的只计算窗口不被遮挡部分的显示渲染的模式，变为渲染完每个窗口的幕后位图再进行拼合，最后成为 Aero 的透明效果和 Flip 3D (Win + Tab) 效果的一部分。</p>
<h3>三 前期开发</h3>
<p>2003 年 2 月 28 日，经过了几个月的沉寂后 Build 4008 (M4) 泄漏。Plex 主题经过修改后成为被设为默认，侧边栏被重新设计和简化，资源管理器开始基于 .NET 构造。最重要的两个变化之一是桌面背景奠定了最终版本的光芒四射的风格，以及完全重新设计、速度加快三倍的交互式安装向导。</p>
<div><a href="http://en.academic.ru/pictures/enwiki/87/Windows_Longhorn_Build_4008.png"><img src="http://en.academic.ru/pictures/enwiki/87/Windows_Longhorn_Build_4008.png" /></a><p>资源管理器、文件预览、改进的搜索</p></div>
<div><a href="http://www.geocities.ws/longhornalpha/lh4008/lh_screenshots/4008setup4.JPG"><img src="http://www.geocities.ws/longhornalpha/lh4008/lh_screenshots/4008setup4.JPG" /></a><p>新的安装向导</p></div>
<p>4 月 28 日， Build 4015 (M5) 被泄露。家长控制、库等开发中的新特性被加入，侧边栏可以移到屏幕底部，同时新增了下载管理器、虚拟文件夹等最终被弃用的功能。但这个版本的资源管理器和侧边栏存在严重的内存泄露问题，必须用第三方工具解决。不久后泄露了基于 Windows Server 2003 RC1 的首个服务器版本 Build 4028 ，稍后的 4029 增加了鼠标悬停预览图片视频、图片批量处理等功能，但内存泄露问题仍未完全解决。</p>
<div><a href="http://chris123nt.com/guides/4029/LH4029Guide_files/ie.JPG"><img src="http://chris123nt.com/guides/4029/LH4029Guide_files/ie.JPG" /></a><p>Plex 主题中的 IE 6.05</p></div>
<div><a href="http://www.activewin.com/articles/2007/images/Longhorn%204015.jpg"><img src="http://www.activewin.com/articles/2007/images/Longhorn%204015.jpg" /></a><p>位于底部的侧边栏</p></div>
<p>不久后，Build 4033 (M6) 和 4039 相继泄漏。 4039 是最后一个使用 Plex 主题的版本，并首次添加了经典的 Aero Glass 效果。</p>
<div><a href="http://www.betaarchive.co.uk/imageupload/1217326418.or.44758.PNG"><img src="http://www.betaarchive.co.uk/imageupload/1217326418.or.44758.PNG" /></a><p>Aero Glass 效果</p></div>
<p>Build 4042 启用了一个叫 Slate 的新主题，原蓝色的界面风格改为偏黑色。2003年的 PDC专业开发者大会 上微软使用了 Build 4051 作为演示版本，其中对开始菜单和IE进行不少改进，同时第一次去掉了开始菜单上的 Start 字样。随后的 4066 服务器测试版第一次出现了全新的 Jade 主题。</p>
<p>2004年的五月， Windows 硬件工程师研讨会 如期举行。会上，微软展示了最新的 Build 4074 (M7) ，使用了完善的 Jade 主题界面，更换了与最终版本相仿的图标，同时发布了全新的 Segoe UI 系统字体。不久后，微软宣布将在 Longhorn 中应用 下一代安全计算基础 (NGSCB) 架构，但因为其华而不实遭到极大反对，最后仅有其中的 Bit Locker 功能保留下来。不久后的 4083 和 4093 极其缺乏稳定性，而且几次移除又重新添加侧边栏和 WinFS 等组件， Vista 开发的内部混乱已经积累到一个临界值。</p>
<div><a href="http://winsupersite.com/site-files/winsupersite.com/files/archive/winsupersite.com/content/content/127732/showcase/4074_ui_05.gif"><img src="http://winsupersite.com/site-files/winsupersite.com/files/archive/winsupersite.com/content/content/127732/showcase/4074_ui_05.gif" /></a><p>资源管理器和图片预览</p></div>
<div><a href="http://www.thevista.ru/files/images/articles/ANOTHER/longhornreloaded.jpg"><img src="http://www.thevista.ru/files/images/articles/ANOTHER/longhornreloaded.jpg" /></a><p>启用 Aero Glass 的 Jade 效果</p></div>
<h3>四 推倒重来</h3>
<p>Longhorn 正是微软的一场“大跃进”。每个团队都给自己定下了完全没法完成的宏伟蓝图，各种语言学家心理学家对工程师们胡乱指挥，不同的团队之间剑拔弩张毫无配合，这个团队的主任一走，另一个团队的项目就取而代之。开发到中期，各种本来计划在 Blackcomb 上的特性被随意的添加，预定的发布日期不断推迟。</p>
<p>终于在 2004 年秋天的一个星期六， Longhorn 的项目负责人吉姆·阿尔钦 (Jim Allchin) 把所有的副总裁召集起来，宣布道：“我们确定无法按预期完成这项产品， Longhorn 已经彻底玩完。我想问问你们，如果从头做起，希望两年能做完，你们认为可以做到什么地步？”话音刚落，全场寂静。一阵七嘴八舌之后，大家总结出了最可行的对策：不用 C#、取消 WinFS、删改 Avalon 。一开始的三大目标就这样被完全否决。不久后，负责了 Windows NT 项目17年之久的NT之父吉姆辞职引退。在 7 月的财年分析会议，直接负责 Windows 的副总裁威尔·普尔 (Will Poole) 只字不提 Longhorn 。</p>
<p>在终于解决了从冲击波病毒开始暴漏出来的大量 XP 安全漏洞之后， 2004 年 8 月，因为当时的开发重心集中于 Windows Server 2003 ，新的并不基于 XP 的 Longhorn 开始重写，两年来的工作就这样付之一炬。因为系统组件对与 WinFS 等组件依赖严重，而且代码质量不高，大量软件都必须推倒重来，使得进度非常缓慢。</p>
<p>一直到了 2005 年 5 月 的 WinHEC 召开，微软终于释出了重写后的第一个开发者预览版 Build 5048 ，但是整体来说 UI 极其丑陋和单调， 内置了 Aero 但是效果不佳，开始菜单增加了搜索条和所有程序面板，丑陋的侧边栏不再默认出现。一个比较重要的特性是和最终版接近的窗口控制按钮。这个版本和XP的差距不大，被称为是一种倒退。随后的 Build 5060 添加了新的登陆界面。</p>
<div><a href="http://www.liewcf.com/blog/wp-images/windows-longhorn-review.JPG"><img src="http://www.liewcf.com/blog/wp-images/windows-longhorn-review.JPG" /></a><p>Build 5048 (DP) 开发者预览版的界面效果</p></div>
<p>2005 年 7 月 初，微软给 Longhorn 定下了源于拉丁文 Vedere (展望) 之意的 Vista 这个名字，吉姆·阿尔钦说，Vista 为这个新系统的功能勾勒了一幅美丽的图景，能够最大限度的激发人们的想象力，点燃用户的激情。</p>
<p>7 月 27 日， Vista Beta 1 (Build 5112) 在 MSDN 和 TechNet 释出。其中引入了新的图形界面，新的高清图标、虚拟文件夹、资源管理器等元素都被添加进来，包括家长控制、 .NET 3.0 等功能开始进行开发。之后，微软开始定期发放社区技术预览版。 Build 5219 作为第一个公开的旗舰版被放出，侧边栏和桌面小工具重新出现，并且内置了全新的媒体中心。随后的 Build 5231 和 Build 5259 增加了 WMP 11 和一些内置软件的更新。</p>
<p>(未完待续)</p>
<p>(妈蛋PO主快写不下去了……感觉越是写到后面，越是变成没有意思的罗列更新和截图，求破)</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/vista-history/">图文回顾 Windows Vista (Longhron) 五年开发历程 (更新五)</a></p>]]></content>
        
        <summary type="html">
            
            Windows Vista 创造了Win家族中的两个最：开发时间最长，用户评价最差。作为一个费时费力、跳票连连又最终失败的系统，Vista 最终丝毫没能撼动老哥 XP 的地位，默默地成为了下一个成功的老弟 Win7 的基石。但是在开发代号为 Longhorn 的无数个泄露版本中
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="Microsoft"/>
        
        <category term="UI"/>
        
        <category term="Vista"/>
        
        <category term="Windows"/>
        
        <category term="交互"/>
        
        <category term="历史"/>
        
    </entry>
    
    <entry>
        <title>时间真是不够用，先让我多睡会觉</title>
        <link href="http://blog.dimpurr.com/time-sleep/"/>
        <id>http://blog.dimpurr.com/time-sleep/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-25T18:47:03+00:00</published>
        <updated>2013-07-25T18:47:03+00:00</updated>
        
        <content type="html"><![CDATA[<p>内心一直有一种奇怪的信念在支撑，导致自己一错再错。那就是，生活向的博文，一定要深夜写……</p>
<p>目测这篇文章已经拖了不止两周，一直以来想把暑假至今发生的事情记录一下，但是因为种种不可抗力一再拖延。无数个深夜在偷玩手机失败的无奈和刷姬加忘记时间的悔恨中度过，直到有一天担心再不写真的就坑了，终于动起了笔。忽然要写反而有点不知道从何开始，或许是已经太久了渐渐开始淡忘暑假刚开始的事情。为了回忆自己的经历倒着翻阅自己的时间线居然也是件挺辛苦的事情，真想总结一下的时候却发现自己好像并不像想象中的做了那么多事。不过有一点可以明确，这又将是一篇诸位可以跳过的撸主自说自话的扯淡文。</p>
<p>呐在开头继承PO主一贯的尿性，先谈一下目前的码字环境。记得曾经说过百度云ROM27以下的自带记事本手感真是舒服到不行，但是在尝试提取失败之后不得不寻找替代品。之前就早已对各种笔记应用失望透顶，只好试图寻找类似简书那样的专注码字的编辑器。在百度手机助手搜寻出大量劣质应用后转战 Google Play ，忽然不禁要感慨原来菜市场的质量就是比天朝应用高一个档次。只是无奈许多编辑器各有中意的特点却没有一个完美，最后选择了一款名为 Power Writer 的英文应用，尽管Logo不甚好看也没有自定义的柔和彩色背景，但是其简洁的功能和界面以及必要的字数统计等功能一样不少以及正合我意的行距段距，使得我终于稍微满意。</p>
<p><span></span></p>
<p>顶着死忠粉丝的压力， Google Reader 还是没有逃过被关闭的命运。其实我一直以来也没怎么用过GR，而且对于稍微显得土气的页面排版不甚感冒。只是自己 Chrome 书签栏里关注博客文件夹的条目很明显已经数百，一个个查看辛苦不说，对于常年爪机党来说简直就是折磨。于是经过寻觅，除去新发布的 AOL 和 Digg ，选择了看起来最靠谱的一家 Feedly ，然后兴致勃勃的花了两个下午把书签栏里有RSS的站点全部添加进去。完工后，赫然近三百条各种业界新闻科技评论菊苣大触的博客站点成功订阅。嘛，其实用哪家服务不算重要，爪机客户端才是重中之重。据说最美的 PRESS 功能真心不足，官方的 Feedly 又Bug多多。最后选择了功能强大但是界面略差的 gReader ，但是更坑爹的是过了几天后变得需要翻墙才能更新，但是在找到更好的替代品之前也只能如此了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/20130726114752.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/20130726114752-600x401.png" /></a><p>Feedly Index</p></div>
<p>暑假伊始，获得了母上大人的恩准钉子决定进行一次大购书。托父上礼品卡的福，我毫不犹豫的购买了编程，硬件，计算机原理方面的大量经典书籍。因为主业是设计，实际上在编程方面很多领域准备浅尝即止，因此把这一批的书看完除了几门主要语言不准备继续深入了。当然这批书本身数量极多，又不乏参考书砖头书，再考虑到学习紧张的缘故，目测中考之前能看完就不错了……另外，没有买设计方面的书的遗憾，在前几天的小额度购书中也补偿了。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/13-7-9-1.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/07/13-7-9-1-600x450.jpg" /></a><p>又一次购书</p></div>
<p>Azone 应该是那种蓄谋已久也靠着机缘巧合最终有幸得以从虚构稿到实际构想再到开发思想的构思，从设计稿上的信息中心遨云栈，再到和E姐讨论之后在实现与设计中挣扎的初稿以及 Axure 练手用的类 Twitter 第一版原型，然后是三三说挺感兴趣愿意负责后端以启动开发，最后我回到拿手的交互和前端用 Fireworks 构建了略微谷歌风格的第三版原型和上手编写前端。应该说从头到尾是计划打折和技术进步的过程，至少学第一次自己尝试了原型到交互到视觉的完整流程，以及学习了 Git 等团队协作和版本管理的工具。最后因为许许多多的API限制和技术原因缩水成仅仅体验增强的微博聚合服务，但是还是希望能成为自己拿的上履历的第一个正式作品。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/Scan0001.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/Scan0001-600x464.png" /></a><p>遨云栈原稿</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/20130610213535.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/07/20130610213535-600x373.jpg" /></a><p>AZone 原型一代</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/Index.fw_.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/Index.fw_-600x450.png" /></a><p>AZone 原型三代</p></div>
<p>追新番也算是目前参与的一个开源项目，尽管目前的状态还是打酱油。还有正在策划中的技术宅吐槽博客和预谋已久的社区，以及自己手上各种想做的小页面和产品。当然无论是什么项目，特别是与他人合作的项目，无非是想和真正的菊苣共事，籍此或许能够学习成长。在姬加等社交网络混迹，认识各种相同兴趣的人，膜拜各种菊苣大触，也是一样的目的。</p>
<p>自己一直处于快速的变化中。回头去看UMunk的最后更新，其实也只是四五月份的事情，远的不说，就是一月前自己刚入姬加的发言，现在看来也幼稚可笑。更不用说回顾之前的博客那些仅仅是年初的文章，却不禁感慨思维回路完全都不一样。可能是因为自己的朝三暮四喜新厌旧，也可能是因为最近真的发生了很多事，或者自己正出于高速的成长期，每一天的自己都变得不同，更成熟也更陌生。</p>
<p>至少自己的生活方式没有变，为了自己所爱的事物努力并乐在其中，一遍抱怨时间不够用一遍赖床睡懒觉，痛并快乐着。这样的生活，真的很幸福。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/time-sleep/">时间真是不够用，先让我多睡会觉</a></p>]]></content>
        
        <summary type="html">
            
            内心一直有一种奇怪的信念在支撑，导致自己一错再错。那就是，生活向的博文，一定要深夜写…… 目测这篇文章已经拖了不止两周，一直以来想把暑假至今发生的事情记录一下，但是因为种种不可抗力一再拖延。无数个深夜在偷玩手机失败的无奈和刷姬加忘记时间的悔恨中度过，直到有一天担心再不写真的就坑
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="AZone"/>
        
        <category term="Google"/>
        
        <category term="RSS"/>
        
        <category term="书籍"/>
        
        <category term="暑假"/>
        
        <category term="追新番"/>
        
        <category term="项目"/>
        
    </entry>
    
    <entry>
        <title>Win 下配置 Sublime Text 的 SASS 插件</title>
        <link href="http://blog.dimpurr.com/sublime-sass/"/>
        <id>http://blog.dimpurr.com/sublime-sass/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-25T12:21:16+00:00</published>
        <updated>2013-07-25T12:21:16+00:00</updated>
        
        <content type="html"><![CDATA[<p>SASS是一门著名的CSS预处理器语言，而 Sublime Text 则堪称界面最优雅的编辑器之一。为ST配置了SASS的插件之后，便可以在ST中很方便的支持SASS的语法高亮以及一键编译。</p>
<p>CSS预处理器即在CSS语法里加入编程中的变量、循环、调用等结构，再将其编译成普通的CSS文件。目前主流的预处理器有实时编译的 LESS 和预编译的 SASS ，在语法部分也有一些区别，个人认为SASS更加强大一些。关于SASS的更多详细介绍在此不再赘述，若想了解请参见 <a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank">SASS用法指南</a> 。</p>
<p>SASS需要Ruby环境的支持，因此首先要下载并安装对应版本的 <a href="http://rubyinstaller.org/downloads/" target="_blank">Ruby Installer for Windows</a> 。然后在开始菜单中启动 Start Command Prompt with Ruby ，在弹出的命令行界面中输入：</p>
<pre>gem install sass</pre>
<p>随后会开始SASS的安装。如果提示 HTTP 302，可能是GEM被墙的问题，请在 Internet 选项 中挂上代理重试。</p>
<p><span></span></p>
<p>安装完成后启动 Sublime Text ，如果已经安装了 Package Control 插件请忽略这一步，否则使用 工具 &gt; 命令面板 或者快捷键 Ctrl + Shift + P 调出 Console ，在控制台中输入：</p>
<pre>import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())</pre>
<p>这样就成功安装了插件管理器，如果失败，也可以直接下载 <a href="http://sublime.wbond.net/Package%20Control.sublime-package" target="_blank">Package Control</a> 将下载后的Package Control.sublime-package 放到 Sublime Text 根目录下的 Installed Packages 文件夹中。</p>
<p>再次打开控制台，选择 Package Contrl: Install Package ，依次搜索并回车安装 Sass 和 SASS Build 两个插件。</p>
<p>安装成功后，.scss文件就可以正常使用代码高亮国。如果文件名后缀是.css，也可以在控制台中搜索SASS选择 Set Syntax: SASS 以切换模式。可以使用 工具 &gt; 编译 或者快捷键 Ctrl + B 编译文件，会自动在当前目录生成一个同名的编译后的CSS文件。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/sublime-sass/">Win 下配置 Sublime Text 的 SASS 插件</a></p>]]></content>
        
        <summary type="html">
            
            SASS是一门著名的CSS预处理器语言，而 Sublime Text 则堪称界面最优雅的编辑器之一。为ST配置了SASS的插件之后，便可以在ST中很方便的支持SASS的语法高亮以及一键编译。 CSS预处理器即在CSS语法里加入编程中的变量、循环、调用等结构，再将其编译成普通的C
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS"/>
        
        <category term="IDE"/>
        
        <category term="SASS"/>
        
        <category term="Sublime"/>
        
        <category term="代码"/>
        
    </entry>
    
    <entry>
        <title>Windows Phone UI 交互设计指南速览</title>
        <link href="http://blog.dimpurr.com/wp-guide/"/>
        <id>http://blog.dimpurr.com/wp-guide/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-19T11:28:22+00:00</published>
        <updated>2013-07-19T11:28:22+00:00</updated>
        
        <content type="html"><![CDATA[<p>灵感来自于瑞士平面设计风格的 Modern UI 开始于Xbox时代，在微软的革新浪潮中成为了 Windows 家族跨平台的标志性设计语言。无论看官如何议论纷纷，鲍尔默算是铁了心要把所有产品拍扁了。</p>
<p>因为项目需要，在此对 Windows Phone 8 的设计指南稍作整理。这份指南只包括了WP有别于其他系统独特的设计模式和规范指南，其他更加具体的实现请参见各种UI书籍和官方指南页面。可以使用这份速览快速了解WP的交互并上手设计，但不能作为完全的参考资料使用。</p>
<p>开篇之前先对当下的WP的开发者环境略作介绍。WP已经超越黑莓就位三大手机系统中的老三，但是这个第三和第二实在差距巨大。WP对于权限把关严格，包括文件目录和系统权限的控制程度仅稍次于iOS。Windows Phone Store 中可能是因为和Xbox和Win8平台的紧密结合，最畅销的应用分类是游戏，其次是工具。国内WP的市场份额较低，优秀应用缺乏，开发者普遍处于观望，大众应用勉强够用，主要顾客群体是较为喜欢新鲜潮流的青年群体。</p>
<p>Windows Phone 的UI极其新潮同时框架严格，在保证了不会有像Andriod一样大量低质量的应用程序存在的情况下同时限制了特色元素的发挥。同时，完全强调以排版为中心的全扁平化风格和 动态Title 为代表的大量动画和手势应用也是特色。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC622542.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC622542.png" /></a><p>Windows Phone 应用标准界面</p></div>
<p>一个典型的WP应用由状态栏、应用主题和应用栏组成。默认情况下，状态栏将始终显示时间，其他状态图标将在用户点击后出现8秒再滑出隐藏。应用栏相当于Andriod的 Action Bar，包括最多四个对当前视图进行操作的圆形按钮和展开菜单的省略号（美其名曰连续点可视指示器）。</p>
<p><span></span></p>
<h3>一 结构和导航</h3>
<h4>Panorama 面板式应用程序中心控件(全景体验)</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC627791.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC627791-600x408.png" /></a><p>标准的 Panorama 控件效果</p></div>
<p>Panorama 是WP中最典型的导航方式之一，就好像是一张长长的卷轴，包括可拖动的背景图、主板面和其他面板。</p>
<p>主面板承担着导航和链接的应用，可以提供通往其他应用的链接和收纳不需要在第一层级展示的功能。可以这么理解，不同的面板相当于不同栏目的主导航，同时在主面板收纳提醒、消息等辅助功能的链接。实际上并不一定要在主面板上开始，可以在应用启动时首先切换到最新动态等更加有趣的内容。</p>
<ul>
<li>每个面板的功能和主题可以是完全独立，没必要其他面板相关。</li>
<li>一般来说建议不要超过五个面板，太多的面板将会使用户感到困惑。</li>
<li>在面板内部可以自由的使用各种样式组织内容，如 深化细目列表 和 图像网格 。</li>
<li>可以混合使用面板间的横向导航和面板内列表的垂直滚动，但是不能在图像网格中纵向滚动。</li>
<li>可以使用和主题相关但并不影响阅读的背景图，也可以使用代码动态改变。</li>
</ul>
<h4>Pivot 标签筛选式应用程序中心控件</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC622527.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC622527.png" /></a><p>标准的 Pivot 控件效果</p></div>
<p>相对于 Panorama 控件，Pivot 更像是桌面系统中的程序选项卡。最大的区别在于，其中的每一个标签内部的主题是完全相同的。Pivot 具有会在顶部紧凑显示标签、点击标签即可跳至目标标签以及支持横向模式等 Panorama 不具有的特性。每个标签具有相同的结构和主题模版，同时可以实时生成和改变标签，相当于动态给固定的模版传入参数。</p>
<p>Pivot 控件往往作为 Panorama 控件的二级界面使用，同时不推荐从一个 Panorama 控件跳至 另一个 Panorama 控件，容易使得用户忘记自己身处的位置。可以增加一个 “主页” 页面，显示所有其余标签的列表，用户就不必依次滑动导航至目标标签。同理，也不必让用户在 主页 开始，而可以在进入时先转到更有趣的主题。</p>
<h4>深化细目列表</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC625681.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC625681.png" /></a><p>一种深化细目列表效果</p></div>
<p>所谓“深化细目列表”，实际上就是一组高度可自定义的列表入口样式。可以由此提供一个包含许多可点击的包括图片和文本的项的列表。</p>
<ul>
<li>列表的一个项可以是图片、文本或二者的混合，也可以同时提供，亦或者增加其他样式。</li>
<li>每个项必须可以点击并查看详细内容。</li>
<li>可以和其他控件混合使用深化细目列表，这样会具有横向和纵向两个方向的滚动导航。</li>
</ul>
<h4>实用设备和游戏</h4>
<p>WP中提倡在应用内使用现实生活中的设备的外观样式，以便用户快速上手。但是于拟物设计决定性的不同，是WP不允许需要操作的控件样式拟物化，因为现实中的旋钮在手机中相对滑块极其难以操作。应该仅仅将拟物设计用在工具类应用的结构和数据呈现，而不可以改变操作方式。合理是使用实用设备设计风格，可以为应用增添魅力，更易使用。</p>
<p>游戏使用的是沉浸式设计，因此并不需要遵守WP的交互指南。在游戏中只需要遵守游戏独有的UX设计准则即可。</p>
<h3>二 交互和体验</h3>
<h4>主题配色</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC622510.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC622510.png" /></a><p>不同的主题配色</p></div>
<p>WP提供了可供用户自定义的多种主题配色。应用默认采用WP设置的全局样式，记得在深色和浅色配色中反复测试样式效果，以免出现不和谐的效果、一般来说，为了系统体验的统一，最好尊重用户的配色选择。但是如果切换不同的样式会对应用的特定品牌元素造成影响，可以将应用锁定为深色或浅色。也可以完全覆写从背景到强调色的一切样式，或者退出系统主题从新建立样式，从而建立品牌特征。</p>
<h4>操作动画和后退堆栈</h4>
<p>WP存在两种运动，“转换”和“动画”。“转换”用于在不同应用、不同面板、不同层级间切换的导航，以帮助用户明确所在的位置。“动画”是当前应用内对用户操作的反馈，如点击、拖动等效果。动画以 2.5 维展现，如倾斜动画并不会表现出深度、阴影等效果，仅展示平面从而强调内容。</p>
<p>系统将把用户访问轨迹中的每个页面保存在 后退堆栈 中。页面的定义是“一个用户可识别的持久状态集合”，即不包括启动动画、登录页面、对话框这些不包含信息的弹出屏幕。使用硬件上的后退按钮将依次退回到用户曾访问的页面快照，但是即使页面内容已经发生改变，在刷新前页面的状态也不会变化。请注意不同的 Pivot 标签尽管包含可记忆的内容，但不算独立的页面，而是整个 Pivot 框架的一部分。</p>
<h4>操作方式</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC622543.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC622543-600x419.png" /></a><p>三种屏幕方向</p></div>
<p>WP提供三种屏幕方向，分别是纵向、横向靠左和横向靠右。在横屏时，状态栏从默认的 32px 扩展到 72px。可以为应用定义全屏视图，并选择是否在全屏下显示状态栏和应用栏。</p>
<p>在WP中的手指和触控笔的交互方式拥有点按（轻触）、连按（双击）、平移（按住拖动）、轻拂（扔出，即按住拖动并快速移动然后离开屏幕）、按住（长按）。WP要求所有设备支持最少4个触控点，最多可支持10个触控点，因硬件而异。</p>
<h4>触摸可访问性</h4>
<p>在WP中，9mm或更大的方块是推荐的理想触控目标大小。最低的触控目标大小不应小于7mm，并且只能在不得已的情况下使用。控件的视觉大小未必与触控面积完全相等，但最低可视大小不应小于4.2mm。更小的情况下，用户不会意识到控件是可触控的。在设计时应该首先判断错误点击的后果，例如拨号程序中触控目标的间距极大，因为出错的代价很高。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC622526.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC622526.png" /></a><p>触控目标的结构</p></div>
<p>一个触控目标拥有以下结构：可视间距、可视资产、触控目标、死空间。可以理解为视觉上的外边距、视觉上的实际大小、实际可触控的区域、触控不执行任何操作的空余区域。</p>
<p>Modern UI 是一种基于排版的设计语言，因此文字缺乏除了颜色以外的更多纹理和样式修饰，排版和拼写的重要性相对较大。WP上最小的字体大小是15磅。</p>
<h4>与系统体验一致</h4>
<p>请在应用中尽可能使用系统控件以保证体验的一致性。</p>
<ul>
<li>每台WP手机都包含“返回”、“开始”和“搜索”三个硬件按钮，因此请勿在应用中内置如上按钮，例如在应用中放置“主页”按钮以回到主页很可能会和原有的后退堆栈逻辑上冲突，使得用户迷失方向。</li>
<li>无法修改“搜索”按钮的行为。在 Outlook 等系统应用中，触摸“搜索”按钮会跳至应用内的搜索功能。在第三方的应用中，将会跳至 Bing 以提供一致的搜索体验。要实现应用内的搜索，请将应用包括在 Bing 搜索范围中。</li>
<li>在信息流中安放操作按钮很可能会造成容易混淆的导航，对于每一项生效的操作，请使用应用栏。</li>
</ul>
<p>WP中无法将应用的设置放在系统设置内部，应该在应用内创建一个和系统设置样式一样的设置页面。需要注意：</p>
<ul>
<li>大部分设置无需点击确认，每个更改应该立即实现，并提供反馈使得用户得知已经操作成功。</li>
<li>对于无法撤销的不可逆更改，例如修改文本，必须提供取消选项。</li>
</ul>
<p>WP提供一个名为 AdControl 的控件显示广告。广告的默认和建议大小为480x80px。具体的定位可以脱离于容器外悬浮显示，也可以标准流定位显示在 Panorama 等控件中并跟随控件改变位置。</p>
<h3>三 控件和实现</h3>
<h4>Title图块</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/69605310.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/07/69605310.jpg" /></a><p>典型的开始屏幕</p></div>
<p>Modern 设计语言的一个标志性特征就是开始屏幕和Title动态磁贴，即图块。图块可以是静态的，也可以通过通知进行更新。图块有超大(4×4，只有系统应用有权限)，宽(2×4)，中(2×2)，小(1×1)几种，用户可以随时切换。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC624343.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC624343.jpg" /></a><p>图块通知</p></div>
<p>所有图标右上角都有一个用于计数的区域，类似于iOS的“红膏药”。可以结合动态图块功能使用。</p>
<ul>
<li>在可能的情况下，尽可能的使用实时拼贴，如动态的显示提醒数量或最新消息。</li>
<li>可以使用“图块通知”服务来控制图块的计数器、背景图像、动态更新。</li>
<li>在应用内提供开关图块动态更新的设置。</li>
<li>如果应用具有一系列图块，确保使用相近的风格以方便辨识为系列。</li>
<li>尽量使用清晰容易理解的几何图形，避免在图块中使用3D、渐变、阴影、圆角等样式。</li>
<li>不能为图块使用黑色或白色背景，这样将在深色或浅色主题的开始屏幕中无法辨别出背景。</li>
<li>如果不想设置背景颜色，可以将背景颜色设为透明，系统会自动进行分配。在这种情况下，确保图标的前景色是白色。</li>
</ul>
<h4>应用栏</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC625674.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC625674.png" /></a><p>标准的应用栏效果</p></div>
<p>应用栏类似于 Android 的 Action Bar 和菜单的结合，是一个永远位于三个硬件按钮方向的72px高栏。</p>
<ul>
<li>在应用栏中最多可以把五个菜单项以按钮方式显示，其余菜单项折叠于右侧的省略号(连续点可视指示器)中。</li>
<li>默认应用栏不算在应用内容有效空间内，如果为应用栏设置了透明，应用会改为全屏显示且应用栏悬浮于底部。</li>
<li>应用栏按键可以显示为启用和禁用两种状态。</li>
</ul>
<p>图标大小为48x48px的透明通道图片，中心是前景色为白色的26x26px图案，不需要包含圆圈，系统会自动生成。只需要绘制白色版本，对于其他主题系统会自动填色。</p>
<h4>Toast 提醒通知</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC625676.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC625676.png" /></a><p>Toast 通知</p></div>
<p>Toast 通知一般用于推送即时消息，不会打断用户的当前任务，显示10秒后会自动消失。如果点击了通知，将会进入应用。一个通知包含应用图标、加粗的标题和一段内容文本。内容只显示一行，过长的文本会被截断。请注意过多的 Toast 通知会使得用户受到打扰。</p>
<h4>Raw 操作通知</h4>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/IC625677.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/IC625677-340x600.png" /></a><p>Raw 通知</p></div>
<p>Raw 通知更加像桌面系统中的弹出对话框，用于在应用中必须执行以进行下一步的操作。仅可以通过应用启动该种通知，无系统范围内显示的方法。</p>
<h3>四 链接和结语</h3>
<p>提供一些可供参考和使用的链接：</p>
<ul>
<li><a href="http://dev.windowsphone.com/zh-cn/" target="_blank">Windows Phone Dev Center</a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/windowsphone/design/hh202915" target="_blank"><span>Windows Phone 设计库</span></a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/windowsphone/design/ff637515" target="_blank">Windows Phone 设计资源</a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/windowsphone/develop/ff967556(v=vs.105).aspx" target="_blank">Windows Phone 用户界面开发与实现</a></li>
</ul>
<p>写了两天终于写完了这篇所谓的“速览”，不得不说微软确实对交互模式做出了极大的创新。至少从个人来说，Modern UI 是我非常喜欢也觉得极其富有新意和美感的设计。Windows Phone 推出以来在应用增长速度上大大超越了 Android 和 iOS，只是因为后来者的身份差距尚远。今年是诸多新系统参与移动操作系统角逐的一年，Firefox OS、 Ubuntu Phone、 Sailfish OS 等等相继推出， iOS7 和 Windows Phone 8 以及 Ubuntu Phone 也创造了其别具一格的设计。至于将来哪个系统能在市场上获得胜利，只能拭目以待了。</p>
<p>本人才疏学浅，若有错误敬请指出。转载请注明出处：<a href="http://blog.dimpurr.com/wp-guide/" target="_blank">Windows Phone UI 交互设计指南速览 | 钉子の次元</a> http://blog.dimpurr.com/wp-guide/</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/wp-guide/">Windows Phone UI 交互设计指南速览</a></p>]]></content>
        
        <summary type="html">
            
            灵感来自于瑞士平面设计风格的 Modern UI 开始于Xbox时代，在微软的革新浪潮中成为了 Windows 家族跨平台的标志性设计语言。无论看官如何议论纷纷，鲍尔默算是铁了心要把所有产品拍扁了。 因为项目需要，在此对 Windows Phone 8 的设计指南稍作整理。这份
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="Microsoft"/>
        
        <category term="UI"/>
        
        <category term="Windows"/>
        
        <category term="Windows Phone"/>
        
        <category term="设计指南"/>
        
    </entry>
    
    <entry>
        <title>Photoshop 三分钟学会去码</title>
        <link href="http://blog.dimpurr.com/ps-mosaics/"/>
        <id>http://blog.dimpurr.com/ps-mosaics/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-19T11:23:38+00:00</published>
        <updated>2013-07-19T11:23:38+00:00</updated>
        
        <content type="html"><![CDATA[<p><em>感谢本文原作者 <a href="https://plus.google.com/116941926954892465421" target="_blank">Luc Plus</a> 同学授权转载，原文地址于 Google+ <a href="https://plus.google.com/116941926954892465421/posts/ASYwTbSJLSx" target="_blank">#三分钟学会去码</a> ，原作者 <a href="http://restart.moe/?p=84" target="_blank">博客</a></em></p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/22_39_141.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/22_39_141.png" /></a><p>三分钟学会去码</p></div>
<p>准备 <s>拖</s> 了这么久渣渣的去字教程终于完成了~本教程分为三个部分，分别介绍三种常用的去字工具，用GIF演示用法并附上详细文字说明。因为本人渣渣没学过PS，所谓教程难免有问题和误区，发现教程有任何问题欢迎+本人大力打脸，抖M的PO会很高兴的。</p>
<p>声明：Po主没系统地学过PS，所有相关知识都是从网上零星学来的，本“教程”仅代表Po主个人观点，各位菊苣如果发现有错欢迎打脸，各位参考这个教程的同学发现被我误导了请尽情骂Po主是混蛋。另外本教程所介绍的工具用法很简单，所以只能进行简单的去字处理。像是在脸上眼睛上华丽的衣服上进行大规模去字什么的处理基本上就要靠画画补上去字的部分，Po主也做不到。遇到难处理的图片还是放弃吧，事前提醒一下，别花了很多时间也没搞定怪教程没用。</p>
<p><span></span></p>
<h3>本教程例图</h3>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/yande%2B257564%2Bfukagawa_kazumi%2Bgenei_wo_kakeru_taiyou%2Bseifuku%2Btaiyou_akari.jpg"><img src="http://img1.dimpurr.com/dimblog/2013/07/yande_akari-600x387.jpg" /></a><p>三分钟学会去码 原图</p></div>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/yande.re+225645+akinashi_yuu+aomi_isara+kiba_mifuyu+koi_to_senkyo_to_chocolate+loli+morishita_michiru+nopan+seifuku+shinonome_satsuki+sumiyoshi_chisato+thighhighs.png"><img src="http://img1.dimpurr.com/dimblog/2013/07/yande.re+225645+akinashi_yuu+aomi_isara+kiba_mifuyu+koi_to_senkyo_to_chocolate+loli+morishita_michiru+nopan+seifuku+shinonome_satsuki+sumiyoshi_chisato+thighhighs-600x387.png" /></a><p>三分钟学会去码 完成图</p></div>
<p>看完上面两张图片对比的同学不要想太多了，咱不可能把从原图到完成图的流程都讲一遍，本渣渣花了8个小时才做了个半成品，要我做完整流程的请饶命……本教程只是用这张图做栗子简单演示三种去字工具的用法，具体怎么运用还是需要你们自己去感受一下。</p>
<p>Ps：别吐槽这个PO配的海报了，我真的不会PS，不会拿PS嵌字，这海报是拿PPT的艺术字做的…</p>
<h3>一 自动填充</h3>
<p>本PO讲的是自动填充，自动填充原理很简单，就是从选区附近的地方选择与边缘相似的图片区域填充覆盖上去，但是这个功能十分神奇，使用效果经常出奇地好，阿逗比做了这么多年的PS算法还是值得信赖的。大部分情况下都推荐先试一下自动填充再进行其它操作，就算第一次自动填充失败也可以试试调整选区之后继续尝试自动填充，总有一次效果会让你满意的。点几下就搞定了，自动填充真棒！塞糕！（殴）</p>
<p>自动填充的操作也十分简单（详见GIF），用任意选择工具选中要进行自动填充的范围，右键选择 填充 （魔棒除外），内容选择 自动识别*，然后确定就行了，⑨都能学会~</p>
<p>不推荐使用自动填充的情况：比如原图的右侧和右上方的一大块文字，使用自动填充基本没效果，由于自动填充是从附近区域找图案进行填充，在周围都是字的地方使用自动填充的结果就是填充了一块别的地方的字到原来的地方，做了等于没做，不信的同学可以自己去试试。</p>
<p>注意事项：</p>
<ol>
<li>选区不能太大，选区太大经常会出现很奇葩的填充结果，比如说会把半边脸拉过来贴到附近的墙上什么的的……</li>
<li>用魔棒创建选区之后要选择其它选择工具才能看见填充的选项，比如说用魔棒选了一个球，选完你在球的选区上按右键是没有填充选项的，要换成矩形选框工具或者套索工具（其它的也行）再右键填充。</li>
<li>要注意在自动填充较大的区域之后要取消选择看一下效果，因为选区的边框附近可能会有一些“脏东西”残留，再用自动填充把不和谐的脏东西和谐掉就OK了。</li>
<li>选择自动填充的时候要注意选区附近的“环境”，太乱的话自动填充的效果可能会很差，见不推荐使用的情况。</li>
</ol>
<p>Ps：图片越大自动填充需要计算的时间越长，变数也多一些，建议把图片调小（宽2000左右）再尝试演示GIF中的操作，直接使用原例图的话结果可能会不一样。另外演示GIF只演示了自动填充的一步，实际上这块区域还是需要处理的，详细的以后再说。</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/1.gif"><img src="http://img1.dimpurr.com/dimblog/2013/07/1.gif" /></a><p>一 自动填充</p></div>
<h3>二 仿制图章</h3>
<p>本PO讲的是仿制图章，仿制图章这个工具泛用性也很广，因为自由选取取样点、画笔大小和硬度可以定制，所以经常用来进行细节的处理。仿制图章对于颜色变化不大的图片效果拔群，指哪打哪谁用谁知道；但是对于色彩变化较多的图片不推荐大规模使用，对于色彩变化比较多的图片使用大量仿制图章处理的时候选取采样点不当的话很有可能会出现不和谐的“色块”，整体效果也不好。</p>
<p>使用仿制图章有一个要点就是要不断变化取样点，取样点一直不变的话很容易出现一大块都是同一种颜色和图案的情况。总之泛用型对图兵器仿制图章想要用好还是要多用把熟练度提高，这个工具机师补正挺高的。</p>
<p>仿制图章的操作也很简单，选择仿制图章，先按住Alt键选择采样点，然后在要覆盖的处理的用画笔地方涂上就行了。</p>
<p>注意事项：</p>
<ol>
<li>根据实际情况选择大小和硬度。在仿制图章的状态下在画布任意地方点右键可以调整画笔的硬度和大小，硬度越大边缘越清晰。像处理衣服天空背景这样的大色块的时候画笔可以大一点，硬度也调高一点；相反处理边缘的时候硬度要适当降低才不会出现明显PS痕迹。</li>
<li>要经常设置取样点。上面也说了取样点一直不变的话涂出来的效果会很难看，取样点变化多一些涂出来的效果才自然。处理颜色变化多的区域更要注意，去字的时候尽量选择字附近的空白地方作取样点，最好能上下左右包围着把字涂掉 <s>太麻烦了我们试试自动填充吧</s> 取样点的选择是机师补正比较大的一项，多做就熟了。</li>
<li>涂一段要松一下鼠标再继续涂。就算是涂大色块也不能选好取样点之后一直刷过去，因为你涂下去的操作要松开鼠标左键才算完成，在松开鼠标之前你涂的部分还是原来的样子。注意GIF中采样点在下面的时候刷的最后一笔，可以看到把下面字的一部分刷上去了。另外举个栗子，现在有线段ABC，你在A左边设了一个取样点，把画笔从A拖到C的过程中你会发现涂到B的时候A那部分又出现了，因为取样点到了原来A的位置，而这时你没松开鼠标，仿制图章的效果没应用，A实际上还是原来的样子所以被捕获涂到B的位置上了。正确的做法是在A左边取样之后涂到B之前松开左键应用修改，然后到C的右边取样从又往左涂，又或者直接在A下方取样直接涂过去，C点上方感觉也不错呢…这一条实际做过很容易理解，总之多试试就好了。</li>
</ol>
<p>Ps：其实处理示例图里的东西只要用自动填充就好了，但是这张图好像也找不到能演示仿制图章的地方了…</p>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/2.gif"><img src="http://img1.dimpurr.com/dimblog/2013/07/2.gif" /></a><p>二 仿制图章</p></div>
<h3>三 修补工具</h3>
<p>本PO讲的是修补工具。修补工具的原理和仿制图章差不多，也是从别的区域选择图案填充到指定的地方。跟仿制图章不同的是修补工具有一个特性，就是在复制图案到目的地之后修补工具会 自动适应 周围的颜色，就像自带光学迷彩一样。如果复制的源图案不明显，周围的色彩又比较鲜明，有可能复制的图案会被后续的适应颜色覆盖而看不出来。修补工具在附近颜色差不多而且附近又有类似形状供抓取的地方使用效果比较好，像引索PO原图右上方黄色天空下的一大片字、“瞳に映る世界”下面的几行小字就很适合用修补工具。</p>
<p>修补工具的操作见GIF，详细用法引用官方说明：</p>
<ul>
<li>在图像中拖移以选择想要修复的区域，并在选项栏中选择“源”。</li>
<li>在图像中拖移，选择要从中取样的区域，并在选项栏中选择“目标”。您也可以在选择修补工具之前建立选区。</li>
<li>将指针定位在选区内，并执行下列操作之一：</li>
<li>如果在选项栏中选中了“源”，请将选区边框拖移到想要从中进行取样的区域。松开鼠标按钮时，原来选中的区域被使用样本像素进行修补。</li>
<li>如果在选项栏中选中了“目标”，请将选区边框拖移到要修补的区域。松开鼠标按钮时，新选中的区域被用样本像素进行修补。</li>
</ul>
<p>注意事项：</p>
<ol>
<li>选框要离修补区远点。由于修补工具的光学迷彩特性，如果你的修补选取贴住了字的边缘，在修补应用光学迷彩效果的时候选区边缘会有很奇怪的现象，比如说边框贴着字的位置可能会出现乱入的圣骑放圣光……</li>
<li>选区内最好不要混进其它差异较大的颜色。理由同上，在处理白色衣物上面的字的时候选框如果不小心把外面的黑色背景选中了，处理的时候会乱入个熊孩子把白色衣服搞脏。另外提一下选框有很多种，不一定都像示例用矩形选框工具。魔棒有点不好控制，在选取不规则图形的时候套索很好用。</li>
<li>使用修补工具之前要确保目标地点的色彩“正确”。这个只能举例说明了，比如说一张图的地上有一大块字要修掉，你先用了自动填充但是效果不好，旁边的黑色水迹违和地被填充到原来没水迹的地面上了，这时不能使用修补工具直接对这块水迹进行处理，如果直接用修补工具结果就是“带着水迹颜色的地面”，这是光学迷彩的效果。所以说使用修补工具之前要确保目标地点的色彩“正确”，正确的做法是使用仿制图章或者变换选区再进行自动填充操作知道去掉不和谐的水迹，调整到地面颜色正常而图案不正常的时候就可以选择使用修补工具处理了。</li>
</ol>
<div><a href="http://img1.dimpurr.com/dimblog/2013/07/3.gif"><img src="http://img1.dimpurr.com/dimblog/2013/07/3.gif" /></a><p>三 修补工具</p></div>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/ps-mosaics/">Photoshop 三分钟学会去码</a></p>]]></content>
        
        <summary type="html">
            
            感谢本文原作者 Luc Plus 同学授权转载，原文地址于 Google+ #三分钟学会去码 ，原作者 博客 三分钟学会去码 准备 拖 了这么久渣渣的去字教程终于完成了~本教程分为三个部分，分别介绍三种常用的去字工具，用GIF演示用法并附上详细文字说明。因为本人渣渣没学过PS，
            
        </summary>
        
        <category term="设计癖"/>
        
        <category term="Photoshop"/>
        
        <category term="修图"/>
        
        <category term="去码"/>
        
        <category term="平面"/>
        
        <category term="美化"/>
        
    </entry>
    
    <entry>
        <title>Ubuntu/Liunx 下 GoAgent 翻墙教程</title>
        <link href="http://blog.dimpurr.com/ubuntu-gae/"/>
        <id>http://blog.dimpurr.com/ubuntu-gae/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-09T14:03:00+00:00</published>
        <updated>2013-07-09T14:03:00+00:00</updated>
        
        <content type="html"><![CDATA[<div><a href="http://img1.dimpurr.com/cyblog/2013/04/2013-04-29-115547.png"><img src="http://img1.dimpurr.com/cyblog/2013/04/2013-04-29-115547-600x341.png" /></a><p>GoAgent 翻墙成功效果</p></div>
<p>因为在 Github 上下载的时候实在无法忍受 24 kb/s 的龟速……查了下资料， Linux 下好像比较常用 ssh 翻墙，但对我来说还是 GoAgent 比较熟悉，于是折腾了一下，最终搞定。上教程。</p>
<p><span>一、准备工作</span></p>
<p>1、申请 AppID 和 Win 下相同，本文假定已经成功申请到至少一个 AppID ，方法在此不再详述，需要的话请访问：<a href="http://blog.howgo.info/archives/3246.html">http://blog.howgo.info/archives/3246.html</a></p>
<p>2、Ubuntu 已经自带 Python ，但是建议还是确认一下。终端 sudo apt-get install python</p>
<p>3、下载 GAE for Linux <a href="https://developers.google.com/appengine/downloads?hl=zh-CN">https://developers.google.com/appengine/downloads?hl=zh-CN</a></p>
<p>4、下载 GoAgent ，Win 和 Linux 是通用的， Linux 下直接用 .py 脚本运行 <a href="https://code.google.com/p/goagent/">https://code.google.com/p/goagent/</a></p>
<h3><span></span></h3>
<h3>二、上传服务端</h3>
<p>如果已经在 Win 下或者其他时候上传过 GoAgent 服务端可跳过此步，无需重新上传。在此重新上传不影响其他平台使用。</p>
<p>1、先解压 GAE 和 GoAgent ，将 goAgent 放到 GAE 的 google_appengine 目录下</p>
<p>2、进入 GoAgent目录/server/python ，编辑 app.yaml ，填入 AppID 和 Version （默认是1)</p>
<p>3、进终端，使用  CD 命令进入你的 GAE 目录，然后激活位于你的 GoAgent 目录的上传脚本。</p>
<pre>cd [GoAgent目录]/server
python uploader.zip</pre>
<p>或者使用Python的内置同步脚本：</p>
<pre>sudo python appcfg.py update [GoAgent目录]/server/python</pre>
<p>随后在终端填入你的email和密码就能上传了。</p>
<h3>三、配置客户端环境</h3>
<p>1、安装 Gevent （非必须组件，若后面遇到问题可尝试安装）：</p>
<pre>sudo apt-get install python-dev curl -L -O https://github.com/python-greenlet/greenlet/archive/0.4.0.tar.gz &amp;&amp; tar xvzpf 0.4.0.tar.gz &amp;&amp; cd greenlet-0.4.0 &amp;&amp;
sudo python setup.py install curl -L -O https://github.com/downloads/surfly/gevent/gevent-1.0rc2.tar.gz &amp;&amp; tar xvzpf gevent-1.0rc2.tar.gz &amp;&amp; cd gevent-1.0rc2 &amp;&amp;
sudo python setup.py install</pre>
<p>2、要正常使用gtk托盘以在托盘区显示图标，需要安装以下软件包（按需要选择）：</p>
<pre>sudo apt-get install python-appindicator
sudo apt-get install python-vte</pre>
<h3>四、配置客户端</h3>
<p>1、在 GoAgent 的 local 目录中，有一个 proxy.ini 文件，将你的 AppID 填入</p>
<p>2、终端 CD 进 GoAgent 目录，激活客户端，如：</p>
<pre>cd [GoAgent目录]/local
sudo python proxy.py</pre>
<p>3、也可以赋予 proxy.py 可执行权限之后直接双击 proxy.py 运行，在 proxy.py 上面右击，属性的权限中勾选允许以程序执行文件即可。</p>
<p>4、运行 goagent-gtk.py 可以使用 GTK 托盘方式即在右上角显示小图标运行 GoAgent 。</p>
<h3>五、其他问题</h3>
<p>1、配置好 GoAgent 后使用方法同与Win下相同，只需要浏览器翻墙的话推荐 Chromium + SwitchProxy ，具体方法参见第一步中给出的申请 AppID 教程结尾处。</p>
<p>2、如果不止在浏览器中翻墙，还需要设置全局代理，可以访问 Ubuntu 系统设置 &gt; 网络 &gt; 代理 在http和https连接处填写 GoAgent 的本地端口地址 127.0.0.1:8087 ，然后点击应用即可。</p>
<p>如果桌面环境没有提供全局代理的设置，也可以手动编辑 /etc/profile 文件，在其中加入：</p>
<pre># 分别指定 HTTP HTTPS FTP 协议使用的代理服务器地址
http_proxy= 127.0.0.1:8087
https_proxy= 127.0.0.1:8087
ftp_proxy= # GoAgent 不支持 FTP
# 设置不使用代理的网址或者IP，用逗号分隔
no_proxy= 127.0.0.1, 192.168.1.1
# 设置环境变量
export http_proxy https_proxy ftp_proxy no_proxy</pre>
<p>3、访问部分网站提示证书不受信任问题与 Win 下相同。解决方法是： Chromium 首选项 &gt; 高级选项 &gt; 管理证书，在 授权中心 导入 GoAgent/local 目录下的 CA.crt 证书，注意不要导入到 服务器 ，否则不起作用。在 授权中心 找到 GoAgent CA 修改信任设置为全部选中，其他浏览器相同。重启浏览器生效。</p>
<p>4、启动后似乎会自动创建桌面图标，如果没有，可以尝试以下办法（别忘了更改为对应路径）：</p>
<p>在桌面新建一个空白文档，命名为 GoAgent.desktop ，然后使用 gedit 或其他文本编辑器打开，然后输入：</p>
<pre>[Desktop Entry]
Type=Application
Name=GoAgent
Comment=GoAgent Start
Categories=Network;Proxy;
Exec=sudo python [GoAgent目录]/local/goagent-gtk.py
Icon=[GoAgent目录]/local/goagent-logo.png
Terminal=true
StartupNotify=true</pre>
<p>这是唯一一种可以和Win下一样正常显示代理窗口的方法，不过每次都要输入一遍账户密码。也可以不让 GoAgent 在终端显示，只需要将 Terminal=true 改成 Terminal=false 。最后别忘了更改一下权限：</p>
<pre>sudo chmod 777  [GoAgent目录]/local/proxy.py</pre>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/ubuntu-gae/">Ubuntu/Liunx 下 GoAgent 翻墙教程</a></p>]]></content>
        
        <summary type="html">
            
            GoAgent 翻墙成功效果 因为在 Github 上下载的时候实在无法忍受 24 kb/s 的龟速……查了下资料， Linux 下好像比较常用 ssh 翻墙，但对我来说还是 GoAgent 比较熟悉，于是折腾了一下，最终搞定。上教程。 一、准备工作 1、申请 AppID 和 
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="GoAgent"/>
        
        <category term="Google"/>
        
        <category term="Liunx"/>
        
        <category term="Python"/>
        
        <category term="Ubuntu"/>
        
        <category term="网络"/>
        
        <category term="翻墙"/>
        
    </entry>
    
    <entry>
        <title>CSS3 Media Query 响应式媒体查询</title>
        <link href="http://blog.dimpurr.com/css-media/"/>
        <id>http://blog.dimpurr.com/css-media/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-07-03T05:46:57+00:00</published>
        <updated>2013-07-03T05:46:57+00:00</updated>
        
        <content type="html"><![CDATA[<p>在CSS中，有一个极其实用的功能：@media 响应式布局。具体来说，就是可以根据客户端的介质和屏幕大小，提供不同的样式表或者只展示样式表中的一部分。通过响应式布局，可以达到只使用单一文件提供多平台的兼容性，省去了诸如浏览器判断之类的代码。</p>
<p>当然这种设计也存在着缺点，比如我所见的不少使用响应式布局的设计在适配移动端时大量使用 display:none 隐藏富媒体元素，这样势必会导致大量不必要的流量。因此，如果有较为重要的移动端需求，那么还是开发专门的移动版页面为好。不过，对于诸如内容较少的页面或者单页式网站来说，响应式布局依然不失为一种偷懒的好方法 ^ ^</p>
<h3>一、在 &lt;head&gt; 链接CSS文件时提供判断语句，选择性加载不同的CSS文件</h3>
<pre>&lt;link rel="stylesheet" href="middle.css" media="screen and (min-width: 400px)"&gt;</pre>
<p>这句意味在满足 media 的判断语句 screen and (min-width: 400px) 即 屏幕并且最小宽度不小于400px 的介质上面使用 middle.css 。</p>
<p><span></span></p>
<h3>二、在CSS文件中分段书写不同设备的代码</h3>
<pre>/* CSS Code */
@media screen and (min-width: 600px) { /* CSS Code */ }
@media screen and (max-width: 599px) { /* CSS Code */ }</pre>
<p>相信这个代码也很容易理解，写在 @media 语句段外的是共用代码，第一个 @media 语句段是 屏幕以及最小宽度600px ，第而个 @media 语句段是 屏幕以及最大宽度599px 。</p>
<p>如果不同的代码段有冲突或者重叠，会按照CSS原本的代码优先级排序，即后方代码替代前方代码，等等。</p>
<h3>三、媒体介质类型</h3>
<p>CSS3中提供了多种媒体介质类型，虽然常用的就俩……注意媒体类型名称区分大小写，并且尽管有些介质类型有重合，但是一个平台只会有一种介质类型。（我猜这个标准很多浏览器不会遵守吧？）</p>
<ol>
<li><strong>all</strong> – 全部媒体类型</li>
<li><strong>braille</strong> – 盲文触摸装置</li>
<li><strong>embossed</strong> – 分页盲文打印机 （W3C的无障碍做的真细心……）</li>
<li><strong>handheld</strong> – 小屏幕和流量有限的手持设备（注意！安装标准来说移动设备都应该使用这个介质类型，但是实际上安卓根本不理会这个介质，请使用 screen 结合媒体查询语句使用）</li>
<li><strong>print</strong> – 提供给打印机的样式，最常用的介质类型，打印页面时获得适合阅读的效果</li>
<li><strong>projection</strong> – 投影，给投影机使用（有人用？）</li>
<li><strong>screen</strong> – 彩色屏幕，最常用的介质类型，一般和屏幕大小表达式联合使用</li>
<li><strong>speech</strong> – 语音朗诵，用于屏幕阅读软件（和将来的Siri？）</li>
<li><strong>tty</strong> – 固定间距字符网格，例如功能机那样的</li>
<li><strong>tv</strong> – 智能电视设备（唔不知道我家的创维酷开支持如何……）</li>
</ol>
<h3>四、媒体查询语句</h3>
<p>除了媒体介质，我们还能通过 and 使用 Media Query 语句，达到对屏幕大小的判断生成响应式布局。（可以通过改变浏览器窗口大小在桌面下测试效果）</p>
<p>一个 Media Query 包含一种媒体类型，如果媒体类型没有指定，那么就是默认类型all，比如：</p>
<pre>media="(max-width: 600px)"</pre>
<p>也可以使用 and 表示同时满足这两者时生效，达到限定范围：</p>
<pre>handheld and (min-width:20em) and (max-width:50em)</pre>
<p>逗号 , 被用来表示 并列 和 或者 ：</p>
<pre>handheld and (max-width:20em), screen and (max-width:30em)</pre>
<p>not 用来排除符合表达式的设备：</p>
<pre>not screen and (color)</pre>
<p>下面来解释一下遇到冲突时的机制：</p>
<pre>&lt;link rel="stylesheet" href="styleA.css" media="screen and (min-width: 800px)"&gt;
&lt;link rel="stylesheet" href="styleB.css" media="screen and (min-width: 600px) and (max-width: 800px)"&gt;
&lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt;</pre>
<p>上面将设备分成3种，分别是宽度大于800px时，应用 styleA ，宽度在600px到800px之间时应用 styleB ，以及宽度小于600px时应用 styleC 。那假如宽度正好等于800px时该应用那个样式？是 styleB，因为前两条表达式都成立，按CSS默认优先级规则后者覆盖了前者。</p>
<p>因此，为了避免冲突，这个例子正常情况应该这样写：</p>
<pre>&lt;link rel="stylesheet" href="styleA.css" media="screen"&gt;
&lt;link rel="stylesheet" href="styleB.css" media="screen and (max-width: 800px)"&gt;
&lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt;</pre>
<h3>五、浏览器支持</h3>
<p>媒体介质在CSS2中已经被添加，因此主流平台的浏览器毫无疑问都可以正确支持。但是 Media Query 语句是CSS3中添加的新功能，部分浏览器可能并不理解。例如IE能成功解读媒体介质，但是却无法解读 and 后面的媒体查询语句，就会连带媒体介质一起忽略。为了让不识别媒体查询语句的浏览器依然识别到媒体介质，可以使用 only 关键字进行hack。</p>
<pre>&lt;link rel="stylesheet"  href="example.css" media="only screen and (color)"&gt;</pre>
<p>添加了 only 关键字后，支持媒体查询语句的浏览器依然正常解析。但不支持媒体查询语句但正确读取媒体介质的设备，由于先读取到 only 而不是 screen ，将忽略这个样式。不支持媒体查询的IE不论是否有 only ，都直接忽略样式。</p>
<p>最后是浏览器支持情况：</p>
<ul>
<li><del><span>IE8-</span></del></li>
<li>IE9+</li>
<li>Chrome 5+</li>
<li>Opera 10+</li>
<li>Firefox 3.6+&lt;</li>
<li>Safari 4+</li>
</ul>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/css-media/">CSS3 Media Query 响应式媒体查询</a></p>]]></content>
        
        <summary type="html">
            
            在CSS中，有一个极其实用的功能：@media 响应式布局。具体来说，就是可以根据客户端的介质和屏幕大小，提供不同的样式表或者只展示样式表中的一部分。通过响应式布局，可以达到只使用单一文件提供多平台的兼容性，省去了诸如浏览器判断之类的代码。 当然这种设计也存在着缺点，比如我所见
            
        </summary>
        
        <category term="代码宅"/>
        
        <category term="CSS"/>
        
        <category term="HTML"/>
        
        <category term="HTML5"/>
        
        <category term="代码"/>
        
        <category term="前端"/>
        
        <category term="网络"/>
        
    </entry>
    
    <entry>
        <title>New Standard.</title>
        <link href="http://blog.dimpurr.com/new-standard/"/>
        <id>http://blog.dimpurr.com/new-standard/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-06-28T15:45:15+00:00</published>
        <updated>2013-06-28T15:45:15+00:00</updated>
        
        <content type="html"><![CDATA[<p>忧郁的打开某某笔记，糟糕的默认行距不得不让人只能回想起自带记事本。后天就是期末考了，这个时间段写这个文章的这个标题有种莫名的讽刺意味。New Stardard，《英语（新标准）》。</p>
<p>既然作为新博客的开荒之文，当然应该先自我介绍背景资料什么的。这里是Dimpurr，可以称呼为钉子。起因大致是在发现母上大人一直在亲切的观摩在下的博客之后，不得不对重新审视自己的言行然后万念俱灰决定从此二三次元分家。不得不说这其实也是个一时兴起的结果，只是ID邮箱QQ都到手之后已经是既成事实了。如果非要在这里对自己做个概括，大概就是个正在二次元化的技术宅吧。或许是谴责我在考前不务正业，GoDaddy毫不留情的吞了我买域名的60元。嗯，这货很穷，支付宝里余额的仅仅供得起一年期。打越洋电话，吃力的听英语，托人代打，搜相关案例，发客户邮件，最后干脆的想不要了。最后还是靠着RP，去他爹臭名昭著的客户邮件破天荒的两天内帮我对账买下了域名。</p>
<p>有时候也不禁会想自己如何才能写出来看起来很有深度实则也很有深度的文字，可惜笔下流出的是和人一样浅薄的扯淡。人失意了就喜欢回首过去辉煌，想当年我也是个吟诗作赋行文流水的文艺青年。只是那个诗词写作音乐美术电脑balabala样样精通的钉子死在了应试教育之下，现在疲于年级排名之下的我去掉电脑就只剩下废材一个。果然小学的自己才是真正的牛逼，只是那个时候自己不懂得炫耀。《失控》《科技想要什么》一本本砖头书堆在书柜上许久没看，相对于曾经津津有味的抱着量子力学的自己纯属历史倒退。社交娱乐真是精神毒药。</p>
<p>都说青春是人生中最美好的时光，初二已经让人不禁想哀叹时间不等人了。被大触刺激的次数已经不少，每次看到年龄和自己相仿的同辈神人总是想一头撞到墙上。越发的长大，自己就越发的变得一文不值。大概是又一次被同辈刺激后，自己下了决心把刷社交网站的时间全用来啃书充电。至于执行力度，这个咱下次再谈。</p>
<p>回首一下之前的博客，大概可以得出的结论是过于轻浮的文风容易使人事后不住捂脸。当然在下随时根据心情和当时情况改变的毫无章法的文风以及时吐槽时文艺的笔触，也是无可推托的直接原因。不过翻阅了不少大触博客的初期文章，倒也是幼稚简单的文笔。只是注目到那上面五六年前的时间戳时，果然笔耕不辍才是唯一一途啊。虽然无法断定现在的文风不会让以后的自己发笑，但是可以确定码字时淡定些总是好的。</p>
<p>最后回首一下此篇文章，铺陈背景，回首过去，展望未来，对新的革命目标和道路提出标准，文风正常，内容有序，是一个合格的开荒文章，可以喝杯水歇歇了。</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/new-standard/">New Standard.</a></p>]]></content>
        
        <summary type="html">
            
            忧郁的打开某某笔记，糟糕的默认行距不得不让人只能回想起自带记事本。后天就是期末考了，这个时间段写这个文章的这个标题有种莫名的讽刺意味。New Stardard，《英语（新标准）》。 既然作为新博客的开荒之文，当然应该先自我介绍背景资料什么的。这里是Dimpurr，可以称呼为钉子
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="介绍"/>
        
        <category term="公告"/>
        
        <category term="域名"/>
        
        <category term="大触"/>
        
        <category term="文字"/>
        
        <category term="期末考"/>
        
        <category term="青春"/>
        
    </entry>
    
    <entry>
        <title>世界，你好！</title>
        <link href="http://blog.dimpurr.com/hello-world/"/>
        <id>http://blog.dimpurr.com/hello-world/</id>
        
        <author>
            <name>Dimpurr</name>
        </author>
        
        <published>2013-06-21T13:18:14+00:00</published>
        <updated>2013-06-21T13:18:14+00:00</updated>
        
        <content type="html"><![CDATA[<blockquote><p>欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！</p></blockquote>
<p>唔。我很好，谢谢……</p>
<p>本文来自 <a href="http://blog.dimpurr.com">钉子の次元 - Dimpurr - an artist, designer and developer from China.</a> ,原文地址 <a href="http://blog.dimpurr.com/hello-world/">世界，你好！</a></p>]]></content>
        
        <summary type="html">
            
            欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！ 唔。我很好，谢谢…… 本文来自 钉子の次元 - Dimpurr - an artist, designer and developer from China. ,原文地址 世界，你好！
            
        </summary>
        
        <category term="碎碎念"/>
        
        <category term="hello word"/>
        
        <category term="介绍"/>
        
        <category term="你好"/>
        
        <category term="公告"/>
        
        <category term="博客"/>
        
    </entry>
    
</feed>